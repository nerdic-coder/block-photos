(function(f) {
  if (typeof exports === 'object' && typeof module !== 'undefined') {
    module.exports = f();
  } else if (typeof define === 'function' && define.amd) {
    define([], f);
  } else {
    var g;
    if (typeof window !== 'undefined') {
      g = window;
    } else if (typeof global !== 'undefined') {
      g = global;
    } else if (typeof self !== 'undefined') {
      g = self;
    } else {
      g = this;
    }
    g.blockstack = f();
  }
})(function() {
  var define, module, exports;
  return (function e(t, n, r) {
    function s(o, u) {
      if (!n[o]) {
        if (!t[o]) {
          var a = typeof require == 'function' && require;
          if (!u && a) return a(o, !0);
          if (i) return i(o, !0);
          var f = new Error("Cannot find module '" + o + "'");
          throw ((f.code = 'MODULE_NOT_FOUND'), f);
        }
        var l = (n[o] = { exports: {} });
        t[o][0].call(
          l.exports,
          function(e) {
            var n = t[o][1][e];
            return s(n ? n : e);
          },
          l,
          l.exports,
          e,
          t,
          n,
          r
        );
      }
      return n[o].exports;
    }
    var i = typeof require == 'function' && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
  })(
    {
      1: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.AppConfig = undefined;
          var _createClass = (function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          })();
          var _authConstants = require('./authConstants');
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          var AppConfig = (exports.AppConfig = (function() {
            function AppConfig() {
              var scopes =
                arguments.length > 0 && arguments[0] !== undefined
                  ? arguments[0]
                  : _authConstants.DEFAULT_SCOPE.slice();
              var appDomain =
                arguments.length > 1 && arguments[1] !== undefined
                  ? arguments[1]
                  : window.location.origin;
              var redirectPath =
                arguments.length > 2 && arguments[2] !== undefined
                  ? arguments[2]
                  : '';
              var manifestPath =
                arguments.length > 3 && arguments[3] !== undefined
                  ? arguments[3]
                  : '/manifest.json';
              var coreNode =
                arguments.length > 4 && arguments[4] !== undefined
                  ? arguments[4]
                  : null;
              var authenticatorURL =
                arguments.length > 5 && arguments[5] !== undefined
                  ? arguments[5]
                  : _authConstants.DEFAULT_BLOCKSTACK_HOST;
              _classCallCheck(this, AppConfig);
              this.appDomain = appDomain;
              this.scopes = scopes;
              this.redirectPath = redirectPath;
              this.manifestPath = manifestPath;
              if (!coreNode) {
                this.coreNode = _authConstants.DEFAULT_CORE_NODE;
              } else {
                this.coreNode = coreNode;
              }
              this.authenticatorURL = authenticatorURL;
            }
            _createClass(AppConfig, [
              {
                key: 'redirectURI',
                value: function redirectURI() {
                  return '' + this.appDomain + this.redirectPath;
                }
              },
              {
                key: 'manifestURI',
                value: function manifestURI() {
                  return '' + this.appDomain + this.manifestPath;
                }
              }
            ]);
            return AppConfig;
          })());
        },
        { './authConstants': 3 }
      ],
      2: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.isUserSignedIn = isUserSignedIn;
          exports.redirectToSignIn = redirectToSignIn;
          exports.isSignInPending = isSignInPending;
          exports.handlePendingSignIn = handlePendingSignIn;
          exports.loadUserData = loadUserData;
          exports.signUserOut = signUserOut;
          exports.makeAuthRequest = makeAuthRequest;
          exports.redirectToSignInWithAuthRequestImpl = redirectToSignInWithAuthRequestImpl;
          exports.redirectToSignInImpl = redirectToSignInImpl;
          exports.handlePendingSignInImpl = handlePendingSignInImpl;
          exports.loadUserDataImpl = loadUserDataImpl;
          exports.redirectToSignInWithAuthRequest = redirectToSignInWithAuthRequest;
          var _queryString = require('query-string');
          var _queryString2 = _interopRequireDefault(_queryString);
          var _jsontokens = require('jsontokens');
          var _index = require('./index');
          var _utils = require('../utils');
          var _index2 = require('../index');
          var _errors = require('../errors');
          var _authMessages = require('./authMessages');
          var _authConstants = require('./authConstants');
          var _profiles = require('../profiles');
          var _config = require('../config');
          var _logger = require('../logger');
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          var DEFAULT_PROFILE = {
            '@type': 'Person',
            '@context': 'http://schema.org'
          };
          function isUserSignedIn() {
            console.warn(
              'DEPRECATION WARNING: The static isUserSignedIn() function will be deprecated in ' +
                'the next major release of blockstack.js. Create an instance of UserSession and call the ' +
                'instance method isUserSignedIn().'
            );
            var userSession = new this.UserSession();
            return userSession.isUserSignedIn();
          }
          function redirectToSignIn() {
            var redirectURI =
              arguments.length > 0 && arguments[0] !== undefined
                ? arguments[0]
                : window.location.origin + '/';
            var manifestURI =
              arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : window.location.origin + '/manifest.json';
            var scopes =
              arguments.length > 2 && arguments[2] !== undefined
                ? arguments[2]
                : _authConstants.DEFAULT_SCOPE;
            console.warn(
              'DEPRECATION WARNING: The static redirectToSignIn() function will be deprecated in the ' +
                'next major release of blockstack.js. Create an instance of UserSession and call the ' +
                'instance method redirectToSignIn().'
            );
            var userSession = new this.UserSession();
            userSession.redirectToSignIn();
          }
          function isSignInPending() {
            console.warn(
              'DEPRECATION WARNING: The static isSignInPending() function will be deprecated in the ' +
                'next major release of blockstack.js. Create an instance of UserSession and call the ' +
                'instance method isSignInPending().'
            );
            var userSession = new this.UserSession();
            return userSession.isSignInPending();
          }
          function handlePendingSignIn() {
            var nameLookupURL =
              arguments.length > 0 && arguments[0] !== undefined
                ? arguments[0]
                : '';
            var authResponseToken =
              arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : getAuthResponseToken();
            var transitKey =
              arguments.length > 2 && arguments[2] !== undefined
                ? arguments[2]
                : '';
            console.warn(
              'DEPRECATION WARNING: The static handlePendingSignIn() function will be deprecated in the ' +
                'next major release of blockstack.js. Create an instance of UserSession and call the ' +
                'instance method handlePendingSignIn().'
            );
            console.warn(
              'DEPRECATION WARNING: handlePendingSignIn() no long supports setting of nameLookupURL and ' +
                'transitKey. The nameLookupURL and transitKey now defaults to values in the default user session.'
            );
            var userSession = new this.UserSession();
            return userSession.handlePendingSignIn(authResponseToken);
          }
          function getAuthResponseToken() {
            var queryDict = _queryString2.default.parse(location.search);
            return queryDict.authResponse ? queryDict.authResponse : '';
          }
          function loadUserData() {
            console.warn(
              'DEPRECATION WARNING: The static loadUserData() function will be deprecated in the ' +
                'next major release of blockstack.js. Create an instance of UserSession and call the ' +
                'instance method loadUserData().'
            );
            var userSession = new this.UserSession();
            return userSession.loadUserData();
          }
          function signUserOut() {
            var redirectURL =
              arguments.length > 0 && arguments[0] !== undefined
                ? arguments[0]
                : null;
            console.warn(
              'DEPRECATION WARNING: The static signUserOut() function will be deprecated in the ' +
                'next major release of blockstack.js. Create an instance of UserSession and call the ' +
                'instance method signUserOut().'
            );
            var userSession = new this.UserSession();
            userSession.signUserOut();
            window.location = redirectURL;
          }
          function makeAuthRequest(
            transitPrivateKey,
            redirectURI,
            manifestURI,
            scopes
          ) {
            var appDomain =
              arguments.length > 4 && arguments[4] !== undefined
                ? arguments[4]
                : window.location.origin;
            var expiresAt = arguments[5];
            var extraParams =
              arguments.length > 6 && arguments[6] !== undefined
                ? arguments[6]
                : {};
            console.warn(
              'DEPRECATION WARNING: The makeAuthRequest() function will be deprecated in the ' +
                'next major release of blockstack.js. Use UserSession to configure your auth request.'
            );
            var userSession = new this.UserSession();
            var transitKey =
              transitPrivateKey == null
                ? userSession.generateAndStoreTransitKey()
                : transitPrivateKey;
            return (0, _authMessages.makeAuthRequestImpl)(
              transitKey,
              redirectURI,
              manifestURI,
              scopes,
              appDomain,
              expiresAt,
              extraParams
            );
          }
          function detectProtocolLaunch(
            authRequest,
            successCallback,
            failCallback
          ) {
            var echoReplyID = Math.random()
              .toString(36)
              .substr(2, 9);
            var echoReplyKeyPrefix = 'echo-reply-';
            var echoReplyKey = '' + echoReplyKeyPrefix + echoReplyID;
            window.localStorage.setItem(echoReplyKey, Date.now().toString());
            var cleanUpLocalStorage = function cleanUpLocalStorage() {
              try {
                window.localStorage.removeItem(echoReplyKey);
                for (var i = 0; i < window.localStorage.length; i++) {
                  var storageKey = window.localStorage.key(i);
                  if (storageKey.startsWith(echoReplyKeyPrefix)) {
                    var storageValue = window.localStorage.getItem(storageKey);
                    if (
                      storageValue === 'success' ||
                      Date.now() - parseInt(storageValue, 10) > 36e5
                    ) {
                      window.localStorage.removeItem(storageKey);
                    }
                  }
                }
              } catch (err) {
                _logger.Logger.error(
                  'Exception cleaning up echo-reply entries in localStorage'
                );
                _logger.Logger.error(err);
              }
            };
            var detectionTimeout = 1e3;
            var redirectToWebAuthTimer = 0;
            var cancelWebAuthRedirectTimer = function cancelWebAuthRedirectTimer() {
              if (redirectToWebAuthTimer) {
                window.clearTimeout(redirectToWebAuthTimer);
                redirectToWebAuthTimer = 0;
              }
            };
            var startWebAuthRedirectTimer = function startWebAuthRedirectTimer() {
              var timeout =
                arguments.length > 0 && arguments[0] !== undefined
                  ? arguments[0]
                  : detectionTimeout;
              cancelWebAuthRedirectTimer();
              redirectToWebAuthTimer = window.setTimeout(function() {
                if (redirectToWebAuthTimer) {
                  cancelWebAuthRedirectTimer();
                  var nextFunc = void 0;
                  if (window.localStorage.getItem(echoReplyKey) === 'success') {
                    _logger.Logger.info('Protocol echo reply detected.');
                    nextFunc = successCallback;
                  } else {
                    _logger.Logger.info('Protocol handler not detected.');
                    nextFunc = failCallback;
                  }
                  failCallback = function failCallback() {};
                  successCallback = function successCallback() {};
                  cleanUpLocalStorage();
                  setTimeout(function() {
                    return nextFunc();
                  }, 100);
                }
              }, timeout);
            };
            startWebAuthRedirectTimer();
            var inputPromptTracker = document.createElement('input');
            inputPromptTracker.type = 'text';
            inputPromptTracker.style.all = 'initial';
            inputPromptTracker.style.opacity = '0';
            inputPromptTracker.style.filter = 'alpha(opacity=0)';
            inputPromptTracker.style.height = '0';
            inputPromptTracker.style.width = '0';
            var inputBlurredFunc = function inputBlurredFunc() {
              var isRefocused = false;
              inputPromptTracker.addEventListener(
                'focus',
                function() {
                  isRefocused = true;
                },
                { once: true, capture: true }
              );
              setTimeout(function() {
                if (redirectToWebAuthTimer && !isRefocused) {
                  _logger.Logger.info(
                    'Detected possible browser prompt for opening the protocol handler app.'
                  );
                  window.clearTimeout(redirectToWebAuthTimer);
                  inputPromptTracker.addEventListener(
                    'focus',
                    function() {
                      if (redirectToWebAuthTimer) {
                        _logger.Logger.info(
                          'Possible browser prompt closed, restarting auth redirect timeout.'
                        );
                        startWebAuthRedirectTimer();
                      }
                    },
                    { once: true, capture: true }
                  );
                }
              }, 100);
            };
            inputPromptTracker.addEventListener('blur', inputBlurredFunc, {
              once: true,
              capture: true
            });
            setTimeout(function() {
              return inputPromptTracker.removeEventListener(
                'blur',
                inputBlurredFunc
              );
            }, 200);
            if (document.body) document.body.appendChild(inputPromptTracker);
            inputPromptTracker.focus();
            var pageVisibilityChanged = function pageVisibilityChanged() {
              if (document.hidden && redirectToWebAuthTimer) {
                _logger.Logger.info(
                  'Detected immediate page visibility change (protocol handler probably working).'
                );
                startWebAuthRedirectTimer(3e3);
              }
            };
            document.addEventListener(
              'visibilitychange',
              pageVisibilityChanged,
              { once: true, capture: true }
            );
            setTimeout(function() {
              return document.removeEventListener(
                'visibilitychange',
                pageVisibilityChanged
              );
            }, 500);
            window.addEventListener(
              'storage',
              function replyEventListener(event) {
                if (
                  event.key === echoReplyKey &&
                  window.localStorage.getItem(echoReplyKey) === 'success'
                ) {
                  cancelWebAuthRedirectTimer();
                  inputPromptTracker.removeEventListener(
                    'blur',
                    inputBlurredFunc
                  );
                  _logger.Logger.info(
                    'Protocol echo reply detected from localStorage event.'
                  );
                  window.removeEventListener('storage', replyEventListener);
                  var nextFunc = successCallback;
                  successCallback = function successCallback() {};
                  failCallback = function failCallback() {};
                  cleanUpLocalStorage();
                  setTimeout(function() {
                    return nextFunc();
                  }, 100);
                }
              },
              false
            );
            _logger.Logger.info(
              'Attempting protocol launch via iframe injection.'
            );
            var locationSrc =
              _utils.BLOCKSTACK_HANDLER +
              ':' +
              authRequest +
              '&echo=' +
              echoReplyID;
            var iframe = document.createElement('iframe');
            iframe.style.all = 'initial';
            iframe.style.display = 'none';
            iframe.src = locationSrc;
            if (document.body) {
              document.body.appendChild(iframe);
            } else {
              _logger.Logger.error(
                'document.body is null when attempting iframe injection for protoocol URI launch'
              );
            }
          }
          function redirectToSignInWithAuthRequestImpl(caller, authRequest) {
            var httpsURI =
              _authConstants.DEFAULT_BLOCKSTACK_HOST +
              '?authRequest=' +
              authRequest;
            if (caller.appConfig && caller.appConfig.authenticatorURL) {
              httpsURI =
                caller.appConfig.authenticatorURL +
                '?authRequest=' +
                authRequest;
            }
            if (
              /Android|webOS|iPhone|iPad|iPod|Opera Mini/i.test(
                navigator.userAgent
              )
            ) {
              _logger.Logger.info('detected mobile OS, sending to https');
              window.location = httpsURI;
              return;
            }
            function successCallback() {
              _logger.Logger.info('protocol handler detected');
            }
            function failCallback() {
              _logger.Logger.warn('protocol handler not detected');
              window.location = httpsURI;
            }
            detectProtocolLaunch(authRequest, successCallback, failCallback);
          }
          function redirectToSignInImpl(caller) {
            var transitKey = caller.generateAndStoreTransitKey();
            var authRequest = caller.makeAuthRequest(transitKey);
            redirectToSignInWithAuthRequestImpl(caller, authRequest);
          }
          function handlePendingSignInImpl(caller, authResponseToken) {
            var transitKey = caller.store.getSessionData().transitKey;
            var coreNodeSessionValue = caller.store.getSessionData().coreNode;
            var nameLookupURL = null;
            if (!coreNodeSessionValue) {
              var tokenPayload = (0, _jsontokens.decodeToken)(authResponseToken)
                .payload;
              if (
                (0, _utils.isLaterVersion)(tokenPayload.version, '1.3.0') &&
                tokenPayload.blockstackAPIUrl !== null &&
                tokenPayload.blockstackAPIUrl !== undefined
              ) {
                _logger.Logger.info(
                  'Overriding ' +
                    _config.config.network.blockstackAPIUrl +
                    ' ' +
                    ('with ' + tokenPayload.blockstackAPIUrl)
                );
                _config.config.network.blockstackAPIUrl =
                  tokenPayload.blockstackAPIUrl;
              }
              nameLookupURL =
                '' +
                _config.config.network.blockstackAPIUrl +
                _authConstants.NAME_LOOKUP_PATH;
            } else {
              nameLookupURL =
                '' + coreNodeSessionValue + _authConstants.NAME_LOOKUP_PATH;
            }
            return (0, _index.verifyAuthResponse)(
              authResponseToken,
              nameLookupURL
            ).then(function(isValid) {
              if (!isValid) {
                throw new _errors.LoginFailedError(
                  'Invalid authentication response.'
                );
              }
              var tokenPayload = (0, _jsontokens.decodeToken)(authResponseToken)
                .payload;
              var appPrivateKey = tokenPayload.private_key;
              var coreSessionToken = tokenPayload.core_token;
              if ((0, _utils.isLaterVersion)(tokenPayload.version, '1.1.0')) {
                if (transitKey !== undefined && transitKey != null) {
                  if (
                    tokenPayload.private_key !== undefined &&
                    tokenPayload.private_key !== null
                  ) {
                    try {
                      appPrivateKey = (0, _authMessages.decryptPrivateKey)(
                        transitKey,
                        tokenPayload.private_key
                      );
                    } catch (e) {
                      _logger.Logger.warn(
                        'Failed decryption of appPrivateKey, will try to use as given'
                      );
                      try {
                        (0, _utils.hexStringToECPair)(tokenPayload.private_key);
                      } catch (ecPairError) {
                        throw new _errors.LoginFailedError(
                          'Failed decrypting appPrivateKey. Usually means' +
                            ' that the transit key has changed during login.'
                        );
                      }
                    }
                  }
                  if (
                    coreSessionToken !== undefined &&
                    coreSessionToken !== null
                  ) {
                    try {
                      coreSessionToken = (0, _authMessages.decryptPrivateKey)(
                        transitKey,
                        coreSessionToken
                      );
                    } catch (e) {
                      _logger.Logger.info(
                        'Failed decryption of coreSessionToken, will try to use as given'
                      );
                    }
                  }
                } else {
                  throw new _errors.LoginFailedError(
                    'Authenticating with protocol > 1.1.0 requires transit' +
                      ' key, and none found.'
                  );
                }
              }
              var hubUrl = _authConstants.BLOCKSTACK_DEFAULT_GAIA_HUB_URL;
              var gaiaAssociationToken = void 0;
              if (
                (0, _utils.isLaterVersion)(tokenPayload.version, '1.2.0') &&
                tokenPayload.hubUrl !== null &&
                tokenPayload.hubUrl !== undefined
              ) {
                hubUrl = tokenPayload.hubUrl;
              }
              if (
                (0, _utils.isLaterVersion)(tokenPayload.version, '1.3.0') &&
                tokenPayload.associationToken !== null &&
                tokenPayload.associationToken !== undefined
              ) {
                gaiaAssociationToken = tokenPayload.associationToken;
              }
              var userData = {
                username: tokenPayload.username,
                profile: tokenPayload.profile,
                decentralizedID: tokenPayload.iss,
                identityAddress: (0, _index2.getAddressFromDID)(
                  tokenPayload.iss
                ),
                appPrivateKey: appPrivateKey,
                coreSessionToken: coreSessionToken,
                authResponseToken: authResponseToken,
                hubUrl: hubUrl,
                gaiaAssociationToken: gaiaAssociationToken
              };
              var profileURL = tokenPayload.profile_url;
              if (
                (userData.profile === null || userData.profile === undefined) &&
                profileURL !== undefined &&
                profileURL !== null
              ) {
                return fetch(profileURL).then(function(response) {
                  if (!response.ok) {
                    userData.profile = Object.assign({}, DEFAULT_PROFILE);
                    var sessionData = caller.store.getSessionData();
                    sessionData.userData = userData;
                    caller.store.setSessionData(sessionData);
                    return userData;
                  } else {
                    return response
                      .text()
                      .then(function(responseText) {
                        return JSON.parse(responseText);
                      })
                      .then(function(wrappedProfile) {
                        return (0,
                        _profiles.extractProfile)(wrappedProfile[0].token);
                      })
                      .then(function(profile) {
                        var sessionData = caller.store.getSessionData();
                        userData.profile = profile;
                        sessionData.userData = userData;
                        caller.store.setSessionData(sessionData);
                        return userData;
                      });
                  }
                });
              } else {
                var sessionData = caller.store.getSessionData();
                userData.profile = tokenPayload.profile;
                sessionData.userData = userData;
                caller.store.setSessionData(sessionData);
                return userData;
              }
            });
          }
          function loadUserDataImpl(caller) {
            var userData = caller.store.getSessionData().userData;
            if (!userData) {
              throw new _errors.InvalidStateError(
                'No user data found. Did the user sign in?'
              );
            }
            return userData;
          }
          function redirectToSignInWithAuthRequest(authRequest) {
            var blockstackIDHost =
              arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : _authConstants.DEFAULT_BLOCKSTACK_HOST;
            console.warn(
              'DEPRECATION WARNING: The static redirectToSignInWithAuthRequest() function will ' +
                'be deprecated in the next major release of blockstack.js. Create an instance of UserSession ' +
                'and call the instance method redirectToSignInWithAuthRequest().'
            );
            var userSession = new this.UserSession();
            var sessionAuthRequest =
              authRequest == null
                ? userSession.makeAuthRequest(
                    userSession.generateAndStoreTransitKey()
                  )
                : authRequest;
            userSession.appConfig.authenticatorURL = blockstackIDHost;
            redirectToSignInWithAuthRequestImpl(
              userSession,
              sessionAuthRequest
            );
          }
        },
        {
          '../config': 12,
          '../errors': 15,
          '../index': 16,
          '../logger': 18,
          '../profiles': 26,
          '../utils': 50,
          './authConstants': 3,
          './authMessages': 4,
          './index': 8,
          jsontokens: 387,
          'query-string': 453
        }
      ],
      3: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          var BLOCKSTACK_HANDLER = (exports.BLOCKSTACK_HANDLER = 'blockstack');
          var BLOCKSTACK_STORAGE_LABEL = (exports.BLOCKSTACK_STORAGE_LABEL =
            'blockstack');
          var DEFAULT_BLOCKSTACK_HOST = (exports.DEFAULT_BLOCKSTACK_HOST =
            'https://browser.blockstack.org/auth');
          var DEFAULT_SCOPE = (exports.DEFAULT_SCOPE = ['store_write']);
          var BLOCKSTACK_APP_PRIVATE_KEY_LABEL = (exports.BLOCKSTACK_APP_PRIVATE_KEY_LABEL =
            'blockstack-transit-private-key');
          var BLOCKSTACK_DEFAULT_GAIA_HUB_URL = (exports.BLOCKSTACK_DEFAULT_GAIA_HUB_URL =
            'https://hub.blockstack.org');
          var DEFAULT_CORE_NODE = (exports.DEFAULT_CORE_NODE =
            'https://core.blockstack.org');
          var NAME_LOOKUP_PATH = (exports.NAME_LOOKUP_PATH = '/v1/names');
          var LOCALSTORAGE_SESSION_KEY = (exports.LOCALSTORAGE_SESSION_KEY =
            'blockstack-session');
        },
        {}
      ],
      4: [
        function(require, module, exports) {
          (function(Buffer) {
            'use strict';
            Object.defineProperty(exports, '__esModule', { value: true });
            exports.generateTransitKey = generateTransitKey;
            exports.makeAuthRequestImpl = makeAuthRequestImpl;
            exports.encryptPrivateKey = encryptPrivateKey;
            exports.decryptPrivateKey = decryptPrivateKey;
            exports.makeAuthResponse = makeAuthResponse;
            require('cross-fetch/polyfill');
            var _jsontokens = require('jsontokens');
            var _index = require('../index');
            var _encryption = require('../encryption');
            var _logger = require('../logger');
            var VERSION = '1.3.1';
            function generateTransitKey() {
              var transitKey = (0, _index.makeECPrivateKey)();
              return transitKey;
            }
            function makeAuthRequestImpl(
              transitPrivateKey,
              redirectURI,
              manifestURI,
              scopes
            ) {
              var appDomain =
                arguments.length > 4 && arguments[4] !== undefined
                  ? arguments[4]
                  : window.location.origin;
              var expiresAt = arguments[5];
              var extraParams =
                arguments.length > 6 && arguments[6] !== undefined
                  ? arguments[6]
                  : {};
              var payload = Object.assign({}, extraParams, {
                jti: (0, _index.makeUUID4)(),
                iat: Math.floor(new Date().getTime() / 1e3),
                exp: Math.floor(expiresAt / 1e3),
                iss: null,
                public_keys: [],
                domain_name: appDomain,
                manifest_uri: manifestURI,
                redirect_uri: redirectURI,
                version: VERSION,
                do_not_include_profile: true,
                supports_hub_url: true,
                scopes: scopes
              });
              _logger.Logger.info(
                'blockstack.js: generating v' + VERSION + ' auth request'
              );
              var publicKey = _jsontokens.SECP256K1Client.derivePublicKey(
                transitPrivateKey
              );
              payload.public_keys = [publicKey];
              var address = (0, _index.publicKeyToAddress)(publicKey);
              payload.iss = (0, _index.makeDIDFromAddress)(address);
              var tokenSigner = new _jsontokens.TokenSigner(
                'ES256k',
                transitPrivateKey
              );
              var token = tokenSigner.sign(payload);
              return token;
            }
            function encryptPrivateKey(publicKey, privateKey) {
              var encryptedObj = (0, _encryption.encryptECIES)(
                publicKey,
                privateKey
              );
              var encryptedJSON = JSON.stringify(encryptedObj);
              return new Buffer(encryptedJSON).toString('hex');
            }
            function decryptPrivateKey(privateKey, hexedEncrypted) {
              var unhexedString = new Buffer(hexedEncrypted, 'hex').toString();
              var encryptedObj = JSON.parse(unhexedString);
              var decrypted = (0, _encryption.decryptECIES)(
                privateKey,
                encryptedObj
              );
              if (typeof decrypted !== 'string') {
                throw new Error('Unable to correctly decrypt private key');
              } else {
                return decrypted;
              }
            }
            function makeAuthResponse(privateKey) {
              var profile =
                arguments.length > 1 && arguments[1] !== undefined
                  ? arguments[1]
                  : {};
              var username =
                arguments.length > 2 && arguments[2] !== undefined
                  ? arguments[2]
                  : null;
              var metadata = arguments[3];
              var coreToken =
                arguments.length > 4 && arguments[4] !== undefined
                  ? arguments[4]
                  : null;
              var appPrivateKey =
                arguments.length > 5 && arguments[5] !== undefined
                  ? arguments[5]
                  : null;
              var expiresAt =
                arguments.length > 6 && arguments[6] !== undefined
                  ? arguments[6]
                  : (0, _index.nextMonth)().getTime();
              var transitPublicKey =
                arguments.length > 7 && arguments[7] !== undefined
                  ? arguments[7]
                  : null;
              var hubUrl =
                arguments.length > 8 && arguments[8] !== undefined
                  ? arguments[8]
                  : null;
              var blockstackAPIUrl =
                arguments.length > 9 && arguments[9] !== undefined
                  ? arguments[9]
                  : null;
              var associationToken =
                arguments.length > 10 && arguments[10] !== undefined
                  ? arguments[10]
                  : null;
              var publicKey = _jsontokens.SECP256K1Client.derivePublicKey(
                privateKey
              );
              var address = (0, _index.publicKeyToAddress)(publicKey);
              var privateKeyPayload = appPrivateKey;
              var coreTokenPayload = coreToken;
              var additionalProperties = {};
              if (appPrivateKey !== undefined && appPrivateKey !== null) {
                _logger.Logger.info(
                  'blockstack.js: generating v' + VERSION + ' auth response'
                );
                if (
                  transitPublicKey !== undefined &&
                  transitPublicKey !== null
                ) {
                  privateKeyPayload = encryptPrivateKey(
                    transitPublicKey,
                    appPrivateKey
                  );
                  if (coreToken !== undefined && coreToken !== null) {
                    coreTokenPayload = encryptPrivateKey(
                      transitPublicKey,
                      coreToken
                    );
                  }
                }
                additionalProperties = {
                  email: metadata.email ? metadata.email : null,
                  profile_url: metadata.profileUrl ? metadata.profileUrl : null,
                  hubUrl: hubUrl,
                  blockstackAPIUrl: blockstackAPIUrl,
                  associationToken: associationToken,
                  version: VERSION
                };
              } else {
                _logger.Logger.info(
                  'blockstack.js: generating legacy auth response'
                );
              }
              var payload = Object.assign(
                {},
                {
                  jti: (0, _index.makeUUID4)(),
                  iat: Math.floor(new Date().getTime() / 1e3),
                  exp: Math.floor(expiresAt / 1e3),
                  iss: (0, _index.makeDIDFromAddress)(address),
                  private_key: privateKeyPayload,
                  public_keys: [publicKey],
                  profile: profile,
                  username: username,
                  core_token: coreTokenPayload
                },
                additionalProperties
              );
              var tokenSigner = new _jsontokens.TokenSigner(
                'ES256k',
                privateKey
              );
              return tokenSigner.sign(payload);
            }
          }.call(this, require('buffer').Buffer));
        },
        {
          '../encryption': 14,
          '../index': 16,
          '../logger': 18,
          buffer: 183,
          'cross-fetch/polyfill': 287,
          jsontokens: 387
        }
      ],
      5: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.getAuthRequestFromURL = getAuthRequestFromURL;
          exports.fetchAppManifest = fetchAppManifest;
          exports.redirectUserToApp = redirectUserToApp;
          var _queryString = require('query-string');
          var _queryString2 = _interopRequireDefault(_queryString);
          var _jsontokens = require('jsontokens');
          var _index = require('../index');
          var _utils = require('../utils');
          var _logger = require('../logger');
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function getAuthRequestFromURL() {
            var queryDict = _queryString2.default.parse(location.search);
            if (
              queryDict.authRequest !== null &&
              queryDict.authRequest !== undefined
            ) {
              return queryDict.authRequest
                .split(_utils.BLOCKSTACK_HANDLER + ':')
                .join('');
            } else {
              return null;
            }
          }
          function fetchAppManifest(authRequest) {
            return new Promise(function(resolve, reject) {
              if (!authRequest) {
                reject('Invalid auth request');
              } else {
                var payload = (0, _jsontokens.decodeToken)(authRequest).payload;
                var manifestURI = payload.manifest_uri;
                try {
                  _logger.Logger.debug('Fetching manifest from ' + manifestURI);
                  fetch(manifestURI)
                    .then(function(response) {
                      return response.text();
                    })
                    .then(function(responseText) {
                      return JSON.parse(responseText);
                    })
                    .then(function(responseJSON) {
                      resolve(responseJSON);
                    })
                    .catch(function(e) {
                      _logger.Logger.debug(e.stack);
                      reject('Could not fetch manifest.json');
                    });
                } catch (e) {
                  _logger.Logger.debug(e.stack);
                  reject('Could not fetch manifest.json');
                }
              }
            });
          }
          function redirectUserToApp(authRequest, authResponse) {
            var payload = (0, _jsontokens.decodeToken)(authRequest).payload;
            var redirectURI = payload.redirect_uri;
            _logger.Logger.debug(redirectURI);
            if (redirectURI) {
              redirectURI = (0, _index.updateQueryStringParameter)(
                redirectURI,
                'authResponse',
                authResponse
              );
            } else {
              throw new Error('Invalid redirect URI');
            }
            window.location = redirectURI;
          }
        },
        {
          '../index': 16,
          '../logger': 18,
          '../utils': 50,
          jsontokens: 387,
          'query-string': 453
        }
      ],
      6: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.makeCoreSessionRequest = makeCoreSessionRequest;
          exports.sendCoreSessionRequest = sendCoreSessionRequest;
          exports.getCoreSession = getCoreSession;
          var _jsontokens = require('jsontokens');
          require('cross-fetch/polyfill');
          function makeCoreSessionRequest(
            appDomain,
            appMethods,
            appPrivateKey
          ) {
            var blockchainID =
              arguments.length > 3 && arguments[3] !== undefined
                ? arguments[3]
                : null;
            var thisDevice =
              arguments.length > 4 && arguments[4] !== undefined
                ? arguments[4]
                : null;
            if (thisDevice === null) {
              thisDevice = '.default';
            }
            var appPublicKey = _jsontokens.SECP256K1Client.derivePublicKey(
              appPrivateKey
            );
            var appPublicKeys = [
              { public_key: appPublicKey, device_id: thisDevice }
            ];
            var authBody = {
              version: 1,
              blockchain_id: blockchainID,
              app_private_key: appPrivateKey,
              app_domain: appDomain,
              methods: appMethods,
              app_public_keys: appPublicKeys,
              device_id: thisDevice
            };
            var tokenSigner = new _jsontokens.TokenSigner(
              'ES256k',
              appPrivateKey
            );
            var token = tokenSigner.sign(authBody);
            return token;
          }
          function sendCoreSessionRequest(
            coreHost,
            corePort,
            coreAuthRequest,
            apiPassword
          ) {
            return new Promise(function(resolve, reject) {
              if (!apiPassword) {
                reject('Missing API password');
                return null;
              }
              var options = {
                headers: { Authorization: 'bearer ' + apiPassword }
              };
              var url =
                'http://' +
                coreHost +
                ':' +
                corePort +
                '/v1/auth?authRequest=' +
                coreAuthRequest;
              return fetch(url, options)
                .then(function(response) {
                  if (!response.ok) {
                    reject('HTTP status not OK');
                    throw new Error('HTTP status not OK');
                  }
                  return response.text();
                })
                .then(function(responseText) {
                  return JSON.parse(responseText);
                })
                .then(function(responseJson) {
                  var token = responseJson.token;
                  if (!token) {
                    reject('Failed to get Core session token');
                    return null;
                  }
                  resolve(token);
                  return token;
                })
                .catch(function(error) {
                  console.error(error);
                  reject('Invalid Core response: not JSON');
                });
            });
          }
          function getCoreSession(
            coreHost,
            corePort,
            apiPassword,
            appPrivateKey
          ) {
            var blockchainId =
              arguments.length > 4 && arguments[4] !== undefined
                ? arguments[4]
                : null;
            var authRequest =
              arguments.length > 5 && arguments[5] !== undefined
                ? arguments[5]
                : null;
            var deviceId =
              arguments.length > 6 && arguments[6] !== undefined
                ? arguments[6]
                : '0';
            if (!authRequest) {
              return Promise.reject('No authRequest provided');
            }
            var payload = null;
            var authRequestObject = null;
            try {
              authRequestObject = (0, _jsontokens.decodeToken)(authRequest);
              if (!authRequestObject) {
                return Promise.reject(
                  'Invalid authRequest in URL query string'
                );
              }
              if (!authRequestObject.payload) {
                return Promise.reject(
                  'Invalid authRequest in URL query string'
                );
              }
              payload = authRequestObject.payload;
            } catch (e) {
              console.error(e.stack);
              return Promise.reject('Failed to parse authRequest in URL');
            }
            var appDomain = payload.domain_name;
            if (!appDomain) {
              return Promise.reject('No domain_name in authRequest');
            }
            var appMethods = payload.scopes;
            var coreAuthRequest = makeCoreSessionRequest(
              appDomain,
              appMethods,
              appPrivateKey,
              blockchainId,
              deviceId
            );
            return sendCoreSessionRequest(
              coreHost,
              corePort,
              coreAuthRequest,
              apiPassword
            );
          }
        },
        { 'cross-fetch/polyfill': 287, jsontokens: 387 }
      ],
      7: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.doSignaturesMatchPublicKeys = doSignaturesMatchPublicKeys;
          exports.doPublicKeysMatchIssuer = doPublicKeysMatchIssuer;
          exports.doPublicKeysMatchUsername = doPublicKeysMatchUsername;
          exports.isIssuanceDateValid = isIssuanceDateValid;
          exports.isExpirationDateValid = isExpirationDateValid;
          exports.isManifestUriValid = isManifestUriValid;
          exports.isRedirectUriValid = isRedirectUriValid;
          exports.verifyAuthRequest = verifyAuthRequest;
          exports.verifyAuthRequestAndLoadManifest = verifyAuthRequestAndLoadManifest;
          exports.verifyAuthResponse = verifyAuthResponse;
          var _jsontokens = require('jsontokens');
          var _index = require('../index');
          var _ = require('.');
          function doSignaturesMatchPublicKeys(token) {
            var payload = (0, _jsontokens.decodeToken)(token).payload;
            var publicKeys = payload.public_keys;
            if (publicKeys.length === 1) {
              var publicKey = publicKeys[0];
              try {
                var tokenVerifier = new _jsontokens.TokenVerifier(
                  'ES256k',
                  publicKey
                );
                var signatureVerified = tokenVerifier.verify(token);
                if (signatureVerified) {
                  return true;
                } else {
                  return false;
                }
              } catch (e) {
                return false;
              }
            } else {
              throw new Error('Multiple public keys are not supported');
            }
          }
          function doPublicKeysMatchIssuer(token) {
            var payload = (0, _jsontokens.decodeToken)(token).payload;
            var publicKeys = payload.public_keys;
            var addressFromIssuer = (0, _index.getAddressFromDID)(payload.iss);
            if (publicKeys.length === 1) {
              var addressFromPublicKeys = (0, _index.publicKeyToAddress)(
                publicKeys[0]
              );
              if (addressFromPublicKeys === addressFromIssuer) {
                return true;
              }
            } else {
              throw new Error('Multiple public keys are not supported');
            }
            return false;
          }
          function doPublicKeysMatchUsername(token, nameLookupURL) {
            return new Promise(function(resolve) {
              var payload = (0, _jsontokens.decodeToken)(token).payload;
              if (!payload.username) {
                resolve(true);
                return;
              }
              if (payload.username === null) {
                resolve(true);
                return;
              }
              if (nameLookupURL === null) {
                resolve(false);
                return;
              }
              var username = payload.username;
              var url = nameLookupURL.replace(/\/$/, '') + '/' + username;
              try {
                fetch(url)
                  .then(function(response) {
                    return response.text();
                  })
                  .then(function(responseText) {
                    return JSON.parse(responseText);
                  })
                  .then(function(responseJSON) {
                    if (responseJSON.hasOwnProperty('address')) {
                      var nameOwningAddress = responseJSON.address;
                      var addressFromIssuer = (0, _index.getAddressFromDID)(
                        payload.iss
                      );
                      if (nameOwningAddress === addressFromIssuer) {
                        resolve(true);
                      } else {
                        resolve(false);
                      }
                    } else {
                      resolve(false);
                    }
                  })
                  .catch(function() {
                    resolve(false);
                  });
              } catch (e) {
                resolve(false);
              }
            });
          }
          function isIssuanceDateValid(token) {
            var payload = (0, _jsontokens.decodeToken)(token).payload;
            if (payload.iat) {
              if (typeof payload.iat !== 'number') {
                return false;
              }
              var issuedAt = new Date(payload.iat * 1e3);
              if (new Date().getTime() < issuedAt.getTime()) {
                return false;
              } else {
                return true;
              }
            } else {
              return true;
            }
          }
          function isExpirationDateValid(token) {
            var payload = (0, _jsontokens.decodeToken)(token).payload;
            if (payload.exp) {
              if (typeof payload.exp !== 'number') {
                return false;
              }
              var expiresAt = new Date(payload.exp * 1e3);
              if (new Date().getTime() > expiresAt.getTime()) {
                return false;
              } else {
                return true;
              }
            } else {
              return true;
            }
          }
          function isManifestUriValid(token) {
            var payload = (0, _jsontokens.decodeToken)(token).payload;
            return (0, _index.isSameOriginAbsoluteUrl)(
              payload.domain_name,
              payload.manifest_uri
            );
          }
          function isRedirectUriValid(token) {
            var payload = (0, _jsontokens.decodeToken)(token).payload;
            return (0, _index.isSameOriginAbsoluteUrl)(
              payload.domain_name,
              payload.redirect_uri
            );
          }
          function verifyAuthRequest(token) {
            return new Promise(function(resolve, reject) {
              if ((0, _jsontokens.decodeToken)(token).header.alg === 'none') {
                reject('Token must be signed in order to be verified');
              }
              Promise.all([
                isExpirationDateValid(token),
                isIssuanceDateValid(token),
                doSignaturesMatchPublicKeys(token),
                doPublicKeysMatchIssuer(token),
                isManifestUriValid(token),
                isRedirectUriValid(token)
              ]).then(function(values) {
                if (values.every(Boolean)) {
                  resolve(true);
                } else {
                  resolve(false);
                }
              });
            });
          }
          function verifyAuthRequestAndLoadManifest(token) {
            return new Promise(function(resolve, reject) {
              return verifyAuthRequest(token).then(function(valid) {
                if (valid) {
                  return (0, _.fetchAppManifest)(token)
                    .then(function(appManifest) {
                      resolve(appManifest);
                    })
                    .catch(function(err) {
                      reject(err);
                    });
                } else {
                  reject();
                  return Promise.reject();
                }
              });
            });
          }
          function verifyAuthResponse(token, nameLookupURL) {
            return new Promise(function(resolve) {
              Promise.all([
                isExpirationDateValid(token),
                isIssuanceDateValid(token),
                doSignaturesMatchPublicKeys(token),
                doPublicKeysMatchIssuer(token),
                doPublicKeysMatchUsername(token, nameLookupURL)
              ]).then(function(values) {
                if (values.every(Boolean)) {
                  resolve(true);
                } else {
                  resolve(false);
                }
              });
            });
          }
        },
        { '.': 8, '../index': 16, jsontokens: 387 }
      ],
      8: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          var _appConfig = require('./appConfig');
          Object.defineProperty(exports, 'AppConfig', {
            enumerable: true,
            get: function get() {
              return _appConfig.AppConfig;
            }
          });
          var _authMessages = require('./authMessages');
          Object.defineProperty(exports, 'makeAuthResponse', {
            enumerable: true,
            get: function get() {
              return _authMessages.makeAuthResponse;
            }
          });
          var _authProvider = require('./authProvider');
          Object.defineProperty(exports, 'getAuthRequestFromURL', {
            enumerable: true,
            get: function get() {
              return _authProvider.getAuthRequestFromURL;
            }
          });
          Object.defineProperty(exports, 'fetchAppManifest', {
            enumerable: true,
            get: function get() {
              return _authProvider.fetchAppManifest;
            }
          });
          Object.defineProperty(exports, 'redirectUserToApp', {
            enumerable: true,
            get: function get() {
              return _authProvider.redirectUserToApp;
            }
          });
          var _authSession = require('./authSession');
          Object.defineProperty(exports, 'makeCoreSessionRequest', {
            enumerable: true,
            get: function get() {
              return _authSession.makeCoreSessionRequest;
            }
          });
          Object.defineProperty(exports, 'sendCoreSessionRequest', {
            enumerable: true,
            get: function get() {
              return _authSession.sendCoreSessionRequest;
            }
          });
          Object.defineProperty(exports, 'getCoreSession', {
            enumerable: true,
            get: function get() {
              return _authSession.getCoreSession;
            }
          });
          var _authVerification = require('./authVerification');
          Object.defineProperty(exports, 'verifyAuthRequest', {
            enumerable: true,
            get: function get() {
              return _authVerification.verifyAuthRequest;
            }
          });
          Object.defineProperty(exports, 'verifyAuthResponse', {
            enumerable: true,
            get: function get() {
              return _authVerification.verifyAuthResponse;
            }
          });
          Object.defineProperty(exports, 'isExpirationDateValid', {
            enumerable: true,
            get: function get() {
              return _authVerification.isExpirationDateValid;
            }
          });
          Object.defineProperty(exports, 'isIssuanceDateValid', {
            enumerable: true,
            get: function get() {
              return _authVerification.isIssuanceDateValid;
            }
          });
          Object.defineProperty(exports, 'doPublicKeysMatchUsername', {
            enumerable: true,
            get: function get() {
              return _authVerification.doPublicKeysMatchUsername;
            }
          });
          Object.defineProperty(exports, 'doPublicKeysMatchIssuer', {
            enumerable: true,
            get: function get() {
              return _authVerification.doPublicKeysMatchIssuer;
            }
          });
          Object.defineProperty(exports, 'doSignaturesMatchPublicKeys', {
            enumerable: true,
            get: function get() {
              return _authVerification.doSignaturesMatchPublicKeys;
            }
          });
          Object.defineProperty(exports, 'isManifestUriValid', {
            enumerable: true,
            get: function get() {
              return _authVerification.isManifestUriValid;
            }
          });
          Object.defineProperty(exports, 'isRedirectUriValid', {
            enumerable: true,
            get: function get() {
              return _authVerification.isRedirectUriValid;
            }
          });
          Object.defineProperty(exports, 'verifyAuthRequestAndLoadManifest', {
            enumerable: true,
            get: function get() {
              return _authVerification.verifyAuthRequestAndLoadManifest;
            }
          });
          var _authApp = require('./authApp');
          Object.defineProperty(exports, 'isUserSignedIn', {
            enumerable: true,
            get: function get() {
              return _authApp.isUserSignedIn;
            }
          });
          Object.defineProperty(exports, 'redirectToSignIn', {
            enumerable: true,
            get: function get() {
              return _authApp.redirectToSignIn;
            }
          });
          Object.defineProperty(exports, 'redirectToSignInWithAuthRequest', {
            enumerable: true,
            get: function get() {
              return _authApp.redirectToSignInWithAuthRequest;
            }
          });
          Object.defineProperty(exports, 'isSignInPending', {
            enumerable: true,
            get: function get() {
              return _authApp.isSignInPending;
            }
          });
          Object.defineProperty(exports, 'handlePendingSignIn', {
            enumerable: true,
            get: function get() {
              return _authApp.handlePendingSignIn;
            }
          });
          Object.defineProperty(exports, 'loadUserData', {
            enumerable: true,
            get: function get() {
              return _authApp.loadUserData;
            }
          });
          Object.defineProperty(exports, 'signUserOut', {
            enumerable: true,
            get: function get() {
              return _authApp.signUserOut;
            }
          });
        },
        {
          './appConfig': 1,
          './authApp': 2,
          './authMessages': 4,
          './authProvider': 5,
          './authSession': 6,
          './authVerification': 7
        }
      ],
      9: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.SessionData = undefined;
          var _createClass = (function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          })();
          var _errors = require('../errors');
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          var SESSION_VERSION = '1.0.0';
          var SessionData = (exports.SessionData = (function() {
            function SessionData(options) {
              _classCallCheck(this, SessionData);
              this.version = SESSION_VERSION;
              this.appPrivateKey = options.appPrivateKey;
              this.identityAddress = options.identityAddress;
              this.username = options.username;
              this.coreNode = options.coreNode;
              this.hubUrl = options.hubUrl;
              this.userData = options.userData;
              this.transitKey = options.transitKey;
              this.gaiaHubConfig = null;
            }
            _createClass(
              SessionData,
              [
                {
                  key: 'getGaiaHubConfig',
                  value: function getGaiaHubConfig() {
                    return this.gaiaHubConfig;
                  }
                },
                {
                  key: 'setGaiaHubConfig',
                  value: function setGaiaHubConfig(config) {
                    this.gaiaHubConfig = config;
                  }
                },
                {
                  key: 'toString',
                  value: function toString() {
                    return JSON.stringify(this);
                  }
                }
              ],
              [
                {
                  key: 'fromJSON',
                  value: function fromJSON(json) {
                    if (json.version !== SESSION_VERSION) {
                      throw new _errors.InvalidStateError(
                        'JSON data version ' +
                          json.version +
                          ' not supported by SessionData'
                      );
                    }
                    var options = {
                      appPrivateKey: json.appPrivateKey,
                      identityAddress: json.identityAddress,
                      username: json.username,
                      coreNode: json.coreNode,
                      hubUrl: json.hubUrl,
                      userData: json.userData,
                      transitKey: json.transitKey
                    };
                    return new SessionData(options);
                  }
                }
              ]
            );
            return SessionData;
          })());
        },
        { '../errors': 15 }
      ],
      10: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.LocalStorageStore = exports.InstanceDataStore = exports.SessionDataStore = undefined;
          var _createClass = (function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          })();
          var _sessionData = require('./sessionData');
          var _authConstants = require('./authConstants');
          var _errors = require('../errors');
          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError(
                "this hasn't been initialised - super() hasn't been called"
              );
            }
            return call &&
              (typeof call === 'object' || typeof call === 'function')
              ? call
              : self;
          }
          function _inherits(subClass, superClass) {
            if (typeof superClass !== 'function' && superClass !== null) {
              throw new TypeError(
                'Super expression must either be null or a function, not ' +
                  typeof superClass
              );
            }
            subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              }
            );
            if (superClass)
              Object.setPrototypeOf
                ? Object.setPrototypeOf(subClass, superClass)
                : (subClass.__proto__ = superClass);
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          var SessionDataStore = (exports.SessionDataStore = (function() {
            function SessionDataStore(sessionOptions) {
              _classCallCheck(this, SessionDataStore);
              if (sessionOptions) {
                var newSessionData = new _sessionData.SessionData(
                  sessionOptions
                );
                this.setSessionData(newSessionData);
              }
            }
            _createClass(SessionDataStore, [
              {
                key: 'getSessionData',
                value: function getSessionData() {
                  throw new Error('Abstract class');
                }
              },
              {
                key: 'setSessionData',
                value: function setSessionData(session) {
                  throw new Error('Abstract class');
                }
              },
              {
                key: 'deleteSessionData',
                value: function deleteSessionData() {
                  throw new Error('Abstract class');
                }
              }
            ]);
            return SessionDataStore;
          })());
          var InstanceDataStore = (exports.InstanceDataStore = (function(
            _SessionDataStore
          ) {
            _inherits(InstanceDataStore, _SessionDataStore);
            function InstanceDataStore(sessionOptions) {
              _classCallCheck(this, InstanceDataStore);
              var _this = _possibleConstructorReturn(
                this,
                (
                  InstanceDataStore.__proto__ ||
                  Object.getPrototypeOf(InstanceDataStore)
                ).call(this, sessionOptions)
              );
              if (!_this.sessionData) {
                _this.setSessionData(new _sessionData.SessionData({}));
              }
              return _this;
            }
            _createClass(InstanceDataStore, [
              {
                key: 'getSessionData',
                value: function getSessionData() {
                  if (!this.sessionData) {
                    throw new _errors.NoSessionDataError(
                      'No session data was found.'
                    );
                  }
                  return this.sessionData;
                }
              },
              {
                key: 'setSessionData',
                value: function setSessionData(session) {
                  this.sessionData = session;
                  return true;
                }
              },
              {
                key: 'deleteSessionData',
                value: function deleteSessionData() {
                  this.setSessionData(new _sessionData.SessionData({}));
                  return true;
                }
              }
            ]);
            return InstanceDataStore;
          })(SessionDataStore));
          var LocalStorageStore = (exports.LocalStorageStore = (function(
            _SessionDataStore2
          ) {
            _inherits(LocalStorageStore, _SessionDataStore2);
            function LocalStorageStore(sessionOptions) {
              _classCallCheck(this, LocalStorageStore);
              var _this2 = _possibleConstructorReturn(
                this,
                (
                  LocalStorageStore.__proto__ ||
                  Object.getPrototypeOf(LocalStorageStore)
                ).call(this, sessionOptions)
              );
              if (
                sessionOptions &&
                sessionOptions.storeOptions &&
                sessionOptions.storeOptions.localStorageKey &&
                sessionOptions.storeOptions.localStorageKey instanceof String
              ) {
                _this2.key = sessionOptions.storeOptions.localStorageKey;
              } else {
                _this2.key = _authConstants.LOCALSTORAGE_SESSION_KEY;
              }
              var data = localStorage.getItem(_this2.key);
              if (!data) {
                var sessionData = new _sessionData.SessionData({});
                _this2.setSessionData(sessionData);
              }
              return _this2;
            }
            _createClass(LocalStorageStore, [
              {
                key: 'getSessionData',
                value: function getSessionData() {
                  var data = localStorage.getItem(this.key);
                  if (!data) {
                    throw new _errors.NoSessionDataError(
                      'No session data was found in localStorage'
                    );
                  }
                  var dataJSON = JSON.parse(data);
                  return _sessionData.SessionData.fromJSON(dataJSON);
                }
              },
              {
                key: 'setSessionData',
                value: function setSessionData(session) {
                  localStorage.setItem(this.key, session.toString());
                  return true;
                }
              },
              {
                key: 'deleteSessionData',
                value: function deleteSessionData() {
                  localStorage.removeItem(this.key);
                  this.setSessionData(new _sessionData.SessionData({}));
                  return true;
                }
              }
            ]);
            return LocalStorageStore;
          })(SessionDataStore));
        },
        { '../errors': 15, './authConstants': 3, './sessionData': 9 }
      ],
      11: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.UserSession = undefined;
          var _createClass = (function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          })();
          var _queryString = require('query-string');
          var _queryString2 = _interopRequireDefault(_queryString);
          var _appConfig = require('./appConfig');
          var _sessionStore = require('./sessionStore');
          var _authApp = require('./authApp');
          var _authMessages = require('./authMessages');
          var _storage = require('../storage');
          var _utils = require('../utils');
          var _errors = require('../errors');
          var _logger = require('../logger');
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          var UserSession = (exports.UserSession = (function() {
            function UserSession(options) {
              _classCallCheck(this, UserSession);
              var runningInBrowser = true;
              if (typeof window === 'undefined') {
                _logger.Logger.debug('UserSession: not running in browser');
                runningInBrowser = false;
              }
              if (options && options.appConfig) {
                this.appConfig = options.appConfig;
              } else if (runningInBrowser) {
                this.appConfig = new _appConfig.AppConfig();
              } else {
                throw new _errors.MissingParameterError(
                  'You need to specify options.appConfig'
                );
              }
              if (options && options.sessionStore) {
                this.store = options.sessionStore;
              } else if (runningInBrowser) {
                if (options) {
                  this.store = new _sessionStore.LocalStorageStore(
                    options.sessionOptions
                  );
                } else {
                  this.store = new _sessionStore.LocalStorageStore();
                }
              } else if (options) {
                this.store = new _sessionStore.InstanceDataStore(
                  options.sessionOptions
                );
              } else {
                this.store = new _sessionStore.InstanceDataStore();
              }
            }
            _createClass(UserSession, [
              {
                key: 'redirectToSignIn',
                value: function redirectToSignIn() {
                  return (0, _authApp.redirectToSignInImpl)(this);
                }
              },
              {
                key: 'redirectToSignInWithAuthRequest',
                value: function redirectToSignInWithAuthRequest(authRequest) {
                  return (0, _authApp.redirectToSignInWithAuthRequestImpl)(
                    this,
                    authRequest
                  );
                }
              },
              {
                key: 'makeAuthRequest',
                value: function makeAuthRequest(transitKey) {
                  var expiresAt =
                    arguments.length > 1 && arguments[1] !== undefined
                      ? arguments[1]
                      : (0, _utils.nextHour)().getTime();
                  var extraParams =
                    arguments.length > 2 && arguments[2] !== undefined
                      ? arguments[2]
                      : {};
                  var appConfig = this.appConfig;
                  if (!appConfig) {
                    throw new _errors.InvalidStateError('Missing AppConfig');
                  }
                  var redirectURI = appConfig.redirectURI();
                  var manifestURI = appConfig.manifestURI();
                  var scopes = appConfig.scopes;
                  var appDomain = appConfig.appDomain;
                  return (0, _authMessages.makeAuthRequestImpl)(
                    transitKey,
                    redirectURI,
                    manifestURI,
                    scopes,
                    appDomain,
                    expiresAt,
                    extraParams
                  );
                }
              },
              {
                key: 'generateAndStoreTransitKey',
                value: function generateAndStoreTransitKey() {
                  var sessionData = this.store.getSessionData();
                  var transitKey = (0, _authMessages.generateTransitKey)();
                  sessionData.transitKey = transitKey;
                  this.store.setSessionData(sessionData);
                  return transitKey;
                }
              },
              {
                key: 'getAuthResponseToken',
                value: function getAuthResponseToken() {
                  var queryDict = _queryString2.default.parse(location.search);
                  return queryDict.authResponse ? queryDict.authResponse : '';
                }
              },
              {
                key: 'isSignInPending',
                value: function isSignInPending() {
                  return !!this.getAuthResponseToken();
                }
              },
              {
                key: 'isUserSignedIn',
                value: function isUserSignedIn() {
                  return !!this.store.getSessionData().userData;
                }
              },
              {
                key: 'handlePendingSignIn',
                value: function handlePendingSignIn() {
                  var authResponseToken =
                    arguments.length > 0 && arguments[0] !== undefined
                      ? arguments[0]
                      : this.getAuthResponseToken();
                  return (0, _authApp.handlePendingSignInImpl)(
                    this,
                    authResponseToken
                  );
                }
              },
              {
                key: 'loadUserData',
                value: function loadUserData() {
                  return (0, _authApp.loadUserDataImpl)(this);
                }
              },
              {
                key: 'signUserOut',
                value: function signUserOut() {
                  this.store.deleteSessionData();
                }
              },
              {
                key: 'encryptContent',
                value: function encryptContent(content, options) {
                  return (0, _storage.encryptContentImpl)(
                    this,
                    content,
                    options
                  );
                }
              },
              {
                key: 'decryptContent',
                value: function decryptContent(content, options) {
                  return (0, _storage.decryptContentImpl)(
                    this,
                    content,
                    options
                  );
                }
              },
              {
                key: 'putFile',
                value: function putFile(path, content, options) {
                  return (0, _storage.putFileImpl)(
                    this,
                    path,
                    content,
                    options
                  );
                }
              },
              {
                key: 'getFile',
                value: function getFile(path, options) {
                  return (0, _storage.getFileImpl)(this, path, options);
                }
              },
              {
                key: 'listFiles',
                value: function listFiles(callback) {
                  return (0, _storage.listFilesImpl)(this, callback);
                }
              },
              {
                key: 'deleteFile',
                value: function deleteFile(path) {
                  Promise.reject(
                    new Error(
                      'Delete of ' + path + ' not supported by gaia hubs'
                    )
                  );
                }
              }
            ]);
            return UserSession;
          })());
        },
        {
          '../errors': 15,
          '../logger': 18,
          '../storage': 49,
          '../utils': 50,
          './appConfig': 1,
          './authApp': 2,
          './authMessages': 4,
          './sessionStore': 10,
          'query-string': 453
        }
      ],
      12: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.config = undefined;
          var _network = require('./network');
          var config = {
            network: _network.network.defaults.MAINNET_DEFAULT,
            logLevel: 'debug'
          };
          exports.config = config;
        },
        { './network': 19 }
      ],
      13: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.makeDIDFromAddress = makeDIDFromAddress;
          exports.makeDIDFromPublicKey = makeDIDFromPublicKey;
          exports.getDIDType = getDIDType;
          exports.getAddressFromDID = getAddressFromDID;
          var _errors = require('./errors');
          function makeDIDFromAddress(address) {
            return 'did:btc-addr:' + address;
          }
          function makeDIDFromPublicKey(publicKey) {
            return 'did:ecdsa-pub:' + publicKey;
          }
          function getDIDType(decentralizedID) {
            var didParts = decentralizedID.split(':');
            if (didParts.length !== 3) {
              throw new _errors.InvalidDIDError(
                'Decentralized IDs must have 3 parts'
              );
            }
            if (didParts[0].toLowerCase() !== 'did') {
              throw new _errors.InvalidDIDError(
                'Decentralized IDs must start with "did"'
              );
            }
            return didParts[1].toLowerCase();
          }
          function getAddressFromDID(decentralizedID) {
            var didType = getDIDType(decentralizedID);
            if (didType === 'btc-addr') {
              return decentralizedID.split(':')[2];
            } else {
              return null;
            }
          }
        },
        { './errors': 15 }
      ],
      14: [
        function(require, module, exports) {
          (function(Buffer) {
            'use strict';
            Object.defineProperty(exports, '__esModule', { value: true });
            exports.getHexFromBN = getHexFromBN;
            exports.encryptECIES = encryptECIES;
            exports.decryptECIES = decryptECIES;
            exports.signECDSA = signECDSA;
            exports.verifyECDSA = verifyECDSA;
            exports.encryptMnemonic = encryptMnemonic;
            exports.decryptMnemonic = decryptMnemonic;
            var _elliptic = require('elliptic');
            var _crypto = require('crypto');
            var _crypto2 = _interopRequireDefault(_crypto);
            var _bip = require('bip39');
            var _bip2 = _interopRequireDefault(_bip);
            var _triplesec = require('triplesec');
            var _triplesec2 = _interopRequireDefault(_triplesec);
            var _keys = require('./keys');
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError('Cannot call a class as a function');
              }
            }
            function _possibleConstructorReturn(self, call) {
              if (!self) {
                throw new ReferenceError(
                  "this hasn't been initialised - super() hasn't been called"
                );
              }
              return call &&
                (typeof call === 'object' || typeof call === 'function')
                ? call
                : self;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== 'function' && superClass !== null) {
                throw new TypeError(
                  'Super expression must either be null or a function, not ' +
                    typeof superClass
                );
              }
              subClass.prototype = Object.create(
                superClass && superClass.prototype,
                {
                  constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                }
              );
              if (superClass)
                Object.setPrototypeOf
                  ? Object.setPrototypeOf(subClass, superClass)
                  : (subClass.__proto__ = superClass);
            }
            var ecurve = new _elliptic.ec('secp256k1');
            function aes256CbcEncrypt(iv, key, plaintext) {
              var cipher = _crypto2.default.createCipheriv(
                'aes-256-cbc',
                key,
                iv
              );
              return Buffer.concat([cipher.update(plaintext), cipher.final()]);
            }
            function aes256CbcDecrypt(iv, key, ciphertext) {
              var cipher = _crypto2.default.createDecipheriv(
                'aes-256-cbc',
                key,
                iv
              );
              return Buffer.concat([cipher.update(ciphertext), cipher.final()]);
            }
            function hmacSha256(key, content) {
              return _crypto2.default
                .createHmac('sha256', key)
                .update(content)
                .digest();
            }
            function equalConstTime(b1, b2) {
              if (b1.length !== b2.length) {
                return false;
              }
              var res = 0;
              for (var i = 0; i < b1.length; i++) {
                res |= b1[i] ^ b2[i];
              }
              return res === 0;
            }
            function sharedSecretToKeys(sharedSecret) {
              var hashedSecret = _crypto2.default
                .createHash('sha512')
                .update(sharedSecret)
                .digest();
              return {
                encryptionKey: hashedSecret.slice(0, 32),
                hmacKey: hashedSecret.slice(32)
              };
            }
            function getHexFromBN(bnInput) {
              var hexOut = bnInput.toString('hex');
              if (hexOut.length === 64) {
                return hexOut;
              } else if (hexOut.length < 64) {
                var padding = '0'.repeat(64 - hexOut.length);
                return '' + padding + hexOut;
              } else {
                throw new Error(
                  'Generated a > 32-byte BN for encryption. Failing.'
                );
              }
            }
            function encryptECIES(publicKey, content) {
              var isString = typeof content === 'string';
              var plainText = Buffer.from(content);
              var ecPK = ecurve.keyFromPublic(publicKey, 'hex').getPublic();
              var ephemeralSK = ecurve.genKeyPair();
              var ephemeralPK = ephemeralSK.getPublic();
              var sharedSecret = ephemeralSK.derive(ecPK);
              var sharedSecretHex = getHexFromBN(sharedSecret);
              var sharedKeys = sharedSecretToKeys(
                new Buffer(sharedSecretHex, 'hex')
              );
              var initializationVector = _crypto2.default.randomBytes(16);
              var cipherText = aes256CbcEncrypt(
                initializationVector,
                sharedKeys.encryptionKey,
                plainText
              );
              var macData = Buffer.concat([
                initializationVector,
                new Buffer(ephemeralPK.encodeCompressed()),
                cipherText
              ]);
              var mac = hmacSha256(sharedKeys.hmacKey, macData);
              return {
                iv: initializationVector.toString('hex'),
                ephemeralPK: ephemeralPK.encodeCompressed('hex'),
                cipherText: cipherText.toString('hex'),
                mac: mac.toString('hex'),
                wasString: isString
              };
            }
            function decryptECIES(privateKey, cipherObject) {
              var ecSK = ecurve.keyFromPrivate(privateKey, 'hex');
              var ephemeralPK = ecurve
                .keyFromPublic(cipherObject.ephemeralPK, 'hex')
                .getPublic();
              var sharedSecret = ecSK.derive(ephemeralPK);
              var sharedSecretBuffer = new Buffer(
                getHexFromBN(sharedSecret),
                'hex'
              );
              var sharedKeys = sharedSecretToKeys(sharedSecretBuffer);
              var ivBuffer = new Buffer(cipherObject.iv, 'hex');
              var cipherTextBuffer = new Buffer(cipherObject.cipherText, 'hex');
              var macData = Buffer.concat([
                ivBuffer,
                new Buffer(ephemeralPK.encodeCompressed()),
                cipherTextBuffer
              ]);
              var actualMac = hmacSha256(sharedKeys.hmacKey, macData);
              var expectedMac = new Buffer(cipherObject.mac, 'hex');
              if (!equalConstTime(expectedMac, actualMac)) {
                throw new Error('Decryption failed: failure in MAC check');
              }
              var plainText = aes256CbcDecrypt(
                ivBuffer,
                sharedKeys.encryptionKey,
                cipherTextBuffer
              );
              if (cipherObject.wasString) {
                return plainText.toString();
              } else {
                return plainText;
              }
            }
            function signECDSA(privateKey, content) {
              var contentBuffer = Buffer.from(content);
              var ecPrivate = ecurve.keyFromPrivate(privateKey, 'hex');
              var publicKey = (0, _keys.getPublicKeyFromPrivate)(privateKey);
              var contentHash = _crypto2.default
                .createHash('sha256')
                .update(contentBuffer)
                .digest();
              var signature = ecPrivate.sign(contentHash);
              var signatureString = signature.toDER('hex');
              return { signature: signatureString, publicKey: publicKey };
            }
            function verifyECDSA(content, publicKey, signature) {
              var contentBuffer = Buffer.from(content);
              var ecPublic = ecurve.keyFromPublic(publicKey, 'hex');
              var contentHash = _crypto2.default
                .createHash('sha256')
                .update(contentBuffer)
                .digest();
              return ecPublic.verify(contentHash, signature);
            }
            function encryptMnemonic(phrase, password) {
              return Promise.resolve().then(function() {
                if (!_bip2.default.validateMnemonic(phrase)) {
                  throw new Error('Not a valid bip39 nmemonic');
                }
                var plaintextNormalized = Buffer.from(
                  _bip2.default.mnemonicToEntropy(phrase).toString('hex'),
                  'hex'
                );
                var salt = _crypto2.default.randomBytes(16);
                var keysAndIV = _crypto2.default.pbkdf2Sync(
                  password,
                  salt,
                  1e5,
                  48,
                  'sha512'
                );
                var encKey = keysAndIV.slice(0, 16);
                var macKey = keysAndIV.slice(16, 32);
                var iv = keysAndIV.slice(32, 48);
                var cipher = _crypto2.default.createCipheriv(
                  'aes-128-cbc',
                  encKey,
                  iv
                );
                var cipherText = cipher
                  .update(plaintextNormalized)
                  .toString('hex');
                cipherText += cipher.final().toString('hex');
                var hmacPayload = Buffer.concat([
                  salt,
                  Buffer.from(cipherText, 'hex')
                ]);
                var hmac = _crypto2.default.createHmac('sha256', macKey);
                hmac.write(hmacPayload);
                var hmacDigest = hmac.digest();
                var payload = Buffer.concat([
                  salt,
                  hmacDigest,
                  Buffer.from(cipherText, 'hex')
                ]);
                return payload;
              });
            }
            var PasswordError = (function(_Error) {
              _inherits(PasswordError, _Error);
              function PasswordError() {
                _classCallCheck(this, PasswordError);
                return _possibleConstructorReturn(
                  this,
                  (
                    PasswordError.__proto__ ||
                    Object.getPrototypeOf(PasswordError)
                  ).apply(this, arguments)
                );
              }
              return PasswordError;
            })(Error);
            function decryptMnemonicBuffer(dataBuffer, password) {
              return Promise.resolve().then(function() {
                var salt = dataBuffer.slice(0, 16);
                var hmacSig = dataBuffer.slice(16, 48);
                var cipherText = dataBuffer.slice(48);
                var hmacPayload = Buffer.concat([salt, cipherText]);
                var keysAndIV = _crypto2.default.pbkdf2Sync(
                  password,
                  salt,
                  1e5,
                  48,
                  'sha512'
                );
                var encKey = keysAndIV.slice(0, 16);
                var macKey = keysAndIV.slice(16, 32);
                var iv = keysAndIV.slice(32, 48);
                var decipher = _crypto2.default.createDecipheriv(
                  'aes-128-cbc',
                  encKey,
                  iv
                );
                var plaintext = decipher.update(cipherText).toString('hex');
                plaintext += decipher.final().toString('hex');
                var hmac = _crypto2.default.createHmac('sha256', macKey);
                hmac.write(hmacPayload);
                var hmacDigest = hmac.digest();
                var hmacSigHash = _crypto2.default
                  .createHash('sha256')
                  .update(hmacSig)
                  .digest()
                  .toString('hex');
                var hmacDigestHash = _crypto2.default
                  .createHash('sha256')
                  .update(hmacDigest)
                  .digest()
                  .toString('hex');
                if (hmacSigHash !== hmacDigestHash) {
                  throw new PasswordError('Wrong password (HMAC mismatch)');
                }
                var mnemonic = _bip2.default.entropyToMnemonic(plaintext);
                if (!_bip2.default.validateMnemonic(mnemonic)) {
                  throw new PasswordError('Wrong password (invalid plaintext)');
                }
                return mnemonic;
              });
            }
            function decryptLegacy(dataBuffer, password) {
              return new Promise(function(resolve, reject) {
                _triplesec2.default.decrypt(
                  { key: Buffer.from(password), data: dataBuffer },
                  function(err, plaintextBuffer) {
                    if (!err) {
                      resolve(plaintextBuffer);
                    } else {
                      reject(err);
                    }
                  }
                );
              });
            }
            function decryptMnemonic(data, password) {
              var dataBuffer = Buffer.isBuffer(data)
                ? data
                : Buffer.from(data, 'hex');
              return decryptMnemonicBuffer(dataBuffer, password).catch(function(
                err
              ) {
                if (err instanceof PasswordError) {
                  throw err;
                }
                return decryptLegacy(dataBuffer, password);
              });
            }
          }.call(this, require('buffer').Buffer));
        },
        {
          './keys': 17,
          bip39: 78,
          buffer: 183,
          crypto: 192,
          elliptic: 309,
          triplesec: 481
        }
      ],
      15: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          var _createClass = (function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          })();
          var _get = function get(object, property, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property);
            if (desc === undefined) {
              var parent = Object.getPrototypeOf(object);
              if (parent === null) {
                return undefined;
              } else {
                return get(parent, property, receiver);
              }
            } else if ('value' in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === undefined) {
                return undefined;
              }
              return getter.call(receiver);
            }
          };
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError(
                "this hasn't been initialised - super() hasn't been called"
              );
            }
            return call &&
              (typeof call === 'object' || typeof call === 'function')
              ? call
              : self;
          }
          function _inherits(subClass, superClass) {
            if (typeof superClass !== 'function' && superClass !== null) {
              throw new TypeError(
                'Super expression must either be null or a function, not ' +
                  typeof superClass
              );
            }
            subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              }
            );
            if (superClass)
              Object.setPrototypeOf
                ? Object.setPrototypeOf(subClass, superClass)
                : (subClass.__proto__ = superClass);
          }
          var ERROR_CODES = (exports.ERROR_CODES = {
            MISSING_PARAMETER: 'missing_parameter',
            REMOTE_SERVICE_ERROR: 'remote_service_error',
            INVALID_STATE: 'invalid_state',
            NO_SESSION_DATA: 'no_session_data',
            UNKNOWN: 'unknown'
          });
          Object.freeze(ERROR_CODES);
          var BlockstackError = (exports.BlockstackError = (function(_Error) {
            _inherits(BlockstackError, _Error);
            function BlockstackError(error) {
              _classCallCheck(this, BlockstackError);
              var _this = _possibleConstructorReturn(
                this,
                (
                  BlockstackError.__proto__ ||
                  Object.getPrototypeOf(BlockstackError)
                ).call(this, error.message)
              );
              _this.code = error.code;
              _this.parameter = error.parameter ? error.parameter : null;
              return _this;
            }
            _createClass(BlockstackError, [
              {
                key: 'toString',
                value: function toString() {
                  return (
                    _get(
                      BlockstackError.prototype.__proto__ ||
                        Object.getPrototypeOf(BlockstackError.prototype),
                      'toString',
                      this
                    ).call(this) +
                    '\n    code: ' +
                    this.code +
                    ' param: ' +
                    (this.parameter ? this.parameter : 'n/a')
                  );
                }
              }
            ]);
            return BlockstackError;
          })(Error));
          var InvalidParameterError = (exports.InvalidParameterError = (function(
            _BlockstackError
          ) {
            _inherits(InvalidParameterError, _BlockstackError);
            function InvalidParameterError(parameter) {
              var message =
                arguments.length > 1 && arguments[1] !== undefined
                  ? arguments[1]
                  : '';
              _classCallCheck(this, InvalidParameterError);
              var _this2 = _possibleConstructorReturn(
                this,
                (
                  InvalidParameterError.__proto__ ||
                  Object.getPrototypeOf(InvalidParameterError)
                ).call(this, {
                  code: 'missing_parameter',
                  message: message,
                  parameter: ''
                })
              );
              _this2.name = 'MissingParametersError';
              return _this2;
            }
            return InvalidParameterError;
          })(BlockstackError));
          var MissingParameterError = (exports.MissingParameterError = (function(
            _BlockstackError2
          ) {
            _inherits(MissingParameterError, _BlockstackError2);
            function MissingParameterError(parameter) {
              var message =
                arguments.length > 1 && arguments[1] !== undefined
                  ? arguments[1]
                  : '';
              _classCallCheck(this, MissingParameterError);
              var _this3 = _possibleConstructorReturn(
                this,
                (
                  MissingParameterError.__proto__ ||
                  Object.getPrototypeOf(MissingParameterError)
                ).call(this, {
                  code: ERROR_CODES.MISSING_PARAMETER,
                  message: message,
                  parameter: parameter
                })
              );
              _this3.name = 'MissingParametersError';
              return _this3;
            }
            return MissingParameterError;
          })(BlockstackError));
          var RemoteServiceError = (exports.RemoteServiceError = (function(
            _BlockstackError3
          ) {
            _inherits(RemoteServiceError, _BlockstackError3);
            function RemoteServiceError(response) {
              var message =
                arguments.length > 1 && arguments[1] !== undefined
                  ? arguments[1]
                  : '';
              _classCallCheck(this, RemoteServiceError);
              var _this4 = _possibleConstructorReturn(
                this,
                (
                  RemoteServiceError.__proto__ ||
                  Object.getPrototypeOf(RemoteServiceError)
                ).call(this, {
                  code: ERROR_CODES.REMOTE_SERVICE_ERROR,
                  message: message
                })
              );
              _this4.response = response;
              return _this4;
            }
            return RemoteServiceError;
          })(BlockstackError));
          var InvalidDIDError = (exports.InvalidDIDError = (function(
            _BlockstackError4
          ) {
            _inherits(InvalidDIDError, _BlockstackError4);
            function InvalidDIDError() {
              var message =
                arguments.length > 0 && arguments[0] !== undefined
                  ? arguments[0]
                  : '';
              _classCallCheck(this, InvalidDIDError);
              var _this5 = _possibleConstructorReturn(
                this,
                (
                  InvalidDIDError.__proto__ ||
                  Object.getPrototypeOf(InvalidDIDError)
                ).call(this, { code: 'invalid_did_error', message: message })
              );
              _this5.name = 'InvalidDIDError';
              return _this5;
            }
            return InvalidDIDError;
          })(BlockstackError));
          var NotEnoughFundsError = (exports.NotEnoughFundsError = (function(
            _BlockstackError5
          ) {
            _inherits(NotEnoughFundsError, _BlockstackError5);
            function NotEnoughFundsError(leftToFund) {
              _classCallCheck(this, NotEnoughFundsError);
              var message =
                'Not enough UTXOs to fund. Left to fund: ' + leftToFund;
              var _this6 = _possibleConstructorReturn(
                this,
                (
                  NotEnoughFundsError.__proto__ ||
                  Object.getPrototypeOf(NotEnoughFundsError)
                ).call(this, { code: 'not_enough_error', message: message })
              );
              _this6.leftToFund = leftToFund;
              _this6.name = 'NotEnoughFundsError';
              _this6.message = message;
              return _this6;
            }
            return NotEnoughFundsError;
          })(BlockstackError));
          var InvalidAmountError = (exports.InvalidAmountError = (function(
            _BlockstackError6
          ) {
            _inherits(InvalidAmountError, _BlockstackError6);
            function InvalidAmountError(fees, specifiedAmount) {
              _classCallCheck(this, InvalidAmountError);
              var message =
                'Not enough coin to fund fees transaction fees. Fees would be ' +
                fees +
                ',' +
                (' specified spend is  ' + specifiedAmount);
              var _this7 = _possibleConstructorReturn(
                this,
                (
                  InvalidAmountError.__proto__ ||
                  Object.getPrototypeOf(InvalidAmountError)
                ).call(this, { code: 'invalid_amount_error', message: message })
              );
              _this7.specifiedAmount = specifiedAmount;
              _this7.fees = fees;
              _this7.name = 'InvalidAmountError';
              _this7.message = message;
              return _this7;
            }
            return InvalidAmountError;
          })(BlockstackError));
          var LoginFailedError = (exports.LoginFailedError = (function(
            _BlockstackError7
          ) {
            _inherits(LoginFailedError, _BlockstackError7);
            function LoginFailedError(reason) {
              _classCallCheck(this, LoginFailedError);
              var message = 'Failed to login: ' + reason;
              var _this8 = _possibleConstructorReturn(
                this,
                (
                  LoginFailedError.__proto__ ||
                  Object.getPrototypeOf(LoginFailedError)
                ).call(this, { code: 'login_failed', message: message })
              );
              _this8.message = message;
              _this8.name = 'LoginFailedError';
              return _this8;
            }
            return LoginFailedError;
          })(BlockstackError));
          var SignatureVerificationError = (exports.SignatureVerificationError = (function(
            _BlockstackError8
          ) {
            _inherits(SignatureVerificationError, _BlockstackError8);
            function SignatureVerificationError(reason) {
              _classCallCheck(this, SignatureVerificationError);
              var message = 'Failed to verify signature: ' + reason;
              var _this9 = _possibleConstructorReturn(
                this,
                (
                  SignatureVerificationError.__proto__ ||
                  Object.getPrototypeOf(SignatureVerificationError)
                ).call(this, {
                  code: 'signature_verification_failure',
                  message: message
                })
              );
              _this9.message = message;
              _this9.name = 'SignatureVerificationError';
              return _this9;
            }
            return SignatureVerificationError;
          })(BlockstackError));
          var InvalidStateError = (exports.InvalidStateError = (function(
            _BlockstackError9
          ) {
            _inherits(InvalidStateError, _BlockstackError9);
            function InvalidStateError(message) {
              _classCallCheck(this, InvalidStateError);
              var _this10 = _possibleConstructorReturn(
                this,
                (
                  InvalidStateError.__proto__ ||
                  Object.getPrototypeOf(InvalidStateError)
                ).call(this, {
                  code: ERROR_CODES.INVALID_STATE,
                  message: message
                })
              );
              _this10.message = message;
              _this10.name = 'InvalidStateError';
              return _this10;
            }
            return InvalidStateError;
          })(BlockstackError));
          var NoSessionDataError = (exports.NoSessionDataError = (function(
            _BlockstackError10
          ) {
            _inherits(NoSessionDataError, _BlockstackError10);
            function NoSessionDataError(message) {
              _classCallCheck(this, NoSessionDataError);
              var _this11 = _possibleConstructorReturn(
                this,
                (
                  NoSessionDataError.__proto__ ||
                  Object.getPrototypeOf(NoSessionDataError)
                ).call(this, {
                  code: ERROR_CODES.INVALID_STATE,
                  message: message
                })
              );
              _this11.message = message;
              _this11.name = 'NoSessionDataError';
              return _this11;
            }
            return NoSessionDataError;
          })(BlockstackError));
        },
        {}
      ],
      16: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.UserSession = exports.decryptMnemonic = exports.encryptMnemonic = exports.config = exports.decodeToken = exports.network = exports.IdentityKeyPair = exports.BlockstackWallet = exports.estimateTXBytes = exports.addUTXOsToFund = exports.PubkeyHashSigner = exports.TransactionSigner = exports.safety = exports.transactions = exports.ecPairToAddress = exports.ecPairToHexString = exports.hexStringToECPair = exports.isSameOriginAbsoluteUrl = exports.isLaterVersion = exports.updateQueryStringParameter = exports.makeUUID4 = exports.nextHour = exports.nextMonth = exports.nextYear = exports.getPublicKeyFromPrivate = exports.publicKeyToAddress = exports.makeECPrivateKey = exports.getEntropy = exports.getAddressFromDID = exports.getDIDType = exports.makeDIDFromPublicKey = exports.makeDIDFromAddress = undefined;
          var _typeof =
            typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
              ? function(obj) {
                  return typeof obj;
                }
              : function(obj) {
                  return obj &&
                    typeof Symbol === 'function' &&
                    obj.constructor === Symbol &&
                    obj !== Symbol.prototype
                    ? 'symbol'
                    : typeof obj;
                };
          var _auth = require('./auth');
          Object.keys(_auth).forEach(function(key) {
            if (key === 'default' || key === '__esModule') return;
            Object.defineProperty(exports, key, {
              enumerable: true,
              get: function get() {
                return _auth[key];
              }
            });
          });
          var _profiles = require('./profiles');
          Object.keys(_profiles).forEach(function(key) {
            if (key === 'default' || key === '__esModule') return;
            Object.defineProperty(exports, key, {
              enumerable: true,
              get: function get() {
                return _profiles[key];
              }
            });
          });
          var _storage = require('./storage');
          Object.keys(_storage).forEach(function(key) {
            if (key === 'default' || key === '__esModule') return;
            Object.defineProperty(exports, key, {
              enumerable: true,
              get: function get() {
                return _storage[key];
              }
            });
          });
          var _dids = require('./dids');
          Object.defineProperty(exports, 'makeDIDFromAddress', {
            enumerable: true,
            get: function get() {
              return _dids.makeDIDFromAddress;
            }
          });
          Object.defineProperty(exports, 'makeDIDFromPublicKey', {
            enumerable: true,
            get: function get() {
              return _dids.makeDIDFromPublicKey;
            }
          });
          Object.defineProperty(exports, 'getDIDType', {
            enumerable: true,
            get: function get() {
              return _dids.getDIDType;
            }
          });
          Object.defineProperty(exports, 'getAddressFromDID', {
            enumerable: true,
            get: function get() {
              return _dids.getAddressFromDID;
            }
          });
          var _keys = require('./keys');
          Object.defineProperty(exports, 'getEntropy', {
            enumerable: true,
            get: function get() {
              return _keys.getEntropy;
            }
          });
          Object.defineProperty(exports, 'makeECPrivateKey', {
            enumerable: true,
            get: function get() {
              return _keys.makeECPrivateKey;
            }
          });
          Object.defineProperty(exports, 'publicKeyToAddress', {
            enumerable: true,
            get: function get() {
              return _keys.publicKeyToAddress;
            }
          });
          Object.defineProperty(exports, 'getPublicKeyFromPrivate', {
            enumerable: true,
            get: function get() {
              return _keys.getPublicKeyFromPrivate;
            }
          });
          var _utils = require('./utils');
          Object.defineProperty(exports, 'nextYear', {
            enumerable: true,
            get: function get() {
              return _utils.nextYear;
            }
          });
          Object.defineProperty(exports, 'nextMonth', {
            enumerable: true,
            get: function get() {
              return _utils.nextMonth;
            }
          });
          Object.defineProperty(exports, 'nextHour', {
            enumerable: true,
            get: function get() {
              return _utils.nextHour;
            }
          });
          Object.defineProperty(exports, 'makeUUID4', {
            enumerable: true,
            get: function get() {
              return _utils.makeUUID4;
            }
          });
          Object.defineProperty(exports, 'updateQueryStringParameter', {
            enumerable: true,
            get: function get() {
              return _utils.updateQueryStringParameter;
            }
          });
          Object.defineProperty(exports, 'isLaterVersion', {
            enumerable: true,
            get: function get() {
              return _utils.isLaterVersion;
            }
          });
          Object.defineProperty(exports, 'isSameOriginAbsoluteUrl', {
            enumerable: true,
            get: function get() {
              return _utils.isSameOriginAbsoluteUrl;
            }
          });
          Object.defineProperty(exports, 'hexStringToECPair', {
            enumerable: true,
            get: function get() {
              return _utils.hexStringToECPair;
            }
          });
          Object.defineProperty(exports, 'ecPairToHexString', {
            enumerable: true,
            get: function get() {
              return _utils.ecPairToHexString;
            }
          });
          Object.defineProperty(exports, 'ecPairToAddress', {
            enumerable: true,
            get: function get() {
              return _utils.ecPairToAddress;
            }
          });
          var _operations = require('./operations');
          Object.defineProperty(exports, 'transactions', {
            enumerable: true,
            get: function get() {
              return _operations.transactions;
            }
          });
          Object.defineProperty(exports, 'safety', {
            enumerable: true,
            get: function get() {
              return _operations.safety;
            }
          });
          Object.defineProperty(exports, 'TransactionSigner', {
            enumerable: true,
            get: function get() {
              return _operations.TransactionSigner;
            }
          });
          Object.defineProperty(exports, 'PubkeyHashSigner', {
            enumerable: true,
            get: function get() {
              return _operations.PubkeyHashSigner;
            }
          });
          Object.defineProperty(exports, 'addUTXOsToFund', {
            enumerable: true,
            get: function get() {
              return _operations.addUTXOsToFund;
            }
          });
          Object.defineProperty(exports, 'estimateTXBytes', {
            enumerable: true,
            get: function get() {
              return _operations.estimateTXBytes;
            }
          });
          var _wallet = require('./wallet');
          Object.defineProperty(exports, 'BlockstackWallet', {
            enumerable: true,
            get: function get() {
              return _wallet.BlockstackWallet;
            }
          });
          Object.defineProperty(exports, 'IdentityKeyPair', {
            enumerable: true,
            get: function get() {
              return _wallet.IdentityKeyPair;
            }
          });
          var _network = require('./network');
          Object.defineProperty(exports, 'network', {
            enumerable: true,
            get: function get() {
              return _network.network;
            }
          });
          var _jsontokens = require('jsontokens');
          Object.defineProperty(exports, 'decodeToken', {
            enumerable: true,
            get: function get() {
              return _jsontokens.decodeToken;
            }
          });
          var _config = require('./config');
          Object.defineProperty(exports, 'config', {
            enumerable: true,
            get: function get() {
              return _config.config;
            }
          });
          var _encryption = require('./encryption');
          Object.defineProperty(exports, 'encryptMnemonic', {
            enumerable: true,
            get: function get() {
              return _encryption.encryptMnemonic;
            }
          });
          Object.defineProperty(exports, 'decryptMnemonic', {
            enumerable: true,
            get: function get() {
              return _encryption.decryptMnemonic;
            }
          });
          var _userSession = require('./auth/userSession');
          Object.defineProperty(exports, 'UserSession', {
            enumerable: true,
            get: function get() {
              return _userSession.UserSession;
            }
          });
          var _queryString = require('query-string');
          var _queryString2 = _interopRequireDefault(_queryString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          (function protocolEchoReplyDetection() {
            if (
              (typeof window === 'undefined'
                ? 'undefined'
                : _typeof(window)) !== 'object' ||
              !window.location ||
              !window.localStorage
            ) {
              return;
            }
            var queryDict = _queryString2.default.parse(window.location.search);
            if (queryDict.echoReply) {
              var echoReplyKey = 'echo-reply-' + queryDict.echoReply;
              window.localStorage.setItem(echoReplyKey, 'success');
              window.setTimeout(function() {
                window.location = decodeURIComponent(
                  queryDict.authContinuation
                );
              }, 10);
            }
          })();
        },
        {
          './auth': 8,
          './auth/userSession': 11,
          './config': 12,
          './dids': 13,
          './encryption': 14,
          './keys': 17,
          './network': 19,
          './operations': 20,
          './profiles': 26,
          './storage': 49,
          './utils': 50,
          './wallet': 51,
          jsontokens: 387,
          'query-string': 453
        }
      ],
      17: [
        function(require, module, exports) {
          (function(Buffer) {
            'use strict';
            Object.defineProperty(exports, '__esModule', { value: true });
            exports.getEntropy = getEntropy;
            exports.makeECPrivateKey = makeECPrivateKey;
            exports.publicKeyToAddress = publicKeyToAddress;
            exports.getPublicKeyFromPrivate = getPublicKeyFromPrivate;
            var _crypto = require('crypto');
            var _bitcoinjsLib = require('bitcoinjs-lib');
            function getEntropy(numberOfBytes) {
              if (!numberOfBytes) {
                numberOfBytes = 32;
              }
              return (0, _crypto.randomBytes)(numberOfBytes);
            }
            function makeECPrivateKey() {
              var keyPair = new _bitcoinjsLib.ECPair.makeRandom({
                rng: getEntropy
              });
              return keyPair.privateKey.toString('hex');
            }
            function publicKeyToAddress(publicKey) {
              var publicKeyBuffer = Buffer.from(publicKey, 'hex');
              var publicKeyHash160 = _bitcoinjsLib.crypto.hash160(
                publicKeyBuffer
              );
              var address = _bitcoinjsLib.address.toBase58Check(
                publicKeyHash160,
                0
              );
              return address;
            }
            function getPublicKeyFromPrivate(privateKey) {
              var keyPair = _bitcoinjsLib.ECPair.fromPrivateKey(
                Buffer.from(privateKey, 'hex')
              );
              return keyPair.publicKey.toString('hex');
            }
          }.call(this, require('buffer').Buffer));
        },
        { 'bitcoinjs-lib': 96, buffer: 183, crypto: 192 }
      ],
      18: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.Logger = exports.levels = undefined;
          var _createClass = (function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          })();
          var _config = require('./config');
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          var levels = (exports.levels = [
            'debug',
            'info',
            'warn',
            'error',
            'none'
          ]);
          var levelToInt = {};
          var intToLevel = {};
          for (var index = 0; index < levels.length; index++) {
            var level = levels[index];
            levelToInt[level] = index;
            intToLevel[index] = level;
          }
          var Logger = (exports.Logger = (function() {
            function Logger() {
              _classCallCheck(this, Logger);
            }
            _createClass(Logger, null, [
              {
                key: 'error',
                value: function error(message) {
                  if (!this.shouldLog('error')) return;
                  console.error(this.logMessage('error', message));
                }
              },
              {
                key: 'warn',
                value: function warn(message) {
                  if (!this.shouldLog('warn')) return;
                  console.warn(this.logMessage('warn', message));
                }
              },
              {
                key: 'info',
                value: function info(message) {
                  if (!this.shouldLog('info')) return;
                  console.log(this.logMessage('info', message));
                }
              },
              {
                key: 'debug',
                value: function debug(message) {
                  if (!this.shouldLog('debug')) return;
                  console.log(this.logMessage('debug', message));
                }
              },
              {
                key: 'logMessage',
                value: function logMessage(level, message) {
                  return '[' + level.toUpperCase() + '] ' + message;
                }
              },
              {
                key: 'shouldLog',
                value: function shouldLog(level) {
                  var currentLevel = levelToInt[_config.config.logLevel];
                  return currentLevel <= levelToInt[level];
                }
              }
            ]);
            return Logger;
          })());
        },
        { './config': 12 }
      ],
      19: [
        function(require, module, exports) {
          (function(Buffer) {
            'use strict';
            Object.defineProperty(exports, '__esModule', { value: true });
            exports.network = exports.BlockchainInfoApi = exports.InsightClient = exports.BitcoindAPI = exports.LocalRegtest = exports.BlockstackNetwork = exports.BitcoinNetwork = undefined;
            var _slicedToArray = (function() {
              function sliceIterator(arr, i) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = undefined;
                try {
                  for (
                    var _i = arr[Symbol.iterator](), _s;
                    !(_n = (_s = _i.next()).done);
                    _n = true
                  ) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i['return']) _i['return']();
                  } finally {
                    if (_d) throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i);
                } else {
                  throw new TypeError(
                    'Invalid attempt to destructure non-iterable instance'
                  );
                }
              };
            })();
            var _createClass = (function() {
              function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ('value' in descriptor) descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps)
                  defineProperties(Constructor.prototype, protoProps);
                if (staticProps) defineProperties(Constructor, staticProps);
                return Constructor;
              };
            })();
            var _bitcoinjsLib = require('bitcoinjs-lib');
            var _bitcoinjsLib2 = _interopRequireDefault(_bitcoinjsLib);
            var _formData = require('form-data');
            var _formData2 = _interopRequireDefault(_formData);
            var _bigi = require('bigi');
            var _bigi2 = _interopRequireDefault(_bigi);
            var _ripemd = require('ripemd160');
            var _ripemd2 = _interopRequireDefault(_ripemd);
            var _errors = require('./errors');
            var _logger = require('./logger');
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _possibleConstructorReturn(self, call) {
              if (!self) {
                throw new ReferenceError(
                  "this hasn't been initialised - super() hasn't been called"
                );
              }
              return call &&
                (typeof call === 'object' || typeof call === 'function')
                ? call
                : self;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== 'function' && superClass !== null) {
                throw new TypeError(
                  'Super expression must either be null or a function, not ' +
                    typeof superClass
                );
              }
              subClass.prototype = Object.create(
                superClass && superClass.prototype,
                {
                  constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                }
              );
              if (superClass)
                Object.setPrototypeOf
                  ? Object.setPrototypeOf(subClass, superClass)
                  : (subClass.__proto__ = superClass);
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError('Cannot call a class as a function');
              }
            }
            var SATOSHIS_PER_BTC = 1e8;
            var TX_BROADCAST_SERVICE_ZONE_FILE_ENDPOINT = 'zone-file';
            var TX_BROADCAST_SERVICE_REGISTRATION_ENDPOINT = 'registration';
            var TX_BROADCAST_SERVICE_TX_ENDPOINT = 'transaction';
            var BitcoinNetwork = (exports.BitcoinNetwork = (function() {
              function BitcoinNetwork() {
                _classCallCheck(this, BitcoinNetwork);
              }
              _createClass(BitcoinNetwork, [
                {
                  key: 'broadcastTransaction',
                  value: function broadcastTransaction(transaction) {
                    return Promise.reject(
                      new Error(
                        'Not implemented, broadcastTransaction(' +
                          transaction +
                          ')'
                      )
                    );
                  }
                },
                {
                  key: 'getBlockHeight',
                  value: function getBlockHeight() {
                    return Promise.reject(
                      new Error('Not implemented, getBlockHeight()')
                    );
                  }
                },
                {
                  key: 'getTransactionInfo',
                  value: function getTransactionInfo(txid) {
                    return Promise.reject(
                      new Error(
                        'Not implemented, getTransactionInfo(' + txid + ')'
                      )
                    );
                  }
                },
                {
                  key: 'getNetworkedUTXOs',
                  value: function getNetworkedUTXOs(address) {
                    return Promise.reject(
                      new Error(
                        'Not implemented, getNetworkedUTXOs(' + address + ')'
                      )
                    );
                  }
                }
              ]);
              return BitcoinNetwork;
            })());
            var BlockstackNetwork = (exports.BlockstackNetwork = (function() {
              function BlockstackNetwork(
                apiUrl,
                broadcastServiceUrl,
                bitcoinAPI
              ) {
                var network =
                  arguments.length > 3 && arguments[3] !== undefined
                    ? arguments[3]
                    : _bitcoinjsLib2.default.networks.bitcoin;
                _classCallCheck(this, BlockstackNetwork);
                this.blockstackAPIUrl = apiUrl;
                this.broadcastServiceUrl = broadcastServiceUrl;
                this.layer1 = network;
                this.btc = bitcoinAPI;
                this.DUST_MINIMUM = 5500;
                this.includeUtxoMap = {};
                this.excludeUtxoSet = [];
                this.MAGIC_BYTES = 'id';
              }
              _createClass(BlockstackNetwork, [
                {
                  key: 'coerceAddress',
                  value: function coerceAddress(address) {
                    var _bitcoinjs$address$fr = _bitcoinjsLib2.default.address.fromBase58Check(
                        address
                      ),
                      hash = _bitcoinjs$address$fr.hash,
                      version = _bitcoinjs$address$fr.version;
                    var scriptHashes = [
                      _bitcoinjsLib2.default.networks.bitcoin.scriptHash,
                      _bitcoinjsLib2.default.networks.testnet.scriptHash
                    ];
                    var pubKeyHashes = [
                      _bitcoinjsLib2.default.networks.bitcoin.pubKeyHash,
                      _bitcoinjsLib2.default.networks.testnet.pubKeyHash
                    ];
                    var coercedVersion = void 0;
                    if (scriptHashes.indexOf(version) >= 0) {
                      coercedVersion = this.layer1.scriptHash;
                    } else if (pubKeyHashes.indexOf(version) >= 0) {
                      coercedVersion = this.layer1.pubKeyHash;
                    } else {
                      throw new Error(
                        'Unrecognized address version number ' +
                          version +
                          ' in ' +
                          address
                      );
                    }
                    return _bitcoinjsLib2.default.address.toBase58Check(
                      hash,
                      coercedVersion
                    );
                  }
                },
                {
                  key: 'getDefaultBurnAddress',
                  value: function getDefaultBurnAddress() {
                    return this.coerceAddress('1111111111111111111114oLvT2');
                  }
                },
                {
                  key: 'getNamePriceV1',
                  value: function getNamePriceV1(fullyQualifiedName) {
                    var _this = this;
                    return fetch(
                      this.blockstackAPIUrl +
                        '/v1/prices/names/' +
                        fullyQualifiedName
                    )
                      .then(function(resp) {
                        if (!resp.ok) {
                          throw new Error(
                            'Failed to query name price for ' +
                              fullyQualifiedName
                          );
                        }
                        return resp;
                      })
                      .then(function(resp) {
                        return resp.json();
                      })
                      .then(function(resp) {
                        return resp.name_price;
                      })
                      .then(function(namePrice) {
                        if (!namePrice || !namePrice.satoshis) {
                          throw new Error(
                            'Failed to get price for ' +
                              fullyQualifiedName +
                              '. Does the namespace exist?'
                          );
                        }
                        if (namePrice.satoshis < _this.DUST_MINIMUM) {
                          namePrice.satoshis = _this.DUST_MINIMUM;
                        }
                        var result = {
                          units: 'BTC',
                          amount: _bigi2.default.fromByteArrayUnsigned(
                            String(namePrice.satoshis)
                          )
                        };
                        return result;
                      });
                  }
                },
                {
                  key: 'getNamespacePriceV1',
                  value: function getNamespacePriceV1(namespaceID) {
                    var _this2 = this;
                    return fetch(
                      this.blockstackAPIUrl +
                        '/v1/prices/namespaces/' +
                        namespaceID
                    )
                      .then(function(resp) {
                        if (!resp.ok) {
                          throw new Error(
                            'Failed to query name price for ' + namespaceID
                          );
                        }
                        return resp;
                      })
                      .then(function(resp) {
                        return resp.json();
                      })
                      .then(function(namespacePrice) {
                        if (!namespacePrice || !namespacePrice.satoshis) {
                          throw new Error(
                            'Failed to get price for ' + namespaceID
                          );
                        }
                        if (namespacePrice.satoshis < _this2.DUST_MINIMUM) {
                          namespacePrice.satoshis = _this2.DUST_MINIMUM;
                        }
                        var result = {
                          units: 'BTC',
                          amount: _bigi2.default.fromByteArrayUnsigned(
                            String(namespacePrice.satoshis)
                          )
                        };
                        return result;
                      });
                  }
                },
                {
                  key: 'getNamePriceV2',
                  value: function getNamePriceV2(fullyQualifiedName) {
                    var _this3 = this;
                    return fetch(
                      this.blockstackAPIUrl +
                        '/v2/prices/names/' +
                        fullyQualifiedName
                    )
                      .then(function(resp) {
                        if (resp.status !== 200) {
                          throw new Error(
                            'The upstream node does not handle the /v2/ price namespace'
                          );
                        }
                        return resp;
                      })
                      .then(function(resp) {
                        return resp.json();
                      })
                      .then(function(resp) {
                        return resp.name_price;
                      })
                      .then(function(namePrice) {
                        if (!namePrice) {
                          throw new Error(
                            'Failed to get price for ' +
                              fullyQualifiedName +
                              '. Does the namespace exist?'
                          );
                        }
                        var result = {
                          units: namePrice.units,
                          amount: _bigi2.default.fromByteArrayUnsigned(
                            namePrice.amount
                          )
                        };
                        if (namePrice.units === 'BTC') {
                          var dustMin = _bigi2.default.fromByteArrayUnsigned(
                            String(_this3.DUST_MINIMUM)
                          );
                          if (result.amount.compareTo(dustMin) < 0) {
                            result.amount = dustMin;
                          }
                        }
                        return result;
                      });
                  }
                },
                {
                  key: 'getNamespacePriceV2',
                  value: function getNamespacePriceV2(namespaceID) {
                    var _this4 = this;
                    return fetch(
                      this.blockstackAPIUrl +
                        '/v2/prices/namespaces/' +
                        namespaceID
                    )
                      .then(function(resp) {
                        if (resp.status !== 200) {
                          throw new Error(
                            'The upstream node does not handle the /v2/ price namespace'
                          );
                        }
                        return resp;
                      })
                      .then(function(resp) {
                        return resp.json();
                      })
                      .then(function(namespacePrice) {
                        if (!namespacePrice) {
                          throw new Error(
                            'Failed to get price for ' + namespaceID
                          );
                        }
                        var result = {
                          units: namespacePrice.units,
                          amount: _bigi2.default.fromByteArrayUnsigned(
                            namespacePrice.amount
                          )
                        };
                        if (namespacePrice.units === 'BTC') {
                          var dustMin = _bigi2.default.fromByteArrayUnsigned(
                            String(_this4.DUST_MINIMUM)
                          );
                          if (result.amount.compareTo(dustMin) < 0) {
                            result.amount = dustMin;
                          }
                        }
                        return result;
                      });
                  }
                },
                {
                  key: 'getNamePrice',
                  value: function getNamePrice(fullyQualifiedName) {
                    var _this5 = this;
                    return Promise.resolve()
                      .then(function() {
                        return _this5.getNamePriceV2(fullyQualifiedName);
                      })
                      .catch(function() {
                        return _this5.getNamePriceV1(fullyQualifiedName);
                      });
                  }
                },
                {
                  key: 'getNamespacePrice',
                  value: function getNamespacePrice(namespaceID) {
                    var _this6 = this;
                    return Promise.resolve()
                      .then(function() {
                        return _this6.getNamespacePriceV2(namespaceID);
                      })
                      .catch(function() {
                        return _this6.getNamespacePriceV1(namespaceID);
                      });
                  }
                },
                {
                  key: 'getGracePeriod',
                  value: function getGracePeriod() {
                    return new Promise(function(resolve) {
                      return resolve(5e3);
                    });
                  }
                },
                {
                  key: 'getNamesOwned',
                  value: function getNamesOwned(address) {
                    var networkAddress = this.coerceAddress(address);
                    return fetch(
                      this.blockstackAPIUrl +
                        '/v1/addresses/bitcoin/' +
                        networkAddress
                    )
                      .then(function(resp) {
                        return resp.json();
                      })
                      .then(function(obj) {
                        return obj.names;
                      });
                  }
                },
                {
                  key: 'getNamespaceBurnAddress',
                  value: function getNamespaceBurnAddress(namespace) {
                    var _this7 = this;
                    return Promise.all([
                      fetch(
                        this.blockstackAPIUrl + '/v1/namespaces/' + namespace
                      ),
                      this.getBlockHeight()
                    ])
                      .then(function(_ref) {
                        var _ref2 = _slicedToArray(_ref, 2),
                          resp = _ref2[0],
                          blockHeight = _ref2[1];
                        if (resp.status === 404) {
                          throw new Error(
                            "No such namespace '" + namespace + "'"
                          );
                        } else {
                          return Promise.all([resp.json(), blockHeight]);
                        }
                      })
                      .then(function(_ref3) {
                        var _ref4 = _slicedToArray(_ref3, 2),
                          namespaceInfo = _ref4[0],
                          blockHeight = _ref4[1];
                        var address = _this7.getDefaultBurnAddress();
                        if (namespaceInfo.version === 2) {
                          if (
                            namespaceInfo.reveal_block + 52595 >=
                            blockHeight
                          ) {
                            address = namespaceInfo.address;
                          }
                        }
                        return address;
                      })
                      .then(function(address) {
                        return _this7.coerceAddress(address);
                      });
                  }
                },
                {
                  key: 'getNameInfo',
                  value: function getNameInfo(fullyQualifiedName) {
                    var _this8 = this;
                    _logger.Logger.debug(this.blockstackAPIUrl);
                    var nameLookupURL =
                      this.blockstackAPIUrl + '/v1/names/' + fullyQualifiedName;
                    return fetch(nameLookupURL)
                      .then(function(resp) {
                        if (resp.status === 404) {
                          throw new Error('Name not found');
                        } else if (resp.status !== 200) {
                          throw new Error(
                            'Bad response status: ' + resp.status
                          );
                        } else {
                          return resp.json();
                        }
                      })
                      .then(function(nameInfo) {
                        _logger.Logger.debug(
                          'nameInfo: ' + JSON.stringify(nameInfo)
                        );
                        if (nameInfo.address) {
                          return Object.assign({}, nameInfo, {
                            address: _this8.coerceAddress(nameInfo.address)
                          });
                        } else {
                          return nameInfo;
                        }
                      });
                  }
                },
                {
                  key: 'getNamespaceInfo',
                  value: function getNamespaceInfo(namespaceID) {
                    var _this9 = this;
                    return fetch(
                      this.blockstackAPIUrl + '/v1/namespaces/' + namespaceID
                    )
                      .then(function(resp) {
                        if (resp.status === 404) {
                          throw new Error('Namespace not found');
                        } else if (resp.status !== 200) {
                          throw new Error(
                            'Bad response status: ' + resp.status
                          );
                        } else {
                          return resp.json();
                        }
                      })
                      .then(function(namespaceInfo) {
                        if (
                          namespaceInfo.address &&
                          namespaceInfo.recipient_address
                        ) {
                          return Object.assign({}, namespaceInfo, {
                            address: _this9.coerceAddress(
                              namespaceInfo.address
                            ),
                            recipient_address: _this9.coerceAddress(
                              namespaceInfo.recipient_address
                            )
                          });
                        } else {
                          return namespaceInfo;
                        }
                      });
                  }
                },
                {
                  key: 'getZonefile',
                  value: function getZonefile(zonefileHash) {
                    return fetch(
                      this.blockstackAPIUrl + '/v1/zonefiles/' + zonefileHash
                    ).then(function(resp) {
                      if (resp.status === 200) {
                        return resp.text().then(function(body) {
                          var sha256 = _bitcoinjsLib2.default.crypto.sha256(
                            body
                          );
                          var h = new _ripemd2.default()
                            .update(sha256)
                            .digest('hex');
                          if (h !== zonefileHash) {
                            throw new Error(
                              'Zone file contents hash to ' +
                                h +
                                ', not ' +
                                zonefileHash
                            );
                          }
                          return body;
                        });
                      } else {
                        throw new Error('Bad response status: ' + resp.status);
                      }
                    });
                  }
                },
                {
                  key: 'getAccountStatus',
                  value: function getAccountStatus(address, tokenType) {
                    var _this10 = this;
                    return fetch(
                      this.blockstackAPIUrl +
                        '/v1/accounts/' +
                        address +
                        '/' +
                        tokenType +
                        '/status'
                    )
                      .then(function(resp) {
                        if (resp.status === 404) {
                          throw new Error('Account not found');
                        } else if (resp.status !== 200) {
                          throw new Error(
                            'Bad response status: ' + resp.status
                          );
                        } else {
                          return resp.json();
                        }
                      })
                      .then(function(accountStatus) {
                        var formattedStatus = Object.assign({}, accountStatus, {
                          address: _this10.coerceAddress(accountStatus.address),
                          debit_value: _bigi2.default.fromByteArrayUnsigned(
                            String(accountStatus.debit_value)
                          ),
                          credit_value: _bigi2.default.fromByteArrayUnsigned(
                            String(accountStatus.credit_value)
                          )
                        });
                        return formattedStatus;
                      });
                  }
                },
                {
                  key: 'getAccountHistoryPage',
                  value: function getAccountHistoryPage(address, page) {
                    var _this11 = this;
                    var url =
                      this.blockstackAPIUrl +
                      '/v1/accounts/' +
                      address +
                      '/history?page=' +
                      page;
                    return fetch(url)
                      .then(function(resp) {
                        if (resp.status === 404) {
                          throw new Error('Account not found');
                        } else if (resp.status !== 200) {
                          throw new Error(
                            'Bad response status: ' + resp.status
                          );
                        } else {
                          return resp.json();
                        }
                      })
                      .then(function(historyList) {
                        if (historyList.error) {
                          throw new Error(
                            'Unable to get account history page: ' +
                              historyList.error
                          );
                        }
                        return historyList.map(function(histEntry) {
                          histEntry.address = _this11.coerceAddress(
                            histEntry.address
                          );
                          histEntry.debit_value = _bigi2.default.fromByteArrayUnsigned(
                            String(histEntry.debit_value)
                          );
                          histEntry.credit_value = _bigi2.default.fromByteArrayUnsigned(
                            String(histEntry.credit_value)
                          );
                          return histEntry;
                        });
                      });
                  }
                },
                {
                  key: 'getAccountAt',
                  value: function getAccountAt(address, blockHeight) {
                    var _this12 = this;
                    var url =
                      this.blockstackAPIUrl +
                      '/v1/accounts/' +
                      address +
                      '/history/' +
                      blockHeight;
                    return fetch(url)
                      .then(function(resp) {
                        if (resp.status === 404) {
                          throw new Error('Account not found');
                        } else if (resp.status !== 200) {
                          throw new Error(
                            'Bad response status: ' + resp.status
                          );
                        } else {
                          return resp.json();
                        }
                      })
                      .then(function(historyList) {
                        if (historyList.error) {
                          throw new Error(
                            'Unable to get historic account state: ' +
                              historyList.error
                          );
                        }
                        return historyList.map(function(histEntry) {
                          histEntry.address = _this12.coerceAddress(
                            histEntry.address
                          );
                          histEntry.debit_value = _bigi2.default.fromByteArrayUnsigned(
                            String(histEntry.debit_value)
                          );
                          histEntry.credit_value = _bigi2.default.fromByteArrayUnsigned(
                            String(histEntry.credit_value)
                          );
                          return histEntry;
                        });
                      });
                  }
                },
                {
                  key: 'getAccountTokens',
                  value: function getAccountTokens(address) {
                    return fetch(
                      this.blockstackAPIUrl +
                        '/v1/accounts/' +
                        address +
                        '/tokens'
                    )
                      .then(function(resp) {
                        if (resp.status === 404) {
                          throw new Error('Account not found');
                        } else if (resp.status !== 200) {
                          throw new Error(
                            'Bad response status: ' + resp.status
                          );
                        } else {
                          return resp.json();
                        }
                      })
                      .then(function(tokenList) {
                        if (tokenList.error) {
                          throw new Error(
                            'Unable to get token list: ' + tokenList.error
                          );
                        }
                        return tokenList;
                      });
                  }
                },
                {
                  key: 'getAccountBalance',
                  value: function getAccountBalance(address, tokenType) {
                    return fetch(
                      this.blockstackAPIUrl +
                        '/v1/accounts/' +
                        address +
                        '/' +
                        tokenType +
                        '/balance'
                    )
                      .then(function(resp) {
                        if (resp.status === 404) {
                          return Promise.resolve().then(function() {
                            return _bigi2.default.fromByteArrayUnsigned('0');
                          });
                        } else if (resp.status !== 200) {
                          throw new Error(
                            'Bad response status: ' + resp.status
                          );
                        } else {
                          return resp.json();
                        }
                      })
                      .then(function(tokenBalance) {
                        if (tokenBalance.error) {
                          throw new Error(
                            'Unable to get account balance: ' +
                              tokenBalance.error
                          );
                        }
                        var balance = '0';
                        if (tokenBalance && tokenBalance.balance) {
                          balance = tokenBalance.balance;
                        }
                        return _bigi2.default.fromByteArrayUnsigned(balance);
                      });
                  }
                },
                {
                  key: 'broadcastServiceFetchHelper',
                  value: function broadcastServiceFetchHelper(endpoint, body) {
                    var requestHeaders = {
                      Accept: 'application/json',
                      'Content-Type': 'application/json'
                    };
                    var options = {
                      method: 'POST',
                      headers: requestHeaders,
                      body: JSON.stringify(body)
                    };
                    var url =
                      this.broadcastServiceUrl + '/v1/broadcast/' + endpoint;
                    return fetch(url, options).then(function(response) {
                      if (response.ok) {
                        return response.json();
                      } else {
                        throw new _errors.RemoteServiceError(response);
                      }
                    });
                  }
                },
                {
                  key: 'broadcastTransaction',
                  value: function broadcastTransaction(transaction) {
                    var transactionToWatch =
                      arguments.length > 1 && arguments[1] !== undefined
                        ? arguments[1]
                        : null;
                    var confirmations =
                      arguments.length > 2 && arguments[2] !== undefined
                        ? arguments[2]
                        : 6;
                    if (!transaction) {
                      var error = new _errors.MissingParameterError(
                        'transaction'
                      );
                      return Promise.reject(error);
                    }
                    if (!confirmations && confirmations !== 0) {
                      var _error = new _errors.MissingParameterError(
                        'confirmations'
                      );
                      return Promise.reject(_error);
                    }
                    if (transactionToWatch === null) {
                      return this.btc.broadcastTransaction(transaction);
                    } else {
                      var endpoint = TX_BROADCAST_SERVICE_TX_ENDPOINT;
                      var requestBody = {
                        transaction: transaction,
                        transactionToWatch: transactionToWatch,
                        confirmations: confirmations
                      };
                      return this.broadcastServiceFetchHelper(
                        endpoint,
                        requestBody
                      );
                    }
                  }
                },
                {
                  key: 'broadcastZoneFile',
                  value: function broadcastZoneFile(zoneFile) {
                    var transactionToWatch =
                      arguments.length > 1 && arguments[1] !== undefined
                        ? arguments[1]
                        : null;
                    if (!zoneFile) {
                      return Promise.reject(
                        new _errors.MissingParameterError('zoneFile')
                      );
                    }
                    if (transactionToWatch) {
                      var requestBody = {
                        zoneFile: zoneFile,
                        transactionToWatch: transactionToWatch
                      };
                      var endpoint = TX_BROADCAST_SERVICE_ZONE_FILE_ENDPOINT;
                      return this.broadcastServiceFetchHelper(
                        endpoint,
                        requestBody
                      );
                    } else {
                      var _requestBody = { zonefile: zoneFile };
                      return fetch(this.blockstackAPIUrl + '/v1/zonefile/', {
                        method: 'POST',
                        body: JSON.stringify(_requestBody),
                        headers: { 'Content-Type': 'application/json' }
                      }).then(function(resp) {
                        var json = resp.json();
                        return json.then(function(respObj) {
                          if (respObj.hasOwnProperty('error')) {
                            throw new _errors.RemoteServiceError(resp);
                          }
                          return respObj.servers;
                        });
                      });
                    }
                  }
                },
                {
                  key: 'broadcastNameRegistration',
                  value: function broadcastNameRegistration(
                    preorderTransaction,
                    registerTransaction,
                    zoneFile
                  ) {
                    if (!preorderTransaction) {
                      var error = new _errors.MissingParameterError(
                        'preorderTransaction'
                      );
                      return Promise.reject(error);
                    }
                    if (!registerTransaction) {
                      var _error2 = new _errors.MissingParameterError(
                        'registerTransaction'
                      );
                      return Promise.reject(_error2);
                    }
                    if (!zoneFile) {
                      var _error3 = new _errors.MissingParameterError(
                        'zoneFile'
                      );
                      return Promise.reject(_error3);
                    }
                    var requestBody = {
                      preorderTransaction: preorderTransaction,
                      registerTransaction: registerTransaction,
                      zoneFile: zoneFile
                    };
                    var endpoint = TX_BROADCAST_SERVICE_REGISTRATION_ENDPOINT;
                    return this.broadcastServiceFetchHelper(
                      endpoint,
                      requestBody
                    );
                  }
                },
                {
                  key: 'getFeeRate',
                  value: function getFeeRate() {
                    return fetch(
                      'https://bitcoinfees.earn.com/api/v1/fees/recommended'
                    )
                      .then(function(resp) {
                        return resp.json();
                      })
                      .then(function(rates) {
                        return Math.floor(rates.fastestFee);
                      });
                  }
                },
                {
                  key: 'countDustOutputs',
                  value: function countDustOutputs() {
                    throw new Error('Not implemented.');
                  }
                },
                {
                  key: 'getUTXOs',
                  value: function getUTXOs(address) {
                    var _this13 = this;
                    return this.getNetworkedUTXOs(address).then(function(
                      networkedUTXOs
                    ) {
                      var returnSet = networkedUTXOs.concat();
                      if (_this13.includeUtxoMap.hasOwnProperty(address)) {
                        returnSet = networkedUTXOs.concat(
                          _this13.includeUtxoMap[address]
                        );
                      }
                      var excludeSet = _this13.excludeUtxoSet;
                      returnSet = returnSet.filter(function(utxo) {
                        var inExcludeSet = excludeSet.reduce(function(
                          inSet,
                          utxoToCheck
                        ) {
                          return (
                            inSet ||
                            (utxoToCheck.tx_hash === utxo.tx_hash &&
                              utxoToCheck.tx_output_n === utxo.tx_output_n)
                          );
                        },
                        false);
                        return !inExcludeSet;
                      });
                      return returnSet;
                    });
                  }
                },
                {
                  key: 'modifyUTXOSetFrom',
                  value: function modifyUTXOSetFrom(txHex) {
                    var _this14 = this;
                    var tx = _bitcoinjsLib2.default.Transaction.fromHex(txHex);
                    var excludeSet = this.excludeUtxoSet.concat();
                    tx.ins.forEach(function(utxoUsed) {
                      var reverseHash = Buffer.from(utxoUsed.hash);
                      reverseHash.reverse();
                      excludeSet.push({
                        tx_hash: reverseHash.toString('hex'),
                        tx_output_n: utxoUsed.index
                      });
                    });
                    this.excludeUtxoSet = excludeSet;
                    var txHash = tx
                      .getHash()
                      .reverse()
                      .toString('hex');
                    tx.outs.forEach(function(utxoCreated, txOutputN) {
                      var isNullData = function isNullData(script) {
                        try {
                          _bitcoinjsLib2.default.payments.embed(
                            { output: script },
                            { validate: true }
                          );
                          return true;
                        } catch (_) {
                          return false;
                        }
                      };
                      if (isNullData(utxoCreated.script)) {
                        return;
                      }
                      var address = _bitcoinjsLib2.default.address.fromOutputScript(
                        utxoCreated.script,
                        _this14.layer1
                      );
                      var includeSet = [];
                      if (_this14.includeUtxoMap.hasOwnProperty(address)) {
                        includeSet = includeSet.concat(
                          _this14.includeUtxoMap[address]
                        );
                      }
                      includeSet.push({
                        tx_hash: txHash,
                        confirmations: 0,
                        value: utxoCreated.value,
                        tx_output_n: txOutputN
                      });
                      _this14.includeUtxoMap[address] = includeSet;
                    });
                  }
                },
                {
                  key: 'resetUTXOs',
                  value: function resetUTXOs(address) {
                    delete this.includeUtxoMap[address];
                    this.excludeUtxoSet = [];
                  }
                },
                {
                  key: 'getConsensusHash',
                  value: function getConsensusHash() {
                    return fetch(
                      this.blockstackAPIUrl +
                        '/v1/blockchains/bitcoin/consensus'
                    )
                      .then(function(resp) {
                        return resp.json();
                      })
                      .then(function(x) {
                        return x.consensus_hash;
                      });
                  }
                },
                {
                  key: 'getTransactionInfo',
                  value: function getTransactionInfo(txHash) {
                    return this.btc.getTransactionInfo(txHash);
                  }
                },
                {
                  key: 'getBlockHeight',
                  value: function getBlockHeight() {
                    return this.btc.getBlockHeight();
                  }
                },
                {
                  key: 'getNetworkedUTXOs',
                  value: function getNetworkedUTXOs(address) {
                    return this.btc.getNetworkedUTXOs(address);
                  }
                }
              ]);
              return BlockstackNetwork;
            })());
            var LocalRegtest = (exports.LocalRegtest = (function(
              _BlockstackNetwork
            ) {
              _inherits(LocalRegtest, _BlockstackNetwork);
              function LocalRegtest(apiUrl, broadcastServiceUrl, bitcoinAPI) {
                _classCallCheck(this, LocalRegtest);
                return _possibleConstructorReturn(
                  this,
                  (
                    LocalRegtest.__proto__ ||
                    Object.getPrototypeOf(LocalRegtest)
                  ).call(
                    this,
                    apiUrl,
                    broadcastServiceUrl,
                    bitcoinAPI,
                    _bitcoinjsLib2.default.networks.testnet
                  )
                );
              }
              _createClass(LocalRegtest, [
                {
                  key: 'getFeeRate',
                  value: function getFeeRate() {
                    return Promise.resolve(Math.floor(1e-5 * SATOSHIS_PER_BTC));
                  }
                }
              ]);
              return LocalRegtest;
            })(BlockstackNetwork));
            var BitcoindAPI = (exports.BitcoindAPI = (function(
              _BitcoinNetwork
            ) {
              _inherits(BitcoindAPI, _BitcoinNetwork);
              function BitcoindAPI(bitcoindUrl, bitcoindCredentials) {
                _classCallCheck(this, BitcoindAPI);
                var _this16 = _possibleConstructorReturn(
                  this,
                  (
                    BitcoindAPI.__proto__ || Object.getPrototypeOf(BitcoindAPI)
                  ).call(this)
                );
                _this16.bitcoindUrl = bitcoindUrl;
                _this16.bitcoindCredentials = bitcoindCredentials;
                _this16.importedBefore = {};
                return _this16;
              }
              _createClass(BitcoindAPI, [
                {
                  key: 'broadcastTransaction',
                  value: function broadcastTransaction(transaction) {
                    var jsonRPC = {
                      jsonrpc: '1.0',
                      method: 'sendrawtransaction',
                      params: [transaction]
                    };
                    var authString = Buffer.from(
                      this.bitcoindCredentials.username +
                        ':' +
                        this.bitcoindCredentials.password
                    ).toString('base64');
                    var headers = { Authorization: 'Basic ' + authString };
                    return fetch(this.bitcoindUrl, {
                      method: 'POST',
                      body: JSON.stringify(jsonRPC),
                      headers: headers
                    })
                      .then(function(resp) {
                        return resp.json();
                      })
                      .then(function(respObj) {
                        return respObj.result;
                      });
                  }
                },
                {
                  key: 'getBlockHeight',
                  value: function getBlockHeight() {
                    var jsonRPC = { jsonrpc: '1.0', method: 'getblockcount' };
                    var authString = Buffer.from(
                      this.bitcoindCredentials.username +
                        ':' +
                        this.bitcoindCredentials.password
                    ).toString('base64');
                    var headers = { Authorization: 'Basic ' + authString };
                    return fetch(this.bitcoindUrl, {
                      method: 'POST',
                      body: JSON.stringify(jsonRPC),
                      headers: headers
                    })
                      .then(function(resp) {
                        return resp.json();
                      })
                      .then(function(respObj) {
                        return respObj.result;
                      });
                  }
                },
                {
                  key: 'getTransactionInfo',
                  value: function getTransactionInfo(txHash) {
                    var _this17 = this;
                    var jsonRPC = {
                      jsonrpc: '1.0',
                      method: 'gettransaction',
                      params: [txHash]
                    };
                    var authString = Buffer.from(
                      this.bitcoindCredentials.username +
                        ':' +
                        this.bitcoindCredentials.password
                    ).toString('base64');
                    var headers = { Authorization: 'Basic ' + authString };
                    return fetch(this.bitcoindUrl, {
                      method: 'POST',
                      body: JSON.stringify(jsonRPC),
                      headers: headers
                    })
                      .then(function(resp) {
                        return resp.json();
                      })
                      .then(function(respObj) {
                        return respObj.result;
                      })
                      .then(function(txInfo) {
                        return txInfo.blockhash;
                      })
                      .then(function(blockhash) {
                        var jsonRPCBlock = {
                          jsonrpc: '1.0',
                          method: 'getblockheader',
                          params: [blockhash]
                        };
                        headers.Authorization = 'Basic ' + authString;
                        return fetch(_this17.bitcoindUrl, {
                          method: 'POST',
                          body: JSON.stringify(jsonRPCBlock),
                          headers: headers
                        });
                      })
                      .then(function(resp) {
                        return resp.json();
                      })
                      .then(function(respObj) {
                        if (!respObj || !respObj.result) {
                          throw new Error('Unconfirmed transaction');
                        } else {
                          return { block_height: respObj.result.height };
                        }
                      });
                  }
                },
                {
                  key: 'getNetworkedUTXOs',
                  value: function getNetworkedUTXOs(address) {
                    var _this18 = this;
                    var jsonRPCImport = {
                      jsonrpc: '1.0',
                      method: 'importaddress',
                      params: [address]
                    };
                    var jsonRPCUnspent = {
                      jsonrpc: '1.0',
                      method: 'listunspent',
                      params: [0, 9999999, [address]]
                    };
                    var authString = Buffer.from(
                      this.bitcoindCredentials.username +
                        ':' +
                        this.bitcoindCredentials.password
                    ).toString('base64');
                    var headers = { Authorization: 'Basic ' + authString };
                    var importPromise = this.importedBefore[address]
                      ? Promise.resolve()
                      : fetch(this.bitcoindUrl, {
                          method: 'POST',
                          body: JSON.stringify(jsonRPCImport),
                          headers: headers
                        }).then(function() {
                          _this18.importedBefore[address] = true;
                        });
                    return importPromise
                      .then(function() {
                        return fetch(_this18.bitcoindUrl, {
                          method: 'POST',
                          body: JSON.stringify(jsonRPCUnspent),
                          headers: headers
                        });
                      })
                      .then(function(resp) {
                        return resp.json();
                      })
                      .then(function(x) {
                        return x.result;
                      })
                      .then(function(utxos) {
                        return utxos.map(function(x) {
                          return Object({
                            value: Math.round(x.amount * SATOSHIS_PER_BTC),
                            confirmations: x.confirmations,
                            tx_hash: x.txid,
                            tx_output_n: x.vout
                          });
                        });
                      });
                  }
                }
              ]);
              return BitcoindAPI;
            })(BitcoinNetwork));
            var InsightClient = (exports.InsightClient = (function(
              _BitcoinNetwork2
            ) {
              _inherits(InsightClient, _BitcoinNetwork2);
              function InsightClient() {
                var insightUrl =
                  arguments.length > 0 && arguments[0] !== undefined
                    ? arguments[0]
                    : 'https://utxo.technofractal.com/';
                _classCallCheck(this, InsightClient);
                var _this19 = _possibleConstructorReturn(
                  this,
                  (
                    InsightClient.__proto__ ||
                    Object.getPrototypeOf(InsightClient)
                  ).call(this)
                );
                _this19.apiUrl = insightUrl;
                return _this19;
              }
              _createClass(InsightClient, [
                {
                  key: 'broadcastTransaction',
                  value: function broadcastTransaction(transaction) {
                    var jsonData = { tx: transaction };
                    return fetch(this.apiUrl + '/tx/send', {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/json' },
                      body: JSON.stringify(jsonData)
                    }).then(function(resp) {
                      return resp.json();
                    });
                  }
                },
                {
                  key: 'getBlockHeight',
                  value: function getBlockHeight() {
                    return fetch(this.apiUrl + '/status')
                      .then(function(resp) {
                        return resp.json();
                      })
                      .then(function(status) {
                        return status.blocks;
                      });
                  }
                },
                {
                  key: 'getTransactionInfo',
                  value: function getTransactionInfo(txHash) {
                    var _this20 = this;
                    return fetch(this.apiUrl + '/tx/' + txHash)
                      .then(function(resp) {
                        return resp.json();
                      })
                      .then(function(transactionInfo) {
                        if (transactionInfo.error) {
                          throw new Error(
                            'Error finding transaction: ' +
                              transactionInfo.error
                          );
                        }
                        return fetch(
                          _this20.apiUrl + '/block/' + transactionInfo.blockHash
                        );
                      })
                      .then(function(resp) {
                        return resp.json();
                      })
                      .then(function(blockInfo) {
                        return { block_height: blockInfo.height };
                      });
                  }
                },
                {
                  key: 'getNetworkedUTXOs',
                  value: function getNetworkedUTXOs(address) {
                    return fetch(this.apiUrl + '/addr/' + address + '/utxo')
                      .then(function(resp) {
                        return resp.json();
                      })
                      .then(function(utxos) {
                        return utxos.map(function(x) {
                          return {
                            value: x.satoshis,
                            confirmations: x.confirmations,
                            tx_hash: x.txid,
                            tx_output_n: x.vout
                          };
                        });
                      });
                  }
                }
              ]);
              return InsightClient;
            })(BitcoinNetwork));
            var BlockchainInfoApi = (exports.BlockchainInfoApi = (function(
              _BitcoinNetwork3
            ) {
              _inherits(BlockchainInfoApi, _BitcoinNetwork3);
              function BlockchainInfoApi() {
                var blockchainInfoUrl =
                  arguments.length > 0 && arguments[0] !== undefined
                    ? arguments[0]
                    : 'https://blockchain.info';
                _classCallCheck(this, BlockchainInfoApi);
                var _this21 = _possibleConstructorReturn(
                  this,
                  (
                    BlockchainInfoApi.__proto__ ||
                    Object.getPrototypeOf(BlockchainInfoApi)
                  ).call(this)
                );
                _this21.utxoProviderUrl = blockchainInfoUrl;
                return _this21;
              }
              _createClass(BlockchainInfoApi, [
                {
                  key: 'getBlockHeight',
                  value: function getBlockHeight() {
                    return fetch(
                      this.utxoProviderUrl + '/latestblock?cors=true'
                    )
                      .then(function(resp) {
                        return resp.json();
                      })
                      .then(function(blockObj) {
                        return blockObj.height;
                      });
                  }
                },
                {
                  key: 'getNetworkedUTXOs',
                  value: function getNetworkedUTXOs(address) {
                    return fetch(
                      this.utxoProviderUrl +
                        '/unspent?format=json&active=' +
                        address +
                        '&cors=true'
                    )
                      .then(function(resp) {
                        if (resp.status === 500) {
                          _logger.Logger.debug(
                            'UTXO provider 500 usually means no UTXOs: returning []'
                          );
                          return { unspent_outputs: [] };
                        } else {
                          return resp.json();
                        }
                      })
                      .then(function(utxoJSON) {
                        return utxoJSON.unspent_outputs;
                      })
                      .then(function(utxoList) {
                        return utxoList.map(function(utxo) {
                          var utxoOut = {
                            value: utxo.value,
                            tx_output_n: utxo.tx_output_n,
                            confirmations: utxo.confirmations,
                            tx_hash: utxo.tx_hash_big_endian
                          };
                          return utxoOut;
                        });
                      });
                  }
                },
                {
                  key: 'getTransactionInfo',
                  value: function getTransactionInfo(txHash) {
                    return fetch(
                      this.utxoProviderUrl + '/rawtx/' + txHash + '?cors=true'
                    )
                      .then(function(resp) {
                        if (resp.status === 200) {
                          return resp.json();
                        } else {
                          throw new Error(
                            "Could not lookup transaction info for '" +
                              txHash +
                              "'. Server error."
                          );
                        }
                      })
                      .then(function(respObj) {
                        return { block_height: respObj.block_height };
                      });
                  }
                },
                {
                  key: 'broadcastTransaction',
                  value: function broadcastTransaction(transaction) {
                    var form = new _formData2.default();
                    form.append('tx', transaction);
                    return fetch(this.utxoProviderUrl + '/pushtx?cors=true', {
                      method: 'POST',
                      body: form
                    }).then(function(resp) {
                      var text = resp.text();
                      return text.then(function(respText) {
                        if (
                          respText
                            .toLowerCase()
                            .indexOf('transaction submitted') >= 0
                        ) {
                          var txHash = _bitcoinjsLib2.default.Transaction.fromHex(
                            transaction
                          )
                            .getHash()
                            .reverse()
                            .toString('hex');
                          return txHash;
                        } else {
                          throw new _errors.RemoteServiceError(
                            resp,
                            'Broadcast transaction failed with message: ' +
                              respText
                          );
                        }
                      });
                    });
                  }
                }
              ]);
              return BlockchainInfoApi;
            })(BitcoinNetwork));
            var LOCAL_REGTEST = new LocalRegtest(
              'http://localhost:16268',
              'http://localhost:16269',
              new BitcoindAPI('http://localhost:18332/', {
                username: 'blockstack',
                password: 'blockstacksystem'
              })
            );
            var MAINNET_DEFAULT = new BlockstackNetwork(
              'https://core.blockstack.org',
              'https://broadcast.blockstack.org',
              new BlockchainInfoApi()
            );
            var network = (exports.network = {
              BlockstackNetwork: BlockstackNetwork,
              LocalRegtest: LocalRegtest,
              BlockchainInfoApi: BlockchainInfoApi,
              BitcoindAPI: BitcoindAPI,
              InsightClient: InsightClient,
              defaults: {
                LOCAL_REGTEST: LOCAL_REGTEST,
                MAINNET_DEFAULT: MAINNET_DEFAULT
              }
            });
          }.call(this, require('buffer').Buffer));
        },
        {
          './errors': 15,
          './logger': 18,
          bigi: 74,
          'bitcoinjs-lib': 96,
          buffer: 183,
          'form-data': 351,
          ripemd160: 459
        }
      ],
      20: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          var _skeletons = require('./skeletons');
          Object.defineProperty(exports, 'makePreorderSkeleton', {
            enumerable: true,
            get: function get() {
              return _skeletons.makePreorderSkeleton;
            }
          });
          var _txbuild = require('./txbuild');
          Object.defineProperty(exports, 'transactions', {
            enumerable: true,
            get: function get() {
              return _txbuild.transactions;
            }
          });
          var _utils = require('./utils');
          Object.keys(_utils).forEach(function(key) {
            if (key === 'default' || key === '__esModule') return;
            Object.defineProperty(exports, key, {
              enumerable: true,
              get: function get() {
                return _utils[key];
              }
            });
          });
          var _signers = require('./signers');
          Object.keys(_signers).forEach(function(key) {
            if (key === 'default' || key === '__esModule') return;
            Object.defineProperty(exports, key, {
              enumerable: true,
              get: function get() {
                return _signers[key];
              }
            });
          });
          var _safety = require('./safety');
          Object.defineProperty(exports, 'safety', {
            enumerable: true,
            get: function get() {
              return _safety.safety;
            }
          });
        },
        {
          './safety': 21,
          './signers': 22,
          './skeletons': 23,
          './txbuild': 24,
          './utils': 25
        }
      ],
      21: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.safety = undefined;
          var _slicedToArray = (function() {
            function sliceIterator(arr, i) {
              var _arr = [];
              var _n = true;
              var _d = false;
              var _e = undefined;
              try {
                for (
                  var _i = arr[Symbol.iterator](), _s;
                  !(_n = (_s = _i.next()).done);
                  _n = true
                ) {
                  _arr.push(_s.value);
                  if (i && _arr.length === i) break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i['return']) _i['return']();
                } finally {
                  if (_d) throw _e;
                }
              }
              return _arr;
            }
            return function(arr, i) {
              if (Array.isArray(arr)) {
                return arr;
              } else if (Symbol.iterator in Object(arr)) {
                return sliceIterator(arr, i);
              } else {
                throw new TypeError(
                  'Invalid attempt to destructure non-iterable instance'
                );
              }
            };
          })();
          var _config = require('../config');
          function isNameValid() {
            var fullyQualifiedName =
              arguments.length > 0 && arguments[0] !== undefined
                ? arguments[0]
                : '';
            var NAME_PART_RULE = /^[a-z0-9\-_+]+$/;
            var LENGTH_MAX_NAME = 37;
            if (
              !fullyQualifiedName ||
              fullyQualifiedName.length > LENGTH_MAX_NAME
            ) {
              return Promise.resolve(false);
            }
            var nameParts = fullyQualifiedName.split('.');
            if (nameParts.length !== 2) {
              return Promise.resolve(false);
            }
            return Promise.resolve(
              nameParts.reduce(function(agg, namePart) {
                if (!agg) {
                  return false;
                } else {
                  return NAME_PART_RULE.test(namePart);
                }
              }, true)
            );
          }
          function isNamespaceValid(namespaceID) {
            var NAMESPACE_RULE = /^[a-z0-9\-_]{1,19}$/;
            return Promise.resolve(namespaceID.match(NAMESPACE_RULE) !== null);
          }
          function isNameAvailable(fullyQualifiedName) {
            return _config.config.network
              .getNameInfo(fullyQualifiedName)
              .then(function() {
                return false;
              })
              .catch(function(e) {
                if (e.message === 'Name not found') {
                  return true;
                } else {
                  throw e;
                }
              });
          }
          function isNamespaceAvailable(namespaceID) {
            return _config.config.network
              .getNamespaceInfo(namespaceID)
              .then(function() {
                return false;
              })
              .catch(function(e) {
                if (e.message === 'Namespace not found') {
                  return true;
                } else {
                  throw e;
                }
              });
          }
          function ownsName(fullyQualifiedName, ownerAddress) {
            return _config.config.network
              .getNameInfo(fullyQualifiedName)
              .then(function(nameInfo) {
                return nameInfo.address === ownerAddress;
              })
              .catch(function(e) {
                if (e.message === 'Name not found') {
                  return false;
                } else {
                  throw e;
                }
              });
          }
          function revealedNamespace(namespaceID, revealAddress) {
            return _config.config.network
              .getNamespaceInfo(namespaceID)
              .then(function(namespaceInfo) {
                return namespaceInfo.recipient_address === revealAddress;
              })
              .catch(function(e) {
                if (e.message === 'Namespace not found') {
                  return false;
                } else {
                  throw e;
                }
              });
          }
          function namespaceIsReady(namespaceID) {
            return _config.config.network
              .getNamespaceInfo(namespaceID)
              .then(function(namespaceInfo) {
                return namespaceInfo.ready;
              })
              .catch(function(e) {
                if (e.message === 'Namespace not found') {
                  return false;
                } else {
                  throw e;
                }
              });
          }
          function namespaceIsRevealed(namespaceID) {
            return _config.config.network
              .getNamespaceInfo(namespaceID)
              .then(function(namespaceInfo) {
                return !namespaceInfo.ready;
              })
              .catch(function(e) {
                if (e.message === 'Namespace not found') {
                  return false;
                } else {
                  throw e;
                }
              });
          }
          function isInGracePeriod(fullyQualifiedName) {
            var network = _config.config.network;
            return Promise.all([
              network.getNameInfo(fullyQualifiedName),
              network.getBlockHeight(),
              network.getGracePeriod(fullyQualifiedName)
            ])
              .then(function(_ref) {
                var _ref2 = _slicedToArray(_ref, 3),
                  nameInfo = _ref2[0],
                  blockHeight = _ref2[1],
                  gracePeriod = _ref2[2];
                var expiresAt = nameInfo.expire_block;
                return (
                  blockHeight >= expiresAt &&
                  blockHeight < gracePeriod + expiresAt
                );
              })
              .catch(function(e) {
                if (e.message === 'Name not found') {
                  return false;
                } else {
                  throw e;
                }
              });
          }
          function addressCanReceiveName(address) {
            return _config.config.network
              .getNamesOwned(address)
              .then(function(names) {
                return Promise.all(
                  names.map(function(name) {
                    return isNameValid(name);
                  })
                ).then(function(validNames) {
                  return (
                    validNames.filter(function(nameValid) {
                      return nameValid;
                    }).length < 25
                  );
                });
              });
          }
          function isAccountSpendable(address, tokenType, blockHeight) {
            return _config.config.network
              .getAccountStatus(address, tokenType)
              .then(function(accountStatus) {
                return accountStatus.transfer_send_block_id >= blockHeight;
              });
          }
          var safety = (exports.safety = {
            addressCanReceiveName: addressCanReceiveName,
            isInGracePeriod: isInGracePeriod,
            ownsName: ownsName,
            isNameAvailable: isNameAvailable,
            isNameValid: isNameValid,
            isNamespaceValid: isNamespaceValid,
            isNamespaceAvailable: isNamespaceAvailable,
            revealedNamespace: revealedNamespace,
            namespaceIsReady: namespaceIsReady,
            namespaceIsRevealed: namespaceIsRevealed,
            isAccountSpendable: isAccountSpendable
          });
        },
        { '../config': 12 }
      ],
      22: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.PubkeyHashSigner = undefined;
          var _createClass = (function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          })();
          var _bitcoinjsLib = require('bitcoinjs-lib');
          var _bitcoinjsLib2 = _interopRequireDefault(_bitcoinjsLib);
          var _utils = require('../utils');
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          var PubkeyHashSigner = (exports.PubkeyHashSigner = (function() {
            function PubkeyHashSigner(ecPair) {
              _classCallCheck(this, PubkeyHashSigner);
              this.ecPair = ecPair;
            }
            _createClass(
              PubkeyHashSigner,
              [
                {
                  key: 'signerVersion',
                  value: function signerVersion() {
                    return 1;
                  }
                },
                {
                  key: 'getAddress',
                  value: function getAddress() {
                    var _this = this;
                    return Promise.resolve().then(function() {
                      return (0, _utils.ecPairToAddress)(_this.ecPair);
                    });
                  }
                },
                {
                  key: 'signTransaction',
                  value: function signTransaction(transaction, inputIndex) {
                    var _this2 = this;
                    return Promise.resolve().then(function() {
                      transaction.sign(inputIndex, _this2.ecPair);
                    });
                  }
                }
              ],
              [
                {
                  key: 'fromHexString',
                  value: function fromHexString(keyHex) {
                    return new PubkeyHashSigner(
                      (0, _utils.hexStringToECPair)(keyHex)
                    );
                  }
                }
              ]
            );
            return PubkeyHashSigner;
          })());
        },
        { '../utils': 50, 'bitcoinjs-lib': 96 }
      ],
      23: [
        function(require, module, exports) {
          (function(Buffer) {
            'use strict';
            Object.defineProperty(exports, '__esModule', { value: true });
            exports.BlockstackNamespace = undefined;
            var _createClass = (function() {
              function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ('value' in descriptor) descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps)
                  defineProperties(Constructor.prototype, protoProps);
                if (staticProps) defineProperties(Constructor, staticProps);
                return Constructor;
              };
            })();
            exports.makePreorderSkeleton = makePreorderSkeleton;
            exports.makeRegisterSkeleton = makeRegisterSkeleton;
            exports.makeRenewalSkeleton = makeRenewalSkeleton;
            exports.makeTransferSkeleton = makeTransferSkeleton;
            exports.makeUpdateSkeleton = makeUpdateSkeleton;
            exports.makeRevokeSkeleton = makeRevokeSkeleton;
            exports.makeNamespacePreorderSkeleton = makeNamespacePreorderSkeleton;
            exports.makeNamespaceRevealSkeleton = makeNamespaceRevealSkeleton;
            exports.makeNamespaceReadySkeleton = makeNamespaceReadySkeleton;
            exports.makeNameImportSkeleton = makeNameImportSkeleton;
            exports.makeAnnounceSkeleton = makeAnnounceSkeleton;
            exports.makeTokenTransferSkeleton = makeTokenTransferSkeleton;
            var _bitcoinjsLib = require('bitcoinjs-lib');
            var _bitcoinjsLib2 = _interopRequireDefault(_bitcoinjsLib);
            var _bigi = require('bigi');
            var _bigi2 = _interopRequireDefault(_bigi);
            var _utils = require('./utils');
            var _config = require('../config');
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError('Cannot call a class as a function');
              }
            }
            var BlockstackNamespace = (exports.BlockstackNamespace = (function() {
              function BlockstackNamespace(namespaceID) {
                _classCallCheck(this, BlockstackNamespace);
                if (namespaceID.length > 19) {
                  throw new Error('Namespace ID too long (19 chars max)');
                }
                if (
                  !namespaceID.match(
                    '[0123456789abcdefghijklmnopqrstuvwxyz_-]+'
                  )
                ) {
                  throw new Error(
                    'Namespace ID can only use characters 0123456789abcdefghijklmnopqrstuvwxyz-_'
                  );
                }
                this.namespaceID = namespaceID;
                this.version = -1;
                this.lifetime = -1;
                this.coeff = -1;
                this.base = -1;
                this.buckets = [-1];
                this.nonalphaDiscount = -1;
                this.noVowelDiscount = -1;
              }
              _createClass(BlockstackNamespace, [
                {
                  key: 'check',
                  value: function check() {
                    try {
                      this.setVersion(this.version);
                      this.setLifetime(this.lifetime);
                      this.setCoeff(this.coeff);
                      this.setBase(this.base);
                      this.setBuckets(this.buckets);
                      this.setNonalphaDiscount(this.nonalphaDiscount);
                      this.setNoVowelDiscount(this.noVowelDiscount);
                      return true;
                    } catch (e) {
                      return false;
                    }
                  }
                },
                {
                  key: 'setVersion',
                  value: function setVersion(version) {
                    if (version < 0 || version > Math.pow(2, 16) - 1) {
                      throw new Error(
                        'Invalid version: must be a 16-bit number'
                      );
                    }
                    this.version = version;
                  }
                },
                {
                  key: 'setLifetime',
                  value: function setLifetime(lifetime) {
                    if (lifetime < 0 || lifetime > Math.pow(2, 32) - 1) {
                      throw new Error(
                        'Invalid lifetime: must be a 32-bit number'
                      );
                    }
                    this.lifetime = lifetime;
                  }
                },
                {
                  key: 'setCoeff',
                  value: function setCoeff(coeff) {
                    if (coeff < 0 || coeff > 255) {
                      throw new Error('Invalid coeff: must be an 8-bit number');
                    }
                    this.coeff = coeff;
                  }
                },
                {
                  key: 'setBase',
                  value: function setBase(base) {
                    if (base < 0 || base > 255) {
                      throw new Error('Invalid base: must be an 8-bit number');
                    }
                    this.base = base;
                  }
                },
                {
                  key: 'setBuckets',
                  value: function setBuckets(buckets) {
                    if (buckets.length !== 16) {
                      throw new Error('Invalid buckets: must have 16 entries');
                    }
                    for (var i = 0; i < buckets.length; i++) {
                      if (buckets[i] < 0 || buckets[i] > 15) {
                        throw new Error(
                          'Invalid buckets: must be 4-bit numbers'
                        );
                      }
                    }
                    this.buckets = buckets.slice(0);
                  }
                },
                {
                  key: 'setNonalphaDiscount',
                  value: function setNonalphaDiscount(nonalphaDiscount) {
                    if (nonalphaDiscount <= 0 || nonalphaDiscount > 15) {
                      throw new Error(
                        'Invalid nonalphaDiscount: must be a positive 4-bit number'
                      );
                    }
                    this.nonalphaDiscount = nonalphaDiscount;
                  }
                },
                {
                  key: 'setNoVowelDiscount',
                  value: function setNoVowelDiscount(noVowelDiscount) {
                    if (noVowelDiscount <= 0 || noVowelDiscount > 15) {
                      throw new Error(
                        'Invalid noVowelDiscount: must be a positive 4-bit number'
                      );
                    }
                    this.noVowelDiscount = noVowelDiscount;
                  }
                },
                {
                  key: 'toHexPayload',
                  value: function toHexPayload() {
                    var lifeHex = (
                      '00000000' + this.lifetime.toString(16)
                    ).slice(-8);
                    var coeffHex = ('00' + this.coeff.toString(16)).slice(-2);
                    var baseHex = ('00' + this.base.toString(16)).slice(-2);
                    var bucketHex = this.buckets
                      .map(function(b) {
                        return b.toString(16);
                      })
                      .reduce(function(b1, b2) {
                        return b1 + b2;
                      }, '');
                    var discountHex =
                      this.nonalphaDiscount.toString(16) +
                      this.noVowelDiscount.toString(16);
                    var versionHex = ('0000' + this.version.toString(16)).slice(
                      -4
                    );
                    var namespaceIDHex = new Buffer(this.namespaceID).toString(
                      'hex'
                    );
                    return (
                      lifeHex +
                      coeffHex +
                      baseHex +
                      bucketHex +
                      discountHex +
                      versionHex +
                      namespaceIDHex
                    );
                  }
                }
              ]);
              return BlockstackNamespace;
            })());
            function asAmountV2(amount) {
              if (typeof amount === 'number') {
                return {
                  units: 'BTC',
                  amount: _bigi2.default.fromByteArrayUnsigned(String(amount))
                };
              } else {
                return { units: amount.units, amount: amount.amount };
              }
            }
            function makeTXbuilder() {
              var txb = new _bitcoinjsLib2.default.TransactionBuilder(
                _config.config.network.layer1
              );
              txb.setVersion(1);
              return txb;
            }
            function opEncode(opcode) {
              var res = '' + _config.config.network.MAGIC_BYTES + opcode;
              if (res.length !== 3) {
                throw new Error('Runtime error: invalid MAGIC_BYTES');
              }
              return res;
            }
            function makePreorderSkeleton(
              fullyQualifiedName,
              consensusHash,
              preorderAddress,
              burnAddress,
              burn
            ) {
              var registerAddress =
                arguments.length > 5 && arguments[5] !== undefined
                  ? arguments[5]
                  : null;
              var burnAmount = asAmountV2(burn);
              var network = _config.config.network;
              var nameBuff = Buffer.from(
                (0, _utils.decodeB40)(fullyQualifiedName),
                'hex'
              );
              var scriptPublicKey = _bitcoinjsLib2.default.address.toOutputScript(
                preorderAddress,
                network.layer1
              );
              var dataBuffers = [nameBuff, scriptPublicKey];
              if (!!registerAddress) {
                var registerBuff = Buffer.from(registerAddress, 'ascii');
                dataBuffers.push(registerBuff);
              }
              var dataBuff = Buffer.concat(dataBuffers);
              var hashed = (0, _utils.hash160)(dataBuff);
              var opReturnBufferLen = burnAmount.units === 'BTC' ? 39 : 66;
              var opReturnBuffer = Buffer.alloc(opReturnBufferLen);
              opReturnBuffer.write(opEncode('?'), 0, 3, 'ascii');
              hashed.copy(opReturnBuffer, 3);
              opReturnBuffer.write(consensusHash, 23, 16, 'hex');
              if (burnAmount.units !== 'BTC') {
                var burnHex = burnAmount.amount.toHex();
                if (burnHex.length > 16) {
                  throw new Error(
                    "Cannot preorder '" +
                      fullyQualifiedName +
                      "': cannot fit price into 8 bytes"
                  );
                }
                var paddedBurnHex = ('0000000000000000' + burnHex).slice(-16);
                opReturnBuffer.write(paddedBurnHex, 39, 8, 'hex');
                opReturnBuffer.write(
                  burnAmount.units,
                  47,
                  burnAmount.units.length,
                  'ascii'
                );
              }
              var nullOutput = _bitcoinjsLib2.default.payments.embed({
                data: [opReturnBuffer]
              }).output;
              var tx = makeTXbuilder();
              tx.addOutput(nullOutput, 0);
              tx.addOutput(preorderAddress, _utils.DUST_MINIMUM);
              if (burnAmount.units === 'BTC') {
                var btcBurnAmount = parseInt(burnAmount.amount.toHex(), 16);
                tx.addOutput(burnAddress, btcBurnAmount);
              } else {
                tx.addOutput(burnAddress, _utils.DUST_MINIMUM);
              }
              return tx.buildIncomplete();
            }
            function makeRegisterSkeleton(fullyQualifiedName, ownerAddress) {
              var valueHash =
                arguments.length > 2 && arguments[2] !== undefined
                  ? arguments[2]
                  : null;
              var burnTokenAmountHex =
                arguments.length > 3 && arguments[3] !== undefined
                  ? arguments[3]
                  : null;
              var payload = void 0;
              if (!!burnTokenAmountHex && !valueHash) {
                valueHash = '0000000000000000000000000000000000000000';
              }
              if (!!valueHash) {
                if (valueHash.length !== 40) {
                  throw new Error(
                    'Value hash length incorrect. Expecting 20-bytes, hex-encoded'
                  );
                }
                if (!!burnTokenAmountHex) {
                  if (burnTokenAmountHex.length !== 16) {
                    throw new Error(
                      'Burn field length incorrect.  Expecting 8-bytes, hex-encoded'
                    );
                  }
                }
                var payloadLen = burnTokenAmountHex ? 65 : 57;
                payload = Buffer.alloc(payloadLen, 0);
                payload.write(fullyQualifiedName, 0, 37, 'ascii');
                payload.write(valueHash, 37, 20, 'hex');
                if (!!burnTokenAmountHex) {
                  payload.write(burnTokenAmountHex, 57, 8, 'hex');
                }
              } else {
                payload = Buffer.from(fullyQualifiedName, 'ascii');
              }
              var opReturnBuffer = Buffer.concat([
                Buffer.from(opEncode(':'), 'ascii'),
                payload
              ]);
              var nullOutput = _bitcoinjsLib2.default.payments.embed({
                data: [opReturnBuffer]
              }).output;
              var tx = makeTXbuilder();
              tx.addOutput(nullOutput, 0);
              tx.addOutput(ownerAddress, _utils.DUST_MINIMUM);
              return tx.buildIncomplete();
            }
            function makeRenewalSkeleton(
              fullyQualifiedName,
              nextOwnerAddress,
              lastOwnerAddress,
              burnAddress,
              burn
            ) {
              var valueHash =
                arguments.length > 5 && arguments[5] !== undefined
                  ? arguments[5]
                  : null;
              var burnAmount = asAmountV2(burn);
              var network = _config.config.network;
              var burnTokenAmount =
                burnAmount.units === 'BTC' ? null : burnAmount.amount;
              var burnBTCAmount =
                burnAmount.units === 'BTC'
                  ? parseInt(burnAmount.amount.toHex(), 16)
                  : _utils.DUST_MINIMUM;
              var burnTokenHex = null;
              if (!!burnTokenAmount) {
                var burnHex = burnTokenAmount.toHex();
                if (burnHex.length > 16) {
                  throw new Error(
                    "Cannot renew '" +
                      fullyQualifiedName +
                      "': cannot fit price into 8 bytes"
                  );
                }
                burnTokenHex = ('0000000000000000' + burnHex).slice(-16);
              }
              var registerTX = makeRegisterSkeleton(
                fullyQualifiedName,
                nextOwnerAddress,
                valueHash,
                burnTokenHex
              );
              var txB = _bitcoinjsLib2.default.TransactionBuilder.fromTransaction(
                registerTX,
                network.layer1
              );
              txB.addOutput(lastOwnerAddress, _utils.DUST_MINIMUM);
              txB.addOutput(burnAddress, burnBTCAmount);
              return txB.buildIncomplete();
            }
            function makeTransferSkeleton(
              fullyQualifiedName,
              consensusHash,
              newOwner
            ) {
              var keepZonefile =
                arguments.length > 3 && arguments[3] !== undefined
                  ? arguments[3]
                  : false;
              var opRet = Buffer.alloc(36);
              var keepChar = '~';
              if (keepZonefile) {
                keepChar = '>';
              }
              opRet.write(opEncode('>'), 0, 3, 'ascii');
              opRet.write(keepChar, 3, 1, 'ascii');
              var hashed = (0, _utils.hash128)(
                Buffer.from(fullyQualifiedName, 'ascii')
              );
              hashed.copy(opRet, 4);
              opRet.write(consensusHash, 20, 16, 'hex');
              var opRetPayload = _bitcoinjsLib2.default.payments.embed({
                data: [opRet]
              }).output;
              var tx = makeTXbuilder();
              tx.addOutput(opRetPayload, 0);
              tx.addOutput(newOwner, _utils.DUST_MINIMUM);
              return tx.buildIncomplete();
            }
            function makeUpdateSkeleton(
              fullyQualifiedName,
              consensusHash,
              valueHash
            ) {
              var opRet = Buffer.alloc(39);
              var nameBuff = Buffer.from(fullyQualifiedName, 'ascii');
              var consensusBuff = Buffer.from(consensusHash, 'ascii');
              var hashedName = (0, _utils.hash128)(
                Buffer.concat([nameBuff, consensusBuff])
              );
              opRet.write(opEncode('+'), 0, 3, 'ascii');
              hashedName.copy(opRet, 3);
              opRet.write(valueHash, 19, 20, 'hex');
              var opRetPayload = _bitcoinjsLib2.default.payments.embed({
                data: [opRet]
              }).output;
              var tx = makeTXbuilder();
              tx.addOutput(opRetPayload, 0);
              return tx.buildIncomplete();
            }
            function makeRevokeSkeleton(fullyQualifiedName) {
              var opRet = Buffer.alloc(3);
              var nameBuff = Buffer.from(fullyQualifiedName, 'ascii');
              opRet.write(opEncode('~'), 0, 3, 'ascii');
              var opReturnBuffer = Buffer.concat([opRet, nameBuff]);
              var nullOutput = _bitcoinjsLib2.default.payments.embed({
                data: [opReturnBuffer]
              }).output;
              var tx = makeTXbuilder();
              tx.addOutput(nullOutput, 0);
              return tx.buildIncomplete();
            }
            function makeNamespacePreorderSkeleton(
              namespaceID,
              consensusHash,
              preorderAddress,
              registerAddress,
              burn
            ) {
              var burnAmount = asAmountV2(burn);
              if (burnAmount.units !== 'BTC' && burnAmount.units !== 'STACKS') {
                throw new Error('Invalid burnUnits ' + burnAmount.units);
              }
              var network = _config.config.network;
              var burnAddress = network.getDefaultBurnAddress();
              var namespaceIDBuff = Buffer.from(
                (0, _utils.decodeB40)(namespaceID),
                'hex'
              );
              var scriptPublicKey = _bitcoinjsLib2.default.address.toOutputScript(
                preorderAddress,
                network.layer1
              );
              var registerBuff = Buffer.from(registerAddress, 'ascii');
              var dataBuffers = [
                namespaceIDBuff,
                scriptPublicKey,
                registerBuff
              ];
              var dataBuff = Buffer.concat(dataBuffers);
              var hashed = (0, _utils.hash160)(dataBuff);
              var btcBurnAmount = _utils.DUST_MINIMUM;
              var opReturnBufferLen = 39;
              if (burnAmount.units === 'STACKS') {
                opReturnBufferLen = 47;
              } else {
                btcBurnAmount = parseInt(burnAmount.amount.toHex(), 16);
              }
              var opReturnBuffer = Buffer.alloc(opReturnBufferLen);
              opReturnBuffer.write(opEncode('*'), 0, 3, 'ascii');
              hashed.copy(opReturnBuffer, 3);
              opReturnBuffer.write(consensusHash, 23, 16, 'hex');
              if (burnAmount.units === 'STACKS') {
                var burnHex = burnAmount.amount.toHex();
                var paddedBurnHex = ('0000000000000000' + burnHex).slice(-16);
                opReturnBuffer.write(paddedBurnHex, 39, 8, 'hex');
              }
              var nullOutput = _bitcoinjsLib2.default.payments.embed({
                data: [opReturnBuffer]
              }).output;
              var tx = makeTXbuilder();
              tx.addOutput(nullOutput, 0);
              tx.addOutput(preorderAddress, _utils.DUST_MINIMUM);
              tx.addOutput(burnAddress, btcBurnAmount);
              return tx.buildIncomplete();
            }
            function makeNamespaceRevealSkeleton(namespace, revealAddress) {
              var hexPayload = namespace.toHexPayload();
              var opReturnBuffer = Buffer.alloc(3 + hexPayload.length / 2);
              opReturnBuffer.write(opEncode('&'), 0, 3, 'ascii');
              opReturnBuffer.write(hexPayload, 3, hexPayload.length / 2, 'hex');
              var nullOutput = _bitcoinjsLib2.default.payments.embed({
                data: [opReturnBuffer]
              }).output;
              var tx = makeTXbuilder();
              tx.addOutput(nullOutput, 0);
              tx.addOutput(revealAddress, _utils.DUST_MINIMUM);
              return tx.buildIncomplete();
            }
            function makeNamespaceReadySkeleton(namespaceID) {
              var opReturnBuffer = Buffer.alloc(3 + namespaceID.length + 1);
              opReturnBuffer.write(opEncode('!'), 0, 3, 'ascii');
              opReturnBuffer.write(
                '.' + namespaceID,
                3,
                namespaceID.length + 1,
                'ascii'
              );
              var nullOutput = _bitcoinjsLib2.default.payments.embed({
                data: [opReturnBuffer]
              }).output;
              var tx = makeTXbuilder();
              tx.addOutput(nullOutput, 0);
              return tx.buildIncomplete();
            }
            function makeNameImportSkeleton(name, recipientAddr, zonefileHash) {
              if (zonefileHash.length !== 40) {
                throw new Error(
                  'Invalid zonefile hash: must be 20 bytes hex-encoded'
                );
              }
              var network = _config.config.network;
              var opReturnBuffer = Buffer.alloc(3 + name.length);
              opReturnBuffer.write(opEncode(';'), 0, 3, 'ascii');
              opReturnBuffer.write(name, 3, name.length, 'ascii');
              var nullOutput = _bitcoinjsLib2.default.payments.embed({
                data: [opReturnBuffer]
              }).output;
              var tx = makeTXbuilder();
              var zonefileHashB58 = _bitcoinjsLib2.default.address.toBase58Check(
                new Buffer(zonefileHash, 'hex'),
                network.layer1.pubKeyHash
              );
              tx.addOutput(nullOutput, 0);
              tx.addOutput(recipientAddr, _utils.DUST_MINIMUM);
              tx.addOutput(zonefileHashB58, _utils.DUST_MINIMUM);
              return tx.buildIncomplete();
            }
            function makeAnnounceSkeleton(messageHash) {
              if (messageHash.length !== 40) {
                throw new Error(
                  'Invalid message hash: must be 20 bytes hex-encoded'
                );
              }
              var opReturnBuffer = Buffer.alloc(3 + messageHash.length / 2);
              opReturnBuffer.write(opEncode('#'), 0, 3, 'ascii');
              opReturnBuffer.write(
                messageHash,
                3,
                messageHash.length / 2,
                'hex'
              );
              var nullOutput = _bitcoinjsLib2.default.payments.embed({
                data: [opReturnBuffer]
              }).output;
              var tx = makeTXbuilder();
              tx.addOutput(nullOutput, 0);
              return tx.buildIncomplete();
            }
            function makeTokenTransferSkeleton(
              recipientAddress,
              consensusHash,
              tokenType,
              tokenAmount,
              scratchArea
            ) {
              if (scratchArea.length > 34) {
                throw new Error(
                  'Invalid scratch area: must be no more than 34 bytes'
                );
              }
              var opReturnBuffer = Buffer.alloc(46 + scratchArea.length);
              var tokenTypeHex = new Buffer(tokenType).toString('hex');
              var tokenTypeHexPadded = (
                '00000000000000000000000000000000000000' + tokenTypeHex
              ).slice(-38);
              var tokenValueHex = tokenAmount.toHex();
              if (tokenValueHex.length > 16) {
                throw new Error(
                  'Cannot send tokens: cannot fit ' +
                    tokenAmount.toString() +
                    ' into 8 bytes'
                );
              }
              var tokenValueHexPadded = (
                '0000000000000000' + tokenValueHex
              ).slice(-16);
              opReturnBuffer.write(opEncode('$'), 0, 3, 'ascii');
              opReturnBuffer.write(
                consensusHash,
                3,
                consensusHash.length / 2,
                'hex'
              );
              opReturnBuffer.write(
                tokenTypeHexPadded,
                19,
                tokenTypeHexPadded.length / 2,
                'hex'
              );
              opReturnBuffer.write(
                tokenValueHexPadded,
                38,
                tokenValueHexPadded.length / 2,
                'hex'
              );
              opReturnBuffer.write(
                scratchArea,
                46,
                scratchArea.length,
                'ascii'
              );
              var nullOutput = _bitcoinjsLib2.default.payments.embed({
                data: [opReturnBuffer]
              }).output;
              var tx = makeTXbuilder();
              tx.addOutput(nullOutput, 0);
              tx.addOutput(recipientAddress, _utils.DUST_MINIMUM);
              return tx.buildIncomplete();
            }
          }.call(this, require('buffer').Buffer));
        },
        {
          '../config': 12,
          './utils': 25,
          bigi: 74,
          'bitcoinjs-lib': 96,
          buffer: 183
        }
      ],
      24: [
        function(require, module, exports) {
          (function(Buffer) {
            'use strict';
            Object.defineProperty(exports, '__esModule', { value: true });
            exports.transactions = undefined;
            var _slicedToArray = (function() {
              function sliceIterator(arr, i) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = undefined;
                try {
                  for (
                    var _i = arr[Symbol.iterator](), _s;
                    !(_n = (_s = _i.next()).done);
                    _n = true
                  ) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i['return']) _i['return']();
                  } finally {
                    if (_d) throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i);
                } else {
                  throw new TypeError(
                    'Invalid attempt to destructure non-iterable instance'
                  );
                }
              };
            })();
            var _bitcoinjsLib = require('bitcoinjs-lib');
            var _bitcoinjsLib2 = _interopRequireDefault(_bitcoinjsLib);
            var _bigi = require('bigi');
            var _bigi2 = _interopRequireDefault(_bigi);
            var _utils = require('./utils');
            var _skeletons = require('./skeletons');
            var _config = require('../config');
            var _errors = require('../errors');
            var _signers = require('./signers');
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            var dummyConsensusHash = 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
            var dummyZonefileHash = 'ffffffffffffffffffffffffffffffffffffffff';
            function addOwnerInput(utxos, ownerAddress, txB) {
              var addChangeOut =
                arguments.length > 3 && arguments[3] !== undefined
                  ? arguments[3]
                  : true;
              if (utxos.length <= 0) {
                throw new Error('Owner has no UTXOs for UPDATE.');
              }
              utxos.sort(function(a, b) {
                return a.value - b.value;
              });
              var ownerUTXO = utxos[0];
              var ownerInput = txB.addInput(
                ownerUTXO.tx_hash,
                ownerUTXO.tx_output_n
              );
              if (addChangeOut) {
                txB.addOutput(ownerAddress, ownerUTXO.value);
              }
              return { index: ownerInput, value: ownerUTXO.value };
            }
            function fundTransaction(
              txB,
              paymentAddress,
              utxos,
              feeRate,
              inAmounts
            ) {
              var changeIndex =
                arguments.length > 5 && arguments[5] !== undefined
                  ? arguments[5]
                  : null;
              if (changeIndex === null) {
                changeIndex = txB.addOutput(
                  paymentAddress,
                  _utils.DUST_MINIMUM
                );
              }
              var txFee = (0, _utils.estimateTXBytes)(txB, 0, 0) * feeRate;
              var outAmounts = (0, _utils.sumOutputValues)(txB);
              var change = (0, _utils.addUTXOsToFund)(
                txB,
                utxos,
                txFee + outAmounts - inAmounts,
                feeRate
              );
              txB.__tx.outs[changeIndex].value += change;
              return txB;
            }
            function returnTransactionHex(txB) {
              var buildIncomplete =
                arguments.length > 1 && arguments[1] !== undefined
                  ? arguments[1]
                  : false;
              if (buildIncomplete) {
                return txB.buildIncomplete().toHex();
              } else {
                return txB.build().toHex();
              }
            }
            function getTransactionSigner(input) {
              if (typeof input === 'string') {
                return _signers.PubkeyHashSigner.fromHexString(input);
              } else {
                return input;
              }
            }
            function estimatePreorder(
              fullyQualifiedName,
              destinationAddress,
              paymentAddress
            ) {
              var paymentUtxos =
                arguments.length > 3 && arguments[3] !== undefined
                  ? arguments[3]
                  : 1;
              var network = _config.config.network;
              var preorderPromise = network
                .getNamePrice(fullyQualifiedName)
                .then(function(namePrice) {
                  return (0,
                  _skeletons.makePreorderSkeleton)(fullyQualifiedName, dummyConsensusHash, paymentAddress, network.getDefaultBurnAddress(), namePrice, destinationAddress);
                });
              return Promise.all([network.getFeeRate(), preorderPromise]).then(
                function(_ref) {
                  var _ref2 = _slicedToArray(_ref, 2),
                    feeRate = _ref2[0],
                    preorderTX = _ref2[1];
                  var outputsValue = (0, _utils.sumOutputValues)(preorderTX);
                  var txFee =
                    feeRate *
                    (0, _utils.estimateTXBytes)(preorderTX, paymentUtxos, 0);
                  return txFee + outputsValue;
                }
              );
            }
            function estimateRegister(
              fullyQualifiedName,
              registerAddress,
              paymentAddress
            ) {
              var includingZonefile =
                arguments.length > 3 && arguments[3] !== undefined
                  ? arguments[3]
                  : false;
              var paymentUtxos =
                arguments.length > 4 && arguments[4] !== undefined
                  ? arguments[4]
                  : 1;
              var network = _config.config.network;
              var valueHash = void 0;
              if (includingZonefile) {
                valueHash = dummyZonefileHash;
              }
              var registerTX = (0, _skeletons.makeRegisterSkeleton)(
                fullyQualifiedName,
                registerAddress,
                valueHash
              );
              return network.getFeeRate().then(function(feeRate) {
                var outputsValue = (0, _utils.sumOutputValues)(registerTX);
                var txFee =
                  feeRate *
                  (0, _utils.estimateTXBytes)(registerTX, paymentUtxos, 1);
                return txFee + outputsValue;
              });
            }
            function estimateUpdate(
              fullyQualifiedName,
              ownerAddress,
              paymentAddress
            ) {
              var paymentUtxos =
                arguments.length > 3 && arguments[3] !== undefined
                  ? arguments[3]
                  : 1;
              var network = _config.config.network;
              var updateTX = (0, _skeletons.makeUpdateSkeleton)(
                fullyQualifiedName,
                dummyConsensusHash,
                dummyZonefileHash
              );
              return network.getFeeRate().then(function(feeRate) {
                var outputsValue = (0, _utils.sumOutputValues)(updateTX);
                var txFee =
                  feeRate *
                  (0, _utils.estimateTXBytes)(updateTX, 1 + paymentUtxos, 2);
                return txFee + outputsValue;
              });
            }
            function estimateTransfer(
              fullyQualifiedName,
              destinationAddress,
              ownerAddress,
              paymentAddress
            ) {
              var paymentUtxos =
                arguments.length > 4 && arguments[4] !== undefined
                  ? arguments[4]
                  : 1;
              var network = _config.config.network;
              var transferTX = (0, _skeletons.makeTransferSkeleton)(
                fullyQualifiedName,
                dummyConsensusHash,
                destinationAddress
              );
              return network.getFeeRate().then(function(feeRate) {
                var outputsValue = (0, _utils.sumOutputValues)(transferTX);
                var txFee =
                  feeRate *
                  (0, _utils.estimateTXBytes)(transferTX, 1 + paymentUtxos, 2);
                return txFee + outputsValue;
              });
            }
            function estimateRenewal(
              fullyQualifiedName,
              destinationAddress,
              ownerAddress,
              paymentAddress
            ) {
              var includingZonefile =
                arguments.length > 4 && arguments[4] !== undefined
                  ? arguments[4]
                  : false;
              var paymentUtxos =
                arguments.length > 5 && arguments[5] !== undefined
                  ? arguments[5]
                  : 1;
              var network = _config.config.network;
              var valueHash = void 0;
              if (includingZonefile) {
                valueHash = dummyZonefileHash;
              }
              var renewalPromise = network
                .getNamePrice(fullyQualifiedName)
                .then(function(namePrice) {
                  return (0,
                  _skeletons.makeRenewalSkeleton)(fullyQualifiedName, destinationAddress, ownerAddress, network.getDefaultBurnAddress(), namePrice, valueHash);
                });
              return Promise.all([network.getFeeRate(), renewalPromise]).then(
                function(_ref3) {
                  var _ref4 = _slicedToArray(_ref3, 2),
                    feeRate = _ref4[0],
                    renewalTX = _ref4[1];
                  var outputsValue = (0, _utils.sumOutputValues)(renewalTX);
                  var txFee =
                    feeRate *
                    (0, _utils.estimateTXBytes)(renewalTX, 1 + paymentUtxos, 1);
                  return txFee + outputsValue - 5500;
                }
              );
            }
            function estimateRevoke(
              fullyQualifiedName,
              ownerAddress,
              paymentAddress
            ) {
              var paymentUtxos =
                arguments.length > 3 && arguments[3] !== undefined
                  ? arguments[3]
                  : 1;
              var network = _config.config.network;
              var revokeTX = (0, _skeletons.makeRevokeSkeleton)(
                fullyQualifiedName
              );
              return Promise.all([network.getFeeRate()]).then(function(_ref5) {
                var _ref6 = _slicedToArray(_ref5, 1),
                  feeRate = _ref6[0];
                var outputsValue = (0, _utils.sumOutputValues)(revokeTX);
                var txFee =
                  feeRate *
                  (0, _utils.estimateTXBytes)(revokeTX, 1 + paymentUtxos, 2);
                return txFee + outputsValue;
              });
            }
            function estimateNamespacePreorder(
              namespaceID,
              revealAddress,
              paymentAddress
            ) {
              var paymentUtxos =
                arguments.length > 3 && arguments[3] !== undefined
                  ? arguments[3]
                  : 1;
              var network = _config.config.network;
              var preorderPromise = network
                .getNamespacePrice(namespaceID)
                .then(function(namespacePrice) {
                  return (0,
                  _skeletons.makeNamespacePreorderSkeleton)(namespaceID, dummyConsensusHash, paymentAddress, revealAddress, namespacePrice);
                });
              return Promise.all([network.getFeeRate(), preorderPromise]).then(
                function(_ref7) {
                  var _ref8 = _slicedToArray(_ref7, 2),
                    feeRate = _ref8[0],
                    preorderTX = _ref8[1];
                  var outputsValue = (0, _utils.sumOutputValues)(preorderTX);
                  var txFee =
                    feeRate *
                    (0, _utils.estimateTXBytes)(preorderTX, paymentUtxos, 0);
                  return txFee + outputsValue;
                }
              );
            }
            function estimateNamespaceReveal(
              namespace,
              revealAddress,
              paymentAddress
            ) {
              var paymentUtxos =
                arguments.length > 3 && arguments[3] !== undefined
                  ? arguments[3]
                  : 1;
              var network = _config.config.network;
              var revealTX = (0, _skeletons.makeNamespaceRevealSkeleton)(
                namespace,
                revealAddress
              );
              return network.getFeeRate().then(function(feeRate) {
                var outputsValue = (0, _utils.sumOutputValues)(revealTX);
                var txFee =
                  feeRate *
                  (0, _utils.estimateTXBytes)(revealTX, paymentUtxos, 1);
                return txFee + outputsValue;
              });
            }
            function estimateNamespaceReady(namespaceID) {
              var revealUtxos =
                arguments.length > 1 && arguments[1] !== undefined
                  ? arguments[1]
                  : 1;
              var network = _config.config.network;
              var readyTX = (0, _skeletons.makeNamespaceReadySkeleton)(
                namespaceID
              );
              return network.getFeeRate().then(function(feeRate) {
                var outputsValue = (0, _utils.sumOutputValues)(readyTX);
                var txFee =
                  feeRate *
                  (0, _utils.estimateTXBytes)(readyTX, revealUtxos, 1);
                return txFee + outputsValue;
              });
            }
            function estimateNameImport(name, recipientAddr, zonefileHash) {
              var importUtxos =
                arguments.length > 3 && arguments[3] !== undefined
                  ? arguments[3]
                  : 1;
              var network = _config.config.network;
              var importTX = (0, _skeletons.makeNameImportSkeleton)(
                name,
                recipientAddr,
                zonefileHash
              );
              return network.getFeeRate().then(function(feeRate) {
                var outputsValue = (0, _utils.sumOutputValues)(importTX);
                var txFee =
                  feeRate *
                  (0, _utils.estimateTXBytes)(importTX, importUtxos, 1);
                return txFee + outputsValue;
              });
            }
            function estimateAnnounce(messageHash) {
              var senderUtxos =
                arguments.length > 1 && arguments[1] !== undefined
                  ? arguments[1]
                  : 1;
              var network = _config.config.network;
              var announceTX = (0, _skeletons.makeAnnounceSkeleton)(
                messageHash
              );
              return network.getFeeRate().then(function(feeRate) {
                var outputsValue = (0, _utils.sumOutputValues)(announceTX);
                var txFee =
                  feeRate *
                  (0, _utils.estimateTXBytes)(announceTX, senderUtxos, 1);
                return txFee + outputsValue;
              });
            }
            function estimateTokenTransfer(
              recipientAddress,
              tokenType,
              tokenAmount,
              scratchArea
            ) {
              var senderUtxos =
                arguments.length > 4 && arguments[4] !== undefined
                  ? arguments[4]
                  : 1;
              var additionalOutputs =
                arguments.length > 5 && arguments[5] !== undefined
                  ? arguments[5]
                  : 1;
              var network = _config.config.network;
              var tokenTransferTX = (0, _skeletons.makeTokenTransferSkeleton)(
                recipientAddress,
                dummyConsensusHash,
                tokenType,
                tokenAmount,
                scratchArea
              );
              return network.getFeeRate().then(function(feeRate) {
                var outputsValue = (0, _utils.sumOutputValues)(tokenTransferTX);
                var txFee =
                  feeRate *
                  (0, _utils.estimateTXBytes)(
                    tokenTransferTX,
                    senderUtxos,
                    additionalOutputs
                  );
                return txFee + outputsValue;
              });
            }
            function makePreorder(
              fullyQualifiedName,
              destinationAddress,
              paymentKeyIn
            ) {
              var buildIncomplete =
                arguments.length > 3 && arguments[3] !== undefined
                  ? arguments[3]
                  : false;
              var network = _config.config.network;
              var namespace = fullyQualifiedName.split('.').pop();
              var paymentKey = getTransactionSigner(paymentKeyIn);
              return paymentKey.getAddress().then(function(preorderAddress) {
                var preorderPromise = Promise.all([
                  network.getConsensusHash(),
                  network.getNamePrice(fullyQualifiedName),
                  network.getNamespaceBurnAddress(namespace)
                ]).then(function(_ref9) {
                  var _ref10 = _slicedToArray(_ref9, 3),
                    consensusHash = _ref10[0],
                    namePrice = _ref10[1],
                    burnAddress = _ref10[2];
                  return (0,
                  _skeletons.makePreorderSkeleton)(fullyQualifiedName, consensusHash, preorderAddress, burnAddress, namePrice, destinationAddress);
                });
                return Promise.all([
                  network.getUTXOs(preorderAddress),
                  network.getFeeRate(),
                  preorderPromise
                ])
                  .then(function(_ref11) {
                    var _ref12 = _slicedToArray(_ref11, 3),
                      utxos = _ref12[0],
                      feeRate = _ref12[1],
                      preorderSkeleton = _ref12[2];
                    var txB = _bitcoinjsLib2.default.TransactionBuilder.fromTransaction(
                      preorderSkeleton,
                      network.layer1
                    );
                    txB.setVersion(1);
                    var changeIndex = 1;
                    var signingTxB = fundTransaction(
                      txB,
                      preorderAddress,
                      utxos,
                      feeRate,
                      0,
                      changeIndex
                    );
                    return (0, _utils.signInputs)(signingTxB, paymentKey);
                  })
                  .then(function(signingTxB) {
                    return returnTransactionHex(signingTxB, buildIncomplete);
                  });
              });
            }
            function makeUpdate(
              fullyQualifiedName,
              ownerKeyIn,
              paymentKeyIn,
              zonefile
            ) {
              var valueHash =
                arguments.length > 4 && arguments[4] !== undefined
                  ? arguments[4]
                  : '';
              var buildIncomplete =
                arguments.length > 5 && arguments[5] !== undefined
                  ? arguments[5]
                  : false;
              var network = _config.config.network;
              if (!valueHash && !zonefile) {
                return Promise.reject(
                  new Error('Need zonefile or valueHash arguments')
                );
              }
              if (valueHash.length === 0) {
                if (!zonefile) {
                  return Promise.reject(
                    new Error('Need zonefile or valueHash arguments')
                  );
                }
                valueHash = (0, _utils.hash160)(Buffer.from(zonefile)).toString(
                  'hex'
                );
              } else if (valueHash.length !== 40) {
                return Promise.reject(
                  new Error('Invalid valueHash ' + valueHash)
                );
              }
              var paymentKey = getTransactionSigner(paymentKeyIn);
              var ownerKey = getTransactionSigner(ownerKeyIn);
              return Promise.all([
                ownerKey.getAddress(),
                paymentKey.getAddress()
              ])
                .then(function(_ref13) {
                  var _ref14 = _slicedToArray(_ref13, 2),
                    ownerAddress = _ref14[0],
                    paymentAddress = _ref14[1];
                  var txPromise = network
                    .getConsensusHash()
                    .then(function(consensusHash) {
                      return (0,
                      _skeletons.makeUpdateSkeleton)(fullyQualifiedName, consensusHash, valueHash);
                    })
                    .then(function(updateTX) {
                      var txB = _bitcoinjsLib2.default.TransactionBuilder.fromTransaction(
                        updateTX,
                        network.layer1
                      );
                      txB.setVersion(1);
                      return txB;
                    });
                  return Promise.all([
                    txPromise,
                    network.getUTXOs(paymentAddress),
                    network.getUTXOs(ownerAddress),
                    network.getFeeRate()
                  ]).then(function(_ref15) {
                    var _ref16 = _slicedToArray(_ref15, 4),
                      txB = _ref16[0],
                      payerUtxos = _ref16[1],
                      ownerUtxos = _ref16[2],
                      feeRate = _ref16[3];
                    var ownerInput = addOwnerInput(
                      ownerUtxos,
                      ownerAddress,
                      txB
                    );
                    var signingTxB = fundTransaction(
                      txB,
                      paymentAddress,
                      payerUtxos,
                      feeRate,
                      ownerInput.value
                    );
                    return (0,
                    _utils.signInputs)(signingTxB, paymentKey, [{ index: ownerInput.index, signer: ownerKey }]);
                  });
                })
                .then(function(signingTxB) {
                  return returnTransactionHex(signingTxB, buildIncomplete);
                });
            }
            function makeRegister(
              fullyQualifiedName,
              registerAddress,
              paymentKeyIn
            ) {
              var zonefile =
                arguments.length > 3 && arguments[3] !== undefined
                  ? arguments[3]
                  : null;
              var valueHash =
                arguments.length > 4 && arguments[4] !== undefined
                  ? arguments[4]
                  : null;
              var buildIncomplete =
                arguments.length > 5 && arguments[5] !== undefined
                  ? arguments[5]
                  : false;
              var network = _config.config.network;
              if (!valueHash && !!zonefile) {
                valueHash = (0, _utils.hash160)(Buffer.from(zonefile)).toString(
                  'hex'
                );
              } else if (!!valueHash && valueHash.length !== 40) {
                return Promise.reject(
                  new Error('Invalid zonefile hash ' + valueHash)
                );
              }
              var registerSkeleton = (0, _skeletons.makeRegisterSkeleton)(
                fullyQualifiedName,
                registerAddress,
                valueHash
              );
              var txB = _bitcoinjsLib2.default.TransactionBuilder.fromTransaction(
                registerSkeleton,
                network.layer1
              );
              txB.setVersion(1);
              var paymentKey = getTransactionSigner(paymentKeyIn);
              return paymentKey
                .getAddress()
                .then(function(paymentAddress) {
                  return Promise.all([
                    network.getUTXOs(paymentAddress),
                    network.getFeeRate()
                  ]).then(function(_ref17) {
                    var _ref18 = _slicedToArray(_ref17, 2),
                      utxos = _ref18[0],
                      feeRate = _ref18[1];
                    var signingTxB = fundTransaction(
                      txB,
                      paymentAddress,
                      utxos,
                      feeRate,
                      0
                    );
                    return (0, _utils.signInputs)(signingTxB, paymentKey);
                  });
                })
                .then(function(signingTxB) {
                  return returnTransactionHex(signingTxB, buildIncomplete);
                });
            }
            function makeTransfer(
              fullyQualifiedName,
              destinationAddress,
              ownerKeyIn,
              paymentKeyIn
            ) {
              var keepZonefile =
                arguments.length > 4 && arguments[4] !== undefined
                  ? arguments[4]
                  : false;
              var buildIncomplete =
                arguments.length > 5 && arguments[5] !== undefined
                  ? arguments[5]
                  : false;
              var network = _config.config.network;
              var paymentKey = getTransactionSigner(paymentKeyIn);
              var ownerKey = getTransactionSigner(ownerKeyIn);
              return Promise.all([
                ownerKey.getAddress(),
                paymentKey.getAddress()
              ])
                .then(function(_ref19) {
                  var _ref20 = _slicedToArray(_ref19, 2),
                    ownerAddress = _ref20[0],
                    paymentAddress = _ref20[1];
                  var txPromise = network
                    .getConsensusHash()
                    .then(function(consensusHash) {
                      return (0,
                      _skeletons.makeTransferSkeleton)(fullyQualifiedName, consensusHash, destinationAddress, keepZonefile);
                    })
                    .then(function(transferTX) {
                      var txB = _bitcoinjsLib2.default.TransactionBuilder.fromTransaction(
                        transferTX,
                        network.layer1
                      );
                      txB.setVersion(1);
                      return txB;
                    });
                  return Promise.all([
                    txPromise,
                    network.getUTXOs(paymentAddress),
                    network.getUTXOs(ownerAddress),
                    network.getFeeRate()
                  ]).then(function(_ref21) {
                    var _ref22 = _slicedToArray(_ref21, 4),
                      txB = _ref22[0],
                      payerUtxos = _ref22[1],
                      ownerUtxos = _ref22[2],
                      feeRate = _ref22[3];
                    var ownerInput = addOwnerInput(
                      ownerUtxos,
                      ownerAddress,
                      txB
                    );
                    var signingTxB = fundTransaction(
                      txB,
                      paymentAddress,
                      payerUtxos,
                      feeRate,
                      ownerInput.value
                    );
                    return (0,
                    _utils.signInputs)(signingTxB, paymentKey, [{ index: ownerInput.index, signer: ownerKey }]);
                  });
                })
                .then(function(signingTxB) {
                  return returnTransactionHex(signingTxB, buildIncomplete);
                });
            }
            function makeRevoke(fullyQualifiedName, ownerKeyIn, paymentKeyIn) {
              var buildIncomplete =
                arguments.length > 3 && arguments[3] !== undefined
                  ? arguments[3]
                  : false;
              var network = _config.config.network;
              var paymentKey = getTransactionSigner(paymentKeyIn);
              var ownerKey = getTransactionSigner(ownerKeyIn);
              return Promise.all([
                ownerKey.getAddress(),
                paymentKey.getAddress()
              ])
                .then(function(_ref23) {
                  var _ref24 = _slicedToArray(_ref23, 2),
                    ownerAddress = _ref24[0],
                    paymentAddress = _ref24[1];
                  var revokeTX = (0, _skeletons.makeRevokeSkeleton)(
                    fullyQualifiedName
                  );
                  var txPromise = _bitcoinjsLib2.default.TransactionBuilder.fromTransaction(
                    revokeTX,
                    network.layer1
                  );
                  txPromise.setVersion(1);
                  return Promise.all([
                    txPromise,
                    network.getUTXOs(paymentAddress),
                    network.getUTXOs(ownerAddress),
                    network.getFeeRate()
                  ]).then(function(_ref25) {
                    var _ref26 = _slicedToArray(_ref25, 4),
                      txB = _ref26[0],
                      payerUtxos = _ref26[1],
                      ownerUtxos = _ref26[2],
                      feeRate = _ref26[3];
                    var ownerInput = addOwnerInput(
                      ownerUtxos,
                      ownerAddress,
                      txB
                    );
                    var signingTxB = fundTransaction(
                      txB,
                      paymentAddress,
                      payerUtxos,
                      feeRate,
                      ownerInput.value
                    );
                    return (0,
                    _utils.signInputs)(signingTxB, paymentKey, [{ index: ownerInput.index, signer: ownerKey }]);
                  });
                })
                .then(function(signingTxB) {
                  return returnTransactionHex(signingTxB, buildIncomplete);
                });
            }
            function makeRenewal(
              fullyQualifiedName,
              destinationAddress,
              ownerKeyIn,
              paymentKeyIn
            ) {
              var zonefile =
                arguments.length > 4 && arguments[4] !== undefined
                  ? arguments[4]
                  : null;
              var valueHash =
                arguments.length > 5 && arguments[5] !== undefined
                  ? arguments[5]
                  : null;
              var buildIncomplete =
                arguments.length > 6 && arguments[6] !== undefined
                  ? arguments[6]
                  : false;
              var network = _config.config.network;
              if (!valueHash && !!zonefile) {
                valueHash = (0, _utils.hash160)(Buffer.from(zonefile)).toString(
                  'hex'
                );
              }
              var namespace = fullyQualifiedName.split('.').pop();
              var paymentKey = getTransactionSigner(paymentKeyIn);
              var ownerKey = getTransactionSigner(ownerKeyIn);
              return Promise.all([
                ownerKey.getAddress(),
                paymentKey.getAddress()
              ])
                .then(function(_ref27) {
                  var _ref28 = _slicedToArray(_ref27, 2),
                    ownerAddress = _ref28[0],
                    paymentAddress = _ref28[1];
                  var txPromise = Promise.all([
                    network.getNamePrice(fullyQualifiedName),
                    network.getNamespaceBurnAddress(namespace)
                  ])
                    .then(function(_ref29) {
                      var _ref30 = _slicedToArray(_ref29, 2),
                        namePrice = _ref30[0],
                        burnAddress = _ref30[1];
                      return (0,
                      _skeletons.makeRenewalSkeleton)(fullyQualifiedName, destinationAddress, ownerAddress, burnAddress, namePrice, valueHash);
                    })
                    .then(function(tx) {
                      var txB = _bitcoinjsLib2.default.TransactionBuilder.fromTransaction(
                        tx,
                        network.layer1
                      );
                      txB.setVersion(1);
                      return txB;
                    });
                  return Promise.all([
                    txPromise,
                    network.getUTXOs(paymentAddress),
                    network.getUTXOs(ownerAddress),
                    network.getFeeRate()
                  ]).then(function(_ref31) {
                    var _ref32 = _slicedToArray(_ref31, 4),
                      txB = _ref32[0],
                      payerUtxos = _ref32[1],
                      ownerUtxos = _ref32[2],
                      feeRate = _ref32[3];
                    var ownerInput = addOwnerInput(
                      ownerUtxos,
                      ownerAddress,
                      txB,
                      false
                    );
                    var ownerOutput = txB.__tx.outs[2];
                    var ownerOutputAddr = _bitcoinjsLib2.default.address.fromOutputScript(
                      ownerOutput.script,
                      network.layer1
                    );
                    if (ownerOutputAddr !== ownerAddress) {
                      return Promise.reject(
                        new Error(
                          'Original owner ' +
                            ownerAddress +
                            ' should have an output at ' +
                            ('index 2 in transaction was ' + ownerOutputAddr)
                        )
                      );
                    }
                    ownerOutput.value = ownerInput.value;
                    var signingTxB = fundTransaction(
                      txB,
                      paymentAddress,
                      payerUtxos,
                      feeRate,
                      ownerInput.value
                    );
                    return (0,
                    _utils.signInputs)(signingTxB, paymentKey, [{ index: ownerInput.index, signer: ownerKey }]);
                  });
                })
                .then(function(signingTxB) {
                  return returnTransactionHex(signingTxB, buildIncomplete);
                });
            }
            function makeNamespacePreorder(
              namespaceID,
              revealAddress,
              paymentKeyIn
            ) {
              var buildIncomplete =
                arguments.length > 3 && arguments[3] !== undefined
                  ? arguments[3]
                  : false;
              var network = _config.config.network;
              var paymentKey = getTransactionSigner(paymentKeyIn);
              return paymentKey.getAddress().then(function(preorderAddress) {
                var preorderPromise = Promise.all([
                  network.getConsensusHash(),
                  network.getNamespacePrice(namespaceID)
                ]).then(function(_ref33) {
                  var _ref34 = _slicedToArray(_ref33, 2),
                    consensusHash = _ref34[0],
                    namespacePrice = _ref34[1];
                  return (0,
                  _skeletons.makeNamespacePreorderSkeleton)(namespaceID, consensusHash, preorderAddress, revealAddress, namespacePrice);
                });
                return Promise.all([
                  network.getUTXOs(preorderAddress),
                  network.getFeeRate(),
                  preorderPromise
                ])
                  .then(function(_ref35) {
                    var _ref36 = _slicedToArray(_ref35, 3),
                      utxos = _ref36[0],
                      feeRate = _ref36[1],
                      preorderSkeleton = _ref36[2];
                    var txB = _bitcoinjsLib2.default.TransactionBuilder.fromTransaction(
                      preorderSkeleton,
                      network.layer1
                    );
                    txB.setVersion(1);
                    var changeIndex = 1;
                    var signingTxB = fundTransaction(
                      txB,
                      preorderAddress,
                      utxos,
                      feeRate,
                      0,
                      changeIndex
                    );
                    return (0, _utils.signInputs)(signingTxB, paymentKey);
                  })
                  .then(function(signingTxB) {
                    return returnTransactionHex(signingTxB, buildIncomplete);
                  });
              });
            }
            function makeNamespaceReveal(
              namespace,
              revealAddress,
              paymentKeyIn
            ) {
              var buildIncomplete =
                arguments.length > 3 && arguments[3] !== undefined
                  ? arguments[3]
                  : false;
              var network = _config.config.network;
              if (!namespace.check()) {
                return Promise.reject(new Error('Invalid namespace'));
              }
              var namespaceRevealTX = (0,
              _skeletons.makeNamespaceRevealSkeleton)(namespace, revealAddress);
              var paymentKey = getTransactionSigner(paymentKeyIn);
              return paymentKey
                .getAddress()
                .then(function(preorderAddress) {
                  return Promise.all([
                    network.getUTXOs(preorderAddress),
                    network.getFeeRate()
                  ]).then(function(_ref37) {
                    var _ref38 = _slicedToArray(_ref37, 2),
                      utxos = _ref38[0],
                      feeRate = _ref38[1];
                    var txB = _bitcoinjsLib2.default.TransactionBuilder.fromTransaction(
                      namespaceRevealTX,
                      network.layer1
                    );
                    txB.setVersion(1);
                    var signingTxB = fundTransaction(
                      txB,
                      preorderAddress,
                      utxos,
                      feeRate,
                      0
                    );
                    return (0, _utils.signInputs)(signingTxB, paymentKey);
                  });
                })
                .then(function(signingTxB) {
                  return returnTransactionHex(signingTxB, buildIncomplete);
                });
            }
            function makeNamespaceReady(namespaceID, revealKeyIn) {
              var buildIncomplete =
                arguments.length > 2 && arguments[2] !== undefined
                  ? arguments[2]
                  : false;
              var network = _config.config.network;
              var namespaceReadyTX = (0, _skeletons.makeNamespaceReadySkeleton)(
                namespaceID
              );
              var revealKey = getTransactionSigner(revealKeyIn);
              return revealKey
                .getAddress()
                .then(function(revealAddress) {
                  return Promise.all([
                    network.getUTXOs(revealAddress),
                    network.getFeeRate()
                  ]).then(function(_ref39) {
                    var _ref40 = _slicedToArray(_ref39, 2),
                      utxos = _ref40[0],
                      feeRate = _ref40[1];
                    var txB = _bitcoinjsLib2.default.TransactionBuilder.fromTransaction(
                      namespaceReadyTX,
                      network.layer1
                    );
                    txB.setVersion(1);
                    var signingTxB = fundTransaction(
                      txB,
                      revealAddress,
                      utxos,
                      feeRate,
                      0
                    );
                    return (0, _utils.signInputs)(signingTxB, revealKey);
                  });
                })
                .then(function(signingTxB) {
                  return returnTransactionHex(signingTxB, buildIncomplete);
                });
            }
            function makeNameImport(
              name,
              recipientAddr,
              zonefileHash,
              importerKeyIn
            ) {
              var buildIncomplete =
                arguments.length > 4 && arguments[4] !== undefined
                  ? arguments[4]
                  : false;
              var network = _config.config.network;
              var nameImportTX = (0, _skeletons.makeNameImportSkeleton)(
                name,
                recipientAddr,
                zonefileHash
              );
              var importerKey = getTransactionSigner(importerKeyIn);
              return importerKey
                .getAddress()
                .then(function(importerAddress) {
                  return Promise.all([
                    network.getUTXOs(importerAddress),
                    network.getFeeRate()
                  ]).then(function(_ref41) {
                    var _ref42 = _slicedToArray(_ref41, 2),
                      utxos = _ref42[0],
                      feeRate = _ref42[1];
                    var txB = _bitcoinjsLib2.default.TransactionBuilder.fromTransaction(
                      nameImportTX,
                      network.layer1
                    );
                    var signingTxB = fundTransaction(
                      txB,
                      importerAddress,
                      utxos,
                      feeRate,
                      0
                    );
                    return (0, _utils.signInputs)(signingTxB, importerKey);
                  });
                })
                .then(function(signingTxB) {
                  return returnTransactionHex(signingTxB, buildIncomplete);
                });
            }
            function makeAnnounce(messageHash, senderKeyIn) {
              var buildIncomplete =
                arguments.length > 2 && arguments[2] !== undefined
                  ? arguments[2]
                  : false;
              var network = _config.config.network;
              var announceTX = (0, _skeletons.makeAnnounceSkeleton)(
                messageHash
              );
              var senderKey = getTransactionSigner(senderKeyIn);
              return senderKey
                .getAddress()
                .then(function(senderAddress) {
                  return Promise.all([
                    network.getUTXOs(senderAddress),
                    network.getFeeRate()
                  ]).then(function(_ref43) {
                    var _ref44 = _slicedToArray(_ref43, 2),
                      utxos = _ref44[0],
                      feeRate = _ref44[1];
                    var txB = _bitcoinjsLib2.default.TransactionBuilder.fromTransaction(
                      announceTX,
                      network.layer1
                    );
                    var signingTxB = fundTransaction(
                      txB,
                      senderAddress,
                      utxos,
                      feeRate,
                      0
                    );
                    return (0, _utils.signInputs)(signingTxB, senderKey);
                  });
                })
                .then(function(signingTxB) {
                  return returnTransactionHex(signingTxB, buildIncomplete);
                });
            }
            function makeTokenTransfer(
              recipientAddress,
              tokenType,
              tokenAmount,
              scratchArea,
              senderKeyIn,
              btcFunderKeyIn
            ) {
              var buildIncomplete =
                arguments.length > 6 && arguments[6] !== undefined
                  ? arguments[6]
                  : false;
              var network = _config.config.network;
              var separateFunder = !!btcFunderKeyIn;
              var senderKey = getTransactionSigner(senderKeyIn);
              var btcKey = btcFunderKeyIn
                ? getTransactionSigner(btcFunderKeyIn)
                : senderKey;
              var txPromise = network
                .getConsensusHash()
                .then(function(consensusHash) {
                  return (0,
                  _skeletons.makeTokenTransferSkeleton)(recipientAddress, consensusHash, tokenType, tokenAmount, scratchArea);
                });
              return Promise.all([senderKey.getAddress(), btcKey.getAddress()])
                .then(function(_ref45) {
                  var _ref46 = _slicedToArray(_ref45, 2),
                    senderAddress = _ref46[0],
                    btcAddress = _ref46[1];
                  var btcUTXOsPromise = separateFunder
                    ? network.getUTXOs(btcAddress)
                    : Promise.resolve([]);
                  var networkPromises = [
                    network.getUTXOs(senderAddress),
                    btcUTXOsPromise,
                    network.getFeeRate(),
                    txPromise
                  ];
                  return Promise.all(networkPromises).then(function(_ref47) {
                    var _ref48 = _slicedToArray(_ref47, 4),
                      senderUTXOs = _ref48[0],
                      btcUTXOs = _ref48[1],
                      feeRate = _ref48[2],
                      tokenTransferTX = _ref48[3];
                    var txB = _bitcoinjsLib2.default.TransactionBuilder.fromTransaction(
                      tokenTransferTX,
                      network.layer1
                    );
                    if (separateFunder) {
                      var payerInput = addOwnerInput(
                        senderUTXOs,
                        senderAddress,
                        txB
                      );
                      var signingTxB = fundTransaction(
                        txB,
                        btcAddress,
                        btcUTXOs,
                        feeRate,
                        payerInput.value
                      );
                      return (0, _utils.signInputs)(signingTxB, btcKey, [
                        { index: payerInput.index, signer: senderKey }
                      ]);
                    } else {
                      var _signingTxB = fundTransaction(
                        txB,
                        senderAddress,
                        senderUTXOs,
                        feeRate,
                        0
                      );
                      return (0, _utils.signInputs)(_signingTxB, senderKey);
                    }
                  });
                })
                .then(function(signingTxB) {
                  return returnTransactionHex(signingTxB, buildIncomplete);
                });
            }
            function makeBitcoinSpend(
              destinationAddress,
              paymentKeyIn,
              amount
            ) {
              var buildIncomplete =
                arguments.length > 3 && arguments[3] !== undefined
                  ? arguments[3]
                  : false;
              if (amount <= 0) {
                return Promise.reject(
                  new _errors.InvalidParameterError(
                    'amount',
                    'amount must be greater than zero'
                  )
                );
              }
              var network = _config.config.network;
              var paymentKey = getTransactionSigner(paymentKeyIn);
              return paymentKey
                .getAddress()
                .then(function(paymentAddress) {
                  return Promise.all([
                    network.getUTXOs(paymentAddress),
                    network.getFeeRate()
                  ]).then(function(_ref49) {
                    var _ref50 = _slicedToArray(_ref49, 2),
                      utxos = _ref50[0],
                      feeRate = _ref50[1];
                    var txB = new _bitcoinjsLib2.default.TransactionBuilder(
                      network.layer1
                    );
                    txB.setVersion(1);
                    var destinationIndex = txB.addOutput(destinationAddress, 0);
                    var change = void 0;
                    try {
                      change = (0, _utils.addUTXOsToFund)(
                        txB,
                        utxos,
                        amount,
                        feeRate,
                        false
                      );
                    } catch (err) {
                      if (err.name === 'NotEnoughFundsError') {
                        amount -= err.leftToFund;
                        change = 0;
                      } else {
                        throw err;
                      }
                    }
                    var feesToPay =
                      feeRate * (0, _utils.estimateTXBytes)(txB, 0, 0);
                    var feeForChange =
                      feeRate * (0, _utils.estimateTXBytes)(txB, 0, 1) -
                      feesToPay;
                    if (change > feeForChange) {
                      feesToPay += feeForChange;
                      txB.addOutput(paymentAddress, change);
                    }
                    var outputAmount = amount - feesToPay;
                    if (outputAmount < _utils.DUST_MINIMUM) {
                      throw new _errors.InvalidAmountError(feesToPay, amount);
                    }
                    txB.__tx.outs[destinationIndex].value = outputAmount;
                    return (0, _utils.signInputs)(txB, paymentKey);
                  });
                })
                .then(function(signingTxB) {
                  return returnTransactionHex(signingTxB, buildIncomplete);
                });
            }
            var transactions = (exports.transactions = {
              makeRenewal: makeRenewal,
              makeUpdate: makeUpdate,
              makePreorder: makePreorder,
              makeRegister: makeRegister,
              makeTransfer: makeTransfer,
              makeRevoke: makeRevoke,
              makeNamespacePreorder: makeNamespacePreorder,
              makeNamespaceReveal: makeNamespaceReveal,
              makeNamespaceReady: makeNamespaceReady,
              makeBitcoinSpend: makeBitcoinSpend,
              makeNameImport: makeNameImport,
              makeAnnounce: makeAnnounce,
              makeTokenTransfer: makeTokenTransfer,
              BlockstackNamespace: _skeletons.BlockstackNamespace,
              estimatePreorder: estimatePreorder,
              estimateRegister: estimateRegister,
              estimateTransfer: estimateTransfer,
              estimateUpdate: estimateUpdate,
              estimateRenewal: estimateRenewal,
              estimateRevoke: estimateRevoke,
              estimateNamespacePreorder: estimateNamespacePreorder,
              estimateNamespaceReveal: estimateNamespaceReveal,
              estimateNamespaceReady: estimateNamespaceReady,
              estimateNameImport: estimateNameImport,
              estimateAnnounce: estimateAnnounce,
              estimateTokenTransfer: estimateTokenTransfer
            });
          }.call(this, require('buffer').Buffer));
        },
        {
          '../config': 12,
          '../errors': 15,
          './signers': 22,
          './skeletons': 23,
          './utils': 25,
          bigi: 74,
          'bitcoinjs-lib': 96,
          buffer: 183
        }
      ],
      25: [
        function(require, module, exports) {
          (function(Buffer) {
            'use strict';
            Object.defineProperty(exports, '__esModule', { value: true });
            exports.DUST_MINIMUM = undefined;
            exports.hash160 = hash160;
            exports.hash128 = hash128;
            exports.estimateTXBytes = estimateTXBytes;
            exports.sumOutputValues = sumOutputValues;
            exports.decodeB40 = decodeB40;
            exports.addUTXOsToFund = addUTXOsToFund;
            exports.signInputs = signInputs;
            var _bitcoinjsLib = require('bitcoinjs-lib');
            var _bitcoinjsLib2 = _interopRequireDefault(_bitcoinjsLib);
            var _ripemd = require('ripemd160');
            var _ripemd2 = _interopRequireDefault(_ripemd);
            var _bigi = require('bigi');
            var _bigi2 = _interopRequireDefault(_bigi);
            var _errors = require('../errors');
            var _signers = require('./signers');
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            var DUST_MINIMUM = (exports.DUST_MINIMUM = 5500);
            function hash160(buff) {
              var sha256 = _bitcoinjsLib2.default.crypto.sha256(buff);
              return new _ripemd2.default().update(sha256).digest();
            }
            function hash128(buff) {
              return Buffer.from(
                _bitcoinjsLib2.default.crypto.sha256(buff).slice(0, 16)
              );
            }
            var TX_EMPTY_SIZE = 4 + 1 + 1 + 4;
            var TX_INPUT_BASE = 32 + 4 + 1 + 4;
            var TX_INPUT_PUBKEYHASH = 107;
            var TX_OUTPUT_BASE = 8 + 1;
            var TX_OUTPUT_PUBKEYHASH = 25;
            function inputBytes(input) {
              if (input && input.script && input.script.length > 0) {
                return TX_INPUT_BASE + input.script.length;
              } else {
                return TX_INPUT_BASE + TX_INPUT_PUBKEYHASH;
              }
            }
            function outputBytes(output) {
              if (output && output.script && output.script.length > 0) {
                return TX_OUTPUT_BASE + output.script.length;
              } else {
                return TX_OUTPUT_BASE + TX_OUTPUT_PUBKEYHASH;
              }
            }
            function transactionBytes(inputs, outputs) {
              return (
                TX_EMPTY_SIZE +
                inputs.reduce(function(a, x) {
                  return a + inputBytes(x);
                }, 0) +
                outputs.reduce(function(a, x) {
                  return a + outputBytes(x);
                }, 0)
              );
            }
            function estimateTXBytes(
              txIn,
              additionalInputs,
              additionalOutputs
            ) {
              var innerTx = txIn;
              if (txIn instanceof _bitcoinjsLib2.default.TransactionBuilder) {
                innerTx = txIn.__tx;
              }
              var dummyInputs = new Array(additionalInputs);
              dummyInputs.fill(null);
              var dummyOutputs = new Array(additionalOutputs);
              dummyOutputs.fill(null);
              var inputs = [].concat(innerTx.ins, dummyInputs);
              var outputs = [].concat(innerTx.outs, dummyOutputs);
              return transactionBytes(inputs, outputs);
            }
            function sumOutputValues(txIn) {
              var innerTx = txIn;
              if (txIn instanceof _bitcoinjsLib2.default.TransactionBuilder) {
                innerTx = txIn.__tx;
              }
              return innerTx.outs.reduce(function(agg, x) {
                return agg + x.value;
              }, 0);
            }
            function decodeB40(input) {
              var characters = '0123456789abcdefghijklmnopqrstuvwxyz-_.+';
              var base = _bigi2.default.valueOf(40);
              var inputDigits = input.split('').reverse();
              var digitValues = inputDigits.map(function(character, exponent) {
                return _bigi2.default
                  .valueOf(characters.indexOf(character))
                  .multiply(base.pow(_bigi2.default.valueOf(exponent)));
              });
              var sum = digitValues.reduce(function(agg, cur) {
                return agg.add(cur);
              }, _bigi2.default.ZERO);
              return sum.toHex();
            }
            function addUTXOsToFund(txBuilderIn, utxos, amountToFund, feeRate) {
              var fundNewFees =
                arguments.length > 4 && arguments[4] !== undefined
                  ? arguments[4]
                  : true;
              if (utxos.length === 0) {
                throw new _errors.NotEnoughFundsError(amountToFund);
              }
              var newFees =
                feeRate *
                (estimateTXBytes(txBuilderIn, 1, 0) -
                  estimateTXBytes(txBuilderIn, 0, 0));
              var utxoThreshhold = amountToFund;
              if (fundNewFees) {
                utxoThreshhold += newFees;
              }
              var goodUtxos = utxos.filter(function(utxo) {
                return utxo.value >= utxoThreshhold;
              });
              if (goodUtxos.length > 0) {
                goodUtxos.sort(function(a, b) {
                  return a.value - b.value;
                });
                var selected = goodUtxos[0];
                var change = selected.value - amountToFund;
                if (fundNewFees) {
                  change -= newFees;
                }
                txBuilderIn.addInput(selected.tx_hash, selected.tx_output_n);
                return change;
              } else {
                utxos.sort(function(a, b) {
                  return b.value - a.value;
                });
                var largest = utxos[0];
                if (newFees >= largest.value) {
                  throw new _errors.NotEnoughFundsError(amountToFund);
                }
                txBuilderIn.addInput(largest.tx_hash, largest.tx_output_n);
                var remainToFund = amountToFund - largest.value;
                if (fundNewFees) {
                  remainToFund += newFees;
                }
                return addUTXOsToFund(
                  txBuilderIn,
                  utxos.slice(1),
                  remainToFund,
                  feeRate,
                  fundNewFees
                );
              }
            }
            function signInputs(txB, defaultSigner, otherSigners) {
              var signerArray = txB.__tx.ins.map(function() {
                return defaultSigner;
              });
              if (otherSigners) {
                otherSigners.forEach(function(signerPair) {
                  signerArray[signerPair.index] = signerPair.signer;
                });
              }
              var signingPromise = Promise.resolve();
              var _loop = function _loop(i) {
                signingPromise = signingPromise.then(function() {
                  return signerArray[i].signTransaction(txB, i);
                });
              };
              for (var i = 0; i < txB.__tx.ins.length; i++) {
                _loop(i);
              }
              return signingPromise.then(function() {
                return txB;
              });
            }
          }.call(this, require('buffer').Buffer));
        },
        {
          '../errors': 15,
          './signers': 22,
          bigi: 74,
          'bitcoinjs-lib': 96,
          buffer: 183,
          ripemd160: 459
        }
      ],
      26: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          var _profile = require('./profile');
          Object.defineProperty(exports, 'Profile', {
            enumerable: true,
            get: function get() {
              return _profile.Profile;
            }
          });
          var _profileSchemas = require('./profileSchemas');
          Object.defineProperty(exports, 'Person', {
            enumerable: true,
            get: function get() {
              return _profileSchemas.Person;
            }
          });
          Object.defineProperty(exports, 'Organization', {
            enumerable: true,
            get: function get() {
              return _profileSchemas.Organization;
            }
          });
          Object.defineProperty(exports, 'CreativeWork', {
            enumerable: true,
            get: function get() {
              return _profileSchemas.CreativeWork;
            }
          });
          Object.defineProperty(exports, 'resolveZoneFileToPerson', {
            enumerable: true,
            get: function get() {
              return _profileSchemas.resolveZoneFileToPerson;
            }
          });
          var _profileTokens = require('./profileTokens');
          Object.defineProperty(exports, 'signProfileToken', {
            enumerable: true,
            get: function get() {
              return _profileTokens.signProfileToken;
            }
          });
          Object.defineProperty(exports, 'wrapProfileToken', {
            enumerable: true,
            get: function get() {
              return _profileTokens.wrapProfileToken;
            }
          });
          Object.defineProperty(exports, 'verifyProfileToken', {
            enumerable: true,
            get: function get() {
              return _profileTokens.verifyProfileToken;
            }
          });
          Object.defineProperty(exports, 'extractProfile', {
            enumerable: true,
            get: function get() {
              return _profileTokens.extractProfile;
            }
          });
          var _profileProofs = require('./profileProofs');
          Object.defineProperty(exports, 'validateProofs', {
            enumerable: true,
            get: function get() {
              return _profileProofs.validateProofs;
            }
          });
          var _services = require('./services');
          Object.defineProperty(exports, 'profileServices', {
            enumerable: true,
            get: function get() {
              return _services.profileServices;
            }
          });
          Object.defineProperty(exports, 'containsValidProofStatement', {
            enumerable: true,
            get: function get() {
              return _services.containsValidProofStatement;
            }
          });
          Object.defineProperty(exports, 'containsValidAddressProofStatement', {
            enumerable: true,
            get: function get() {
              return _services.containsValidAddressProofStatement;
            }
          });
          var _profileZoneFiles = require('./profileZoneFiles');
          Object.defineProperty(exports, 'makeProfileZoneFile', {
            enumerable: true,
            get: function get() {
              return _profileZoneFiles.makeProfileZoneFile;
            }
          });
          Object.defineProperty(exports, 'getTokenFileUrl', {
            enumerable: true,
            get: function get() {
              return _profileZoneFiles.getTokenFileUrl;
            }
          });
          Object.defineProperty(exports, 'resolveZoneFileToProfile', {
            enumerable: true,
            get: function get() {
              return _profileZoneFiles.resolveZoneFileToProfile;
            }
          });
          var _profileLookup = require('./profileLookup');
          Object.defineProperty(exports, 'lookupProfile', {
            enumerable: true,
            get: function get() {
              return _profileLookup.lookupProfile;
            }
          });
        },
        {
          './profile': 27,
          './profileLookup': 28,
          './profileProofs': 29,
          './profileSchemas': 31,
          './profileTokens': 37,
          './profileZoneFiles': 38,
          './services': 42
        }
      ],
      27: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.Profile = undefined;
          var _createClass = (function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          })();
          var _schemaInspector = require('schema-inspector');
          var _schemaInspector2 = _interopRequireDefault(_schemaInspector);
          var _profileTokens = require('./profileTokens');
          var _profileProofs = require('./profileProofs');
          var _profileZoneFiles = require('./profileZoneFiles');
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          var schemaDefinition = {
            type: 'object',
            properties: {
              '@context': { type: 'string', optional: true },
              '@type': { type: 'string' }
            }
          };
          var Profile = (exports.Profile = (function() {
            function Profile() {
              var profile =
                arguments.length > 0 && arguments[0] !== undefined
                  ? arguments[0]
                  : {};
              _classCallCheck(this, Profile);
              this._profile = Object.assign(
                {},
                { '@context': 'http://schema.org/' },
                profile
              );
            }
            _createClass(
              Profile,
              [
                {
                  key: 'toJSON',
                  value: function toJSON() {
                    return Object.assign({}, this._profile);
                  }
                },
                {
                  key: 'toToken',
                  value: function toToken(privateKey) {
                    return (0, _profileTokens.signProfileToken)(
                      this.toJSON(),
                      privateKey
                    );
                  }
                }
              ],
              [
                {
                  key: 'validateSchema',
                  value: function validateSchema(profile) {
                    var strict =
                      arguments.length > 1 && arguments[1] !== undefined
                        ? arguments[1]
                        : false;
                    schemaDefinition.strict = strict;
                    return _schemaInspector2.default.validate(
                      schemaDefinition,
                      profile
                    );
                  }
                },
                {
                  key: 'fromToken',
                  value: function fromToken(token) {
                    var publicKeyOrAddress =
                      arguments.length > 1 && arguments[1] !== undefined
                        ? arguments[1]
                        : null;
                    var profile = (0, _profileTokens.extractProfile)(
                      token,
                      publicKeyOrAddress
                    );
                    return new Profile(profile);
                  }
                },
                {
                  key: 'makeZoneFile',
                  value: function makeZoneFile(domainName, tokenFileURL) {
                    return (0, _profileZoneFiles.makeProfileZoneFile)(
                      domainName,
                      tokenFileURL
                    );
                  }
                },
                {
                  key: 'validateProofs',
                  value: function validateProofs(domainName) {
                    return (0, _profileProofs.validateProofs)(
                      this.toJSON(),
                      domainName
                    );
                  }
                }
              ]
            );
            return Profile;
          })());
        },
        {
          './profileProofs': 29,
          './profileTokens': 37,
          './profileZoneFiles': 38,
          'schema-inspector': 461
        }
      ],
      28: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.lookupProfile = lookupProfile;
          var _profileZoneFiles = require('./profileZoneFiles');
          var _config = require('../config');
          function lookupProfile(username) {
            var zoneFileLookupURL =
              arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : null;
            if (!username) {
              return Promise.reject();
            }
            var lookupPromise = void 0;
            if (zoneFileLookupURL) {
              var url = zoneFileLookupURL.replace(/\/$/, '') + '/' + username;
              lookupPromise = fetch(url).then(function(response) {
                return response.json();
              });
            } else {
              lookupPromise = _config.config.network.getNameInfo(username);
            }
            return lookupPromise.then(function(responseJSON) {
              if (
                responseJSON.hasOwnProperty('zonefile') &&
                responseJSON.hasOwnProperty('address')
              ) {
                return (0, _profileZoneFiles.resolveZoneFileToProfile)(
                  responseJSON.zonefile,
                  responseJSON.address
                );
              } else {
                throw new Error(
                  'Invalid zonefile lookup response: did not contain `address`' +
                    ' or `zonefile` field'
                );
              }
            });
          }
        },
        { '../config': 12, './profileZoneFiles': 38 }
      ],
      29: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.validateProofs = validateProofs;
          var _services = require('./services');
          function validateProofs(profile, ownerAddress) {
            var name =
              arguments.length > 2 && arguments[2] !== undefined
                ? arguments[2]
                : null;
            if (!profile) {
              throw new Error('Profile must not be null');
            }
            var accounts = [];
            var proofsToValidate = [];
            if (profile.hasOwnProperty('account')) {
              accounts = profile.account;
            } else {
              return new Promise(function(resolve) {
                resolve([]);
              });
            }
            accounts.forEach(function(account) {
              if (
                account.hasOwnProperty('service') &&
                !_services.profileServices.hasOwnProperty(account.service)
              ) {
                return;
              }
              if (
                !(
                  account.hasOwnProperty('proofType') &&
                  account.proofType === 'http' &&
                  account.hasOwnProperty('proofUrl')
                )
              ) {
                return;
              }
              var proof = {
                service: account.service,
                proof_url: account.proofUrl,
                identifier: account.identifier,
                valid: false
              };
              proofsToValidate.push(
                _services.profileServices[account.service].validateProof(
                  proof,
                  ownerAddress,
                  name
                )
              );
            });
            return Promise.all(proofsToValidate);
          }
        },
        { './services': 42 }
      ],
      30: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.CreativeWork = undefined;
          var _createClass = (function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          })();
          var _schemaInspector = require('schema-inspector');
          var _schemaInspector2 = _interopRequireDefault(_schemaInspector);
          var _profileTokens = require('../profileTokens');
          var _profile = require('../profile');
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError(
                "this hasn't been initialised - super() hasn't been called"
              );
            }
            return call &&
              (typeof call === 'object' || typeof call === 'function')
              ? call
              : self;
          }
          function _inherits(subClass, superClass) {
            if (typeof superClass !== 'function' && superClass !== null) {
              throw new TypeError(
                'Super expression must either be null or a function, not ' +
                  typeof superClass
              );
            }
            subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              }
            );
            if (superClass)
              Object.setPrototypeOf
                ? Object.setPrototypeOf(subClass, superClass)
                : (subClass.__proto__ = superClass);
          }
          var schemaDefinition = {
            type: 'object',
            properties: {
              '@context': { type: 'string', optional: true },
              '@type': { type: 'string' },
              '@id': { type: 'string', optional: true }
            }
          };
          var CreativeWork = (exports.CreativeWork = (function(_Profile) {
            _inherits(CreativeWork, _Profile);
            function CreativeWork() {
              var profile =
                arguments.length > 0 && arguments[0] !== undefined
                  ? arguments[0]
                  : {};
              _classCallCheck(this, CreativeWork);
              var _this = _possibleConstructorReturn(
                this,
                (
                  CreativeWork.__proto__ || Object.getPrototypeOf(CreativeWork)
                ).call(this, profile)
              );
              _this._profile = Object.assign(
                {},
                { '@type': 'CreativeWork' },
                _this._profile
              );
              return _this;
            }
            _createClass(CreativeWork, null, [
              {
                key: 'validateSchema',
                value: function validateSchema(profile) {
                  var strict =
                    arguments.length > 1 && arguments[1] !== undefined
                      ? arguments[1]
                      : false;
                  schemaDefinition.strict = strict;
                  return _schemaInspector2.default.validate(
                    schemaDefinition,
                    profile
                  );
                }
              },
              {
                key: 'fromToken',
                value: function fromToken(token) {
                  var publicKeyOrAddress =
                    arguments.length > 1 && arguments[1] !== undefined
                      ? arguments[1]
                      : null;
                  var profile = (0, _profileTokens.extractProfile)(
                    token,
                    publicKeyOrAddress
                  );
                  return new CreativeWork(profile);
                }
              }
            ]);
            return CreativeWork;
          })(_profile.Profile));
        },
        { '../profile': 27, '../profileTokens': 37, 'schema-inspector': 461 }
      ],
      31: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          var _person = require('./person');
          Object.defineProperty(exports, 'Person', {
            enumerable: true,
            get: function get() {
              return _person.Person;
            }
          });
          var _organization = require('./organization');
          Object.defineProperty(exports, 'Organization', {
            enumerable: true,
            get: function get() {
              return _organization.Organization;
            }
          });
          var _creativework = require('./creativework');
          Object.defineProperty(exports, 'CreativeWork', {
            enumerable: true,
            get: function get() {
              return _creativework.CreativeWork;
            }
          });
          var _personLegacy = require('./personLegacy');
          Object.defineProperty(exports, 'getPersonFromLegacyFormat', {
            enumerable: true,
            get: function get() {
              return _personLegacy.getPersonFromLegacyFormat;
            }
          });
          var _personZoneFiles = require('./personZoneFiles');
          Object.defineProperty(exports, 'resolveZoneFileToPerson', {
            enumerable: true,
            get: function get() {
              return _personZoneFiles.resolveZoneFileToPerson;
            }
          });
        },
        {
          './creativework': 30,
          './organization': 32,
          './person': 33,
          './personLegacy': 34,
          './personZoneFiles': 36
        }
      ],
      32: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.Organization = undefined;
          var _createClass = (function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          })();
          var _schemaInspector = require('schema-inspector');
          var _schemaInspector2 = _interopRequireDefault(_schemaInspector);
          var _profileTokens = require('../profileTokens');
          var _profile = require('../profile');
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError(
                "this hasn't been initialised - super() hasn't been called"
              );
            }
            return call &&
              (typeof call === 'object' || typeof call === 'function')
              ? call
              : self;
          }
          function _inherits(subClass, superClass) {
            if (typeof superClass !== 'function' && superClass !== null) {
              throw new TypeError(
                'Super expression must either be null or a function, not ' +
                  typeof superClass
              );
            }
            subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              }
            );
            if (superClass)
              Object.setPrototypeOf
                ? Object.setPrototypeOf(subClass, superClass)
                : (subClass.__proto__ = superClass);
          }
          var schemaDefinition = {
            type: 'object',
            properties: {
              '@context': { type: 'string', optional: true },
              '@type': { type: 'string' },
              '@id': { type: 'string', optional: true }
            }
          };
          var Organization = (exports.Organization = (function(_Profile) {
            _inherits(Organization, _Profile);
            function Organization() {
              var profile =
                arguments.length > 0 && arguments[0] !== undefined
                  ? arguments[0]
                  : {};
              _classCallCheck(this, Organization);
              var _this = _possibleConstructorReturn(
                this,
                (
                  Organization.__proto__ || Object.getPrototypeOf(Organization)
                ).call(this, profile)
              );
              _this._profile = Object.assign(
                {},
                { '@type': 'Organization' },
                _this._profile
              );
              return _this;
            }
            _createClass(Organization, null, [
              {
                key: 'validateSchema',
                value: function validateSchema(profile) {
                  var strict =
                    arguments.length > 1 && arguments[1] !== undefined
                      ? arguments[1]
                      : false;
                  schemaDefinition.strict = strict;
                  return _schemaInspector2.default.validate(
                    schemaDefinition,
                    profile
                  );
                }
              },
              {
                key: 'fromToken',
                value: function fromToken(token) {
                  var publicKeyOrAddress =
                    arguments.length > 1 && arguments[1] !== undefined
                      ? arguments[1]
                      : null;
                  var profile = (0, _profileTokens.extractProfile)(
                    token,
                    publicKeyOrAddress
                  );
                  return new Organization(profile);
                }
              }
            ]);
            return Organization;
          })(_profile.Profile));
        },
        { '../profile': 27, '../profileTokens': 37, 'schema-inspector': 461 }
      ],
      33: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.Person = undefined;
          var _createClass = (function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          })();
          var _schemaInspector = require('schema-inspector');
          var _schemaInspector2 = _interopRequireDefault(_schemaInspector);
          var _profile = require('../profile');
          var _profileTokens = require('../profileTokens');
          var _personLegacy = require('./personLegacy');
          var _personUtils = require('./personUtils');
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError(
                "this hasn't been initialised - super() hasn't been called"
              );
            }
            return call &&
              (typeof call === 'object' || typeof call === 'function')
              ? call
              : self;
          }
          function _inherits(subClass, superClass) {
            if (typeof superClass !== 'function' && superClass !== null) {
              throw new TypeError(
                'Super expression must either be null or a function, not ' +
                  typeof superClass
              );
            }
            subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              }
            );
            if (superClass)
              Object.setPrototypeOf
                ? Object.setPrototypeOf(subClass, superClass)
                : (subClass.__proto__ = superClass);
          }
          var schemaDefinition = {
            type: 'object',
            strict: false,
            properties: {
              '@context': { type: 'string', optional: true },
              '@type': { type: 'string' },
              '@id': { type: 'string', optional: true },
              name: { type: 'string', optional: true },
              givenName: { type: 'string', optional: true },
              familyName: { type: 'string', optional: true },
              description: { type: 'string', optional: true },
              image: {
                type: 'array',
                optional: true,
                items: {
                  type: 'object',
                  properties: {
                    '@type': { type: 'string' },
                    name: { type: 'string', optional: true },
                    contentUrl: { type: 'string', optional: true }
                  }
                }
              },
              website: {
                type: 'array',
                optional: true,
                items: {
                  type: 'object',
                  properties: {
                    '@type': { type: 'string' },
                    url: { type: 'string', optional: true }
                  }
                }
              },
              account: {
                type: 'array',
                optional: true,
                items: {
                  type: 'object',
                  properties: {
                    '@type': { type: 'string' },
                    service: { type: 'string', optional: true },
                    identifier: { type: 'string', optional: true },
                    proofType: { type: 'string', optional: true },
                    proofUrl: { type: 'string', optional: true },
                    proofMessage: { type: 'string', optional: true },
                    proofSignature: { type: 'string', optional: true }
                  }
                }
              },
              worksFor: {
                type: 'array',
                optional: true,
                items: {
                  type: 'object',
                  properties: {
                    '@type': { type: 'string' },
                    '@id': { type: 'string', optional: true }
                  }
                }
              },
              knows: {
                type: 'array',
                optional: true,
                items: {
                  type: 'object',
                  properties: {
                    '@type': { type: 'string' },
                    '@id': { type: 'string', optional: true }
                  }
                }
              },
              address: {
                type: 'object',
                optional: true,
                properties: {
                  '@type': { type: 'string' },
                  streetAddress: { type: 'string', optional: true },
                  addressLocality: { type: 'string', optional: true },
                  postalCode: { type: 'string', optional: true },
                  addressCountry: { type: 'string', optional: true }
                }
              },
              birthDate: { type: 'string', optional: true },
              taxID: { type: 'string', optional: true }
            }
          };
          var Person = (exports.Person = (function(_Profile) {
            _inherits(Person, _Profile);
            function Person() {
              var profile =
                arguments.length > 0 && arguments[0] !== undefined
                  ? arguments[0]
                  : {};
              _classCallCheck(this, Person);
              var _this = _possibleConstructorReturn(
                this,
                (Person.__proto__ || Object.getPrototypeOf(Person)).call(
                  this,
                  profile
                )
              );
              _this._profile = Object.assign(
                {},
                { '@type': 'Person' },
                _this._profile
              );
              return _this;
            }
            _createClass(
              Person,
              [
                {
                  key: 'toJSON',
                  value: function toJSON() {
                    return {
                      profile: this.profile(),
                      name: this.name(),
                      givenName: this.givenName(),
                      familyName: this.familyName(),
                      description: this.description(),
                      avatarUrl: this.avatarUrl(),
                      verifiedAccounts: this.verifiedAccounts(),
                      address: this.address(),
                      birthDate: this.birthDate(),
                      connections: this.connections(),
                      organizations: this.organizations()
                    };
                  }
                },
                {
                  key: 'profile',
                  value: function profile() {
                    return Object.assign({}, this._profile);
                  }
                },
                {
                  key: 'name',
                  value: function name() {
                    return (0, _personUtils.getName)(this.profile());
                  }
                },
                {
                  key: 'givenName',
                  value: function givenName() {
                    return (0, _personUtils.getGivenName)(this.profile());
                  }
                },
                {
                  key: 'familyName',
                  value: function familyName() {
                    return (0, _personUtils.getFamilyName)(this.profile());
                  }
                },
                {
                  key: 'description',
                  value: function description() {
                    return (0, _personUtils.getDescription)(this.profile());
                  }
                },
                {
                  key: 'avatarUrl',
                  value: function avatarUrl() {
                    return (0, _personUtils.getAvatarUrl)(this.profile());
                  }
                },
                {
                  key: 'verifiedAccounts',
                  value: function verifiedAccounts(verifications) {
                    return (0, _personUtils.getVerifiedAccounts)(
                      this.profile(),
                      verifications
                    );
                  }
                },
                {
                  key: 'address',
                  value: function address() {
                    return (0, _personUtils.getAddress)(this.profile());
                  }
                },
                {
                  key: 'birthDate',
                  value: function birthDate() {
                    return (0, _personUtils.getBirthDate)(this.profile());
                  }
                },
                {
                  key: 'connections',
                  value: function connections() {
                    return (0, _personUtils.getConnections)(this.profile());
                  }
                },
                {
                  key: 'organizations',
                  value: function organizations() {
                    return (0, _personUtils.getOrganizations)(this.profile());
                  }
                }
              ],
              [
                {
                  key: 'validateSchema',
                  value: function validateSchema(profile) {
                    var strict =
                      arguments.length > 1 && arguments[1] !== undefined
                        ? arguments[1]
                        : false;
                    schemaDefinition.strict = strict;
                    return _schemaInspector2.default.validate(
                      schemaDefinition,
                      profile
                    );
                  }
                },
                {
                  key: 'fromToken',
                  value: function fromToken(token) {
                    var publicKeyOrAddress =
                      arguments.length > 1 && arguments[1] !== undefined
                        ? arguments[1]
                        : null;
                    var profile = (0, _profileTokens.extractProfile)(
                      token,
                      publicKeyOrAddress
                    );
                    return new Person(profile);
                  }
                },
                {
                  key: 'fromLegacyFormat',
                  value: function fromLegacyFormat(legacyProfile) {
                    var profile = (0, _personLegacy.getPersonFromLegacyFormat)(
                      legacyProfile
                    );
                    return new Person(profile);
                  }
                }
              ]
            );
            return Person;
          })(_profile.Profile));
        },
        {
          '../profile': 27,
          '../profileTokens': 37,
          './personLegacy': 34,
          './personUtils': 35,
          'schema-inspector': 461
        }
      ],
      34: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.getPersonFromLegacyFormat = getPersonFromLegacyFormat;
          function formatAccount(serviceName, data) {
            var proofUrl = void 0;
            if (data.proof && data.proof.url) {
              proofUrl = data.proof.url;
            }
            return {
              '@type': 'Account',
              service: serviceName,
              identifier: data.username,
              proofType: 'http',
              proofUrl: proofUrl
            };
          }
          function getPersonFromLegacyFormat(profile) {
            var profileData = { '@type': 'Person' };
            if (profile) {
              if (profile.name && profile.name.formatted) {
                profileData.name = profile.name.formatted;
              }
              if (profile.bio) {
                profileData.description = profile.bio;
              }
              if (profile.location && profile.location.formatted) {
                profileData.address = {
                  '@type': 'PostalAddress',
                  addressLocality: profile.location.formatted
                };
              }
              var images = [];
              if (profile.avatar && profile.avatar.url) {
                images.push({
                  '@type': 'ImageObject',
                  name: 'avatar',
                  contentUrl: profile.avatar.url
                });
              }
              if (profile.cover && profile.cover.url) {
                images.push({
                  '@type': 'ImageObject',
                  name: 'cover',
                  contentUrl: profile.cover.url
                });
              }
              if (images.length) {
                profileData.image = images;
              }
              if (profile.website) {
                profileData.website = [
                  { '@type': 'WebSite', url: profile.website }
                ];
              }
              var accounts = [];
              if (profile.bitcoin && profile.bitcoin.address) {
                accounts.push({
                  '@type': 'Account',
                  role: 'payment',
                  service: 'bitcoin',
                  identifier: profile.bitcoin.address
                });
              }
              if (profile.twitter && profile.twitter.username) {
                accounts.push(formatAccount('twitter', profile.twitter));
              }
              if (profile.facebook && profile.facebook.username) {
                accounts.push(formatAccount('facebook', profile.facebook));
              }
              if (profile.github && profile.github.username) {
                accounts.push(formatAccount('github', profile.github));
              }
              if (profile.auth) {
                if (profile.auth.length > 0) {
                  if (profile.auth[0] && profile.auth[0].publicKeychain) {
                    accounts.push({
                      '@type': 'Account',
                      role: 'key',
                      service: 'bip32',
                      identifier: profile.auth[0].publicKeychain
                    });
                  }
                }
              }
              if (profile.pgp && profile.pgp.url) {
                accounts.push({
                  '@type': 'Account',
                  role: 'key',
                  service: 'pgp',
                  identifier: profile.pgp.fingerprint,
                  contentUrl: profile.pgp.url
                });
              }
              profileData.account = accounts;
            }
            return profileData;
          }
        },
        {}
      ],
      35: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.getName = getName;
          exports.getGivenName = getGivenName;
          exports.getFamilyName = getFamilyName;
          exports.getDescription = getDescription;
          exports.getAvatarUrl = getAvatarUrl;
          exports.getVerifiedAccounts = getVerifiedAccounts;
          exports.getOrganizations = getOrganizations;
          exports.getConnections = getConnections;
          exports.getAddress = getAddress;
          exports.getBirthDate = getBirthDate;
          function getName(profile) {
            if (!profile) {
              return null;
            }
            var name = null;
            if (profile.name) {
              name = profile.name;
            } else if (profile.givenName || profile.familyName) {
              name = '';
              if (profile.givenName) {
                name = profile.givenName;
              }
              if (profile.familyName) {
                name += ' ' + profile.familyName;
              }
            }
            return name;
          }
          function getGivenName(profile) {
            if (!profile) {
              return null;
            }
            var givenName = null;
            if (profile.givenName) {
              givenName = profile.givenName;
            } else if (profile.name) {
              var nameParts = profile.name.split(' ');
              givenName = nameParts.slice(0, -1).join(' ');
            }
            return givenName;
          }
          function getFamilyName(profile) {
            if (!profile) {
              return null;
            }
            var familyName = null;
            if (profile.familyName) {
              familyName = profile.familyName;
            } else if (profile.name) {
              var nameParts = profile.name.split(' ');
              familyName = nameParts.pop();
            }
            return familyName;
          }
          function getDescription(profile) {
            if (!profile) {
              return null;
            }
            var description = null;
            if (profile.description) {
              description = profile.description;
            }
            return description;
          }
          function getAvatarUrl(profile) {
            if (!profile) {
              return null;
            }
            var avatarContentUrl = null;
            if (profile.image) {
              profile.image.map(function(image) {
                if (image.name === 'avatar') {
                  avatarContentUrl = image.contentUrl;
                  return avatarContentUrl;
                } else {
                  return null;
                }
              });
            }
            return avatarContentUrl;
          }
          function getVerifiedAccounts(profile, verifications) {
            if (!profile) {
              return null;
            }
            var filteredAccounts = [];
            if (profile.hasOwnProperty('account') && verifications) {
              profile.account.map(function(account) {
                var accountIsValid = false;
                var proofUrl = null;
                verifications.map(function(verification) {
                  if (verification.hasOwnProperty('proof_url')) {
                    verification.proofUrl = verification.proof_url;
                  }
                  if (
                    verification.valid &&
                    verification.service === account.service &&
                    verification.identifier === account.identifier &&
                    verification.proofUrl
                  ) {
                    accountIsValid = true;
                    proofUrl = verification.proofUrl;
                    return true;
                  } else {
                    return false;
                  }
                });
                if (accountIsValid) {
                  account.proofUrl = proofUrl;
                  filteredAccounts.push(account);
                  return account;
                } else {
                  return null;
                }
              });
            }
            return filteredAccounts;
          }
          function getOrganizations(profile) {
            if (!profile) {
              return null;
            }
            var organizations = [];
            if (profile.hasOwnProperty('worksFor')) {
              return profile.worksFor;
            }
            return organizations;
          }
          function getConnections(profile) {
            if (!profile) {
              return null;
            }
            var connections = [];
            if (profile.hasOwnProperty('knows')) {
              connections = profile.knows;
            }
            return connections;
          }
          function getAddress(profile) {
            if (!profile) {
              return null;
            }
            var addressString = null;
            if (profile.hasOwnProperty('address')) {
              var addressParts = [];
              if (profile.address.hasOwnProperty('streetAddress')) {
                addressParts.push(profile.address.streetAddress);
              }
              if (profile.address.hasOwnProperty('addressLocality')) {
                addressParts.push(profile.address.addressLocality);
              }
              if (profile.address.hasOwnProperty('postalCode')) {
                addressParts.push(profile.address.postalCode);
              }
              if (profile.address.hasOwnProperty('addressCountry')) {
                addressParts.push(profile.address.addressCountry);
              }
              if (addressParts.length) {
                addressString = addressParts.join(', ');
              }
            }
            return addressString;
          }
          function getBirthDate(profile) {
            if (!profile) {
              return null;
            }
            var monthNames = [
              'January',
              'February',
              'March',
              'April',
              'May',
              'June',
              'July',
              'August',
              'September',
              'October',
              'November',
              'December'
            ];
            var birthDateString = null;
            if (profile.hasOwnProperty('birthDate')) {
              var date = new Date(profile.birthDate);
              birthDateString =
                monthNames[date.getMonth()] +
                ' ' +
                date.getDate() +
                ', ' +
                date.getFullYear();
            }
            return birthDateString;
          }
        },
        {}
      ],
      36: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.resolveZoneFileToPerson = resolveZoneFileToPerson;
          var _zoneFile = require('zone-file');
          var _person = require('./person');
          var _profileZoneFiles = require('../profileZoneFiles');
          var _profileTokens = require('../profileTokens');
          function resolveZoneFileToPerson(
            zoneFile,
            publicKeyOrAddress,
            callback
          ) {
            var zoneFileJson = null;
            try {
              zoneFileJson = (0, _zoneFile.parseZoneFile)(zoneFile);
              if (!zoneFileJson.hasOwnProperty('$origin')) {
                zoneFileJson = null;
                throw new Error('zone file is missing an origin');
              }
            } catch (e) {
              console.error(e);
            }
            var tokenFileUrl = null;
            if (zoneFileJson && Object.keys(zoneFileJson).length > 0) {
              tokenFileUrl = (0, _profileZoneFiles.getTokenFileUrl)(
                zoneFileJson
              );
            } else {
              var profile = null;
              try {
                profile = JSON.parse(zoneFile);
                var person = _person.Person.fromLegacyFormat(profile);
                profile = person.profile();
              } catch (error) {
                console.warn(error);
              }
              callback(profile);
              return;
            }
            if (tokenFileUrl) {
              fetch(tokenFileUrl)
                .then(function(response) {
                  return response.text();
                })
                .then(function(responseText) {
                  return JSON.parse(responseText);
                })
                .then(function(responseJson) {
                  var tokenRecords = responseJson;
                  var token = tokenRecords[0].token;
                  var profile = (0, _profileTokens.extractProfile)(
                    token,
                    publicKeyOrAddress
                  );
                  callback(profile);
                })
                .catch(function(error) {
                  console.warn(error);
                });
            } else {
              console.warn('Token file url not found');
              callback({});
            }
          }
        },
        {
          '../profileTokens': 37,
          '../profileZoneFiles': 38,
          './person': 33,
          'zone-file': 569
        }
      ],
      37: [
        function(require, module, exports) {
          (function(Buffer) {
            'use strict';
            Object.defineProperty(exports, '__esModule', { value: true });
            exports.signProfileToken = signProfileToken;
            exports.wrapProfileToken = wrapProfileToken;
            exports.verifyProfileToken = verifyProfileToken;
            exports.extractProfile = extractProfile;
            var _bitcoinjsLib = require('bitcoinjs-lib');
            var _jsontokens = require('jsontokens');
            var _utils = require('../utils');
            function signProfileToken(profile, privateKey) {
              var subject =
                arguments.length > 2 && arguments[2] !== undefined
                  ? arguments[2]
                  : null;
              var issuer =
                arguments.length > 3 && arguments[3] !== undefined
                  ? arguments[3]
                  : null;
              var signingAlgorithm =
                arguments.length > 4 && arguments[4] !== undefined
                  ? arguments[4]
                  : 'ES256K';
              var issuedAt =
                arguments.length > 5 && arguments[5] !== undefined
                  ? arguments[5]
                  : new Date();
              var expiresAt =
                arguments.length > 6 && arguments[6] !== undefined
                  ? arguments[6]
                  : (0, _utils.nextYear)();
              if (signingAlgorithm !== 'ES256K') {
                throw new Error('Signing algorithm not supported');
              }
              var publicKey = _jsontokens.SECP256K1Client.derivePublicKey(
                privateKey
              );
              if (subject === null) {
                subject = { publicKey: publicKey };
              }
              if (issuer === null) {
                issuer = { publicKey: publicKey };
              }
              var tokenSigner = new _jsontokens.TokenSigner(
                signingAlgorithm,
                privateKey
              );
              var payload = {
                jti: (0, _utils.makeUUID4)(),
                iat: issuedAt.toISOString(),
                exp: expiresAt.toISOString(),
                subject: subject,
                issuer: issuer,
                claim: profile
              };
              return tokenSigner.sign(payload);
            }
            function wrapProfileToken(token) {
              return {
                token: token,
                decodedToken: (0, _jsontokens.decodeToken)(token)
              };
            }
            function verifyProfileToken(token, publicKeyOrAddress) {
              var decodedToken = (0, _jsontokens.decodeToken)(token);
              var payload = decodedToken.payload;
              if (payload.hasOwnProperty('subject')) {
                if (!payload.subject.hasOwnProperty('publicKey')) {
                  throw new Error("Token doesn't have a subject public key");
                }
              } else {
                throw new Error("Token doesn't have a subject");
              }
              if (payload.hasOwnProperty('issuer')) {
                if (!payload.issuer.hasOwnProperty('publicKey')) {
                  throw new Error("Token doesn't have an issuer public key");
                }
              } else {
                throw new Error("Token doesn't have an issuer");
              }
              if (!payload.hasOwnProperty('claim')) {
                throw new Error("Token doesn't have a claim");
              }
              var issuerPublicKey = payload.issuer.publicKey;
              var publicKeyBuffer = new Buffer(issuerPublicKey, 'hex');
              var compressedKeyPair = _bitcoinjsLib.ECPair.fromPublicKey(
                publicKeyBuffer,
                { compressed: true }
              );
              var compressedAddress = (0, _utils.ecPairToAddress)(
                compressedKeyPair
              );
              var uncompressedKeyPair = _bitcoinjsLib.ECPair.fromPublicKey(
                publicKeyBuffer,
                { compressed: false }
              );
              var uncompressedAddress = (0, _utils.ecPairToAddress)(
                uncompressedKeyPair
              );
              if (publicKeyOrAddress === issuerPublicKey) {
              } else if (publicKeyOrAddress === compressedAddress) {
              } else if (publicKeyOrAddress === uncompressedAddress) {
              } else {
                throw new Error(
                  'Token issuer public key does not match the verifying value'
                );
              }
              var tokenVerifier = new _jsontokens.TokenVerifier(
                decodedToken.header.alg,
                issuerPublicKey
              );
              if (!tokenVerifier) {
                throw new Error('Invalid token verifier');
              }
              var tokenVerified = tokenVerifier.verify(token);
              if (!tokenVerified) {
                throw new Error('Token verification failed');
              }
              return decodedToken;
            }
            function extractProfile(token) {
              var publicKeyOrAddress =
                arguments.length > 1 && arguments[1] !== undefined
                  ? arguments[1]
                  : null;
              var decodedToken = void 0;
              if (publicKeyOrAddress) {
                decodedToken = verifyProfileToken(token, publicKeyOrAddress);
              } else {
                decodedToken = (0, _jsontokens.decodeToken)(token);
              }
              var profile = {};
              if (decodedToken.hasOwnProperty('payload')) {
                var payload = decodedToken.payload;
                if (payload.hasOwnProperty('claim')) {
                  profile = decodedToken.payload.claim;
                }
              }
              return profile;
            }
          }.call(this, require('buffer').Buffer));
        },
        { '../utils': 50, 'bitcoinjs-lib': 96, buffer: 183, jsontokens: 387 }
      ],
      38: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.makeProfileZoneFile = makeProfileZoneFile;
          exports.getTokenFileUrl = getTokenFileUrl;
          exports.resolveZoneFileToProfile = resolveZoneFileToProfile;
          var _zoneFile = require('zone-file');
          var _profileTokens = require('./profileTokens');
          var _index = require('./index');
          var _logger = require('../logger');
          function makeProfileZoneFile(origin, tokenFileUrl) {
            if (tokenFileUrl.indexOf('://') < 0) {
              throw new Error('Invalid token file url');
            }
            var urlScheme = tokenFileUrl.split('://')[0];
            var urlParts = tokenFileUrl.split('://')[1].split('/');
            var domain = urlParts[0];
            var pathname = '/' + urlParts.slice(1).join('/');
            var zoneFile = {
              $origin: origin,
              $ttl: 3600,
              uri: [
                {
                  name: '_http._tcp',
                  priority: 10,
                  weight: 1,
                  target: urlScheme + '://' + domain + pathname
                }
              ]
            };
            var zoneFileTemplate = '{$origin}\n{$ttl}\n{uri}\n';
            return (0, _zoneFile.makeZoneFile)(zoneFile, zoneFileTemplate);
          }
          function getTokenFileUrl(zoneFileJson) {
            if (!zoneFileJson.hasOwnProperty('uri')) {
              return null;
            }
            if (!Array.isArray(zoneFileJson.uri)) {
              return null;
            }
            if (zoneFileJson.uri.length < 1) {
              return null;
            }
            var firstUriRecord = zoneFileJson.uri[0];
            if (!firstUriRecord.hasOwnProperty('target')) {
              return null;
            }
            var tokenFileUrl = firstUriRecord.target;
            if (tokenFileUrl.startsWith('https')) {
            } else if (tokenFileUrl.startsWith('http')) {
            } else {
              tokenFileUrl = 'https://' + tokenFileUrl;
            }
            return tokenFileUrl;
          }
          function resolveZoneFileToProfile(zoneFile, publicKeyOrAddress) {
            return new Promise(function(resolve, reject) {
              var zoneFileJson = null;
              try {
                zoneFileJson = (0, _zoneFile.parseZoneFile)(zoneFile);
                if (!zoneFileJson.hasOwnProperty('$origin')) {
                  zoneFileJson = null;
                }
              } catch (e) {
                reject(e);
              }
              var tokenFileUrl = null;
              if (zoneFileJson && Object.keys(zoneFileJson).length > 0) {
                tokenFileUrl = getTokenFileUrl(zoneFileJson);
              } else {
                var profile = null;
                try {
                  profile = JSON.parse(zoneFile);
                  profile = _index.Person.fromLegacyFormat(profile).profile();
                } catch (error) {
                  reject(error);
                }
                resolve(profile);
                return;
              }
              if (tokenFileUrl) {
                fetch(tokenFileUrl)
                  .then(function(response) {
                    return response.text();
                  })
                  .then(function(responseText) {
                    return JSON.parse(responseText);
                  })
                  .then(function(responseJson) {
                    var tokenRecords = responseJson;
                    var profile = (0, _profileTokens.extractProfile)(
                      tokenRecords[0].token,
                      publicKeyOrAddress
                    );
                    resolve(profile);
                  })
                  .catch(function(error) {
                    _logger.Logger.error(
                      'resolveZoneFileToProfile: error fetching token file ' +
                        tokenFileUrl,
                      error
                    );
                    reject(error);
                  });
              } else {
                _logger.Logger.debug(
                  'Token file url not found. Resolving to blank profile.'
                );
                resolve({});
              }
            });
          }
        },
        {
          '../logger': 18,
          './index': 26,
          './profileTokens': 37,
          'zone-file': 569
        }
      ],
      39: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.Facebook = undefined;
          var _createClass = (function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          })();
          var _get = function get(object, property, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property);
            if (desc === undefined) {
              var parent = Object.getPrototypeOf(object);
              if (parent === null) {
                return undefined;
              } else {
                return get(parent, property, receiver);
              }
            } else if ('value' in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === undefined) {
                return undefined;
              }
              return getter.call(receiver);
            }
          };
          var _cheerio = require('cheerio');
          var _cheerio2 = _interopRequireDefault(_cheerio);
          var _service = require('./service');
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError(
                "this hasn't been initialised - super() hasn't been called"
              );
            }
            return call &&
              (typeof call === 'object' || typeof call === 'function')
              ? call
              : self;
          }
          function _inherits(subClass, superClass) {
            if (typeof superClass !== 'function' && superClass !== null) {
              throw new TypeError(
                'Super expression must either be null or a function, not ' +
                  typeof superClass
              );
            }
            subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              }
            );
            if (superClass)
              Object.setPrototypeOf
                ? Object.setPrototypeOf(subClass, superClass)
                : (subClass.__proto__ = superClass);
          }
          var Facebook = (function(_Service) {
            _inherits(Facebook, _Service);
            function Facebook() {
              _classCallCheck(this, Facebook);
              return _possibleConstructorReturn(
                this,
                (Facebook.__proto__ || Object.getPrototypeOf(Facebook)).apply(
                  this,
                  arguments
                )
              );
            }
            _createClass(Facebook, null, [
              {
                key: 'getProofUrl',
                value: function getProofUrl(proof) {
                  return this.normalizeFacebookUrl(proof);
                }
              },
              {
                key: 'normalizeFacebookUrl',
                value: function normalizeFacebookUrl(proof) {
                  var proofUrl = proof.proof_url.toLowerCase();
                  var urlRegex = /(?:http[s]*:\/\/){0,1}(?:[a-zA-Z0-9-]+\.)+facebook\.com/;
                  proofUrl = _get(
                    Facebook.__proto__ || Object.getPrototypeOf(Facebook),
                    'prefixScheme',
                    this
                  ).call(this, proofUrl);
                  if (proofUrl.startsWith('https://facebook.com')) {
                    var tokens = proofUrl.split('https://facebook.com');
                    proofUrl = 'https://www.facebook.com' + tokens[1];
                    tokens = proofUrl
                      .split('https://www.facebook.com/')[1]
                      .split('/posts/');
                    var postId = tokens[1];
                    proofUrl =
                      'https://www.facebook.com/' +
                      proof.identifier +
                      '/posts/' +
                      postId;
                  } else if (proofUrl.match(urlRegex)) {
                    var _tokens = proofUrl
                      .split('facebook.com/')[1]
                      .split('/posts/');
                    var _postId = _tokens[1];
                    proofUrl =
                      'https://www.facebook.com/' +
                      proof.identifier +
                      '/posts/' +
                      _postId;
                  } else {
                    throw new Error(
                      'Proof url ' +
                        proof.proof_url +
                        ' is not valid for service ' +
                        proof.service
                    );
                  }
                  return proofUrl;
                }
              },
              {
                key: 'getProofStatement',
                value: function getProofStatement(searchText) {
                  var $ = _cheerio2.default.load(searchText);
                  var statement = $('meta[name="description"]').attr('content');
                  return statement !== undefined ? statement.trim() : '';
                }
              }
            ]);
            return Facebook;
          })(_service.Service);
          exports.Facebook = Facebook;
        },
        { './service': 45, cheerio: 271 }
      ],
      40: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.Github = undefined;
          var _createClass = (function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          })();
          var _get = function get(object, property, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property);
            if (desc === undefined) {
              var parent = Object.getPrototypeOf(object);
              if (parent === null) {
                return undefined;
              } else {
                return get(parent, property, receiver);
              }
            } else if ('value' in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === undefined) {
                return undefined;
              }
              return getter.call(receiver);
            }
          };
          var _service = require('./service');
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError(
                "this hasn't been initialised - super() hasn't been called"
              );
            }
            return call &&
              (typeof call === 'object' || typeof call === 'function')
              ? call
              : self;
          }
          function _inherits(subClass, superClass) {
            if (typeof superClass !== 'function' && superClass !== null) {
              throw new TypeError(
                'Super expression must either be null or a function, not ' +
                  typeof superClass
              );
            }
            subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              }
            );
            if (superClass)
              Object.setPrototypeOf
                ? Object.setPrototypeOf(subClass, superClass)
                : (subClass.__proto__ = superClass);
          }
          var Github = (function(_Service) {
            _inherits(Github, _Service);
            function Github() {
              _classCallCheck(this, Github);
              return _possibleConstructorReturn(
                this,
                (Github.__proto__ || Object.getPrototypeOf(Github)).apply(
                  this,
                  arguments
                )
              );
            }
            _createClass(Github, null, [
              {
                key: 'getBaseUrls',
                value: function getBaseUrls() {
                  var baseUrls = [
                    'https://gist.github.com/',
                    'http://gist.github.com',
                    'gist.github.com'
                  ];
                  return baseUrls;
                }
              },
              {
                key: 'getProofUrl',
                value: function getProofUrl(proof) {
                  var baseUrls = this.getBaseUrls();
                  var proofUrl = proof.proof_url.toLowerCase();
                  proofUrl = _get(
                    Github.__proto__ || Object.getPrototypeOf(Github),
                    'prefixScheme',
                    this
                  ).call(this, proofUrl);
                  for (var i = 0; i < baseUrls.length; i++) {
                    var requiredPrefix = (
                      '' +
                      baseUrls[i] +
                      proof.identifier
                    ).toLowerCase();
                    if (proofUrl.startsWith(requiredPrefix)) {
                      var raw = proofUrl.endsWith('/') ? 'raw' : '/raw';
                      return '' + proofUrl + raw;
                    }
                  }
                  throw new Error(
                    'Proof url ' +
                      proof.proof_url +
                      ' is not valid for service ' +
                      proof.service
                  );
                }
              }
            ]);
            return Github;
          })(_service.Service);
          exports.Github = Github;
        },
        { './service': 45 }
      ],
      41: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.HackerNews = undefined;
          var _createClass = (function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          })();
          var _get = function get(object, property, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property);
            if (desc === undefined) {
              var parent = Object.getPrototypeOf(object);
              if (parent === null) {
                return undefined;
              } else {
                return get(parent, property, receiver);
              }
            } else if ('value' in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === undefined) {
                return undefined;
              }
              return getter.call(receiver);
            }
          };
          var _cheerio = require('cheerio');
          var _cheerio2 = _interopRequireDefault(_cheerio);
          var _service = require('./service');
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError(
                "this hasn't been initialised - super() hasn't been called"
              );
            }
            return call &&
              (typeof call === 'object' || typeof call === 'function')
              ? call
              : self;
          }
          function _inherits(subClass, superClass) {
            if (typeof superClass !== 'function' && superClass !== null) {
              throw new TypeError(
                'Super expression must either be null or a function, not ' +
                  typeof superClass
              );
            }
            subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              }
            );
            if (superClass)
              Object.setPrototypeOf
                ? Object.setPrototypeOf(subClass, superClass)
                : (subClass.__proto__ = superClass);
          }
          var HackerNews = (function(_Service) {
            _inherits(HackerNews, _Service);
            function HackerNews() {
              _classCallCheck(this, HackerNews);
              return _possibleConstructorReturn(
                this,
                (
                  HackerNews.__proto__ || Object.getPrototypeOf(HackerNews)
                ).apply(this, arguments)
              );
            }
            _createClass(HackerNews, null, [
              {
                key: 'getBaseUrls',
                value: function getBaseUrls() {
                  var baseUrls = [
                    'https://news.ycombinator.com/user?id=',
                    'http://news.ycombinator.com/user?id=',
                    'news.ycombinator.com/user?id='
                  ];
                  return baseUrls;
                }
              },
              {
                key: 'getProofUrl',
                value: function getProofUrl(proof) {
                  var baseUrls = this.getBaseUrls();
                  var proofUrl = _get(
                    HackerNews.__proto__ || Object.getPrototypeOf(HackerNews),
                    'prefixScheme',
                    this
                  ).call(this, proof.proof_url);
                  for (var i = 0; i < baseUrls.length; i++) {
                    if (proofUrl === '' + baseUrls[i] + proof.identifier) {
                      return proofUrl;
                    }
                  }
                  throw new Error(
                    'Proof url ' +
                      proof.proof_url +
                      ' is not valid for service ' +
                      proof.service
                  );
                }
              },
              {
                key: 'getProofStatement',
                value: function getProofStatement(searchText) {
                  var $ = _cheerio2.default.load(searchText);
                  var tables = $('#hnmain')
                    .children()
                    .find('table');
                  var statement = '';
                  if (tables.length > 0) {
                    tables.each(function(tableIndex, table) {
                      var rows = $(table).find('tr');
                      if (rows.length > 0) {
                        rows.each(function(idx, row) {
                          var heading = $(row)
                            .find('td')
                            .first()
                            .text()
                            .trim();
                          if (heading === 'about:') {
                            statement = $(row)
                              .find('td')
                              .last()
                              .text()
                              .trim();
                          }
                        });
                      }
                    });
                  }
                  return statement;
                }
              }
            ]);
            return HackerNews;
          })(_service.Service);
          exports.HackerNews = HackerNews;
        },
        { './service': 45, cheerio: 271 }
      ],
      42: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.containsValidAddressProofStatement = exports.containsValidProofStatement = exports.profileServices = undefined;
          var _serviceUtils = require('./serviceUtils');
          Object.defineProperty(exports, 'containsValidProofStatement', {
            enumerable: true,
            get: function get() {
              return _serviceUtils.containsValidProofStatement;
            }
          });
          Object.defineProperty(exports, 'containsValidAddressProofStatement', {
            enumerable: true,
            get: function get() {
              return _serviceUtils.containsValidAddressProofStatement;
            }
          });
          var _facebook = require('./facebook');
          var _github = require('./github');
          var _twitter = require('./twitter');
          var _instagram = require('./instagram');
          var _hackerNews = require('./hackerNews');
          var _linkedIn = require('./linkedIn');
          var profileServices = (exports.profileServices = {
            facebook: _facebook.Facebook,
            github: _github.Github,
            twitter: _twitter.Twitter,
            instagram: _instagram.Instagram,
            hackerNews: _hackerNews.HackerNews,
            linkedIn: _linkedIn.LinkedIn
          });
        },
        {
          './facebook': 39,
          './github': 40,
          './hackerNews': 41,
          './instagram': 43,
          './linkedIn': 44,
          './serviceUtils': 46,
          './twitter': 47
        }
      ],
      43: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.Instagram = undefined;
          var _createClass = (function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          })();
          var _get = function get(object, property, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property);
            if (desc === undefined) {
              var parent = Object.getPrototypeOf(object);
              if (parent === null) {
                return undefined;
              } else {
                return get(parent, property, receiver);
              }
            } else if ('value' in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === undefined) {
                return undefined;
              }
              return getter.call(receiver);
            }
          };
          var _cheerio = require('cheerio');
          var _cheerio2 = _interopRequireDefault(_cheerio);
          var _service = require('./service');
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError(
                "this hasn't been initialised - super() hasn't been called"
              );
            }
            return call &&
              (typeof call === 'object' || typeof call === 'function')
              ? call
              : self;
          }
          function _inherits(subClass, superClass) {
            if (typeof superClass !== 'function' && superClass !== null) {
              throw new TypeError(
                'Super expression must either be null or a function, not ' +
                  typeof superClass
              );
            }
            subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              }
            );
            if (superClass)
              Object.setPrototypeOf
                ? Object.setPrototypeOf(subClass, superClass)
                : (subClass.__proto__ = superClass);
          }
          var Instagram = (function(_Service) {
            _inherits(Instagram, _Service);
            function Instagram() {
              _classCallCheck(this, Instagram);
              return _possibleConstructorReturn(
                this,
                (Instagram.__proto__ || Object.getPrototypeOf(Instagram)).apply(
                  this,
                  arguments
                )
              );
            }
            _createClass(Instagram, null, [
              {
                key: 'getBaseUrls',
                value: function getBaseUrls() {
                  var baseUrls = [
                    'https://www.instagram.com/',
                    'https://instagram.com/'
                  ];
                  return baseUrls;
                }
              },
              {
                key: 'getProofUrl',
                value: function getProofUrl(proof) {
                  var baseUrls = this.getBaseUrls();
                  var normalizedProofUrl = this.normalizeInstagramUrl(proof);
                  for (var i = 0; i < baseUrls.length; i++) {
                    if (normalizedProofUrl.startsWith('' + baseUrls[i])) {
                      return normalizedProofUrl;
                    }
                  }
                  throw new Error(
                    'Proof url ' +
                      proof.proof_url +
                      ' is not valid for service ' +
                      proof.service
                  );
                }
              },
              {
                key: 'normalizeInstagramUrl',
                value: function normalizeInstagramUrl(proof) {
                  var proofUrl = proof.proof_url;
                  proofUrl = _get(
                    Instagram.__proto__ || Object.getPrototypeOf(Instagram),
                    'prefixScheme',
                    this
                  ).call(this, proofUrl);
                  if (proofUrl.startsWith('https://instagram.com')) {
                    var tokens = proofUrl.split('https://instagram.com');
                    proofUrl = 'https://www.instagram.com' + tokens[1];
                  }
                  return proofUrl;
                }
              },
              {
                key: 'shouldValidateIdentityInBody',
                value: function shouldValidateIdentityInBody() {
                  return true;
                }
              },
              {
                key: 'getProofIdentity',
                value: function getProofIdentity(searchText) {
                  var $ = _cheerio2.default.load(searchText);
                  var username = $('meta[property="og:description"]').attr(
                    'content'
                  );
                  if (
                    username !== undefined &&
                    username.split(':').length > 1
                  ) {
                    return username
                      .split(':')[0]
                      .match(/(@\w+)/)[0]
                      .substr(1);
                  } else {
                    return '';
                  }
                }
              },
              {
                key: 'getProofStatement',
                value: function getProofStatement(searchText) {
                  var $ = _cheerio2.default.load(searchText);
                  var statement = $('meta[property="og:description"]').attr(
                    'content'
                  );
                  if (
                    statement !== undefined &&
                    statement.split(':').length > 1
                  ) {
                    return statement
                      .split(':')[1]
                      .trim()
                      .replace('“', '')
                      .replace('”', '');
                  } else {
                    return '';
                  }
                }
              }
            ]);
            return Instagram;
          })(_service.Service);
          exports.Instagram = Instagram;
        },
        { './service': 45, cheerio: 271 }
      ],
      44: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.LinkedIn = undefined;
          var _createClass = (function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          })();
          var _get = function get(object, property, receiver) {
            if (object === null) object = Function.prototype;
            var desc = Object.getOwnPropertyDescriptor(object, property);
            if (desc === undefined) {
              var parent = Object.getPrototypeOf(object);
              if (parent === null) {
                return undefined;
              } else {
                return get(parent, property, receiver);
              }
            } else if ('value' in desc) {
              return desc.value;
            } else {
              var getter = desc.get;
              if (getter === undefined) {
                return undefined;
              }
              return getter.call(receiver);
            }
          };
          var _cheerio = require('cheerio');
          var _cheerio2 = _interopRequireDefault(_cheerio);
          var _service = require('./service');
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError(
                "this hasn't been initialised - super() hasn't been called"
              );
            }
            return call &&
              (typeof call === 'object' || typeof call === 'function')
              ? call
              : self;
          }
          function _inherits(subClass, superClass) {
            if (typeof superClass !== 'function' && superClass !== null) {
              throw new TypeError(
                'Super expression must either be null or a function, not ' +
                  typeof superClass
              );
            }
            subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              }
            );
            if (superClass)
              Object.setPrototypeOf
                ? Object.setPrototypeOf(subClass, superClass)
                : (subClass.__proto__ = superClass);
          }
          var LinkedIn = (function(_Service) {
            _inherits(LinkedIn, _Service);
            function LinkedIn() {
              _classCallCheck(this, LinkedIn);
              return _possibleConstructorReturn(
                this,
                (LinkedIn.__proto__ || Object.getPrototypeOf(LinkedIn)).apply(
                  this,
                  arguments
                )
              );
            }
            _createClass(LinkedIn, null, [
              {
                key: 'getBaseUrls',
                value: function getBaseUrls() {
                  var baseUrls = [
                    'https://www.linkedin.com/feed/update/',
                    'http://www.linkedin.com/feed/update/',
                    'www.linkedin.com/feed/update/'
                  ];
                  return baseUrls;
                }
              },
              {
                key: 'getProofUrl',
                value: function getProofUrl(proof) {
                  var baseUrls = this.getBaseUrls();
                  var proofUrl = proof.proof_url.toLowerCase();
                  proofUrl = _get(
                    LinkedIn.__proto__ || Object.getPrototypeOf(LinkedIn),
                    'prefixScheme',
                    this
                  ).call(this, proofUrl);
                  for (var i = 0; i < baseUrls.length; i++) {
                    if (proofUrl.startsWith('' + baseUrls[i])) {
                      return proofUrl;
                    }
                  }
                  throw new Error(
                    'Proof url ' +
                      proof.proof_url +
                      ' is not valid for service ' +
                      proof.service
                  );
                }
              },
              {
                key: 'shouldValidateIdentityInBody',
                value: function shouldValidateIdentityInBody() {
                  return true;
                }
              },
              {
                key: 'getProofIdentity',
                value: function getProofIdentity(searchText) {
                  var $ = _cheerio2.default.load(searchText);
                  var profileLink = $('article').find(
                    '.post-meta__profile-link'
                  );
                  if (profileLink !== undefined) {
                    if (profileLink.attr('href') === undefined) {
                      return '';
                    }
                    return profileLink
                      .attr('href')
                      .split('/')
                      .pop();
                  } else {
                    return '';
                  }
                }
              },
              {
                key: 'getProofStatement',
                value: function getProofStatement(searchText) {
                  var $ = _cheerio2.default.load(searchText);
                  var postContent = $('article').find('.commentary');
                  var statement = '';
                  if (postContent !== undefined) {
                    statement = postContent.text();
                  }
                  return statement;
                }
              }
            ]);
            return LinkedIn;
          })(_service.Service);
          exports.LinkedIn = LinkedIn;
        },
        { './service': 45, cheerio: 271 }
      ],
      45: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.Service = undefined;
          var _createClass = (function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          })();
          require('cross-fetch/polyfill');
          var _serviceUtils = require('./serviceUtils');
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          var Service = (exports.Service = (function() {
            function Service() {
              _classCallCheck(this, Service);
            }
            _createClass(Service, null, [
              {
                key: 'validateProof',
                value: function validateProof(proof, ownerAddress) {
                  var _this = this;
                  var name =
                    arguments.length > 2 && arguments[2] !== undefined
                      ? arguments[2]
                      : null;
                  var proofUrl = void 0;
                  return Promise.resolve()
                    .then(function() {
                      proofUrl = _this.getProofUrl(proof);
                      return fetch(proofUrl);
                    })
                    .then(function(res) {
                      if (res.status !== 200) {
                        throw new Error(
                          'Proof url ' +
                            proofUrl +
                            ' returned unexpected http status ' +
                            res.status +
                            '.\n              Unable to validate proof.'
                        );
                      }
                      return res.text();
                    })
                    .then(function(text) {
                      if (
                        _this.shouldValidateIdentityInBody() &&
                        proof.identifier !== _this.getProofIdentity(text)
                      ) {
                        return proof;
                      }
                      var proofText = _this.getProofStatement(text);
                      proof.valid =
                        (0, _serviceUtils.containsValidProofStatement)(
                          proofText,
                          name
                        ) ||
                        (0, _serviceUtils.containsValidAddressProofStatement)(
                          proofText,
                          ownerAddress
                        );
                      return proof;
                    })
                    .catch(function(error) {
                      console.error(error);
                      proof.valid = false;
                      return proof;
                    });
                }
              },
              {
                key: 'getBaseUrls',
                value: function getBaseUrls() {
                  return [];
                }
              },
              {
                key: 'getProofIdentity',
                value: function getProofIdentity(searchText) {
                  return searchText;
                }
              },
              {
                key: 'getProofStatement',
                value: function getProofStatement(searchText) {
                  return searchText;
                }
              },
              {
                key: 'shouldValidateIdentityInBody',
                value: function shouldValidateIdentityInBody() {
                  return false;
                }
              },
              {
                key: 'prefixScheme',
                value: function prefixScheme(proofUrl) {
                  if (
                    !proofUrl.startsWith('https://') &&
                    !proofUrl.startsWith('http://')
                  ) {
                    return 'https://' + proofUrl;
                  } else if (proofUrl.startsWith('http://')) {
                    return proofUrl.replace('http://', 'https://');
                  } else {
                    return proofUrl;
                  }
                }
              },
              {
                key: 'getProofUrl',
                value: function getProofUrl(proof) {
                  var baseUrls = this.getBaseUrls();
                  var proofUrl = proof.proof_url.toLowerCase();
                  proofUrl = this.prefixScheme(proofUrl);
                  for (var i = 0; i < baseUrls.length; i++) {
                    var requiredPrefix = (
                      '' +
                      baseUrls[i] +
                      proof.identifier
                    ).toLowerCase();
                    if (proofUrl.startsWith(requiredPrefix)) {
                      return proofUrl;
                    }
                  }
                  throw new Error(
                    'Proof url ' +
                      proof.proof_url +
                      ' is not valid for service ' +
                      proof.service
                  );
                }
              }
            ]);
            return Service;
          })());
        },
        { './serviceUtils': 46, 'cross-fetch/polyfill': 287 }
      ],
      46: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.containsValidProofStatement = containsValidProofStatement;
          exports.containsValidAddressProofStatement = containsValidAddressProofStatement;
          function containsValidProofStatement(searchText) {
            var name =
              arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : null;
            if (!name) {
              return false;
            }
            searchText = searchText.toLowerCase();
            if (name.split('.').length < 2) {
              throw new Error(
                'Please provide the fully qualified Blockstack name.'
              );
            }
            var username = null;
            if (name.endsWith('.id')) {
              username = name.split('.id')[0];
            }
            var verificationStyles =
              username != null
                ? [
                    'verifying myself: my bitcoin username is +' + username,
                    'verifying myself: my bitcoin username is ' + username,
                    'verifying myself: my openname is ' + username,
                    'verifying that +' + username + ' is my bitcoin username',
                    'verifying that ' + username + ' is my bitcoin username',
                    'verifying that ' + username + ' is my openname',
                    'verifying that +' + username + ' is my openname',
                    'verifying i am +' + username + ' on my passcard',
                    'verifying that +' + username + ' is my blockchain id',
                    'verifying that "' + name + '" is my blockstack id',
                    'verifying that ' + name + ' is my blockstack id',
                    'verifying that &quot;' +
                      name +
                      '&quot; is my blockstack id'
                  ]
                : [
                    'verifying that "' + name + '" is my blockstack id',
                    'verifying that ' + name + ' is my blockstack id',
                    'verifying that &quot;' +
                      name +
                      '&quot; is my blockstack id'
                  ];
            for (var i = 0; i < verificationStyles.length; i++) {
              var verificationStyle = verificationStyles[i];
              if (searchText.includes(verificationStyle)) {
                return true;
              }
            }
            if (
              username != null &&
              searchText.includes('verifymyonename') &&
              searchText.includes('+' + username)
            ) {
              return true;
            }
            return false;
          }
          function containsValidAddressProofStatement(proofStatement, address) {
            proofStatement =
              proofStatement.split(address)[0].toLowerCase() + address;
            var verificationStyles = [
              'verifying my blockstack id is secured with the address ' +
                address
            ];
            for (var i = 0; i < verificationStyles.length; i++) {
              var verificationStyle = verificationStyles[i];
              if (proofStatement.includes(verificationStyle)) {
                return true;
              }
            }
            return false;
          }
        },
        {}
      ],
      47: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.Twitter = undefined;
          var _createClass = (function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          })();
          var _cheerio = require('cheerio');
          var _cheerio2 = _interopRequireDefault(_cheerio);
          var _service = require('./service');
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError(
                "this hasn't been initialised - super() hasn't been called"
              );
            }
            return call &&
              (typeof call === 'object' || typeof call === 'function')
              ? call
              : self;
          }
          function _inherits(subClass, superClass) {
            if (typeof superClass !== 'function' && superClass !== null) {
              throw new TypeError(
                'Super expression must either be null or a function, not ' +
                  typeof superClass
              );
            }
            subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              }
            );
            if (superClass)
              Object.setPrototypeOf
                ? Object.setPrototypeOf(subClass, superClass)
                : (subClass.__proto__ = superClass);
          }
          var Twitter = (function(_Service) {
            _inherits(Twitter, _Service);
            function Twitter() {
              _classCallCheck(this, Twitter);
              return _possibleConstructorReturn(
                this,
                (Twitter.__proto__ || Object.getPrototypeOf(Twitter)).apply(
                  this,
                  arguments
                )
              );
            }
            _createClass(Twitter, null, [
              {
                key: 'getBaseUrls',
                value: function getBaseUrls() {
                  var baseUrls = [
                    'https://twitter.com/',
                    'http://twitter.com/',
                    'twitter.com/'
                  ];
                  return baseUrls;
                }
              },
              {
                key: 'getProofStatement',
                value: function getProofStatement(searchText) {
                  var $ = _cheerio2.default.load(searchText);
                  var statement = $('meta[property="og:description"]').attr(
                    'content'
                  );
                  if (statement !== undefined) {
                    return statement
                      .trim()
                      .replace('“', '')
                      .replace('”', '');
                  } else {
                    return '';
                  }
                }
              }
            ]);
            return Twitter;
          })(_service.Service);
          exports.Twitter = Twitter;
        },
        { './service': 45, cheerio: 271 }
      ],
      48: [
        function(require, module, exports) {
          (function(Buffer) {
            'use strict';
            Object.defineProperty(exports, '__esModule', { value: true });
            exports.BLOCKSTACK_GAIA_HUB_LABEL = undefined;
            exports.uploadToGaiaHub = uploadToGaiaHub;
            exports.getFullReadUrl = getFullReadUrl;
            exports.connectToGaiaHub = connectToGaiaHub;
            exports.setLocalGaiaHubConnection = setLocalGaiaHubConnection;
            exports.getOrSetLocalGaiaHubConnection = getOrSetLocalGaiaHubConnection;
            exports.getBucketUrl = getBucketUrl;
            var _bitcoinjsLib = require('bitcoinjs-lib');
            var _bitcoinjsLib2 = _interopRequireDefault(_bitcoinjsLib);
            var _crypto = require('crypto');
            var _crypto2 = _interopRequireDefault(_crypto);
            var _jsontokens = require('jsontokens');
            var _utils = require('../utils');
            var _index = require('../index');
            var _authConstants = require('../auth/authConstants');
            var _logger = require('../logger');
            var _errors = require('../errors');
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            var BLOCKSTACK_GAIA_HUB_LABEL = (exports.BLOCKSTACK_GAIA_HUB_LABEL =
              'blockstack-gaia-hub-config');
            function uploadToGaiaHub(filename, contents, hubConfig) {
              var contentType =
                arguments.length > 3 && arguments[3] !== undefined
                  ? arguments[3]
                  : 'application/octet-stream';
              _logger.Logger.debug(
                'uploadToGaiaHub: uploading ' +
                  filename +
                  ' to ' +
                  hubConfig.server
              );
              return fetch(
                hubConfig.server +
                  '/store/' +
                  hubConfig.address +
                  '/' +
                  filename,
                {
                  method: 'POST',
                  headers: {
                    'Content-Type': contentType,
                    Authorization: 'bearer ' + hubConfig.token
                  },
                  body: contents
                }
              )
                .then(function(response) {
                  if (response.ok) {
                    return response.text();
                  } else {
                    throw new Error('Error when uploading to Gaia hub');
                  }
                })
                .then(function(responseText) {
                  return JSON.parse(responseText);
                })
                .then(function(responseJSON) {
                  return responseJSON.publicURL;
                });
            }
            function getFullReadUrl(filename, hubConfig) {
              return (
                '' + hubConfig.url_prefix + hubConfig.address + '/' + filename
              );
            }
            function makeLegacyAuthToken(challengeText, signerKeyHex) {
              var parsedChallenge = void 0;
              try {
                parsedChallenge = JSON.parse(challengeText);
              } catch (err) {
                throw new Error(
                  'Failed in parsing legacy challenge text from the gaia hub.'
                );
              }
              if (
                parsedChallenge[0] === 'gaiahub' &&
                parsedChallenge[3] === 'blockstack_storage_please_sign'
              ) {
                var signer = (0, _index.hexStringToECPair)(
                  signerKeyHex + (signerKeyHex.length === 64 ? '01' : '')
                );
                var digest = _bitcoinjsLib2.default.crypto.sha256(
                  challengeText
                );
                var signature = signer
                  .sign(digest)
                  .toDER()
                  .toString('hex');
                var publickey = (0, _index.getPublicKeyFromPrivate)(
                  signerKeyHex
                );
                var _token = Buffer.from(
                  JSON.stringify({ publickey: publickey, signature: signature })
                ).toString('base64');
                return _token;
              } else {
                throw new Error(
                  'Failed to connect to legacy gaia hub. If you operate this hub, please update.'
                );
              }
            }
            function makeV1GaiaAuthToken(
              hubInfo,
              signerKeyHex,
              hubUrl,
              associationToken
            ) {
              var challengeText = hubInfo.challenge_text;
              var handlesV1Auth =
                hubInfo.latest_auth_version &&
                parseInt(hubInfo.latest_auth_version.slice(1), 10) >= 1;
              var iss = (0, _index.getPublicKeyFromPrivate)(signerKeyHex);
              if (!handlesV1Auth) {
                return makeLegacyAuthToken(challengeText, signerKeyHex);
              }
              var salt = _crypto2.default.randomBytes(16).toString('hex');
              var payload = {
                gaiaChallenge: challengeText,
                hubUrl: hubUrl,
                iss: iss,
                salt: salt,
                associationToken: associationToken
              };
              var token = new _jsontokens.TokenSigner(
                'ES256K',
                signerKeyHex
              ).sign(payload);
              return 'v1:' + token;
            }
            function connectToGaiaHub(
              gaiaHubUrl,
              challengeSignerHex,
              associationToken
            ) {
              _logger.Logger.debug(
                'connectToGaiaHub: ' + gaiaHubUrl + '/hub_info'
              );
              return fetch(gaiaHubUrl + '/hub_info')
                .then(function(response) {
                  return response.json();
                })
                .then(function(hubInfo) {
                  var readURL = hubInfo.read_url_prefix;
                  var token = makeV1GaiaAuthToken(
                    hubInfo,
                    challengeSignerHex,
                    gaiaHubUrl,
                    associationToken
                  );
                  var address = (0, _utils.ecPairToAddress)(
                    (0, _index.hexStringToECPair)(
                      challengeSignerHex +
                        (challengeSignerHex.length === 64 ? '01' : '')
                    )
                  );
                  return {
                    url_prefix: readURL,
                    address: address,
                    token: token,
                    server: gaiaHubUrl
                  };
                });
            }
            function setLocalGaiaHubConnection(caller) {
              var userData = caller.loadUserData();
              if (!userData) {
                throw new _errors.InvalidStateError('Missing userData');
              }
              if (!userData.hubUrl) {
                userData.hubUrl =
                  _authConstants.BLOCKSTACK_DEFAULT_GAIA_HUB_URL;
              }
              return connectToGaiaHub(
                userData.hubUrl,
                userData.appPrivateKey,
                userData.associationToken
              ).then(function(gaiaConfig) {
                userData.gaiaHubConfig = gaiaConfig;
                return gaiaConfig;
              });
            }
            function getOrSetLocalGaiaHubConnection(caller) {
              var userData = caller.store.getSessionData().userData;
              if (!userData) {
                throw new _errors.InvalidStateError('Missing userData');
              }
              var hubConfig = userData.gaiaHubConfig;
              if (hubConfig) {
                return Promise.resolve(hubConfig);
              }
              return setLocalGaiaHubConnection(caller);
            }
            function getBucketUrl(gaiaHubUrl, appPrivateKey) {
              var challengeSigner = void 0;
              try {
                challengeSigner = _bitcoinjsLib2.default.ECPair.fromPrivateKey(
                  new Buffer(appPrivateKey, 'hex')
                );
              } catch (e) {
                return Promise.reject(e);
              }
              return fetch(gaiaHubUrl + '/hub_info')
                .then(function(response) {
                  return response.text();
                })
                .then(function(responseText) {
                  return JSON.parse(responseText);
                })
                .then(function(responseJSON) {
                  var readURL = responseJSON.read_url_prefix;
                  var address = (0, _utils.ecPairToAddress)(challengeSigner);
                  var bucketUrl = '' + readURL + address + '/';
                  return bucketUrl;
                });
            }
          }.call(this, require('buffer').Buffer));
        },
        {
          '../auth/authConstants': 3,
          '../errors': 15,
          '../index': 16,
          '../logger': 18,
          '../utils': 50,
          'bitcoinjs-lib': 96,
          buffer: 183,
          crypto: 192,
          jsontokens: 387
        }
      ],
      49: [
        function(require, module, exports) {
          (function(Buffer) {
            'use strict';
            Object.defineProperty(exports, '__esModule', { value: true });
            exports.BLOCKSTACK_GAIA_HUB_LABEL = exports.uploadToGaiaHub = exports.connectToGaiaHub = undefined;
            var _slicedToArray = (function() {
              function sliceIterator(arr, i) {
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = undefined;
                try {
                  for (
                    var _i = arr[Symbol.iterator](), _s;
                    !(_n = (_s = _i.next()).done);
                    _n = true
                  ) {
                    _arr.push(_s.value);
                    if (i && _arr.length === i) break;
                  }
                } catch (err) {
                  _d = true;
                  _e = err;
                } finally {
                  try {
                    if (!_n && _i['return']) _i['return']();
                  } finally {
                    if (_d) throw _e;
                  }
                }
                return _arr;
              }
              return function(arr, i) {
                if (Array.isArray(arr)) {
                  return arr;
                } else if (Symbol.iterator in Object(arr)) {
                  return sliceIterator(arr, i);
                } else {
                  throw new TypeError(
                    'Invalid attempt to destructure non-iterable instance'
                  );
                }
              };
            })();
            exports.encryptContent = encryptContent;
            exports.decryptContent = decryptContent;
            exports.getFile = getFile;
            exports.putFile = putFile;
            exports.listFiles = listFiles;
            exports.deleteFile = deleteFile;
            exports.getUserAppFileUrl = getUserAppFileUrl;
            exports.encryptContentImpl = encryptContentImpl;
            exports.decryptContentImpl = decryptContentImpl;
            exports.getFileImpl = getFileImpl;
            exports.putFileImpl = putFileImpl;
            exports.getAppBucketUrl = getAppBucketUrl;
            exports.listFilesImpl = listFilesImpl;
            var _hub = require('./hub');
            var _encryption = require('../encryption');
            var _keys = require('../keys');
            var _profiles = require('../profiles');
            var _errors = require('../errors');
            var _logger = require('../logger');
            var SIGNATURE_FILE_SUFFIX = '.sig';
            function encryptContent(content, options) {
              console.warn(
                'DEPRECATION WARNING: The static encryptContent() function will be deprecated in ' +
                  'the next major release of blockstack.js. Create an instance of UserSession and call the ' +
                  'instance method encryptContent().'
              );
              var userSession = new this.UserSession();
              return userSession.encryptContent(content, options);
            }
            function decryptContent(content, options) {
              console.warn(
                'DEPRECATION WARNING: The static decryptContent() function will be deprecated in ' +
                  'the next major release of blockstack.js. Create an instance of UserSession and call the ' +
                  'instance method decryptContent().'
              );
              var userSession = new this.UserSession();
              return userSession.decryptContent(content, options);
            }
            function getFile(path, options) {
              console.warn(
                'DEPRECATION WARNING: The static getFile() function will be deprecated in ' +
                  'the next major release of blockstack.js. Create an instance of UserSession and call the ' +
                  'instance method getFile().'
              );
              var userSession = new this.UserSession();
              return userSession.getFile(path, options);
            }
            function putFile(path, content, options) {
              console.warn(
                'DEPRECATION WARNING: The static putFile() function will be deprecated in ' +
                  'the next major release of blockstack.js. Create an instance of UserSession and call the ' +
                  'instance method putFile().'
              );
              var userSession = new this.UserSession();
              return userSession.putFile(path, content, options);
            }
            function listFiles(callback) {
              console.warn(
                'DEPRECATION WARNING: The static listFiles() function will be deprecated in ' +
                  'the next major release of blockstack.js. Create an instance of UserSession and call the ' +
                  'instance method listFiles().'
              );
              var userSession = new this.UserSession();
              return userSession.listFiles(callback);
            }
            function deleteFile(path) {
              Promise.reject(
                new Error('Delete of ' + path + ' not supported by gaia hubs')
              );
            }
            function getUserAppFileUrl(path, username, appOrigin) {
              var zoneFileLookupURL =
                arguments.length > 3 && arguments[3] !== undefined
                  ? arguments[3]
                  : null;
              return (0, _profiles.lookupProfile)(username, zoneFileLookupURL)
                .then(function(profile) {
                  if (profile.hasOwnProperty('apps')) {
                    if (profile.apps.hasOwnProperty(appOrigin)) {
                      return profile.apps[appOrigin];
                    } else {
                      return null;
                    }
                  } else {
                    return null;
                  }
                })
                .then(function(bucketUrl) {
                  if (bucketUrl) {
                    var bucket = bucketUrl.replace(/\/?(\?|#|$)/, '/$1');
                    return '' + bucket + path;
                  } else {
                    return null;
                  }
                });
            }
            function encryptContentImpl(caller, content, options) {
              var defaults = { publicKey: null };
              var opt = Object.assign({}, defaults, options);
              if (!opt.publicKey) {
                var userData = caller.loadUserData();
                var _privateKey = userData.appPrivateKey;
                opt.publicKey = (0, _keys.getPublicKeyFromPrivate)(_privateKey);
              }
              var cipherObject = (0, _encryption.encryptECIES)(
                opt.publicKey,
                content
              );
              return JSON.stringify(cipherObject);
            }
            function decryptContentImpl(caller, content, options) {
              var defaults = { privateKey: null };
              var opt = Object.assign({}, defaults, options);
              var privateKey = opt.privateKey;
              if (!privateKey) {
                privateKey = caller.loadUserData().appPrivateKey;
              }
              try {
                var cipherObject = JSON.parse(content);
                return (0, _encryption.decryptECIES)(privateKey, cipherObject);
              } catch (err) {
                if (err instanceof SyntaxError) {
                  throw new Error(
                    'Failed to parse encrypted content JSON. The content may not ' +
                      'be encrypted. If using getFile, try passing { decrypt: false }.'
                  );
                } else {
                  throw err;
                }
              }
            }
            function getGaiaAddress(caller, app, username, zoneFileLookupURL) {
              return Promise.resolve()
                .then(function() {
                  if (username) {
                    return getUserAppFileUrl(
                      '/',
                      username,
                      app,
                      zoneFileLookupURL
                    );
                  } else {
                    return (0, _hub.getOrSetLocalGaiaHubConnection)(
                      caller
                    ).then(function(gaiaHubConfig) {
                      return (0, _hub.getFullReadUrl)('/', gaiaHubConfig);
                    });
                  }
                })
                .then(function(fileUrl) {
                  var matches = fileUrl.match(
                    /([13][a-km-zA-HJ-NP-Z0-9]{26,35})/
                  );
                  if (!matches) {
                    throw new Error('Failed to parse gaia address');
                  }
                  return matches[matches.length - 1];
                });
            }
            function getFileContents(
              caller,
              path,
              app,
              username,
              zoneFileLookupURL,
              forceText
            ) {
              return Promise.resolve()
                .then(function() {
                  if (username) {
                    return getUserAppFileUrl(
                      path,
                      username,
                      app,
                      zoneFileLookupURL
                    );
                  } else {
                    return (0, _hub.getOrSetLocalGaiaHubConnection)(
                      caller
                    ).then(function(gaiaHubConfig) {
                      return (0, _hub.getFullReadUrl)(path, gaiaHubConfig);
                    });
                  }
                })
                .then(function(readUrl) {
                  return new Promise(function(resolve, reject) {
                    if (!readUrl) {
                      reject(null);
                    } else {
                      resolve(readUrl);
                    }
                  });
                })
                .then(function(readUrl) {
                  return fetch(readUrl);
                })
                .then(function(response) {
                  if (response.status !== 200) {
                    if (response.status === 404) {
                      _logger.Logger.debug(
                        'getFile ' + path + ' returned 404, returning null'
                      );
                      return null;
                    } else {
                      throw new Error(
                        'getFile ' +
                          path +
                          ' failed with HTTP status ' +
                          response.status
                      );
                    }
                  }
                  var contentType = response.headers.get('Content-Type');
                  if (
                    forceText ||
                    contentType === null ||
                    contentType.startsWith('text') ||
                    contentType === 'application/json'
                  ) {
                    return response.text();
                  } else {
                    return response.arrayBuffer();
                  }
                });
            }
            function getFileSignedUnencrypted(caller, path, opt) {
              return Promise.all([
                getFileContents(
                  caller,
                  path,
                  opt.app,
                  opt.username,
                  opt.zoneFileLookupURL,
                  false
                ),
                getFileContents(
                  caller,
                  '' + path + SIGNATURE_FILE_SUFFIX,
                  opt.app,
                  opt.username,
                  opt.zoneFileLookupURL,
                  true
                ),
                getGaiaAddress(
                  caller,
                  opt.app,
                  opt.username,
                  opt.zoneFileLookupURL
                )
              ]).then(function(_ref) {
                var _ref2 = _slicedToArray(_ref, 3),
                  fileContents = _ref2[0],
                  signatureContents = _ref2[1],
                  gaiaAddress = _ref2[2];
                if (!fileContents) {
                  return fileContents;
                }
                if (!gaiaAddress) {
                  throw new _errors.SignatureVerificationError(
                    'Failed to get gaia address for verification of: ' +
                      ('' + path)
                  );
                }
                if (
                  !signatureContents ||
                  typeof signatureContents !== 'string'
                ) {
                  throw new _errors.SignatureVerificationError(
                    'Failed to obtain signature for file: ' +
                      (path + ' -- looked in ' + path + SIGNATURE_FILE_SUFFIX)
                  );
                }
                var signature = void 0;
                var publicKey = void 0;
                try {
                  var sigObject = JSON.parse(signatureContents);
                  signature = sigObject.signature;
                  publicKey = sigObject.publicKey;
                } catch (err) {
                  if (err instanceof SyntaxError) {
                    throw new Error(
                      'Failed to parse signature content JSON ' +
                        ('(path: ' + path + SIGNATURE_FILE_SUFFIX + ')') +
                        ' The content may be corrupted.'
                    );
                  } else {
                    throw err;
                  }
                }
                var signerAddress = (0, _keys.publicKeyToAddress)(publicKey);
                if (gaiaAddress !== signerAddress) {
                  throw new _errors.SignatureVerificationError(
                    'Signer pubkey address (' +
                      signerAddress +
                      ") doesn't" +
                      (' match gaia address (' + gaiaAddress + ')')
                  );
                } else if (
                  !(0, _encryption.verifyECDSA)(
                    Buffer.from(fileContents),
                    publicKey,
                    signature
                  )
                ) {
                  throw new _errors.SignatureVerificationError(
                    'Contents do not match ECDSA signature: ' +
                      ('path: ' +
                        path +
                        ', signature: ' +
                        path +
                        SIGNATURE_FILE_SUFFIX)
                  );
                } else {
                  return fileContents;
                }
              });
            }
            function handleSignedEncryptedContents(
              caller,
              path,
              storedContents,
              app,
              username,
              zoneFileLookupURL
            ) {
              var appPrivateKey = caller.loadUserData().appPrivateKey;
              var appPublicKey = (0, _keys.getPublicKeyFromPrivate)(
                appPrivateKey
              );
              var addressPromise = void 0;
              if (username) {
                addressPromise = getGaiaAddress(
                  caller,
                  app,
                  username,
                  zoneFileLookupURL
                );
              } else {
                var address = (0, _keys.publicKeyToAddress)(appPublicKey);
                addressPromise = Promise.resolve(address);
              }
              return addressPromise.then(function(address) {
                if (!address) {
                  throw new _errors.SignatureVerificationError(
                    'Failed to get gaia address for verification of: ' +
                      ('' + path)
                  );
                }
                var sigObject = void 0;
                try {
                  sigObject = JSON.parse(storedContents);
                } catch (err) {
                  if (err instanceof SyntaxError) {
                    throw new Error(
                      'Failed to parse encrypted, signed content JSON. The content may not ' +
                        'be encrypted. If using getFile, try passing' +
                        ' { verify: false, decrypt: false }.'
                    );
                  } else {
                    throw err;
                  }
                }
                var signature = sigObject.signature;
                var signerPublicKey = sigObject.publicKey;
                var cipherText = sigObject.cipherText;
                var signerAddress = (0, _keys.publicKeyToAddress)(
                  signerPublicKey
                );
                if (!signerPublicKey || !cipherText || !signature) {
                  throw new _errors.SignatureVerificationError(
                    'Failed to get signature verification data from file:' +
                      (' ' + path)
                  );
                } else if (signerAddress !== address) {
                  throw new _errors.SignatureVerificationError(
                    'Signer pubkey address (' +
                      signerAddress +
                      ") doesn't" +
                      (' match gaia address (' + address + ')')
                  );
                } else if (
                  !(0, _encryption.verifyECDSA)(
                    cipherText,
                    signerPublicKey,
                    signature
                  )
                ) {
                  throw new _errors.SignatureVerificationError(
                    'Contents do not match ECDSA signature in file:' +
                      (' ' + path)
                  );
                } else {
                  return caller.decryptContent(cipherText);
                }
              });
            }
            function getFileImpl(caller, path, options) {
              var appConfig = caller.appConfig;
              if (!appConfig) {
                throw new _errors.InvalidStateError('Missing AppConfig');
              }
              var defaults = {
                decrypt: true,
                verify: false,
                username: null,
                app: appConfig.appDomain,
                zoneFileLookupURL: null
              };
              var opt = Object.assign({}, defaults, options);
              if (opt.verify && !opt.decrypt) {
                return getFileSignedUnencrypted(caller, path, opt);
              }
              return getFileContents(
                caller,
                path,
                opt.app,
                opt.username,
                opt.zoneFileLookupURL,
                !!opt.decrypt
              ).then(function(storedContents) {
                if (storedContents === null) {
                  return storedContents;
                } else if (opt.decrypt && !opt.verify) {
                  if (typeof storedContents !== 'string') {
                    throw new Error(
                      'Expected to get back a string for the cipherText'
                    );
                  }
                  return decryptContentImpl(caller, storedContents);
                } else if (opt.decrypt && opt.verify) {
                  if (typeof storedContents !== 'string') {
                    throw new Error(
                      'Expected to get back a string for the cipherText'
                    );
                  }
                  return handleSignedEncryptedContents(
                    caller,
                    path,
                    storedContents,
                    opt.app,
                    opt.username,
                    opt.zoneFileLookupURL
                  );
                } else if (!opt.verify && !opt.decrypt) {
                  return storedContents;
                } else {
                  throw new Error('Should be unreachable.');
                }
              });
            }
            function putFileImpl(caller, path, content, options) {
              var defaults = { encrypt: true, sign: false, contentType: '' };
              var opt = Object.assign({}, defaults, options);
              var contentType = opt.contentType;
              if (!contentType) {
                contentType =
                  typeof content === 'string'
                    ? 'text/plain; charset=utf-8'
                    : 'application/octet-stream';
              }
              var privateKey = '';
              var publicKey = '';
              if (opt.sign) {
                if (typeof opt.sign === 'string') {
                  privateKey = opt.sign;
                } else {
                  privateKey = caller.loadUserData().appPrivateKey;
                }
              }
              if (opt.encrypt) {
                if (typeof opt.encrypt === 'string') {
                  publicKey = opt.encrypt;
                } else {
                  if (!privateKey) {
                    privateKey = caller.loadUserData().appPrivateKey;
                  }
                  publicKey = (0, _keys.getPublicKeyFromPrivate)(privateKey);
                }
              }
              if (!opt.encrypt && opt.sign) {
                var signatureObject = (0, _encryption.signECDSA)(
                  privateKey,
                  content
                );
                var signatureContent = JSON.stringify(signatureObject);
                return (0, _hub.getOrSetLocalGaiaHubConnection)(caller)
                  .then(function(gaiaHubConfig) {
                    return new Promise(function(resolve, reject) {
                      return Promise.all([
                        (0, _hub.uploadToGaiaHub)(
                          path,
                          content,
                          gaiaHubConfig,
                          contentType
                        ),
                        (0, _hub.uploadToGaiaHub)(
                          '' + path + SIGNATURE_FILE_SUFFIX,
                          signatureContent,
                          gaiaHubConfig,
                          'application/json'
                        )
                      ])
                        .then(resolve)
                        .catch(function() {
                          (0, _hub.setLocalGaiaHubConnection)(caller).then(
                            function(freshHubConfig) {
                              return Promise.all([
                                (0, _hub.uploadToGaiaHub)(
                                  path,
                                  content,
                                  freshHubConfig,
                                  contentType
                                ),
                                (0, _hub.uploadToGaiaHub)(
                                  '' + path + SIGNATURE_FILE_SUFFIX,
                                  signatureContent,
                                  freshHubConfig,
                                  'application/json'
                                )
                              ])
                                .then(resolve)
                                .catch(reject);
                            }
                          );
                        });
                    });
                  })
                  .then(function(fileUrls) {
                    return fileUrls[0];
                  });
              }
              if (opt.encrypt && !opt.sign) {
                content = encryptContentImpl(caller, content, {
                  publicKey: publicKey
                });
                contentType = 'application/json';
              } else if (opt.encrypt && opt.sign) {
                var cipherText = encryptContentImpl(caller, content, {
                  publicKey: publicKey
                });
                var _signatureObject = (0, _encryption.signECDSA)(
                  privateKey,
                  cipherText
                );
                var signedCipherObject = {
                  signature: _signatureObject.signature,
                  publicKey: _signatureObject.publicKey,
                  cipherText: cipherText
                };
                content = JSON.stringify(signedCipherObject);
                contentType = 'application/json';
              }
              return (0, _hub.getOrSetLocalGaiaHubConnection)(caller).then(
                function(gaiaHubConfig) {
                  return new Promise(function(resolve, reject) {
                    (0, _hub.uploadToGaiaHub)(
                      path,
                      content,
                      gaiaHubConfig,
                      contentType
                    )
                      .then(resolve)
                      .catch(function() {
                        (0, _hub.setLocalGaiaHubConnection)(caller).then(
                          function(freshHubConfig) {
                            return (0, _hub.uploadToGaiaHub)(
                              path,
                              content,
                              freshHubConfig,
                              contentType
                            )
                              .then(resolve)
                              .catch(reject);
                          }
                        );
                      });
                  });
                }
              );
            }
            function getAppBucketUrl(gaiaHubUrl, appPrivateKey) {
              return (0, _hub.getBucketUrl)(gaiaHubUrl, appPrivateKey);
            }
            function listFilesLoop(
              hubConfig,
              page,
              callCount,
              fileCount,
              callback
            ) {
              if (callCount > 65536) {
                throw new Error('Too many entries to list');
              }
              var httpStatus = void 0;
              var pageRequest = JSON.stringify({ page: page });
              var fetchOptions = {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Content-Length': '' + pageRequest.length,
                  Authorization: 'bearer ' + hubConfig.token
                },
                body: pageRequest
              };
              return fetch(
                hubConfig.server + '/list-files/' + hubConfig.address,
                fetchOptions
              )
                .then(function(response) {
                  httpStatus = response.status;
                  if (httpStatus >= 400) {
                    throw new Error(
                      'listFiles failed with HTTP status ' + httpStatus
                    );
                  }
                  return response.text();
                })
                .then(function(responseText) {
                  return JSON.parse(responseText);
                })
                .then(function(responseJSON) {
                  var entries = responseJSON.entries;
                  var nextPage = responseJSON.page;
                  if (entries === null || entries === undefined) {
                    throw new Error('Bad listFiles response: no entries');
                  }
                  for (var i = 0; i < entries.length; i++) {
                    var rc = callback(entries[i]);
                    if (!rc) {
                      return Promise.resolve(fileCount + i);
                    }
                  }
                  if (nextPage && entries.length > 0) {
                    return listFilesLoop(
                      hubConfig,
                      nextPage,
                      callCount + 1,
                      fileCount + entries.length,
                      callback
                    );
                  } else {
                    return Promise.resolve(fileCount + entries.length);
                  }
                });
            }
            function listFilesImpl(caller, callback) {
              return (0, _hub.getOrSetLocalGaiaHubConnection)(caller).then(
                function(gaiaHubConfig) {
                  return listFilesLoop(gaiaHubConfig, null, 0, 0, callback);
                }
              );
            }
            exports.connectToGaiaHub = _hub.connectToGaiaHub;
            exports.uploadToGaiaHub = _hub.uploadToGaiaHub;
            exports.BLOCKSTACK_GAIA_HUB_LABEL = _hub.BLOCKSTACK_GAIA_HUB_LABEL;
          }.call(this, require('buffer').Buffer));
        },
        {
          '../encryption': 14,
          '../errors': 15,
          '../keys': 17,
          '../logger': 18,
          '../profiles': 26,
          './hub': 48,
          buffer: 183
        }
      ],
      50: [
        function(require, module, exports) {
          (function(Buffer) {
            'use strict';
            Object.defineProperty(exports, '__esModule', { value: true });
            exports.BLOCKSTACK_HANDLER = undefined;
            exports.nextYear = nextYear;
            exports.nextMonth = nextMonth;
            exports.nextHour = nextHour;
            exports.updateQueryStringParameter = updateQueryStringParameter;
            exports.isLaterVersion = isLaterVersion;
            exports.hexStringToECPair = hexStringToECPair;
            exports.ecPairToHexString = ecPairToHexString;
            exports.ecPairToAddress = ecPairToAddress;
            exports.makeUUID4 = makeUUID4;
            exports.isSameOriginAbsoluteUrl = isSameOriginAbsoluteUrl;
            var _url = require('url');
            var _url2 = _interopRequireDefault(_url);
            var _bitcoinjsLib = require('bitcoinjs-lib');
            var _config = require('./config');
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            var BLOCKSTACK_HANDLER = (exports.BLOCKSTACK_HANDLER =
              'blockstack');
            function nextYear() {
              return new Date(
                new Date().setFullYear(new Date().getFullYear() + 1)
              );
            }
            function nextMonth() {
              return new Date(new Date().setMonth(new Date().getMonth() + 1));
            }
            function nextHour() {
              return new Date(new Date().setHours(new Date().getHours() + 1));
            }
            function updateQueryStringParameter(uri, key, value) {
              var re = new RegExp('([?&])' + key + '=.*?(&|$)', 'i');
              var separator = uri.indexOf('?') !== -1 ? '&' : '?';
              if (uri.match(re)) {
                return uri.replace(re, '$1' + key + '=' + value + '$2');
              } else {
                return '' + uri + separator + key + '=' + value;
              }
            }
            function isLaterVersion(v1, v2) {
              if (v1 === undefined) {
                v1 = '0.0.0';
              }
              if (v2 === undefined) {
                v2 = '0.0.0';
              }
              var v1tuple = v1.split('.').map(function(x) {
                return parseInt(x, 10);
              });
              var v2tuple = v2.split('.').map(function(x) {
                return parseInt(x, 10);
              });
              for (var index = 0; index < v2.length; index++) {
                if (index >= v1.length) {
                  v2tuple.push(0);
                }
                if (v1tuple[index] < v2tuple[index]) {
                  return false;
                }
              }
              return true;
            }
            function hexStringToECPair(skHex) {
              var ecPairOptions = {
                network: _config.config.network.layer1,
                compressed: true
              };
              if (skHex.length === 66) {
                if (skHex.slice(64) !== '01') {
                  throw new Error(
                    'Improperly formatted private-key hex string. 66-length hex usually ' +
                      'indicates compressed key, but last byte must be == 1'
                  );
                }
                return _bitcoinjsLib.ECPair.fromPrivateKey(
                  new Buffer(skHex.slice(0, 64), 'hex'),
                  ecPairOptions
                );
              } else if (skHex.length === 64) {
                ecPairOptions.compressed = false;
                return _bitcoinjsLib.ECPair.fromPrivateKey(
                  new Buffer(skHex, 'hex'),
                  ecPairOptions
                );
              } else {
                throw new Error(
                  'Improperly formatted private-key hex string: length should be 64 or 66.'
                );
              }
            }
            function ecPairToHexString(secretKey) {
              var ecPointHex = secretKey.privateKey.toString('hex');
              if (secretKey.compressed) {
                return ecPointHex + '01';
              } else {
                return ecPointHex;
              }
            }
            function ecPairToAddress(keyPair) {
              return _bitcoinjsLib.address.toBase58Check(
                _bitcoinjsLib.crypto.hash160(keyPair.publicKey),
                keyPair.network.pubKeyHash
              );
            }
            function makeUUID4() {
              var d = new Date().getTime();
              if (
                typeof performance !== 'undefined' &&
                typeof performance.now === 'function'
              ) {
                d += performance.now();
              }
              return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(
                /[xy]/g,
                function(c) {
                  var r = (d + Math.random() * 16) % 16 | 0;
                  d = Math.floor(d / 16);
                  return (c === 'x' ? r : (r & 3) | 8).toString(16);
                }
              );
            }
            function isSameOriginAbsoluteUrl(uri1, uri2) {
              var parsedUri1 = _url2.default.parse(uri1);
              var parsedUri2 = _url2.default.parse(uri2);
              var port1 =
                parseInt(parsedUri1.port, 10) | 0 ||
                (parsedUri1.protocol === 'https:' ? 443 : 80);
              var port2 =
                parseInt(parsedUri2.port, 10) | 0 ||
                (parsedUri2.protocol === 'https:' ? 443 : 80);
              var match = {
                scheme: parsedUri1.protocol === parsedUri2.protocol,
                hostname: parsedUri1.hostname === parsedUri2.hostname,
                port: port1 === port2,
                absolute:
                  (uri1.includes('http://') || uri1.includes('https://')) &&
                  (uri2.includes('http://') || uri2.includes('https://'))
              };
              return (
                match.scheme && match.hostname && match.port && match.absolute
              );
            }
          }.call(this, require('buffer').Buffer));
        },
        { './config': 12, 'bitcoinjs-lib': 96, buffer: 183, url: 260 }
      ],
      51: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.BlockstackWallet = undefined;
          var _regenerator = require('babel-runtime/regenerator');
          var _regenerator2 = _interopRequireDefault(_regenerator);
          var _createClass = (function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          })();
          var _crypto = require('crypto');
          var _crypto2 = _interopRequireDefault(_crypto);
          var _bitcoinjsLib = require('bitcoinjs-lib');
          var _bitcoinjsLib2 = _interopRequireDefault(_bitcoinjsLib);
          var _bip = require('bip39');
          var _bip2 = _interopRequireDefault(_bip);
          var _bip3 = require('bip32');
          var _bip4 = _interopRequireDefault(_bip3);
          var _utils = require('./utils');
          var _encryption = require('./encryption');
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _asyncToGenerator(fn) {
            return function() {
              var gen = fn.apply(this, arguments);
              return new Promise(function(resolve, reject) {
                function step(key, arg) {
                  try {
                    var info = gen[key](arg);
                    var value = info.value;
                  } catch (error) {
                    reject(error);
                    return;
                  }
                  if (info.done) {
                    resolve(value);
                  } else {
                    return Promise.resolve(value).then(
                      function(value) {
                        step('next', value);
                      },
                      function(err) {
                        step('throw', err);
                      }
                    );
                  }
                }
                return step('next');
              });
            };
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          var APPS_NODE_INDEX = 0;
          var IDENTITY_KEYCHAIN = 888;
          var BLOCKSTACK_ON_BITCOIN = 0;
          var BITCOIN_BIP_44_PURPOSE = 44;
          var BITCOIN_COIN_TYPE = 0;
          var BITCOIN_ACCOUNT_INDEX = 0;
          var EXTERNAL_ADDRESS = 'EXTERNAL_ADDRESS';
          var CHANGE_ADDRESS = 'CHANGE_ADDRESS';
          function hashCode(string) {
            var hash = 0;
            if (string.length === 0) return hash;
            for (var i = 0; i < string.length; i++) {
              var character = string.charCodeAt(i);
              hash = (hash << 5) - hash + character;
              hash &= hash;
            }
            return hash & 2147483647;
          }
          function getNodePrivateKey(node) {
            return (0, _utils.ecPairToHexString)(
              _bitcoinjsLib.ECPair.fromPrivateKey(node.privateKey)
            );
          }
          function getNodePublicKey(node) {
            return node.publicKey.toString('hex');
          }
          var BlockstackWallet = (exports.BlockstackWallet = (function() {
            function BlockstackWallet(rootNode) {
              _classCallCheck(this, BlockstackWallet);
              this.rootNode = rootNode;
            }
            _createClass(
              BlockstackWallet,
              [
                {
                  key: 'toBase58',
                  value: function toBase58() {
                    return this.rootNode.toBase58();
                  }
                },
                {
                  key: 'getIdentityPrivateKeychain',
                  value: function getIdentityPrivateKeychain() {
                    return this.rootNode
                      .deriveHardened(IDENTITY_KEYCHAIN)
                      .deriveHardened(BLOCKSTACK_ON_BITCOIN);
                  }
                },
                {
                  key: 'getBitcoinPrivateKeychain',
                  value: function getBitcoinPrivateKeychain() {
                    return this.rootNode
                      .deriveHardened(BITCOIN_BIP_44_PURPOSE)
                      .deriveHardened(BITCOIN_COIN_TYPE)
                      .deriveHardened(BITCOIN_ACCOUNT_INDEX);
                  }
                },
                {
                  key: 'getBitcoinNode',
                  value: function getBitcoinNode(addressIndex) {
                    var chainType =
                      arguments.length > 1 && arguments[1] !== undefined
                        ? arguments[1]
                        : EXTERNAL_ADDRESS;
                    return BlockstackWallet.getNodeFromBitcoinKeychain(
                      this.getBitcoinPrivateKeychain().toBase58(),
                      addressIndex,
                      chainType
                    );
                  }
                },
                {
                  key: 'getIdentityAddressNode',
                  value: function getIdentityAddressNode(identityIndex) {
                    var identityPrivateKeychain = this.getIdentityPrivateKeychain();
                    return identityPrivateKeychain.deriveHardened(
                      identityIndex
                    );
                  }
                },
                {
                  key: 'getIdentitySalt',
                  value: function getIdentitySalt() {
                    var identityPrivateKeychain = this.getIdentityPrivateKeychain();
                    var publicKeyHex = getNodePublicKey(
                      identityPrivateKeychain
                    );
                    return _crypto2.default
                      .createHash('sha256')
                      .update(publicKeyHex)
                      .digest('hex');
                  }
                },
                {
                  key: 'getBitcoinAddress',
                  value: function getBitcoinAddress(addressIndex) {
                    return BlockstackWallet.getAddressFromBIP32Node(
                      this.getBitcoinNode(addressIndex)
                    );
                  }
                },
                {
                  key: 'getBitcoinPrivateKey',
                  value: function getBitcoinPrivateKey(addressIndex) {
                    return getNodePrivateKey(this.getBitcoinNode(addressIndex));
                  }
                },
                {
                  key: 'getBitcoinPublicKeychain',
                  value: function getBitcoinPublicKeychain() {
                    return this.getBitcoinPrivateKeychain().neutered();
                  }
                },
                {
                  key: 'getIdentityPublicKeychain',
                  value: function getIdentityPublicKeychain() {
                    return this.getIdentityPrivateKeychain().neutered();
                  }
                },
                {
                  key: 'getIdentityKeyPair',
                  value: function getIdentityKeyPair(addressIndex) {
                    var alwaysUncompressed =
                      arguments.length > 1 && arguments[1] !== undefined
                        ? arguments[1]
                        : false;
                    var identityNode = this.getIdentityAddressNode(
                      addressIndex
                    );
                    var address = BlockstackWallet.getAddressFromBIP32Node(
                      identityNode
                    );
                    var identityKey = getNodePrivateKey(identityNode);
                    if (alwaysUncompressed && identityKey.length === 66) {
                      identityKey = identityKey.slice(0, 64);
                    }
                    var identityKeyID = getNodePublicKey(identityNode);
                    var appsNodeKey = BlockstackWallet.getAppsNode(
                      identityNode
                    ).toBase58();
                    var salt = this.getIdentitySalt();
                    var keyPair = {
                      key: identityKey,
                      keyID: identityKeyID,
                      address: address,
                      appsNodeKey: appsNodeKey,
                      salt: salt
                    };
                    return keyPair;
                  }
                }
              ],
              [
                {
                  key: 'fromSeedBuffer',
                  value: function fromSeedBuffer(seed) {
                    return new BlockstackWallet(_bip4.default.fromSeed(seed));
                  }
                },
                {
                  key: 'fromBase58',
                  value: function fromBase58(keychain) {
                    return new BlockstackWallet(
                      _bip4.default.fromBase58(keychain)
                    );
                  }
                },
                {
                  key: 'fromEncryptedMnemonic',
                  value: function fromEncryptedMnemonic(data, password) {
                    return (0, _encryption.decryptMnemonic)(data, password)
                      .then(function(mnemonic) {
                        var seed = _bip2.default.mnemonicToSeed(mnemonic);
                        return new BlockstackWallet(
                          _bip4.default.fromSeed(seed)
                        );
                      })
                      .catch(function(err) {
                        if (
                          err.message &&
                          err.message.startsWith('bad header;')
                        ) {
                          throw new Error('Incorrect password');
                        } else {
                          throw err;
                        }
                      });
                  }
                },
                {
                  key: 'generateMnemonic',
                  value: function generateMnemonic() {
                    return _bip2.default.generateMnemonic(
                      128,
                      _crypto.randomBytes
                    );
                  }
                },
                {
                  key: 'encryptMnemonic',
                  value: (function() {
                    var _ref = _asyncToGenerator(
                      _regenerator2.default.mark(function _callee(
                        mnemonic,
                        password
                      ) {
                        var encryptedBuffer;
                        return _regenerator2.default.wrap(
                          function _callee$(_context) {
                            while (1) {
                              switch ((_context.prev = _context.next)) {
                                case 0:
                                  _context.next = 2;
                                  return (0, _encryption.encryptMnemonic)(
                                    mnemonic,
                                    password
                                  );
                                case 2:
                                  encryptedBuffer = _context.sent;
                                  return _context.abrupt(
                                    'return',
                                    encryptedBuffer.toString('hex')
                                  );
                                case 4:
                                case 'end':
                                  return _context.stop();
                              }
                            }
                          },
                          _callee,
                          this
                        );
                      })
                    );
                    function encryptMnemonic(_x3, _x4) {
                      return _ref.apply(this, arguments);
                    }
                    return encryptMnemonic;
                  })()
                },
                {
                  key: 'getAppsNode',
                  value: function getAppsNode(identityNode) {
                    return identityNode.deriveHardened(APPS_NODE_INDEX);
                  }
                },
                {
                  key: 'getNodeFromBitcoinKeychain',
                  value: function getNodeFromBitcoinKeychain(
                    keychainBase58,
                    addressIndex
                  ) {
                    var chainType =
                      arguments.length > 2 && arguments[2] !== undefined
                        ? arguments[2]
                        : EXTERNAL_ADDRESS;
                    var chain = void 0;
                    if (chainType === EXTERNAL_ADDRESS) {
                      chain = 0;
                    } else if (chainType === CHANGE_ADDRESS) {
                      chain = 1;
                    } else {
                      throw new Error('Invalid chain type');
                    }
                    var keychain = _bip4.default.fromBase58(keychainBase58);
                    return keychain.derive(chain).derive(addressIndex);
                  }
                },
                {
                  key: 'getAddressFromBitcoinKeychain',
                  value: function getAddressFromBitcoinKeychain(
                    keychainBase58,
                    addressIndex
                  ) {
                    var chainType =
                      arguments.length > 2 && arguments[2] !== undefined
                        ? arguments[2]
                        : EXTERNAL_ADDRESS;
                    return BlockstackWallet.getAddressFromBIP32Node(
                      BlockstackWallet.getNodeFromBitcoinKeychain(
                        keychainBase58,
                        addressIndex,
                        chainType
                      )
                    );
                  }
                },
                {
                  key: 'getLegacyAppPrivateKey',
                  value: function getLegacyAppPrivateKey(
                    appsNodeKey,
                    salt,
                    appDomain
                  ) {
                    var hash = _crypto2.default
                      .createHash('sha256')
                      .update('' + appDomain + salt)
                      .digest('hex');
                    var appIndex = hashCode(hash);
                    var appNode = _bip4.default
                      .fromBase58(appsNodeKey)
                      .deriveHardened(appIndex);
                    return getNodePrivateKey(appNode).slice(0, 64);
                  }
                },
                {
                  key: 'getAddressFromBIP32Node',
                  value: function getAddressFromBIP32Node(node) {
                    return _bitcoinjsLib2.default.payments.p2pkh({
                      pubkey: node.publicKey
                    }).address;
                  }
                },
                {
                  key: 'getAppPrivateKey',
                  value: function getAppPrivateKey(
                    appsNodeKey,
                    salt,
                    appDomain
                  ) {
                    var hash = _crypto2.default
                      .createHash('sha256')
                      .update('' + appDomain + salt)
                      .digest('hex');
                    var appIndexHexes = [];
                    if (hash.length !== 64) {
                      throw new Error(
                        'Unexpected app-domain hash length of ' + hash.length
                      );
                    }
                    for (var i = 0; i < 11; i++) {
                      appIndexHexes.push(hash.slice(i * 6, i * 6 + 6));
                    }
                    var appNode = _bip4.default.fromBase58(appsNodeKey);
                    appIndexHexes.forEach(function(hex) {
                      if (hex.length > 6) {
                        throw new Error('Invalid hex string length');
                      }
                      appNode = appNode.deriveHardened(parseInt(hex, 16));
                    });
                    return getNodePrivateKey(appNode).slice(0, 64);
                  }
                }
              ]
            );
            return BlockstackWallet;
          })());
        },
        {
          './encryption': 14,
          './utils': 50,
          'babel-runtime/regenerator': 66,
          bip32: 77,
          bip39: 78,
          'bitcoinjs-lib': 96,
          crypto: 192
        }
      ],
      52: [
        function(require, module, exports) {
          var asn1 = exports;
          asn1.bignum = require('bn.js');
          asn1.define = require('./asn1/api').define;
          asn1.base = require('./asn1/base');
          asn1.constants = require('./asn1/constants');
          asn1.decoders = require('./asn1/decoders');
          asn1.encoders = require('./asn1/encoders');
        },
        {
          './asn1/api': 53,
          './asn1/base': 55,
          './asn1/constants': 59,
          './asn1/decoders': 61,
          './asn1/encoders': 64,
          'bn.js': 134
        }
      ],
      53: [
        function(require, module, exports) {
          var asn1 = require('../asn1');
          var inherits = require('inherits');
          var api = exports;
          api.define = function define(name, body) {
            return new Entity(name, body);
          };
          function Entity(name, body) {
            this.name = name;
            this.body = body;
            this.decoders = {};
            this.encoders = {};
          }
          Entity.prototype._createNamed = function createNamed(base) {
            var named;
            try {
              named = require('vm').runInThisContext(
                '(function ' +
                  this.name +
                  '(entity) {\n' +
                  '  this._initNamed(entity);\n' +
                  '})'
              );
            } catch (e) {
              named = function(entity) {
                this._initNamed(entity);
              };
            }
            inherits(named, base);
            named.prototype._initNamed = function initnamed(entity) {
              base.call(this, entity);
            };
            return new named(this);
          };
          Entity.prototype._getDecoder = function _getDecoder(enc) {
            enc = enc || 'der';
            if (!this.decoders.hasOwnProperty(enc))
              this.decoders[enc] = this._createNamed(asn1.decoders[enc]);
            return this.decoders[enc];
          };
          Entity.prototype.decode = function decode(data, enc, options) {
            return this._getDecoder(enc).decode(data, options);
          };
          Entity.prototype._getEncoder = function _getEncoder(enc) {
            enc = enc || 'der';
            if (!this.encoders.hasOwnProperty(enc))
              this.encoders[enc] = this._createNamed(asn1.encoders[enc]);
            return this.encoders[enc];
          };
          Entity.prototype.encode = function encode(data, enc, reporter) {
            return this._getEncoder(enc).encode(data, reporter);
          };
        },
        { '../asn1': 52, inherits: 381, vm: 266 }
      ],
      54: [
        function(require, module, exports) {
          var inherits = require('inherits');
          var Reporter = require('../base').Reporter;
          var Buffer = require('buffer').Buffer;
          function DecoderBuffer(base, options) {
            Reporter.call(this, options);
            if (!Buffer.isBuffer(base)) {
              this.error('Input not Buffer');
              return;
            }
            this.base = base;
            this.offset = 0;
            this.length = base.length;
          }
          inherits(DecoderBuffer, Reporter);
          exports.DecoderBuffer = DecoderBuffer;
          DecoderBuffer.prototype.save = function save() {
            return {
              offset: this.offset,
              reporter: Reporter.prototype.save.call(this)
            };
          };
          DecoderBuffer.prototype.restore = function restore(save) {
            var res = new DecoderBuffer(this.base);
            res.offset = save.offset;
            res.length = this.offset;
            this.offset = save.offset;
            Reporter.prototype.restore.call(this, save.reporter);
            return res;
          };
          DecoderBuffer.prototype.isEmpty = function isEmpty() {
            return this.offset === this.length;
          };
          DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
            if (this.offset + 1 <= this.length)
              return this.base.readUInt8(this.offset++, true);
            else return this.error(fail || 'DecoderBuffer overrun');
          };
          DecoderBuffer.prototype.skip = function skip(bytes, fail) {
            if (!(this.offset + bytes <= this.length))
              return this.error(fail || 'DecoderBuffer overrun');
            var res = new DecoderBuffer(this.base);
            res._reporterState = this._reporterState;
            res.offset = this.offset;
            res.length = this.offset + bytes;
            this.offset += bytes;
            return res;
          };
          DecoderBuffer.prototype.raw = function raw(save) {
            return this.base.slice(
              save ? save.offset : this.offset,
              this.length
            );
          };
          function EncoderBuffer(value, reporter) {
            if (Array.isArray(value)) {
              this.length = 0;
              this.value = value.map(function(item) {
                if (!(item instanceof EncoderBuffer))
                  item = new EncoderBuffer(item, reporter);
                this.length += item.length;
                return item;
              }, this);
            } else if (typeof value === 'number') {
              if (!(0 <= value && value <= 255))
                return reporter.error('non-byte EncoderBuffer value');
              this.value = value;
              this.length = 1;
            } else if (typeof value === 'string') {
              this.value = value;
              this.length = Buffer.byteLength(value);
            } else if (Buffer.isBuffer(value)) {
              this.value = value;
              this.length = value.length;
            } else {
              return reporter.error('Unsupported type: ' + typeof value);
            }
          }
          exports.EncoderBuffer = EncoderBuffer;
          EncoderBuffer.prototype.join = function join(out, offset) {
            if (!out) out = new Buffer(this.length);
            if (!offset) offset = 0;
            if (this.length === 0) return out;
            if (Array.isArray(this.value)) {
              this.value.forEach(function(item) {
                item.join(out, offset);
                offset += item.length;
              });
            } else {
              if (typeof this.value === 'number') out[offset] = this.value;
              else if (typeof this.value === 'string')
                out.write(this.value, offset);
              else if (Buffer.isBuffer(this.value))
                this.value.copy(out, offset);
              offset += this.length;
            }
            return out;
          };
        },
        { '../base': 55, buffer: 183, inherits: 381 }
      ],
      55: [
        function(require, module, exports) {
          var base = exports;
          base.Reporter = require('./reporter').Reporter;
          base.DecoderBuffer = require('./buffer').DecoderBuffer;
          base.EncoderBuffer = require('./buffer').EncoderBuffer;
          base.Node = require('./node');
        },
        { './buffer': 54, './node': 56, './reporter': 57 }
      ],
      56: [
        function(require, module, exports) {
          var Reporter = require('../base').Reporter;
          var EncoderBuffer = require('../base').EncoderBuffer;
          var DecoderBuffer = require('../base').DecoderBuffer;
          var assert = require('minimalistic-assert');
          var tags = [
            'seq',
            'seqof',
            'set',
            'setof',
            'objid',
            'bool',
            'gentime',
            'utctime',
            'null_',
            'enum',
            'int',
            'objDesc',
            'bitstr',
            'bmpstr',
            'charstr',
            'genstr',
            'graphstr',
            'ia5str',
            'iso646str',
            'numstr',
            'octstr',
            'printstr',
            't61str',
            'unistr',
            'utf8str',
            'videostr'
          ];
          var methods = [
            'key',
            'obj',
            'use',
            'optional',
            'explicit',
            'implicit',
            'def',
            'choice',
            'any',
            'contains'
          ].concat(tags);
          var overrided = [
            '_peekTag',
            '_decodeTag',
            '_use',
            '_decodeStr',
            '_decodeObjid',
            '_decodeTime',
            '_decodeNull',
            '_decodeInt',
            '_decodeBool',
            '_decodeList',
            '_encodeComposite',
            '_encodeStr',
            '_encodeObjid',
            '_encodeTime',
            '_encodeNull',
            '_encodeInt',
            '_encodeBool'
          ];
          function Node(enc, parent) {
            var state = {};
            this._baseState = state;
            state.enc = enc;
            state.parent = parent || null;
            state.children = null;
            state.tag = null;
            state.args = null;
            state.reverseArgs = null;
            state.choice = null;
            state.optional = false;
            state.any = false;
            state.obj = false;
            state.use = null;
            state.useDecoder = null;
            state.key = null;
            state['default'] = null;
            state.explicit = null;
            state.implicit = null;
            state.contains = null;
            if (!state.parent) {
              state.children = [];
              this._wrap();
            }
          }
          module.exports = Node;
          var stateProps = [
            'enc',
            'parent',
            'children',
            'tag',
            'args',
            'reverseArgs',
            'choice',
            'optional',
            'any',
            'obj',
            'use',
            'alteredUse',
            'key',
            'default',
            'explicit',
            'implicit',
            'contains'
          ];
          Node.prototype.clone = function clone() {
            var state = this._baseState;
            var cstate = {};
            stateProps.forEach(function(prop) {
              cstate[prop] = state[prop];
            });
            var res = new this.constructor(cstate.parent);
            res._baseState = cstate;
            return res;
          };
          Node.prototype._wrap = function wrap() {
            var state = this._baseState;
            methods.forEach(function(method) {
              this[method] = function _wrappedMethod() {
                var clone = new this.constructor(this);
                state.children.push(clone);
                return clone[method].apply(clone, arguments);
              };
            }, this);
          };
          Node.prototype._init = function init(body) {
            var state = this._baseState;
            assert(state.parent === null);
            body.call(this);
            state.children = state.children.filter(function(child) {
              return child._baseState.parent === this;
            }, this);
            assert.equal(
              state.children.length,
              1,
              'Root node can have only one child'
            );
          };
          Node.prototype._useArgs = function useArgs(args) {
            var state = this._baseState;
            var children = args.filter(function(arg) {
              return arg instanceof this.constructor;
            }, this);
            args = args.filter(function(arg) {
              return !(arg instanceof this.constructor);
            }, this);
            if (children.length !== 0) {
              assert(state.children === null);
              state.children = children;
              children.forEach(function(child) {
                child._baseState.parent = this;
              }, this);
            }
            if (args.length !== 0) {
              assert(state.args === null);
              state.args = args;
              state.reverseArgs = args.map(function(arg) {
                if (typeof arg !== 'object' || arg.constructor !== Object)
                  return arg;
                var res = {};
                Object.keys(arg).forEach(function(key) {
                  if (key == (key | 0)) key |= 0;
                  var value = arg[key];
                  res[value] = key;
                });
                return res;
              });
            }
          };
          overrided.forEach(function(method) {
            Node.prototype[method] = function _overrided() {
              var state = this._baseState;
              throw new Error(
                method + ' not implemented for encoding: ' + state.enc
              );
            };
          });
          tags.forEach(function(tag) {
            Node.prototype[tag] = function _tagMethod() {
              var state = this._baseState;
              var args = Array.prototype.slice.call(arguments);
              assert(state.tag === null);
              state.tag = tag;
              this._useArgs(args);
              return this;
            };
          });
          Node.prototype.use = function use(item) {
            assert(item);
            var state = this._baseState;
            assert(state.use === null);
            state.use = item;
            return this;
          };
          Node.prototype.optional = function optional() {
            var state = this._baseState;
            state.optional = true;
            return this;
          };
          Node.prototype.def = function def(val) {
            var state = this._baseState;
            assert(state['default'] === null);
            state['default'] = val;
            state.optional = true;
            return this;
          };
          Node.prototype.explicit = function explicit(num) {
            var state = this._baseState;
            assert(state.explicit === null && state.implicit === null);
            state.explicit = num;
            return this;
          };
          Node.prototype.implicit = function implicit(num) {
            var state = this._baseState;
            assert(state.explicit === null && state.implicit === null);
            state.implicit = num;
            return this;
          };
          Node.prototype.obj = function obj() {
            var state = this._baseState;
            var args = Array.prototype.slice.call(arguments);
            state.obj = true;
            if (args.length !== 0) this._useArgs(args);
            return this;
          };
          Node.prototype.key = function key(newKey) {
            var state = this._baseState;
            assert(state.key === null);
            state.key = newKey;
            return this;
          };
          Node.prototype.any = function any() {
            var state = this._baseState;
            state.any = true;
            return this;
          };
          Node.prototype.choice = function choice(obj) {
            var state = this._baseState;
            assert(state.choice === null);
            state.choice = obj;
            this._useArgs(
              Object.keys(obj).map(function(key) {
                return obj[key];
              })
            );
            return this;
          };
          Node.prototype.contains = function contains(item) {
            var state = this._baseState;
            assert(state.use === null);
            state.contains = item;
            return this;
          };
          Node.prototype._decode = function decode(input, options) {
            var state = this._baseState;
            if (state.parent === null)
              return input.wrapResult(
                state.children[0]._decode(input, options)
              );
            var result = state['default'];
            var present = true;
            var prevKey = null;
            if (state.key !== null) prevKey = input.enterKey(state.key);
            if (state.optional) {
              var tag = null;
              if (state.explicit !== null) tag = state.explicit;
              else if (state.implicit !== null) tag = state.implicit;
              else if (state.tag !== null) tag = state.tag;
              if (tag === null && !state.any) {
                var save = input.save();
                try {
                  if (state.choice === null)
                    this._decodeGeneric(state.tag, input, options);
                  else this._decodeChoice(input, options);
                  present = true;
                } catch (e) {
                  present = false;
                }
                input.restore(save);
              } else {
                present = this._peekTag(input, tag, state.any);
                if (input.isError(present)) return present;
              }
            }
            var prevObj;
            if (state.obj && present) prevObj = input.enterObject();
            if (present) {
              if (state.explicit !== null) {
                var explicit = this._decodeTag(input, state.explicit);
                if (input.isError(explicit)) return explicit;
                input = explicit;
              }
              var start = input.offset;
              if (state.use === null && state.choice === null) {
                if (state.any) var save = input.save();
                var body = this._decodeTag(
                  input,
                  state.implicit !== null ? state.implicit : state.tag,
                  state.any
                );
                if (input.isError(body)) return body;
                if (state.any) result = input.raw(save);
                else input = body;
              }
              if (options && options.track && state.tag !== null)
                options.track(input.path(), start, input.length, 'tagged');
              if (options && options.track && state.tag !== null)
                options.track(
                  input.path(),
                  input.offset,
                  input.length,
                  'content'
                );
              if (state.any) result = result;
              else if (state.choice === null)
                result = this._decodeGeneric(state.tag, input, options);
              else result = this._decodeChoice(input, options);
              if (input.isError(result)) return result;
              if (
                !state.any &&
                state.choice === null &&
                state.children !== null
              ) {
                state.children.forEach(function decodeChildren(child) {
                  child._decode(input, options);
                });
              }
              if (
                state.contains &&
                (state.tag === 'octstr' || state.tag === 'bitstr')
              ) {
                var data = new DecoderBuffer(result);
                result = this._getUse(
                  state.contains,
                  input._reporterState.obj
                )._decode(data, options);
              }
            }
            if (state.obj && present) result = input.leaveObject(prevObj);
            if (state.key !== null && (result !== null || present === true))
              input.leaveKey(prevKey, state.key, result);
            else if (prevKey !== null) input.exitKey(prevKey);
            return result;
          };
          Node.prototype._decodeGeneric = function decodeGeneric(
            tag,
            input,
            options
          ) {
            var state = this._baseState;
            if (tag === 'seq' || tag === 'set') return null;
            if (tag === 'seqof' || tag === 'setof')
              return this._decodeList(input, tag, state.args[0], options);
            else if (/str$/.test(tag))
              return this._decodeStr(input, tag, options);
            else if (tag === 'objid' && state.args)
              return this._decodeObjid(
                input,
                state.args[0],
                state.args[1],
                options
              );
            else if (tag === 'objid')
              return this._decodeObjid(input, null, null, options);
            else if (tag === 'gentime' || tag === 'utctime')
              return this._decodeTime(input, tag, options);
            else if (tag === 'null_') return this._decodeNull(input, options);
            else if (tag === 'bool') return this._decodeBool(input, options);
            else if (tag === 'objDesc')
              return this._decodeStr(input, tag, options);
            else if (tag === 'int' || tag === 'enum')
              return this._decodeInt(
                input,
                state.args && state.args[0],
                options
              );
            if (state.use !== null) {
              return this._getUse(state.use, input._reporterState.obj)._decode(
                input,
                options
              );
            } else {
              return input.error('unknown tag: ' + tag);
            }
          };
          Node.prototype._getUse = function _getUse(entity, obj) {
            var state = this._baseState;
            state.useDecoder = this._use(entity, obj);
            assert(state.useDecoder._baseState.parent === null);
            state.useDecoder = state.useDecoder._baseState.children[0];
            if (state.implicit !== state.useDecoder._baseState.implicit) {
              state.useDecoder = state.useDecoder.clone();
              state.useDecoder._baseState.implicit = state.implicit;
            }
            return state.useDecoder;
          };
          Node.prototype._decodeChoice = function decodeChoice(input, options) {
            var state = this._baseState;
            var result = null;
            var match = false;
            Object.keys(state.choice).some(function(key) {
              var save = input.save();
              var node = state.choice[key];
              try {
                var value = node._decode(input, options);
                if (input.isError(value)) return false;
                result = { type: key, value: value };
                match = true;
              } catch (e) {
                input.restore(save);
                return false;
              }
              return true;
            }, this);
            if (!match) return input.error('Choice not matched');
            return result;
          };
          Node.prototype._createEncoderBuffer = function createEncoderBuffer(
            data
          ) {
            return new EncoderBuffer(data, this.reporter);
          };
          Node.prototype._encode = function encode(data, reporter, parent) {
            var state = this._baseState;
            if (state['default'] !== null && state['default'] === data) return;
            var result = this._encodeValue(data, reporter, parent);
            if (result === undefined) return;
            if (this._skipDefault(result, reporter, parent)) return;
            return result;
          };
          Node.prototype._encodeValue = function encode(
            data,
            reporter,
            parent
          ) {
            var state = this._baseState;
            if (state.parent === null)
              return state.children[0]._encode(
                data,
                reporter || new Reporter()
              );
            var result = null;
            this.reporter = reporter;
            if (state.optional && data === undefined) {
              if (state['default'] !== null) data = state['default'];
              else return;
            }
            var content = null;
            var primitive = false;
            if (state.any) {
              result = this._createEncoderBuffer(data);
            } else if (state.choice) {
              result = this._encodeChoice(data, reporter);
            } else if (state.contains) {
              content = this._getUse(state.contains, parent)._encode(
                data,
                reporter
              );
              primitive = true;
            } else if (state.children) {
              content = state.children
                .map(function(child) {
                  if (child._baseState.tag === 'null_')
                    return child._encode(null, reporter, data);
                  if (child._baseState.key === null)
                    return reporter.error('Child should have a key');
                  var prevKey = reporter.enterKey(child._baseState.key);
                  if (typeof data !== 'object')
                    return reporter.error(
                      'Child expected, but input is not object'
                    );
                  var res = child._encode(
                    data[child._baseState.key],
                    reporter,
                    data
                  );
                  reporter.leaveKey(prevKey);
                  return res;
                }, this)
                .filter(function(child) {
                  return child;
                });
              content = this._createEncoderBuffer(content);
            } else {
              if (state.tag === 'seqof' || state.tag === 'setof') {
                if (!(state.args && state.args.length === 1))
                  return reporter.error('Too many args for : ' + state.tag);
                if (!Array.isArray(data))
                  return reporter.error('seqof/setof, but data is not Array');
                var child = this.clone();
                child._baseState.implicit = null;
                content = this._createEncoderBuffer(
                  data.map(function(item) {
                    var state = this._baseState;
                    return this._getUse(state.args[0], data)._encode(
                      item,
                      reporter
                    );
                  }, child)
                );
              } else if (state.use !== null) {
                result = this._getUse(state.use, parent)._encode(
                  data,
                  reporter
                );
              } else {
                content = this._encodePrimitive(state.tag, data);
                primitive = true;
              }
            }
            var result;
            if (!state.any && state.choice === null) {
              var tag = state.implicit !== null ? state.implicit : state.tag;
              var cls = state.implicit === null ? 'universal' : 'context';
              if (tag === null) {
                if (state.use === null)
                  reporter.error('Tag could be omitted only for .use()');
              } else {
                if (state.use === null)
                  result = this._encodeComposite(tag, primitive, cls, content);
              }
            }
            if (state.explicit !== null)
              result = this._encodeComposite(
                state.explicit,
                false,
                'context',
                result
              );
            return result;
          };
          Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
            var state = this._baseState;
            var node = state.choice[data.type];
            if (!node) {
              assert(
                false,
                data.type +
                  ' not found in ' +
                  JSON.stringify(Object.keys(state.choice))
              );
            }
            return node._encode(data.value, reporter);
          };
          Node.prototype._encodePrimitive = function encodePrimitive(
            tag,
            data
          ) {
            var state = this._baseState;
            if (/str$/.test(tag)) return this._encodeStr(data, tag);
            else if (tag === 'objid' && state.args)
              return this._encodeObjid(
                data,
                state.reverseArgs[0],
                state.args[1]
              );
            else if (tag === 'objid')
              return this._encodeObjid(data, null, null);
            else if (tag === 'gentime' || tag === 'utctime')
              return this._encodeTime(data, tag);
            else if (tag === 'null_') return this._encodeNull();
            else if (tag === 'int' || tag === 'enum')
              return this._encodeInt(data, state.args && state.reverseArgs[0]);
            else if (tag === 'bool') return this._encodeBool(data);
            else if (tag === 'objDesc') return this._encodeStr(data, tag);
            else throw new Error('Unsupported tag: ' + tag);
          };
          Node.prototype._isNumstr = function isNumstr(str) {
            return /^[0-9 ]*$/.test(str);
          };
          Node.prototype._isPrintstr = function isPrintstr(str) {
            return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(str);
          };
        },
        { '../base': 55, 'minimalistic-assert': 441 }
      ],
      57: [
        function(require, module, exports) {
          var inherits = require('inherits');
          function Reporter(options) {
            this._reporterState = {
              obj: null,
              path: [],
              options: options || {},
              errors: []
            };
          }
          exports.Reporter = Reporter;
          Reporter.prototype.isError = function isError(obj) {
            return obj instanceof ReporterError;
          };
          Reporter.prototype.save = function save() {
            var state = this._reporterState;
            return { obj: state.obj, pathLen: state.path.length };
          };
          Reporter.prototype.restore = function restore(data) {
            var state = this._reporterState;
            state.obj = data.obj;
            state.path = state.path.slice(0, data.pathLen);
          };
          Reporter.prototype.enterKey = function enterKey(key) {
            return this._reporterState.path.push(key);
          };
          Reporter.prototype.exitKey = function exitKey(index) {
            var state = this._reporterState;
            state.path = state.path.slice(0, index - 1);
          };
          Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
            var state = this._reporterState;
            this.exitKey(index);
            if (state.obj !== null) state.obj[key] = value;
          };
          Reporter.prototype.path = function path() {
            return this._reporterState.path.join('/');
          };
          Reporter.prototype.enterObject = function enterObject() {
            var state = this._reporterState;
            var prev = state.obj;
            state.obj = {};
            return prev;
          };
          Reporter.prototype.leaveObject = function leaveObject(prev) {
            var state = this._reporterState;
            var now = state.obj;
            state.obj = prev;
            return now;
          };
          Reporter.prototype.error = function error(msg) {
            var err;
            var state = this._reporterState;
            var inherited = msg instanceof ReporterError;
            if (inherited) {
              err = msg;
            } else {
              err = new ReporterError(
                state.path
                  .map(function(elem) {
                    return '[' + JSON.stringify(elem) + ']';
                  })
                  .join(''),
                msg.message || msg,
                msg.stack
              );
            }
            if (!state.options.partial) throw err;
            if (!inherited) state.errors.push(err);
            return err;
          };
          Reporter.prototype.wrapResult = function wrapResult(result) {
            var state = this._reporterState;
            if (!state.options.partial) return result;
            return {
              result: this.isError(result) ? null : result,
              errors: state.errors
            };
          };
          function ReporterError(path, msg) {
            this.path = path;
            this.rethrow(msg);
          }
          inherits(ReporterError, Error);
          ReporterError.prototype.rethrow = function rethrow(msg) {
            this.message = msg + ' at: ' + (this.path || '(shallow)');
            if (Error.captureStackTrace)
              Error.captureStackTrace(this, ReporterError);
            if (!this.stack) {
              try {
                throw new Error(this.message);
              } catch (e) {
                this.stack = e.stack;
              }
            }
            return this;
          };
        },
        { inherits: 381 }
      ],
      58: [
        function(require, module, exports) {
          var constants = require('../constants');
          exports.tagClass = {
            0: 'universal',
            1: 'application',
            2: 'context',
            3: 'private'
          };
          exports.tagClassByName = constants._reverse(exports.tagClass);
          exports.tag = {
            0: 'end',
            1: 'bool',
            2: 'int',
            3: 'bitstr',
            4: 'octstr',
            5: 'null_',
            6: 'objid',
            7: 'objDesc',
            8: 'external',
            9: 'real',
            10: 'enum',
            11: 'embed',
            12: 'utf8str',
            13: 'relativeOid',
            16: 'seq',
            17: 'set',
            18: 'numstr',
            19: 'printstr',
            20: 't61str',
            21: 'videostr',
            22: 'ia5str',
            23: 'utctime',
            24: 'gentime',
            25: 'graphstr',
            26: 'iso646str',
            27: 'genstr',
            28: 'unistr',
            29: 'charstr',
            30: 'bmpstr'
          };
          exports.tagByName = constants._reverse(exports.tag);
        },
        { '../constants': 59 }
      ],
      59: [
        function(require, module, exports) {
          var constants = exports;
          constants._reverse = function reverse(map) {
            var res = {};
            Object.keys(map).forEach(function(key) {
              if ((key | 0) == key) key = key | 0;
              var value = map[key];
              res[value] = key;
            });
            return res;
          };
          constants.der = require('./der');
        },
        { './der': 58 }
      ],
      60: [
        function(require, module, exports) {
          var inherits = require('inherits');
          var asn1 = require('../../asn1');
          var base = asn1.base;
          var bignum = asn1.bignum;
          var der = asn1.constants.der;
          function DERDecoder(entity) {
            this.enc = 'der';
            this.name = entity.name;
            this.entity = entity;
            this.tree = new DERNode();
            this.tree._init(entity.body);
          }
          module.exports = DERDecoder;
          DERDecoder.prototype.decode = function decode(data, options) {
            if (!(data instanceof base.DecoderBuffer))
              data = new base.DecoderBuffer(data, options);
            return this.tree._decode(data, options);
          };
          function DERNode(parent) {
            base.Node.call(this, 'der', parent);
          }
          inherits(DERNode, base.Node);
          DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
            if (buffer.isEmpty()) return false;
            var state = buffer.save();
            var decodedTag = derDecodeTag(
              buffer,
              'Failed to peek tag: "' + tag + '"'
            );
            if (buffer.isError(decodedTag)) return decodedTag;
            buffer.restore(state);
            return (
              decodedTag.tag === tag ||
              decodedTag.tagStr === tag ||
              decodedTag.tagStr + 'of' === tag ||
              any
            );
          };
          DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
            var decodedTag = derDecodeTag(
              buffer,
              'Failed to decode tag of "' + tag + '"'
            );
            if (buffer.isError(decodedTag)) return decodedTag;
            var len = derDecodeLen(
              buffer,
              decodedTag.primitive,
              'Failed to get length of "' + tag + '"'
            );
            if (buffer.isError(len)) return len;
            if (
              !any &&
              decodedTag.tag !== tag &&
              decodedTag.tagStr !== tag &&
              decodedTag.tagStr + 'of' !== tag
            ) {
              return buffer.error('Failed to match tag: "' + tag + '"');
            }
            if (decodedTag.primitive || len !== null)
              return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
            var state = buffer.save();
            var res = this._skipUntilEnd(
              buffer,
              'Failed to skip indefinite length body: "' + this.tag + '"'
            );
            if (buffer.isError(res)) return res;
            len = buffer.offset - state.offset;
            buffer.restore(state);
            return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
          };
          DERNode.prototype._skipUntilEnd = function skipUntilEnd(
            buffer,
            fail
          ) {
            while (true) {
              var tag = derDecodeTag(buffer, fail);
              if (buffer.isError(tag)) return tag;
              var len = derDecodeLen(buffer, tag.primitive, fail);
              if (buffer.isError(len)) return len;
              var res;
              if (tag.primitive || len !== null) res = buffer.skip(len);
              else res = this._skipUntilEnd(buffer, fail);
              if (buffer.isError(res)) return res;
              if (tag.tagStr === 'end') break;
            }
          };
          DERNode.prototype._decodeList = function decodeList(
            buffer,
            tag,
            decoder,
            options
          ) {
            var result = [];
            while (!buffer.isEmpty()) {
              var possibleEnd = this._peekTag(buffer, 'end');
              if (buffer.isError(possibleEnd)) return possibleEnd;
              var res = decoder.decode(buffer, 'der', options);
              if (buffer.isError(res) && possibleEnd) break;
              result.push(res);
            }
            return result;
          };
          DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
            if (tag === 'bitstr') {
              var unused = buffer.readUInt8();
              if (buffer.isError(unused)) return unused;
              return { unused: unused, data: buffer.raw() };
            } else if (tag === 'bmpstr') {
              var raw = buffer.raw();
              if (raw.length % 2 === 1)
                return buffer.error(
                  'Decoding of string type: bmpstr length mismatch'
                );
              var str = '';
              for (var i = 0; i < raw.length / 2; i++) {
                str += String.fromCharCode(raw.readUInt16BE(i * 2));
              }
              return str;
            } else if (tag === 'numstr') {
              var numstr = buffer.raw().toString('ascii');
              if (!this._isNumstr(numstr)) {
                return buffer.error(
                  'Decoding of string type: ' + 'numstr unsupported characters'
                );
              }
              return numstr;
            } else if (tag === 'octstr') {
              return buffer.raw();
            } else if (tag === 'objDesc') {
              return buffer.raw();
            } else if (tag === 'printstr') {
              var printstr = buffer.raw().toString('ascii');
              if (!this._isPrintstr(printstr)) {
                return buffer.error(
                  'Decoding of string type: ' +
                    'printstr unsupported characters'
                );
              }
              return printstr;
            } else if (/str$/.test(tag)) {
              return buffer.raw().toString();
            } else {
              return buffer.error(
                'Decoding of string type: ' + tag + ' unsupported'
              );
            }
          };
          DERNode.prototype._decodeObjid = function decodeObjid(
            buffer,
            values,
            relative
          ) {
            var result;
            var identifiers = [];
            var ident = 0;
            while (!buffer.isEmpty()) {
              var subident = buffer.readUInt8();
              ident <<= 7;
              ident |= subident & 127;
              if ((subident & 128) === 0) {
                identifiers.push(ident);
                ident = 0;
              }
            }
            if (subident & 128) identifiers.push(ident);
            var first = (identifiers[0] / 40) | 0;
            var second = identifiers[0] % 40;
            if (relative) result = identifiers;
            else result = [first, second].concat(identifiers.slice(1));
            if (values) {
              var tmp = values[result.join(' ')];
              if (tmp === undefined) tmp = values[result.join('.')];
              if (tmp !== undefined) result = tmp;
            }
            return result;
          };
          DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
            var str = buffer.raw().toString();
            if (tag === 'gentime') {
              var year = str.slice(0, 4) | 0;
              var mon = str.slice(4, 6) | 0;
              var day = str.slice(6, 8) | 0;
              var hour = str.slice(8, 10) | 0;
              var min = str.slice(10, 12) | 0;
              var sec = str.slice(12, 14) | 0;
            } else if (tag === 'utctime') {
              var year = str.slice(0, 2) | 0;
              var mon = str.slice(2, 4) | 0;
              var day = str.slice(4, 6) | 0;
              var hour = str.slice(6, 8) | 0;
              var min = str.slice(8, 10) | 0;
              var sec = str.slice(10, 12) | 0;
              if (year < 70) year = 2e3 + year;
              else year = 1900 + year;
            } else {
              return buffer.error(
                'Decoding ' + tag + ' time is not supported yet'
              );
            }
            return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
          };
          DERNode.prototype._decodeNull = function decodeNull(buffer) {
            return null;
          };
          DERNode.prototype._decodeBool = function decodeBool(buffer) {
            var res = buffer.readUInt8();
            if (buffer.isError(res)) return res;
            else return res !== 0;
          };
          DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
            var raw = buffer.raw();
            var res = new bignum(raw);
            if (values) res = values[res.toString(10)] || res;
            return res;
          };
          DERNode.prototype._use = function use(entity, obj) {
            if (typeof entity === 'function') entity = entity(obj);
            return entity._getDecoder('der').tree;
          };
          function derDecodeTag(buf, fail) {
            var tag = buf.readUInt8(fail);
            if (buf.isError(tag)) return tag;
            var cls = der.tagClass[tag >> 6];
            var primitive = (tag & 32) === 0;
            if ((tag & 31) === 31) {
              var oct = tag;
              tag = 0;
              while ((oct & 128) === 128) {
                oct = buf.readUInt8(fail);
                if (buf.isError(oct)) return oct;
                tag <<= 7;
                tag |= oct & 127;
              }
            } else {
              tag &= 31;
            }
            var tagStr = der.tag[tag];
            return { cls: cls, primitive: primitive, tag: tag, tagStr: tagStr };
          }
          function derDecodeLen(buf, primitive, fail) {
            var len = buf.readUInt8(fail);
            if (buf.isError(len)) return len;
            if (!primitive && len === 128) return null;
            if ((len & 128) === 0) {
              return len;
            }
            var num = len & 127;
            if (num > 4) return buf.error('length octect is too long');
            len = 0;
            for (var i = 0; i < num; i++) {
              len <<= 8;
              var j = buf.readUInt8(fail);
              if (buf.isError(j)) return j;
              len |= j;
            }
            return len;
          }
        },
        { '../../asn1': 52, inherits: 381 }
      ],
      61: [
        function(require, module, exports) {
          var decoders = exports;
          decoders.der = require('./der');
          decoders.pem = require('./pem');
        },
        { './der': 60, './pem': 62 }
      ],
      62: [
        function(require, module, exports) {
          var inherits = require('inherits');
          var Buffer = require('buffer').Buffer;
          var DERDecoder = require('./der');
          function PEMDecoder(entity) {
            DERDecoder.call(this, entity);
            this.enc = 'pem';
          }
          inherits(PEMDecoder, DERDecoder);
          module.exports = PEMDecoder;
          PEMDecoder.prototype.decode = function decode(data, options) {
            var lines = data.toString().split(/[\r\n]+/g);
            var label = options.label.toUpperCase();
            var re = /^-----(BEGIN|END) ([^-]+)-----$/;
            var start = -1;
            var end = -1;
            for (var i = 0; i < lines.length; i++) {
              var match = lines[i].match(re);
              if (match === null) continue;
              if (match[2] !== label) continue;
              if (start === -1) {
                if (match[1] !== 'BEGIN') break;
                start = i;
              } else {
                if (match[1] !== 'END') break;
                end = i;
                break;
              }
            }
            if (start === -1 || end === -1)
              throw new Error('PEM section not found for: ' + label);
            var base64 = lines.slice(start + 1, end).join('');
            base64.replace(/[^a-z0-9\+\/=]+/gi, '');
            var input = new Buffer(base64, 'base64');
            return DERDecoder.prototype.decode.call(this, input, options);
          };
        },
        { './der': 60, buffer: 183, inherits: 381 }
      ],
      63: [
        function(require, module, exports) {
          var inherits = require('inherits');
          var Buffer = require('buffer').Buffer;
          var asn1 = require('../../asn1');
          var base = asn1.base;
          var der = asn1.constants.der;
          function DEREncoder(entity) {
            this.enc = 'der';
            this.name = entity.name;
            this.entity = entity;
            this.tree = new DERNode();
            this.tree._init(entity.body);
          }
          module.exports = DEREncoder;
          DEREncoder.prototype.encode = function encode(data, reporter) {
            return this.tree._encode(data, reporter).join();
          };
          function DERNode(parent) {
            base.Node.call(this, 'der', parent);
          }
          inherits(DERNode, base.Node);
          DERNode.prototype._encodeComposite = function encodeComposite(
            tag,
            primitive,
            cls,
            content
          ) {
            var encodedTag = encodeTag(tag, primitive, cls, this.reporter);
            if (content.length < 128) {
              var header = new Buffer(2);
              header[0] = encodedTag;
              header[1] = content.length;
              return this._createEncoderBuffer([header, content]);
            }
            var lenOctets = 1;
            for (var i = content.length; i >= 256; i >>= 8) lenOctets++;
            var header = new Buffer(1 + 1 + lenOctets);
            header[0] = encodedTag;
            header[1] = 128 | lenOctets;
            for (var i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
              header[i] = j & 255;
            return this._createEncoderBuffer([header, content]);
          };
          DERNode.prototype._encodeStr = function encodeStr(str, tag) {
            if (tag === 'bitstr') {
              return this._createEncoderBuffer([str.unused | 0, str.data]);
            } else if (tag === 'bmpstr') {
              var buf = new Buffer(str.length * 2);
              for (var i = 0; i < str.length; i++) {
                buf.writeUInt16BE(str.charCodeAt(i), i * 2);
              }
              return this._createEncoderBuffer(buf);
            } else if (tag === 'numstr') {
              if (!this._isNumstr(str)) {
                return this.reporter.error(
                  'Encoding of string type: numstr supports ' +
                    'only digits and space'
                );
              }
              return this._createEncoderBuffer(str);
            } else if (tag === 'printstr') {
              if (!this._isPrintstr(str)) {
                return this.reporter.error(
                  'Encoding of string type: printstr supports ' +
                    'only latin upper and lower case letters, ' +
                    'digits, space, apostrophe, left and rigth ' +
                    'parenthesis, plus sign, comma, hyphen, ' +
                    'dot, slash, colon, equal sign, ' +
                    'question mark'
                );
              }
              return this._createEncoderBuffer(str);
            } else if (/str$/.test(tag)) {
              return this._createEncoderBuffer(str);
            } else if (tag === 'objDesc') {
              return this._createEncoderBuffer(str);
            } else {
              return this.reporter.error(
                'Encoding of string type: ' + tag + ' unsupported'
              );
            }
          };
          DERNode.prototype._encodeObjid = function encodeObjid(
            id,
            values,
            relative
          ) {
            if (typeof id === 'string') {
              if (!values)
                return this.reporter.error(
                  'string objid given, but no values map found'
                );
              if (!values.hasOwnProperty(id))
                return this.reporter.error('objid not found in values map');
              id = values[id].split(/[\s\.]+/g);
              for (var i = 0; i < id.length; i++) id[i] |= 0;
            } else if (Array.isArray(id)) {
              id = id.slice();
              for (var i = 0; i < id.length; i++) id[i] |= 0;
            }
            if (!Array.isArray(id)) {
              return this.reporter.error(
                'objid() should be either array or string, ' +
                  'got: ' +
                  JSON.stringify(id)
              );
            }
            if (!relative) {
              if (id[1] >= 40)
                return this.reporter.error('Second objid identifier OOB');
              id.splice(0, 2, id[0] * 40 + id[1]);
            }
            var size = 0;
            for (var i = 0; i < id.length; i++) {
              var ident = id[i];
              for (size++; ident >= 128; ident >>= 7) size++;
            }
            var objid = new Buffer(size);
            var offset = objid.length - 1;
            for (var i = id.length - 1; i >= 0; i--) {
              var ident = id[i];
              objid[offset--] = ident & 127;
              while ((ident >>= 7) > 0) objid[offset--] = 128 | (ident & 127);
            }
            return this._createEncoderBuffer(objid);
          };
          function two(num) {
            if (num < 10) return '0' + num;
            else return num;
          }
          DERNode.prototype._encodeTime = function encodeTime(time, tag) {
            var str;
            var date = new Date(time);
            if (tag === 'gentime') {
              str = [
                two(date.getFullYear()),
                two(date.getUTCMonth() + 1),
                two(date.getUTCDate()),
                two(date.getUTCHours()),
                two(date.getUTCMinutes()),
                two(date.getUTCSeconds()),
                'Z'
              ].join('');
            } else if (tag === 'utctime') {
              str = [
                two(date.getFullYear() % 100),
                two(date.getUTCMonth() + 1),
                two(date.getUTCDate()),
                two(date.getUTCHours()),
                two(date.getUTCMinutes()),
                two(date.getUTCSeconds()),
                'Z'
              ].join('');
            } else {
              this.reporter.error(
                'Encoding ' + tag + ' time is not supported yet'
              );
            }
            return this._encodeStr(str, 'octstr');
          };
          DERNode.prototype._encodeNull = function encodeNull() {
            return this._createEncoderBuffer('');
          };
          DERNode.prototype._encodeInt = function encodeInt(num, values) {
            if (typeof num === 'string') {
              if (!values)
                return this.reporter.error(
                  'String int or enum given, but no values map'
                );
              if (!values.hasOwnProperty(num)) {
                return this.reporter.error(
                  "Values map doesn't contain: " + JSON.stringify(num)
                );
              }
              num = values[num];
            }
            if (typeof num !== 'number' && !Buffer.isBuffer(num)) {
              var numArray = num.toArray();
              if (!num.sign && numArray[0] & 128) {
                numArray.unshift(0);
              }
              num = new Buffer(numArray);
            }
            if (Buffer.isBuffer(num)) {
              var size = num.length;
              if (num.length === 0) size++;
              var out = new Buffer(size);
              num.copy(out);
              if (num.length === 0) out[0] = 0;
              return this._createEncoderBuffer(out);
            }
            if (num < 128) return this._createEncoderBuffer(num);
            if (num < 256) return this._createEncoderBuffer([0, num]);
            var size = 1;
            for (var i = num; i >= 256; i >>= 8) size++;
            var out = new Array(size);
            for (var i = out.length - 1; i >= 0; i--) {
              out[i] = num & 255;
              num >>= 8;
            }
            if (out[0] & 128) {
              out.unshift(0);
            }
            return this._createEncoderBuffer(new Buffer(out));
          };
          DERNode.prototype._encodeBool = function encodeBool(value) {
            return this._createEncoderBuffer(value ? 255 : 0);
          };
          DERNode.prototype._use = function use(entity, obj) {
            if (typeof entity === 'function') entity = entity(obj);
            return entity._getEncoder('der').tree;
          };
          DERNode.prototype._skipDefault = function skipDefault(
            dataBuffer,
            reporter,
            parent
          ) {
            var state = this._baseState;
            var i;
            if (state['default'] === null) return false;
            var data = dataBuffer.join();
            if (state.defaultBuffer === undefined)
              state.defaultBuffer = this._encodeValue(
                state['default'],
                reporter,
                parent
              ).join();
            if (data.length !== state.defaultBuffer.length) return false;
            for (i = 0; i < data.length; i++)
              if (data[i] !== state.defaultBuffer[i]) return false;
            return true;
          };
          function encodeTag(tag, primitive, cls, reporter) {
            var res;
            if (tag === 'seqof') tag = 'seq';
            else if (tag === 'setof') tag = 'set';
            if (der.tagByName.hasOwnProperty(tag)) res = der.tagByName[tag];
            else if (typeof tag === 'number' && (tag | 0) === tag) res = tag;
            else return reporter.error('Unknown tag: ' + tag);
            if (res >= 31)
              return reporter.error('Multi-octet tag encoding unsupported');
            if (!primitive) res |= 32;
            res |= der.tagClassByName[cls || 'universal'] << 6;
            return res;
          }
        },
        { '../../asn1': 52, buffer: 183, inherits: 381 }
      ],
      64: [
        function(require, module, exports) {
          var encoders = exports;
          encoders.der = require('./der');
          encoders.pem = require('./pem');
        },
        { './der': 63, './pem': 65 }
      ],
      65: [
        function(require, module, exports) {
          var inherits = require('inherits');
          var DEREncoder = require('./der');
          function PEMEncoder(entity) {
            DEREncoder.call(this, entity);
            this.enc = 'pem';
          }
          inherits(PEMEncoder, DEREncoder);
          module.exports = PEMEncoder;
          PEMEncoder.prototype.encode = function encode(data, options) {
            var buf = DEREncoder.prototype.encode.call(this, data);
            var p = buf.toString('base64');
            var out = ['-----BEGIN ' + options.label + '-----'];
            for (var i = 0; i < p.length; i += 64) out.push(p.slice(i, i + 64));
            out.push('-----END ' + options.label + '-----');
            return out.join('\n');
          };
        },
        { './der': 63, inherits: 381 }
      ],
      66: [
        function(require, module, exports) {
          module.exports = require('regenerator-runtime');
        },
        { 'regenerator-runtime': 457 }
      ],
      67: [
        function(require, module, exports) {
          var Buffer = require('safe-buffer').Buffer;
          module.exports = function base(ALPHABET) {
            var ALPHABET_MAP = {};
            var BASE = ALPHABET.length;
            var LEADER = ALPHABET.charAt(0);
            for (var z = 0; z < ALPHABET.length; z++) {
              var x = ALPHABET.charAt(z);
              if (ALPHABET_MAP[x] !== undefined)
                throw new TypeError(x + ' is ambiguous');
              ALPHABET_MAP[x] = z;
            }
            function encode(source) {
              if (source.length === 0) return '';
              var digits = [0];
              for (var i = 0; i < source.length; ++i) {
                for (var j = 0, carry = source[i]; j < digits.length; ++j) {
                  carry += digits[j] << 8;
                  digits[j] = carry % BASE;
                  carry = (carry / BASE) | 0;
                }
                while (carry > 0) {
                  digits.push(carry % BASE);
                  carry = (carry / BASE) | 0;
                }
              }
              var string = '';
              for (var k = 0; source[k] === 0 && k < source.length - 1; ++k)
                string += LEADER;
              for (var q = digits.length - 1; q >= 0; --q)
                string += ALPHABET[digits[q]];
              return string;
            }
            function decodeUnsafe(string) {
              if (typeof string !== 'string')
                throw new TypeError('Expected String');
              if (string.length === 0) return Buffer.allocUnsafe(0);
              var bytes = [0];
              for (var i = 0; i < string.length; i++) {
                var value = ALPHABET_MAP[string[i]];
                if (value === undefined) return;
                for (var j = 0, carry = value; j < bytes.length; ++j) {
                  carry += bytes[j] * BASE;
                  bytes[j] = carry & 255;
                  carry >>= 8;
                }
                while (carry > 0) {
                  bytes.push(carry & 255);
                  carry >>= 8;
                }
              }
              for (
                var k = 0;
                string[k] === LEADER && k < string.length - 1;
                ++k
              ) {
                bytes.push(0);
              }
              return Buffer.from(bytes.reverse());
            }
            function decode(string) {
              var buffer = decodeUnsafe(string);
              if (buffer) return buffer;
              throw new Error('Non-base' + BASE + ' character');
            }
            return {
              encode: encode,
              decodeUnsafe: decodeUnsafe,
              decode: decode
            };
          };
        },
        { 'safe-buffer': 460 }
      ],
      68: [
        function(require, module, exports) {
          (function(Buffer) {
            'use strict';
            Object.defineProperty(exports, '__esModule', { value: true });
            const pad_string_1 = require('./pad-string');
            function encode(input, encoding = 'utf8') {
              if (Buffer.isBuffer(input)) {
                return fromBase64(input.toString('base64'));
              }
              return fromBase64(
                Buffer.from(input, encoding).toString('base64')
              );
            }
            function decode(base64url, encoding = 'utf8') {
              return Buffer.from(toBase64(base64url), 'base64').toString(
                encoding
              );
            }
            function toBase64(base64url) {
              base64url = base64url.toString();
              return pad_string_1
                .default(base64url)
                .replace(/\-/g, '+')
                .replace(/_/g, '/');
            }
            function fromBase64(base64) {
              return base64
                .replace(/=/g, '')
                .replace(/\+/g, '-')
                .replace(/\//g, '_');
            }
            function toBuffer(base64url) {
              return Buffer.from(toBase64(base64url), 'base64');
            }
            let base64url = encode;
            base64url.encode = encode;
            base64url.decode = decode;
            base64url.toBase64 = toBase64;
            base64url.fromBase64 = fromBase64;
            base64url.toBuffer = toBuffer;
            exports.default = base64url;
          }.call(this, require('buffer').Buffer));
        },
        { './pad-string': 69, buffer: 183 }
      ],
      69: [
        function(require, module, exports) {
          (function(Buffer) {
            'use strict';
            Object.defineProperty(exports, '__esModule', { value: true });
            function padString(input) {
              let segmentLength = 4;
              let stringLength = input.length;
              let diff = stringLength % segmentLength;
              if (!diff) {
                return input;
              }
              let position = stringLength;
              let padLength = segmentLength - diff;
              let paddedStringLength = stringLength + padLength;
              let buffer = Buffer.alloc(paddedStringLength);
              buffer.write(input);
              while (padLength--) {
                buffer.write('=', position++);
              }
              return buffer.toString();
            }
            exports.default = padString;
          }.call(this, require('buffer').Buffer));
        },
        { buffer: 183 }
      ],
      70: [
        function(require, module, exports) {
          module.exports = require('./dist/base64url').default;
          module.exports.default = module.exports;
        },
        { './dist/base64url': 68 }
      ],
      71: [
        function(require, module, exports) {
          'use strict';
          var ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
          var ALPHABET_MAP = {};
          for (var z = 0; z < ALPHABET.length; z++) {
            var x = ALPHABET.charAt(z);
            if (ALPHABET_MAP[x] !== undefined)
              throw new TypeError(x + ' is ambiguous');
            ALPHABET_MAP[x] = z;
          }
          function polymodStep(pre) {
            var b = pre >> 25;
            return (
              ((pre & 33554431) << 5) ^
              (-((b >> 0) & 1) & 996825010) ^
              (-((b >> 1) & 1) & 642813549) ^
              (-((b >> 2) & 1) & 513874426) ^
              (-((b >> 3) & 1) & 1027748829) ^
              (-((b >> 4) & 1) & 705979059)
            );
          }
          function prefixChk(prefix) {
            var chk = 1;
            for (var i = 0; i < prefix.length; ++i) {
              var c = prefix.charCodeAt(i);
              if (c < 33 || c > 126)
                throw new Error('Invalid prefix (' + prefix + ')');
              chk = polymodStep(chk) ^ (c >> 5);
            }
            chk = polymodStep(chk);
            for (i = 0; i < prefix.length; ++i) {
              var v = prefix.charCodeAt(i);
              chk = polymodStep(chk) ^ (v & 31);
            }
            return chk;
          }
          function encode(prefix, words, LIMIT) {
            LIMIT = LIMIT || 90;
            if (prefix.length + 7 + words.length > LIMIT)
              throw new TypeError('Exceeds length limit');
            prefix = prefix.toLowerCase();
            var chk = prefixChk(prefix);
            var result = prefix + '1';
            for (var i = 0; i < words.length; ++i) {
              var x = words[i];
              if (x >> 5 !== 0) throw new Error('Non 5-bit word');
              chk = polymodStep(chk) ^ x;
              result += ALPHABET.charAt(x);
            }
            for (i = 0; i < 6; ++i) {
              chk = polymodStep(chk);
            }
            chk ^= 1;
            for (i = 0; i < 6; ++i) {
              var v = (chk >> ((5 - i) * 5)) & 31;
              result += ALPHABET.charAt(v);
            }
            return result;
          }
          function decode(str, LIMIT) {
            LIMIT = LIMIT || 90;
            if (str.length < 8) throw new TypeError(str + ' too short');
            if (str.length > LIMIT) throw new TypeError('Exceeds length limit');
            var lowered = str.toLowerCase();
            var uppered = str.toUpperCase();
            if (str !== lowered && str !== uppered)
              throw new Error('Mixed-case string ' + str);
            str = lowered;
            var split = str.lastIndexOf('1');
            if (split === -1)
              throw new Error('No separator character for ' + str);
            if (split === 0) throw new Error('Missing prefix for ' + str);
            var prefix = str.slice(0, split);
            var wordChars = str.slice(split + 1);
            if (wordChars.length < 6) throw new Error('Data too short');
            var chk = prefixChk(prefix);
            var words = [];
            for (var i = 0; i < wordChars.length; ++i) {
              var c = wordChars.charAt(i);
              var v = ALPHABET_MAP[c];
              if (v === undefined) throw new Error('Unknown character ' + c);
              chk = polymodStep(chk) ^ v;
              if (i + 6 >= wordChars.length) continue;
              words.push(v);
            }
            if (chk !== 1) throw new Error('Invalid checksum for ' + str);
            return { prefix: prefix, words: words };
          }
          function convert(data, inBits, outBits, pad) {
            var value = 0;
            var bits = 0;
            var maxV = (1 << outBits) - 1;
            var result = [];
            for (var i = 0; i < data.length; ++i) {
              value = (value << inBits) | data[i];
              bits += inBits;
              while (bits >= outBits) {
                bits -= outBits;
                result.push((value >> bits) & maxV);
              }
            }
            if (pad) {
              if (bits > 0) {
                result.push((value << (outBits - bits)) & maxV);
              }
            } else {
              if (bits >= inBits) throw new Error('Excess padding');
              if ((value << (outBits - bits)) & maxV)
                throw new Error('Non-zero padding');
            }
            return result;
          }
          function toWords(bytes) {
            return convert(bytes, 8, 5, true);
          }
          function fromWords(words) {
            return convert(words, 5, 8, false);
          }
          module.exports = {
            decode: decode,
            encode: encode,
            toWords: toWords,
            fromWords: fromWords
          };
        },
        {}
      ],
      72: [
        function(require, module, exports) {
          function BigInteger(a, b, c) {
            if (!(this instanceof BigInteger)) return new BigInteger(a, b, c);
            if (a != null) {
              if ('number' == typeof a) this.fromNumber(a, b, c);
              else if (b == null && 'string' != typeof a)
                this.fromString(a, 256);
              else this.fromString(a, b);
            }
          }
          var proto = BigInteger.prototype;
          proto.__bigi = require('../package.json').version;
          BigInteger.isBigInteger = function(obj, check_ver) {
            return (
              obj && obj.__bigi && (!check_ver || obj.__bigi === proto.__bigi)
            );
          };
          var dbits;
          function am1(i, x, w, j, c, n) {
            while (--n >= 0) {
              var v = x * this[i++] + w[j] + c;
              c = Math.floor(v / 67108864);
              w[j++] = v & 67108863;
            }
            return c;
          }
          function am2(i, x, w, j, c, n) {
            var xl = x & 32767,
              xh = x >> 15;
            while (--n >= 0) {
              var l = this[i] & 32767;
              var h = this[i++] >> 15;
              var m = xh * l + h * xl;
              l = xl * l + ((m & 32767) << 15) + w[j] + (c & 1073741823);
              c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
              w[j++] = l & 1073741823;
            }
            return c;
          }
          function am3(i, x, w, j, c, n) {
            var xl = x & 16383,
              xh = x >> 14;
            while (--n >= 0) {
              var l = this[i] & 16383;
              var h = this[i++] >> 14;
              var m = xh * l + h * xl;
              l = xl * l + ((m & 16383) << 14) + w[j] + c;
              c = (l >> 28) + (m >> 14) + xh * h;
              w[j++] = l & 268435455;
            }
            return c;
          }
          BigInteger.prototype.am = am1;
          dbits = 26;
          BigInteger.prototype.DB = dbits;
          BigInteger.prototype.DM = (1 << dbits) - 1;
          var DV = (BigInteger.prototype.DV = 1 << dbits);
          var BI_FP = 52;
          BigInteger.prototype.FV = Math.pow(2, BI_FP);
          BigInteger.prototype.F1 = BI_FP - dbits;
          BigInteger.prototype.F2 = 2 * dbits - BI_FP;
          var BI_RM = '0123456789abcdefghijklmnopqrstuvwxyz';
          var BI_RC = new Array();
          var rr, vv;
          rr = '0'.charCodeAt(0);
          for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
          rr = 'a'.charCodeAt(0);
          for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
          rr = 'A'.charCodeAt(0);
          for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
          function int2char(n) {
            return BI_RM.charAt(n);
          }
          function intAt(s, i) {
            var c = BI_RC[s.charCodeAt(i)];
            return c == null ? -1 : c;
          }
          function bnpCopyTo(r) {
            for (var i = this.t - 1; i >= 0; --i) r[i] = this[i];
            r.t = this.t;
            r.s = this.s;
          }
          function bnpFromInt(x) {
            this.t = 1;
            this.s = x < 0 ? -1 : 0;
            if (x > 0) this[0] = x;
            else if (x < -1) this[0] = x + DV;
            else this.t = 0;
          }
          function nbv(i) {
            var r = new BigInteger();
            r.fromInt(i);
            return r;
          }
          function bnpFromString(s, b) {
            var self = this;
            var k;
            if (b == 16) k = 4;
            else if (b == 8) k = 3;
            else if (b == 256) k = 8;
            else if (b == 2) k = 1;
            else if (b == 32) k = 5;
            else if (b == 4) k = 2;
            else {
              self.fromRadix(s, b);
              return;
            }
            self.t = 0;
            self.s = 0;
            var i = s.length,
              mi = false,
              sh = 0;
            while (--i >= 0) {
              var x = k == 8 ? s[i] & 255 : intAt(s, i);
              if (x < 0) {
                if (s.charAt(i) == '-') mi = true;
                continue;
              }
              mi = false;
              if (sh == 0) self[self.t++] = x;
              else if (sh + k > self.DB) {
                self[self.t - 1] |= (x & ((1 << (self.DB - sh)) - 1)) << sh;
                self[self.t++] = x >> (self.DB - sh);
              } else self[self.t - 1] |= x << sh;
              sh += k;
              if (sh >= self.DB) sh -= self.DB;
            }
            if (k == 8 && (s[0] & 128) != 0) {
              self.s = -1;
              if (sh > 0) self[self.t - 1] |= ((1 << (self.DB - sh)) - 1) << sh;
            }
            self.clamp();
            if (mi) BigInteger.ZERO.subTo(self, self);
          }
          function bnpClamp() {
            var c = this.s & this.DM;
            while (this.t > 0 && this[this.t - 1] == c) --this.t;
          }
          function bnToString(b) {
            var self = this;
            if (self.s < 0) return '-' + self.negate().toString(b);
            var k;
            if (b == 16) k = 4;
            else if (b == 8) k = 3;
            else if (b == 2) k = 1;
            else if (b == 32) k = 5;
            else if (b == 4) k = 2;
            else return self.toRadix(b);
            var km = (1 << k) - 1,
              d,
              m = false,
              r = '',
              i = self.t;
            var p = self.DB - ((i * self.DB) % k);
            if (i-- > 0) {
              if (p < self.DB && (d = self[i] >> p) > 0) {
                m = true;
                r = int2char(d);
              }
              while (i >= 0) {
                if (p < k) {
                  d = (self[i] & ((1 << p) - 1)) << (k - p);
                  d |= self[--i] >> (p += self.DB - k);
                } else {
                  d = (self[i] >> (p -= k)) & km;
                  if (p <= 0) {
                    p += self.DB;
                    --i;
                  }
                }
                if (d > 0) m = true;
                if (m) r += int2char(d);
              }
            }
            return m ? r : '0';
          }
          function bnNegate() {
            var r = new BigInteger();
            BigInteger.ZERO.subTo(this, r);
            return r;
          }
          function bnAbs() {
            return this.s < 0 ? this.negate() : this;
          }
          function bnCompareTo(a) {
            var r = this.s - a.s;
            if (r != 0) return r;
            var i = this.t;
            r = i - a.t;
            if (r != 0) return this.s < 0 ? -r : r;
            while (--i >= 0) if ((r = this[i] - a[i]) != 0) return r;
            return 0;
          }
          function nbits(x) {
            var r = 1,
              t;
            if ((t = x >>> 16) != 0) {
              x = t;
              r += 16;
            }
            if ((t = x >> 8) != 0) {
              x = t;
              r += 8;
            }
            if ((t = x >> 4) != 0) {
              x = t;
              r += 4;
            }
            if ((t = x >> 2) != 0) {
              x = t;
              r += 2;
            }
            if ((t = x >> 1) != 0) {
              x = t;
              r += 1;
            }
            return r;
          }
          function bnBitLength() {
            if (this.t <= 0) return 0;
            return (
              this.DB * (this.t - 1) +
              nbits(this[this.t - 1] ^ (this.s & this.DM))
            );
          }
          function bnByteLength() {
            return this.bitLength() >> 3;
          }
          function bnpDLShiftTo(n, r) {
            var i;
            for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i];
            for (i = n - 1; i >= 0; --i) r[i] = 0;
            r.t = this.t + n;
            r.s = this.s;
          }
          function bnpDRShiftTo(n, r) {
            for (var i = n; i < this.t; ++i) r[i - n] = this[i];
            r.t = Math.max(this.t - n, 0);
            r.s = this.s;
          }
          function bnpLShiftTo(n, r) {
            var self = this;
            var bs = n % self.DB;
            var cbs = self.DB - bs;
            var bm = (1 << cbs) - 1;
            var ds = Math.floor(n / self.DB),
              c = (self.s << bs) & self.DM,
              i;
            for (i = self.t - 1; i >= 0; --i) {
              r[i + ds + 1] = (self[i] >> cbs) | c;
              c = (self[i] & bm) << bs;
            }
            for (i = ds - 1; i >= 0; --i) r[i] = 0;
            r[ds] = c;
            r.t = self.t + ds + 1;
            r.s = self.s;
            r.clamp();
          }
          function bnpRShiftTo(n, r) {
            var self = this;
            r.s = self.s;
            var ds = Math.floor(n / self.DB);
            if (ds >= self.t) {
              r.t = 0;
              return;
            }
            var bs = n % self.DB;
            var cbs = self.DB - bs;
            var bm = (1 << bs) - 1;
            r[0] = self[ds] >> bs;
            for (var i = ds + 1; i < self.t; ++i) {
              r[i - ds - 1] |= (self[i] & bm) << cbs;
              r[i - ds] = self[i] >> bs;
            }
            if (bs > 0) r[self.t - ds - 1] |= (self.s & bm) << cbs;
            r.t = self.t - ds;
            r.clamp();
          }
          function bnpSubTo(a, r) {
            var self = this;
            var i = 0,
              c = 0,
              m = Math.min(a.t, self.t);
            while (i < m) {
              c += self[i] - a[i];
              r[i++] = c & self.DM;
              c >>= self.DB;
            }
            if (a.t < self.t) {
              c -= a.s;
              while (i < self.t) {
                c += self[i];
                r[i++] = c & self.DM;
                c >>= self.DB;
              }
              c += self.s;
            } else {
              c += self.s;
              while (i < a.t) {
                c -= a[i];
                r[i++] = c & self.DM;
                c >>= self.DB;
              }
              c -= a.s;
            }
            r.s = c < 0 ? -1 : 0;
            if (c < -1) r[i++] = self.DV + c;
            else if (c > 0) r[i++] = c;
            r.t = i;
            r.clamp();
          }
          function bnpMultiplyTo(a, r) {
            var x = this.abs(),
              y = a.abs();
            var i = x.t;
            r.t = i + y.t;
            while (--i >= 0) r[i] = 0;
            for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
            r.s = 0;
            r.clamp();
            if (this.s != a.s) BigInteger.ZERO.subTo(r, r);
          }
          function bnpSquareTo(r) {
            var x = this.abs();
            var i = (r.t = 2 * x.t);
            while (--i >= 0) r[i] = 0;
            for (i = 0; i < x.t - 1; ++i) {
              var c = x.am(i, x[i], r, 2 * i, 0, 1);
              if (
                (r[i + x.t] += x.am(
                  i + 1,
                  2 * x[i],
                  r,
                  2 * i + 1,
                  c,
                  x.t - i - 1
                )) >= x.DV
              ) {
                r[i + x.t] -= x.DV;
                r[i + x.t + 1] = 1;
              }
            }
            if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
            r.s = 0;
            r.clamp();
          }
          function bnpDivRemTo(m, q, r) {
            var self = this;
            var pm = m.abs();
            if (pm.t <= 0) return;
            var pt = self.abs();
            if (pt.t < pm.t) {
              if (q != null) q.fromInt(0);
              if (r != null) self.copyTo(r);
              return;
            }
            if (r == null) r = new BigInteger();
            var y = new BigInteger(),
              ts = self.s,
              ms = m.s;
            var nsh = self.DB - nbits(pm[pm.t - 1]);
            if (nsh > 0) {
              pm.lShiftTo(nsh, y);
              pt.lShiftTo(nsh, r);
            } else {
              pm.copyTo(y);
              pt.copyTo(r);
            }
            var ys = y.t;
            var y0 = y[ys - 1];
            if (y0 == 0) return;
            var yt = y0 * (1 << self.F1) + (ys > 1 ? y[ys - 2] >> self.F2 : 0);
            var d1 = self.FV / yt,
              d2 = (1 << self.F1) / yt,
              e = 1 << self.F2;
            var i = r.t,
              j = i - ys,
              t = q == null ? new BigInteger() : q;
            y.dlShiftTo(j, t);
            if (r.compareTo(t) >= 0) {
              r[r.t++] = 1;
              r.subTo(t, r);
            }
            BigInteger.ONE.dlShiftTo(ys, t);
            t.subTo(y, y);
            while (y.t < ys) y[y.t++] = 0;
            while (--j >= 0) {
              var qd =
                r[--i] == y0
                  ? self.DM
                  : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
              if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
                y.dlShiftTo(j, t);
                r.subTo(t, r);
                while (r[i] < --qd) r.subTo(t, r);
              }
            }
            if (q != null) {
              r.drShiftTo(ys, q);
              if (ts != ms) BigInteger.ZERO.subTo(q, q);
            }
            r.t = ys;
            r.clamp();
            if (nsh > 0) r.rShiftTo(nsh, r);
            if (ts < 0) BigInteger.ZERO.subTo(r, r);
          }
          function bnMod(a) {
            var r = new BigInteger();
            this.abs().divRemTo(a, null, r);
            if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);
            return r;
          }
          function Classic(m) {
            this.m = m;
          }
          function cConvert(x) {
            if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
            else return x;
          }
          function cRevert(x) {
            return x;
          }
          function cReduce(x) {
            x.divRemTo(this.m, null, x);
          }
          function cMulTo(x, y, r) {
            x.multiplyTo(y, r);
            this.reduce(r);
          }
          function cSqrTo(x, r) {
            x.squareTo(r);
            this.reduce(r);
          }
          Classic.prototype.convert = cConvert;
          Classic.prototype.revert = cRevert;
          Classic.prototype.reduce = cReduce;
          Classic.prototype.mulTo = cMulTo;
          Classic.prototype.sqrTo = cSqrTo;
          function bnpInvDigit() {
            if (this.t < 1) return 0;
            var x = this[0];
            if ((x & 1) == 0) return 0;
            var y = x & 3;
            y = (y * (2 - (x & 15) * y)) & 15;
            y = (y * (2 - (x & 255) * y)) & 255;
            y = (y * (2 - (((x & 65535) * y) & 65535))) & 65535;
            y = (y * (2 - ((x * y) % this.DV))) % this.DV;
            return y > 0 ? this.DV - y : -y;
          }
          function Montgomery(m) {
            this.m = m;
            this.mp = m.invDigit();
            this.mpl = this.mp & 32767;
            this.mph = this.mp >> 15;
            this.um = (1 << (m.DB - 15)) - 1;
            this.mt2 = 2 * m.t;
          }
          function montConvert(x) {
            var r = new BigInteger();
            x.abs().dlShiftTo(this.m.t, r);
            r.divRemTo(this.m, null, r);
            if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);
            return r;
          }
          function montRevert(x) {
            var r = new BigInteger();
            x.copyTo(r);
            this.reduce(r);
            return r;
          }
          function montReduce(x) {
            while (x.t <= this.mt2) x[x.t++] = 0;
            for (var i = 0; i < this.m.t; ++i) {
              var j = x[i] & 32767;
              var u0 =
                (j * this.mpl +
                  (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) <<
                    15)) &
                x.DM;
              j = i + this.m.t;
              x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
              while (x[j] >= x.DV) {
                x[j] -= x.DV;
                x[++j]++;
              }
            }
            x.clamp();
            x.drShiftTo(this.m.t, x);
            if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
          }
          function montSqrTo(x, r) {
            x.squareTo(r);
            this.reduce(r);
          }
          function montMulTo(x, y, r) {
            x.multiplyTo(y, r);
            this.reduce(r);
          }
          Montgomery.prototype.convert = montConvert;
          Montgomery.prototype.revert = montRevert;
          Montgomery.prototype.reduce = montReduce;
          Montgomery.prototype.mulTo = montMulTo;
          Montgomery.prototype.sqrTo = montSqrTo;
          function bnpIsEven() {
            return (this.t > 0 ? this[0] & 1 : this.s) == 0;
          }
          function bnpExp(e, z) {
            if (e > 4294967295 || e < 1) return BigInteger.ONE;
            var r = new BigInteger(),
              r2 = new BigInteger(),
              g = z.convert(this),
              i = nbits(e) - 1;
            g.copyTo(r);
            while (--i >= 0) {
              z.sqrTo(r, r2);
              if ((e & (1 << i)) > 0) z.mulTo(r2, g, r);
              else {
                var t = r;
                r = r2;
                r2 = t;
              }
            }
            return z.revert(r);
          }
          function bnModPowInt(e, m) {
            var z;
            if (e < 256 || m.isEven()) z = new Classic(m);
            else z = new Montgomery(m);
            return this.exp(e, z);
          }
          proto.copyTo = bnpCopyTo;
          proto.fromInt = bnpFromInt;
          proto.fromString = bnpFromString;
          proto.clamp = bnpClamp;
          proto.dlShiftTo = bnpDLShiftTo;
          proto.drShiftTo = bnpDRShiftTo;
          proto.lShiftTo = bnpLShiftTo;
          proto.rShiftTo = bnpRShiftTo;
          proto.subTo = bnpSubTo;
          proto.multiplyTo = bnpMultiplyTo;
          proto.squareTo = bnpSquareTo;
          proto.divRemTo = bnpDivRemTo;
          proto.invDigit = bnpInvDigit;
          proto.isEven = bnpIsEven;
          proto.exp = bnpExp;
          proto.toString = bnToString;
          proto.negate = bnNegate;
          proto.abs = bnAbs;
          proto.compareTo = bnCompareTo;
          proto.bitLength = bnBitLength;
          proto.byteLength = bnByteLength;
          proto.mod = bnMod;
          proto.modPowInt = bnModPowInt;
          function bnClone() {
            var r = new BigInteger();
            this.copyTo(r);
            return r;
          }
          function bnIntValue() {
            if (this.s < 0) {
              if (this.t == 1) return this[0] - this.DV;
              else if (this.t == 0) return -1;
            } else if (this.t == 1) return this[0];
            else if (this.t == 0) return 0;
            return (
              ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0]
            );
          }
          function bnByteValue() {
            return this.t == 0 ? this.s : (this[0] << 24) >> 24;
          }
          function bnShortValue() {
            return this.t == 0 ? this.s : (this[0] << 16) >> 16;
          }
          function bnpChunkSize(r) {
            return Math.floor((Math.LN2 * this.DB) / Math.log(r));
          }
          function bnSigNum() {
            if (this.s < 0) return -1;
            else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;
            else return 1;
          }
          function bnpToRadix(b) {
            if (b == null) b = 10;
            if (this.signum() == 0 || b < 2 || b > 36) return '0';
            var cs = this.chunkSize(b);
            var a = Math.pow(b, cs);
            var d = nbv(a),
              y = new BigInteger(),
              z = new BigInteger(),
              r = '';
            this.divRemTo(d, y, z);
            while (y.signum() > 0) {
              r = (a + z.intValue()).toString(b).substr(1) + r;
              y.divRemTo(d, y, z);
            }
            return z.intValue().toString(b) + r;
          }
          function bnpFromRadix(s, b) {
            var self = this;
            self.fromInt(0);
            if (b == null) b = 10;
            var cs = self.chunkSize(b);
            var d = Math.pow(b, cs),
              mi = false,
              j = 0,
              w = 0;
            for (var i = 0; i < s.length; ++i) {
              var x = intAt(s, i);
              if (x < 0) {
                if (s.charAt(i) == '-' && self.signum() == 0) mi = true;
                continue;
              }
              w = b * w + x;
              if (++j >= cs) {
                self.dMultiply(d);
                self.dAddOffset(w, 0);
                j = 0;
                w = 0;
              }
            }
            if (j > 0) {
              self.dMultiply(Math.pow(b, j));
              self.dAddOffset(w, 0);
            }
            if (mi) BigInteger.ZERO.subTo(self, self);
          }
          function bnpFromNumber(a, b, c) {
            var self = this;
            if ('number' == typeof b) {
              if (a < 2) self.fromInt(1);
              else {
                self.fromNumber(a, c);
                if (!self.testBit(a - 1))
                  self.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, self);
                if (self.isEven()) self.dAddOffset(1, 0);
                while (!self.isProbablePrime(b)) {
                  self.dAddOffset(2, 0);
                  if (self.bitLength() > a)
                    self.subTo(BigInteger.ONE.shiftLeft(a - 1), self);
                }
              }
            } else {
              var x = new Array(),
                t = a & 7;
              x.length = (a >> 3) + 1;
              b.nextBytes(x);
              if (t > 0) x[0] &= (1 << t) - 1;
              else x[0] = 0;
              self.fromString(x, 256);
            }
          }
          function bnToByteArray() {
            var self = this;
            var i = self.t,
              r = new Array();
            r[0] = self.s;
            var p = self.DB - ((i * self.DB) % 8),
              d,
              k = 0;
            if (i-- > 0) {
              if (p < self.DB && (d = self[i] >> p) != (self.s & self.DM) >> p)
                r[k++] = d | (self.s << (self.DB - p));
              while (i >= 0) {
                if (p < 8) {
                  d = (self[i] & ((1 << p) - 1)) << (8 - p);
                  d |= self[--i] >> (p += self.DB - 8);
                } else {
                  d = (self[i] >> (p -= 8)) & 255;
                  if (p <= 0) {
                    p += self.DB;
                    --i;
                  }
                }
                if ((d & 128) != 0) d |= -256;
                if (k === 0 && (self.s & 128) != (d & 128)) ++k;
                if (k > 0 || d != self.s) r[k++] = d;
              }
            }
            return r;
          }
          function bnEquals(a) {
            return this.compareTo(a) == 0;
          }
          function bnMin(a) {
            return this.compareTo(a) < 0 ? this : a;
          }
          function bnMax(a) {
            return this.compareTo(a) > 0 ? this : a;
          }
          function bnpBitwiseTo(a, op, r) {
            var self = this;
            var i,
              f,
              m = Math.min(a.t, self.t);
            for (i = 0; i < m; ++i) r[i] = op(self[i], a[i]);
            if (a.t < self.t) {
              f = a.s & self.DM;
              for (i = m; i < self.t; ++i) r[i] = op(self[i], f);
              r.t = self.t;
            } else {
              f = self.s & self.DM;
              for (i = m; i < a.t; ++i) r[i] = op(f, a[i]);
              r.t = a.t;
            }
            r.s = op(self.s, a.s);
            r.clamp();
          }
          function op_and(x, y) {
            return x & y;
          }
          function bnAnd(a) {
            var r = new BigInteger();
            this.bitwiseTo(a, op_and, r);
            return r;
          }
          function op_or(x, y) {
            return x | y;
          }
          function bnOr(a) {
            var r = new BigInteger();
            this.bitwiseTo(a, op_or, r);
            return r;
          }
          function op_xor(x, y) {
            return x ^ y;
          }
          function bnXor(a) {
            var r = new BigInteger();
            this.bitwiseTo(a, op_xor, r);
            return r;
          }
          function op_andnot(x, y) {
            return x & ~y;
          }
          function bnAndNot(a) {
            var r = new BigInteger();
            this.bitwiseTo(a, op_andnot, r);
            return r;
          }
          function bnNot() {
            var r = new BigInteger();
            for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i];
            r.t = this.t;
            r.s = ~this.s;
            return r;
          }
          function bnShiftLeft(n) {
            var r = new BigInteger();
            if (n < 0) this.rShiftTo(-n, r);
            else this.lShiftTo(n, r);
            return r;
          }
          function bnShiftRight(n) {
            var r = new BigInteger();
            if (n < 0) this.lShiftTo(-n, r);
            else this.rShiftTo(n, r);
            return r;
          }
          function lbit(x) {
            if (x == 0) return -1;
            var r = 0;
            if ((x & 65535) == 0) {
              x >>= 16;
              r += 16;
            }
            if ((x & 255) == 0) {
              x >>= 8;
              r += 8;
            }
            if ((x & 15) == 0) {
              x >>= 4;
              r += 4;
            }
            if ((x & 3) == 0) {
              x >>= 2;
              r += 2;
            }
            if ((x & 1) == 0) ++r;
            return r;
          }
          function bnGetLowestSetBit() {
            for (var i = 0; i < this.t; ++i)
              if (this[i] != 0) return i * this.DB + lbit(this[i]);
            if (this.s < 0) return this.t * this.DB;
            return -1;
          }
          function cbit(x) {
            var r = 0;
            while (x != 0) {
              x &= x - 1;
              ++r;
            }
            return r;
          }
          function bnBitCount() {
            var r = 0,
              x = this.s & this.DM;
            for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x);
            return r;
          }
          function bnTestBit(n) {
            var j = Math.floor(n / this.DB);
            if (j >= this.t) return this.s != 0;
            return (this[j] & (1 << n % this.DB)) != 0;
          }
          function bnpChangeBit(n, op) {
            var r = BigInteger.ONE.shiftLeft(n);
            this.bitwiseTo(r, op, r);
            return r;
          }
          function bnSetBit(n) {
            return this.changeBit(n, op_or);
          }
          function bnClearBit(n) {
            return this.changeBit(n, op_andnot);
          }
          function bnFlipBit(n) {
            return this.changeBit(n, op_xor);
          }
          function bnpAddTo(a, r) {
            var self = this;
            var i = 0,
              c = 0,
              m = Math.min(a.t, self.t);
            while (i < m) {
              c += self[i] + a[i];
              r[i++] = c & self.DM;
              c >>= self.DB;
            }
            if (a.t < self.t) {
              c += a.s;
              while (i < self.t) {
                c += self[i];
                r[i++] = c & self.DM;
                c >>= self.DB;
              }
              c += self.s;
            } else {
              c += self.s;
              while (i < a.t) {
                c += a[i];
                r[i++] = c & self.DM;
                c >>= self.DB;
              }
              c += a.s;
            }
            r.s = c < 0 ? -1 : 0;
            if (c > 0) r[i++] = c;
            else if (c < -1) r[i++] = self.DV + c;
            r.t = i;
            r.clamp();
          }
          function bnAdd(a) {
            var r = new BigInteger();
            this.addTo(a, r);
            return r;
          }
          function bnSubtract(a) {
            var r = new BigInteger();
            this.subTo(a, r);
            return r;
          }
          function bnMultiply(a) {
            var r = new BigInteger();
            this.multiplyTo(a, r);
            return r;
          }
          function bnSquare() {
            var r = new BigInteger();
            this.squareTo(r);
            return r;
          }
          function bnDivide(a) {
            var r = new BigInteger();
            this.divRemTo(a, r, null);
            return r;
          }
          function bnRemainder(a) {
            var r = new BigInteger();
            this.divRemTo(a, null, r);
            return r;
          }
          function bnDivideAndRemainder(a) {
            var q = new BigInteger(),
              r = new BigInteger();
            this.divRemTo(a, q, r);
            return new Array(q, r);
          }
          function bnpDMultiply(n) {
            this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
            ++this.t;
            this.clamp();
          }
          function bnpDAddOffset(n, w) {
            if (n == 0) return;
            while (this.t <= w) this[this.t++] = 0;
            this[w] += n;
            while (this[w] >= this.DV) {
              this[w] -= this.DV;
              if (++w >= this.t) this[this.t++] = 0;
              ++this[w];
            }
          }
          function NullExp() {}
          function nNop(x) {
            return x;
          }
          function nMulTo(x, y, r) {
            x.multiplyTo(y, r);
          }
          function nSqrTo(x, r) {
            x.squareTo(r);
          }
          NullExp.prototype.convert = nNop;
          NullExp.prototype.revert = nNop;
          NullExp.prototype.mulTo = nMulTo;
          NullExp.prototype.sqrTo = nSqrTo;
          function bnPow(e) {
            return this.exp(e, new NullExp());
          }
          function bnpMultiplyLowerTo(a, n, r) {
            var i = Math.min(this.t + a.t, n);
            r.s = 0;
            r.t = i;
            while (i > 0) r[--i] = 0;
            var j;
            for (j = r.t - this.t; i < j; ++i)
              r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
            for (j = Math.min(a.t, n); i < j; ++i)
              this.am(0, a[i], r, i, 0, n - i);
            r.clamp();
          }
          function bnpMultiplyUpperTo(a, n, r) {
            --n;
            var i = (r.t = this.t + a.t - n);
            r.s = 0;
            while (--i >= 0) r[i] = 0;
            for (i = Math.max(n - this.t, 0); i < a.t; ++i)
              r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
            r.clamp();
            r.drShiftTo(1, r);
          }
          function Barrett(m) {
            this.r2 = new BigInteger();
            this.q3 = new BigInteger();
            BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
            this.mu = this.r2.divide(m);
            this.m = m;
          }
          function barrettConvert(x) {
            if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);
            else if (x.compareTo(this.m) < 0) return x;
            else {
              var r = new BigInteger();
              x.copyTo(r);
              this.reduce(r);
              return r;
            }
          }
          function barrettRevert(x) {
            return x;
          }
          function barrettReduce(x) {
            var self = this;
            x.drShiftTo(self.m.t - 1, self.r2);
            if (x.t > self.m.t + 1) {
              x.t = self.m.t + 1;
              x.clamp();
            }
            self.mu.multiplyUpperTo(self.r2, self.m.t + 1, self.q3);
            self.m.multiplyLowerTo(self.q3, self.m.t + 1, self.r2);
            while (x.compareTo(self.r2) < 0) x.dAddOffset(1, self.m.t + 1);
            x.subTo(self.r2, x);
            while (x.compareTo(self.m) >= 0) x.subTo(self.m, x);
          }
          function barrettSqrTo(x, r) {
            x.squareTo(r);
            this.reduce(r);
          }
          function barrettMulTo(x, y, r) {
            x.multiplyTo(y, r);
            this.reduce(r);
          }
          Barrett.prototype.convert = barrettConvert;
          Barrett.prototype.revert = barrettRevert;
          Barrett.prototype.reduce = barrettReduce;
          Barrett.prototype.mulTo = barrettMulTo;
          Barrett.prototype.sqrTo = barrettSqrTo;
          function bnModPow(e, m) {
            var i = e.bitLength(),
              k,
              r = nbv(1),
              z;
            if (i <= 0) return r;
            else if (i < 18) k = 1;
            else if (i < 48) k = 3;
            else if (i < 144) k = 4;
            else if (i < 768) k = 5;
            else k = 6;
            if (i < 8) z = new Classic(m);
            else if (m.isEven()) z = new Barrett(m);
            else z = new Montgomery(m);
            var g = new Array(),
              n = 3,
              k1 = k - 1,
              km = (1 << k) - 1;
            g[1] = z.convert(this);
            if (k > 1) {
              var g2 = new BigInteger();
              z.sqrTo(g[1], g2);
              while (n <= km) {
                g[n] = new BigInteger();
                z.mulTo(g2, g[n - 2], g[n]);
                n += 2;
              }
            }
            var j = e.t - 1,
              w,
              is1 = true,
              r2 = new BigInteger(),
              t;
            i = nbits(e[j]) - 1;
            while (j >= 0) {
              if (i >= k1) w = (e[j] >> (i - k1)) & km;
              else {
                w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);
                if (j > 0) w |= e[j - 1] >> (this.DB + i - k1);
              }
              n = k;
              while ((w & 1) == 0) {
                w >>= 1;
                --n;
              }
              if ((i -= n) < 0) {
                i += this.DB;
                --j;
              }
              if (is1) {
                g[w].copyTo(r);
                is1 = false;
              } else {
                while (n > 1) {
                  z.sqrTo(r, r2);
                  z.sqrTo(r2, r);
                  n -= 2;
                }
                if (n > 0) z.sqrTo(r, r2);
                else {
                  t = r;
                  r = r2;
                  r2 = t;
                }
                z.mulTo(r2, g[w], r);
              }
              while (j >= 0 && (e[j] & (1 << i)) == 0) {
                z.sqrTo(r, r2);
                t = r;
                r = r2;
                r2 = t;
                if (--i < 0) {
                  i = this.DB - 1;
                  --j;
                }
              }
            }
            return z.revert(r);
          }
          function bnGCD(a) {
            var x = this.s < 0 ? this.negate() : this.clone();
            var y = a.s < 0 ? a.negate() : a.clone();
            if (x.compareTo(y) < 0) {
              var t = x;
              x = y;
              y = t;
            }
            var i = x.getLowestSetBit(),
              g = y.getLowestSetBit();
            if (g < 0) return x;
            if (i < g) g = i;
            if (g > 0) {
              x.rShiftTo(g, x);
              y.rShiftTo(g, y);
            }
            while (x.signum() > 0) {
              if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);
              if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);
              if (x.compareTo(y) >= 0) {
                x.subTo(y, x);
                x.rShiftTo(1, x);
              } else {
                y.subTo(x, y);
                y.rShiftTo(1, y);
              }
            }
            if (g > 0) y.lShiftTo(g, y);
            return y;
          }
          function bnpModInt(n) {
            if (n <= 0) return 0;
            var d = this.DV % n,
              r = this.s < 0 ? n - 1 : 0;
            if (this.t > 0)
              if (d == 0) r = this[0] % n;
              else
                for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n;
            return r;
          }
          function bnModInverse(m) {
            var ac = m.isEven();
            if (this.signum() === 0) throw new Error('division by zero');
            if ((this.isEven() && ac) || m.signum() == 0)
              return BigInteger.ZERO;
            var u = m.clone(),
              v = this.clone();
            var a = nbv(1),
              b = nbv(0),
              c = nbv(0),
              d = nbv(1);
            while (u.signum() != 0) {
              while (u.isEven()) {
                u.rShiftTo(1, u);
                if (ac) {
                  if (!a.isEven() || !b.isEven()) {
                    a.addTo(this, a);
                    b.subTo(m, b);
                  }
                  a.rShiftTo(1, a);
                } else if (!b.isEven()) b.subTo(m, b);
                b.rShiftTo(1, b);
              }
              while (v.isEven()) {
                v.rShiftTo(1, v);
                if (ac) {
                  if (!c.isEven() || !d.isEven()) {
                    c.addTo(this, c);
                    d.subTo(m, d);
                  }
                  c.rShiftTo(1, c);
                } else if (!d.isEven()) d.subTo(m, d);
                d.rShiftTo(1, d);
              }
              if (u.compareTo(v) >= 0) {
                u.subTo(v, u);
                if (ac) a.subTo(c, a);
                b.subTo(d, b);
              } else {
                v.subTo(u, v);
                if (ac) c.subTo(a, c);
                d.subTo(b, d);
              }
            }
            if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
            while (d.compareTo(m) >= 0) d.subTo(m, d);
            while (d.signum() < 0) d.addTo(m, d);
            return d;
          }
          var lowprimes = [
            2,
            3,
            5,
            7,
            11,
            13,
            17,
            19,
            23,
            29,
            31,
            37,
            41,
            43,
            47,
            53,
            59,
            61,
            67,
            71,
            73,
            79,
            83,
            89,
            97,
            101,
            103,
            107,
            109,
            113,
            127,
            131,
            137,
            139,
            149,
            151,
            157,
            163,
            167,
            173,
            179,
            181,
            191,
            193,
            197,
            199,
            211,
            223,
            227,
            229,
            233,
            239,
            241,
            251,
            257,
            263,
            269,
            271,
            277,
            281,
            283,
            293,
            307,
            311,
            313,
            317,
            331,
            337,
            347,
            349,
            353,
            359,
            367,
            373,
            379,
            383,
            389,
            397,
            401,
            409,
            419,
            421,
            431,
            433,
            439,
            443,
            449,
            457,
            461,
            463,
            467,
            479,
            487,
            491,
            499,
            503,
            509,
            521,
            523,
            541,
            547,
            557,
            563,
            569,
            571,
            577,
            587,
            593,
            599,
            601,
            607,
            613,
            617,
            619,
            631,
            641,
            643,
            647,
            653,
            659,
            661,
            673,
            677,
            683,
            691,
            701,
            709,
            719,
            727,
            733,
            739,
            743,
            751,
            757,
            761,
            769,
            773,
            787,
            797,
            809,
            811,
            821,
            823,
            827,
            829,
            839,
            853,
            857,
            859,
            863,
            877,
            881,
            883,
            887,
            907,
            911,
            919,
            929,
            937,
            941,
            947,
            953,
            967,
            971,
            977,
            983,
            991,
            997
          ];
          var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
          function bnIsProbablePrime(t) {
            var i,
              x = this.abs();
            if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
              for (i = 0; i < lowprimes.length; ++i)
                if (x[0] == lowprimes[i]) return true;
              return false;
            }
            if (x.isEven()) return false;
            i = 1;
            while (i < lowprimes.length) {
              var m = lowprimes[i],
                j = i + 1;
              while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];
              m = x.modInt(m);
              while (i < j) if (m % lowprimes[i++] == 0) return false;
            }
            return x.millerRabin(t);
          }
          function bnpMillerRabin(t) {
            var n1 = this.subtract(BigInteger.ONE);
            var k = n1.getLowestSetBit();
            if (k <= 0) return false;
            var r = n1.shiftRight(k);
            t = (t + 1) >> 1;
            if (t > lowprimes.length) t = lowprimes.length;
            var a = new BigInteger(null);
            var j,
              bases = [];
            for (var i = 0; i < t; ++i) {
              for (;;) {
                j = lowprimes[Math.floor(Math.random() * lowprimes.length)];
                if (bases.indexOf(j) == -1) break;
              }
              bases.push(j);
              a.fromInt(j);
              var y = a.modPow(r, this);
              if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
                var j = 1;
                while (j++ < k && y.compareTo(n1) != 0) {
                  y = y.modPowInt(2, this);
                  if (y.compareTo(BigInteger.ONE) == 0) return false;
                }
                if (y.compareTo(n1) != 0) return false;
              }
            }
            return true;
          }
          proto.chunkSize = bnpChunkSize;
          proto.toRadix = bnpToRadix;
          proto.fromRadix = bnpFromRadix;
          proto.fromNumber = bnpFromNumber;
          proto.bitwiseTo = bnpBitwiseTo;
          proto.changeBit = bnpChangeBit;
          proto.addTo = bnpAddTo;
          proto.dMultiply = bnpDMultiply;
          proto.dAddOffset = bnpDAddOffset;
          proto.multiplyLowerTo = bnpMultiplyLowerTo;
          proto.multiplyUpperTo = bnpMultiplyUpperTo;
          proto.modInt = bnpModInt;
          proto.millerRabin = bnpMillerRabin;
          proto.clone = bnClone;
          proto.intValue = bnIntValue;
          proto.byteValue = bnByteValue;
          proto.shortValue = bnShortValue;
          proto.signum = bnSigNum;
          proto.toByteArray = bnToByteArray;
          proto.equals = bnEquals;
          proto.min = bnMin;
          proto.max = bnMax;
          proto.and = bnAnd;
          proto.or = bnOr;
          proto.xor = bnXor;
          proto.andNot = bnAndNot;
          proto.not = bnNot;
          proto.shiftLeft = bnShiftLeft;
          proto.shiftRight = bnShiftRight;
          proto.getLowestSetBit = bnGetLowestSetBit;
          proto.bitCount = bnBitCount;
          proto.testBit = bnTestBit;
          proto.setBit = bnSetBit;
          proto.clearBit = bnClearBit;
          proto.flipBit = bnFlipBit;
          proto.add = bnAdd;
          proto.subtract = bnSubtract;
          proto.multiply = bnMultiply;
          proto.divide = bnDivide;
          proto.remainder = bnRemainder;
          proto.divideAndRemainder = bnDivideAndRemainder;
          proto.modPow = bnModPow;
          proto.modInverse = bnModInverse;
          proto.pow = bnPow;
          proto.gcd = bnGCD;
          proto.isProbablePrime = bnIsProbablePrime;
          proto.square = bnSquare;
          BigInteger.ZERO = nbv(0);
          BigInteger.ONE = nbv(1);
          BigInteger.valueOf = nbv;
          module.exports = BigInteger;
        },
        { '../package.json': 75 }
      ],
      73: [
        function(require, module, exports) {
          (function(Buffer) {
            var assert = require('assert');
            var BigInteger = require('./bigi');
            BigInteger.fromByteArrayUnsigned = function(byteArray) {
              if (byteArray[0] & 128) {
                return new BigInteger([0].concat(byteArray));
              }
              return new BigInteger(byteArray);
            };
            BigInteger.prototype.toByteArrayUnsigned = function() {
              var byteArray = this.toByteArray();
              return byteArray[0] === 0 ? byteArray.slice(1) : byteArray;
            };
            BigInteger.fromDERInteger = function(byteArray) {
              return new BigInteger(byteArray);
            };
            BigInteger.prototype.toDERInteger =
              BigInteger.prototype.toByteArray;
            BigInteger.fromBuffer = function(buffer) {
              if (buffer[0] & 128) {
                var byteArray = Array.prototype.slice.call(buffer);
                return new BigInteger([0].concat(byteArray));
              }
              return new BigInteger(buffer);
            };
            BigInteger.fromHex = function(hex) {
              if (hex === '') return BigInteger.ZERO;
              assert.equal(
                hex,
                hex.match(/^[A-Fa-f0-9]+/),
                'Invalid hex string'
              );
              assert.equal(hex.length % 2, 0, 'Incomplete hex');
              return new BigInteger(hex, 16);
            };
            BigInteger.prototype.toBuffer = function(size) {
              var byteArray = this.toByteArrayUnsigned();
              var zeros = [];
              var padding = size - byteArray.length;
              while (zeros.length < padding) zeros.push(0);
              return new Buffer(zeros.concat(byteArray));
            };
            BigInteger.prototype.toHex = function(size) {
              return this.toBuffer(size).toString('hex');
            };
          }.call(this, require('buffer').Buffer));
        },
        { './bigi': 72, assert: 151, buffer: 183 }
      ],
      74: [
        function(require, module, exports) {
          var BigInteger = require('./bigi');
          require('./convert');
          module.exports = BigInteger;
        },
        { './bigi': 72, './convert': 73 }
      ],
      75: [
        function(require, module, exports) {
          module.exports = {
            _args: [
              [
                'bigi@1.4.2',
                '/Users/Yukan/Desktop/work/blockstack/blockstack.js'
              ]
            ],
            _from: 'bigi@1.4.2',
            _id: 'bigi@1.4.2',
            _inBundle: false,
            _integrity: 'sha1-nGZalfiLiwj8Bc/XMfVhhZ1yWCU=',
            _location: '/bigi',
            _phantomChildren: {},
            _requested: {
              type: 'version',
              registry: true,
              raw: 'bigi@1.4.2',
              name: 'bigi',
              escapedName: 'bigi',
              rawSpec: '1.4.2',
              saveSpec: null,
              fetchSpec: '1.4.2'
            },
            _requiredBy: ['/', '/ecurve'],
            _resolved: 'https://registry.npmjs.org/bigi/-/bigi-1.4.2.tgz',
            _spec: '1.4.2',
            _where: '/Users/Yukan/Desktop/work/blockstack/blockstack.js',
            bugs: { url: 'https://github.com/cryptocoinjs/bigi/issues' },
            dependencies: {},
            description: 'Big integers.',
            devDependencies: {
              coveralls: '^2.11.2',
              istanbul: '^0.3.5',
              jshint: '^2.5.1',
              mocha: '^2.1.0',
              mochify: '^2.1.0'
            },
            homepage: 'https://github.com/cryptocoinjs/bigi#readme',
            keywords: [
              'cryptography',
              'math',
              'bitcoin',
              'arbitrary',
              'precision',
              'arithmetic',
              'big',
              'integer',
              'int',
              'number',
              'biginteger',
              'bigint',
              'bignumber',
              'decimal',
              'float'
            ],
            main: './lib/index.js',
            name: 'bigi',
            repository: {
              url: 'git+https://github.com/cryptocoinjs/bigi.git',
              type: 'git'
            },
            scripts: {
              'browser-test': 'mochify --wd -R spec',
              coverage:
                'istanbul cover ./node_modules/.bin/_mocha -- --reporter list test/*.js',
              coveralls:
                'npm run-script coverage && node ./node_modules/.bin/coveralls < coverage/lcov.info',
              jshint: 'jshint --config jshint.json lib/*.js ; true',
              test: '_mocha -- test/*.js',
              unit: 'mocha'
            },
            testling: {
              files: 'test/*.js',
              harness: 'mocha',
              browsers: [
                'ie/9..latest',
                'firefox/latest',
                'chrome/latest',
                'safari/6.0..latest',
                'iphone/6.0..latest',
                'android-browser/4.2..latest'
              ]
            },
            version: '1.4.2'
          };
        },
        {}
      ],
      76: [
        function(require, module, exports) {
          let createHash = require('create-hash');
          let createHmac = require('create-hmac');
          function hash160(buffer) {
            return createHash('rmd160')
              .update(
                createHash('sha256')
                  .update(buffer)
                  .digest()
              )
              .digest();
          }
          function hmacSHA512(key, data) {
            return createHmac('sha512', key)
              .update(data)
              .digest();
          }
          module.exports = { hash160: hash160, hmacSHA512: hmacSHA512 };
        },
        { 'create-hash': 283, 'create-hmac': 285 }
      ],
      77: [
        function(require, module, exports) {
          let Buffer = require('safe-buffer').Buffer;
          let bs58check = require('bs58check');
          let crypto = require('./crypto');
          let ecc = require('tiny-secp256k1');
          let typeforce = require('typeforce');
          let wif = require('wif');
          let UINT256_TYPE = typeforce.BufferN(32);
          let NETWORK_TYPE = typeforce.compile({
            wif: typeforce.UInt8,
            bip32: { public: typeforce.UInt32, private: typeforce.UInt32 }
          });
          let BITCOIN = {
            wif: 128,
            bip32: { public: 76067358, private: 76066276 }
          };
          function BIP32(d, Q, chainCode, network) {
            typeforce(NETWORK_TYPE, network);
            this.__d = d || null;
            this.__Q = Q || null;
            this.chainCode = chainCode;
            this.depth = 0;
            this.index = 0;
            this.network = network;
            this.parentFingerprint = 0;
          }
          Object.defineProperty(BIP32.prototype, 'identifier', {
            get: function() {
              return crypto.hash160(this.publicKey);
            }
          });
          Object.defineProperty(BIP32.prototype, 'fingerprint', {
            get: function() {
              return this.identifier.slice(0, 4);
            }
          });
          Object.defineProperty(BIP32.prototype, 'privateKey', {
            enumerable: false,
            get: function() {
              return this.__d;
            }
          });
          Object.defineProperty(BIP32.prototype, 'publicKey', {
            get: function() {
              if (!this.__Q)
                this.__Q = ecc.pointFromScalar(this.__d, this.compressed);
              return this.__Q;
            }
          });
          BIP32.prototype.isNeutered = function() {
            return this.__d === null;
          };
          BIP32.prototype.neutered = function() {
            let neutered = fromPublicKey(
              this.publicKey,
              this.chainCode,
              this.network
            );
            neutered.depth = this.depth;
            neutered.index = this.index;
            neutered.parentFingerprint = this.parentFingerprint;
            return neutered;
          };
          BIP32.prototype.toBase58 = function() {
            let network = this.network;
            let version = !this.isNeutered()
              ? network.bip32.private
              : network.bip32.public;
            let buffer = Buffer.allocUnsafe(78);
            buffer.writeUInt32BE(version, 0);
            buffer.writeUInt8(this.depth, 4);
            buffer.writeUInt32BE(this.parentFingerprint, 5);
            buffer.writeUInt32BE(this.index, 9);
            this.chainCode.copy(buffer, 13);
            if (!this.isNeutered()) {
              buffer.writeUInt8(0, 45);
              this.privateKey.copy(buffer, 46);
            } else {
              this.publicKey.copy(buffer, 45);
            }
            return bs58check.encode(buffer);
          };
          BIP32.prototype.toWIF = function() {
            if (!this.privateKey) throw new TypeError('Missing private key');
            return wif.encode(this.network.wif, this.privateKey, true);
          };
          let HIGHEST_BIT = 2147483648;
          BIP32.prototype.derive = function(index) {
            typeforce(typeforce.UInt32, index);
            let isHardened = index >= HIGHEST_BIT;
            let data = Buffer.allocUnsafe(37);
            if (isHardened) {
              if (this.isNeutered())
                throw new TypeError(
                  'Missing private key for hardened child key'
                );
              data[0] = 0;
              this.privateKey.copy(data, 1);
              data.writeUInt32BE(index, 33);
            } else {
              this.publicKey.copy(data, 0);
              data.writeUInt32BE(index, 33);
            }
            let I = crypto.hmacSHA512(this.chainCode, data);
            let IL = I.slice(0, 32);
            let IR = I.slice(32);
            if (!ecc.isPrivate(IL)) return this.derive(index + 1);
            let hd;
            if (!this.isNeutered()) {
              let ki = ecc.privateAdd(this.privateKey, IL);
              if (ki == null) return this.derive(index + 1);
              hd = fromPrivateKey(ki, IR, this.network);
            } else {
              let Ki = ecc.pointAddScalar(this.publicKey, IL, true);
              if (Ki === null) return this.derive(index + 1);
              hd = fromPublicKey(Ki, IR, this.network);
            }
            hd.depth = this.depth + 1;
            hd.index = index;
            hd.parentFingerprint = this.fingerprint.readUInt32BE(0);
            return hd;
          };
          let UINT31_MAX = Math.pow(2, 31) - 1;
          function UInt31(value) {
            return typeforce.UInt32(value) && value <= UINT31_MAX;
          }
          BIP32.prototype.deriveHardened = function(index) {
            typeforce(UInt31, index);
            return this.derive(index + HIGHEST_BIT);
          };
          function BIP32Path(value) {
            return (
              typeforce.String(value) && value.match(/^(m\/)?(\d+'?\/)*\d+'?$/)
            );
          }
          BIP32.prototype.derivePath = function(path) {
            typeforce(BIP32Path, path);
            let splitPath = path.split('/');
            if (splitPath[0] === 'm') {
              if (this.parentFingerprint)
                throw new TypeError('Expected master, got child');
              splitPath = splitPath.slice(1);
            }
            return splitPath.reduce(function(prevHd, indexStr) {
              let index;
              if (indexStr.slice(-1) === "'") {
                index = parseInt(indexStr.slice(0, -1), 10);
                return prevHd.deriveHardened(index);
              } else {
                index = parseInt(indexStr, 10);
                return prevHd.derive(index);
              }
            }, this);
          };
          BIP32.prototype.sign = function(hash) {
            return ecc.sign(hash, this.privateKey);
          };
          BIP32.prototype.verify = function(hash, signature) {
            return ecc.verify(hash, this.publicKey, signature);
          };
          function fromBase58(string, network) {
            let buffer = bs58check.decode(string);
            if (buffer.length !== 78)
              throw new TypeError('Invalid buffer length');
            network = network || BITCOIN;
            let version = buffer.readUInt32BE(0);
            if (
              version !== network.bip32.private &&
              version !== network.bip32.public
            )
              throw new TypeError('Invalid network version');
            let depth = buffer[4];
            let parentFingerprint = buffer.readUInt32BE(5);
            if (depth === 0) {
              if (parentFingerprint !== 0)
                throw new TypeError('Invalid parent fingerprint');
            }
            let index = buffer.readUInt32BE(9);
            if (depth === 0 && index !== 0)
              throw new TypeError('Invalid index');
            let chainCode = buffer.slice(13, 45);
            let hd;
            if (version === network.bip32.private) {
              if (buffer.readUInt8(45) !== 0)
                throw new TypeError('Invalid private key');
              let k = buffer.slice(46, 78);
              hd = fromPrivateKey(k, chainCode, network);
            } else {
              let X = buffer.slice(45, 78);
              hd = fromPublicKey(X, chainCode, network);
            }
            hd.depth = depth;
            hd.index = index;
            hd.parentFingerprint = parentFingerprint;
            return hd;
          }
          function fromPrivateKey(privateKey, chainCode, network) {
            typeforce(
              { privateKey: UINT256_TYPE, chainCode: UINT256_TYPE },
              { privateKey: privateKey, chainCode: chainCode }
            );
            network = network || BITCOIN;
            if (!ecc.isPrivate(privateKey))
              throw new TypeError('Private key not in range [1, n)');
            return new BIP32(privateKey, null, chainCode, network);
          }
          function fromPublicKey(publicKey, chainCode, network) {
            typeforce(
              { publicKey: typeforce.BufferN(33), chainCode: UINT256_TYPE },
              { publicKey: publicKey, chainCode: chainCode }
            );
            network = network || BITCOIN;
            if (!ecc.isPoint(publicKey))
              throw new TypeError('Point is not on the curve');
            return new BIP32(null, publicKey, chainCode, network);
          }
          function fromSeed(seed, network) {
            typeforce(typeforce.Buffer, seed);
            if (seed.length < 16)
              throw new TypeError('Seed should be at least 128 bits');
            if (seed.length > 64)
              throw new TypeError('Seed should be at most 512 bits');
            network = network || BITCOIN;
            let I = crypto.hmacSHA512('Bitcoin seed', seed);
            let IL = I.slice(0, 32);
            let IR = I.slice(32);
            return fromPrivateKey(IL, IR, network);
          }
          module.exports = {
            fromBase58: fromBase58,
            fromPrivateKey: fromPrivateKey,
            fromPublicKey: fromPublicKey,
            fromSeed: fromSeed
          };
        },
        {
          './crypto': 76,
          bs58check: 269,
          'safe-buffer': 460,
          'tiny-secp256k1': 472,
          typeforce: 499,
          wif: 568
        }
      ],
      78: [
        function(require, module, exports) {
          var Buffer = require('safe-buffer').Buffer;
          var createHash = require('create-hash');
          var pbkdf2 = require('pbkdf2').pbkdf2Sync;
          var randomBytes = require('randombytes');
          var unorm = require('unorm');
          var CHINESE_SIMPLIFIED_WORDLIST = require('./wordlists/chinese_simplified.json');
          var CHINESE_TRADITIONAL_WORDLIST = require('./wordlists/chinese_traditional.json');
          var ENGLISH_WORDLIST = require('./wordlists/english.json');
          var FRENCH_WORDLIST = require('./wordlists/french.json');
          var ITALIAN_WORDLIST = require('./wordlists/italian.json');
          var JAPANESE_WORDLIST = require('./wordlists/japanese.json');
          var KOREAN_WORDLIST = require('./wordlists/korean.json');
          var SPANISH_WORDLIST = require('./wordlists/spanish.json');
          var DEFAULT_WORDLIST = ENGLISH_WORDLIST;
          var INVALID_MNEMONIC = 'Invalid mnemonic';
          var INVALID_ENTROPY = 'Invalid entropy';
          var INVALID_CHECKSUM = 'Invalid mnemonic checksum';
          function lpad(str, padString, length) {
            while (str.length < length) str = padString + str;
            return str;
          }
          function binaryToByte(bin) {
            return parseInt(bin, 2);
          }
          function bytesToBinary(bytes) {
            return bytes
              .map(function(x) {
                return lpad(x.toString(2), '0', 8);
              })
              .join('');
          }
          function deriveChecksumBits(entropyBuffer) {
            var ENT = entropyBuffer.length * 8;
            var CS = ENT / 32;
            var hash = createHash('sha256')
              .update(entropyBuffer)
              .digest();
            return bytesToBinary([].slice.call(hash)).slice(0, CS);
          }
          function salt(password) {
            return 'mnemonic' + (password || '');
          }
          function mnemonicToSeed(mnemonic, password) {
            var mnemonicBuffer = Buffer.from(unorm.nfkd(mnemonic), 'utf8');
            var saltBuffer = Buffer.from(salt(unorm.nfkd(password)), 'utf8');
            return pbkdf2(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512');
          }
          function mnemonicToSeedHex(mnemonic, password) {
            return mnemonicToSeed(mnemonic, password).toString('hex');
          }
          function mnemonicToEntropy(mnemonic, wordlist) {
            wordlist = wordlist || DEFAULT_WORDLIST;
            var words = unorm.nfkd(mnemonic).split(' ');
            if (words.length % 3 !== 0) throw new Error(INVALID_MNEMONIC);
            var bits = words
              .map(function(word) {
                var index = wordlist.indexOf(word);
                if (index === -1) throw new Error(INVALID_MNEMONIC);
                return lpad(index.toString(2), '0', 11);
              })
              .join('');
            var dividerIndex = Math.floor(bits.length / 33) * 32;
            var entropyBits = bits.slice(0, dividerIndex);
            var checksumBits = bits.slice(dividerIndex);
            var entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte);
            if (entropyBytes.length < 16) throw new Error(INVALID_ENTROPY);
            if (entropyBytes.length > 32) throw new Error(INVALID_ENTROPY);
            if (entropyBytes.length % 4 !== 0) throw new Error(INVALID_ENTROPY);
            var entropy = Buffer.from(entropyBytes);
            var newChecksum = deriveChecksumBits(entropy);
            if (newChecksum !== checksumBits) throw new Error(INVALID_CHECKSUM);
            return entropy.toString('hex');
          }
          function entropyToMnemonic(entropy, wordlist) {
            if (!Buffer.isBuffer(entropy))
              entropy = Buffer.from(entropy, 'hex');
            wordlist = wordlist || DEFAULT_WORDLIST;
            if (entropy.length < 16) throw new TypeError(INVALID_ENTROPY);
            if (entropy.length > 32) throw new TypeError(INVALID_ENTROPY);
            if (entropy.length % 4 !== 0) throw new TypeError(INVALID_ENTROPY);
            var entropyBits = bytesToBinary([].slice.call(entropy));
            var checksumBits = deriveChecksumBits(entropy);
            var bits = entropyBits + checksumBits;
            var chunks = bits.match(/(.{1,11})/g);
            var words = chunks.map(function(binary) {
              var index = binaryToByte(binary);
              return wordlist[index];
            });
            return wordlist === JAPANESE_WORDLIST
              ? words.join('　')
              : words.join(' ');
          }
          function generateMnemonic(strength, rng, wordlist) {
            strength = strength || 128;
            if (strength % 32 !== 0) throw new TypeError(INVALID_ENTROPY);
            rng = rng || randomBytes;
            return entropyToMnemonic(rng(strength / 8), wordlist);
          }
          function validateMnemonic(mnemonic, wordlist) {
            try {
              mnemonicToEntropy(mnemonic, wordlist);
            } catch (e) {
              return false;
            }
            return true;
          }
          module.exports = {
            mnemonicToSeed: mnemonicToSeed,
            mnemonicToSeedHex: mnemonicToSeedHex,
            mnemonicToEntropy: mnemonicToEntropy,
            entropyToMnemonic: entropyToMnemonic,
            generateMnemonic: generateMnemonic,
            validateMnemonic: validateMnemonic,
            wordlists: {
              EN: ENGLISH_WORDLIST,
              JA: JAPANESE_WORDLIST,
              chinese_simplified: CHINESE_SIMPLIFIED_WORDLIST,
              chinese_traditional: CHINESE_TRADITIONAL_WORDLIST,
              english: ENGLISH_WORDLIST,
              french: FRENCH_WORDLIST,
              italian: ITALIAN_WORDLIST,
              japanese: JAPANESE_WORDLIST,
              korean: KOREAN_WORDLIST,
              spanish: SPANISH_WORDLIST
            }
          };
        },
        {
          './wordlists/chinese_simplified.json': 79,
          './wordlists/chinese_traditional.json': 80,
          './wordlists/english.json': 81,
          './wordlists/french.json': 82,
          './wordlists/italian.json': 83,
          './wordlists/japanese.json': 84,
          './wordlists/korean.json': 85,
          './wordlists/spanish.json': 86,
          'create-hash': 283,
          pbkdf2: 447,
          randombytes: 456,
          'safe-buffer': 460,
          unorm: 501
        }
      ],
      79: [
        function(require, module, exports) {
          module.exports = [
            '的',
            '一',
            '是',
            '在',
            '不',
            '了',
            '有',
            '和',
            '人',
            '这',
            '中',
            '大',
            '为',
            '上',
            '个',
            '国',
            '我',
            '以',
            '要',
            '他',
            '时',
            '来',
            '用',
            '们',
            '生',
            '到',
            '作',
            '地',
            '于',
            '出',
            '就',
            '分',
            '对',
            '成',
            '会',
            '可',
            '主',
            '发',
            '年',
            '动',
            '同',
            '工',
            '也',
            '能',
            '下',
            '过',
            '子',
            '说',
            '产',
            '种',
            '面',
            '而',
            '方',
            '后',
            '多',
            '定',
            '行',
            '学',
            '法',
            '所',
            '民',
            '得',
            '经',
            '十',
            '三',
            '之',
            '进',
            '着',
            '等',
            '部',
            '度',
            '家',
            '电',
            '力',
            '里',
            '如',
            '水',
            '化',
            '高',
            '自',
            '二',
            '理',
            '起',
            '小',
            '物',
            '现',
            '实',
            '加',
            '量',
            '都',
            '两',
            '体',
            '制',
            '机',
            '当',
            '使',
            '点',
            '从',
            '业',
            '本',
            '去',
            '把',
            '性',
            '好',
            '应',
            '开',
            '它',
            '合',
            '还',
            '因',
            '由',
            '其',
            '些',
            '然',
            '前',
            '外',
            '天',
            '政',
            '四',
            '日',
            '那',
            '社',
            '义',
            '事',
            '平',
            '形',
            '相',
            '全',
            '表',
            '间',
            '样',
            '与',
            '关',
            '各',
            '重',
            '新',
            '线',
            '内',
            '数',
            '正',
            '心',
            '反',
            '你',
            '明',
            '看',
            '原',
            '又',
            '么',
            '利',
            '比',
            '或',
            '但',
            '质',
            '气',
            '第',
            '向',
            '道',
            '命',
            '此',
            '变',
            '条',
            '只',
            '没',
            '结',
            '解',
            '问',
            '意',
            '建',
            '月',
            '公',
            '无',
            '系',
            '军',
            '很',
            '情',
            '者',
            '最',
            '立',
            '代',
            '想',
            '已',
            '通',
            '并',
            '提',
            '直',
            '题',
            '党',
            '程',
            '展',
            '五',
            '果',
            '料',
            '象',
            '员',
            '革',
            '位',
            '入',
            '常',
            '文',
            '总',
            '次',
            '品',
            '式',
            '活',
            '设',
            '及',
            '管',
            '特',
            '件',
            '长',
            '求',
            '老',
            '头',
            '基',
            '资',
            '边',
            '流',
            '路',
            '级',
            '少',
            '图',
            '山',
            '统',
            '接',
            '知',
            '较',
            '将',
            '组',
            '见',
            '计',
            '别',
            '她',
            '手',
            '角',
            '期',
            '根',
            '论',
            '运',
            '农',
            '指',
            '几',
            '九',
            '区',
            '强',
            '放',
            '决',
            '西',
            '被',
            '干',
            '做',
            '必',
            '战',
            '先',
            '回',
            '则',
            '任',
            '取',
            '据',
            '处',
            '队',
            '南',
            '给',
            '色',
            '光',
            '门',
            '即',
            '保',
            '治',
            '北',
            '造',
            '百',
            '规',
            '热',
            '领',
            '七',
            '海',
            '口',
            '东',
            '导',
            '器',
            '压',
            '志',
            '世',
            '金',
            '增',
            '争',
            '济',
            '阶',
            '油',
            '思',
            '术',
            '极',
            '交',
            '受',
            '联',
            '什',
            '认',
            '六',
            '共',
            '权',
            '收',
            '证',
            '改',
            '清',
            '美',
            '再',
            '采',
            '转',
            '更',
            '单',
            '风',
            '切',
            '打',
            '白',
            '教',
            '速',
            '花',
            '带',
            '安',
            '场',
            '身',
            '车',
            '例',
            '真',
            '务',
            '具',
            '万',
            '每',
            '目',
            '至',
            '达',
            '走',
            '积',
            '示',
            '议',
            '声',
            '报',
            '斗',
            '完',
            '类',
            '八',
            '离',
            '华',
            '名',
            '确',
            '才',
            '科',
            '张',
            '信',
            '马',
            '节',
            '话',
            '米',
            '整',
            '空',
            '元',
            '况',
            '今',
            '集',
            '温',
            '传',
            '土',
            '许',
            '步',
            '群',
            '广',
            '石',
            '记',
            '需',
            '段',
            '研',
            '界',
            '拉',
            '林',
            '律',
            '叫',
            '且',
            '究',
            '观',
            '越',
            '织',
            '装',
            '影',
            '算',
            '低',
            '持',
            '音',
            '众',
            '书',
            '布',
            '复',
            '容',
            '儿',
            '须',
            '际',
            '商',
            '非',
            '验',
            '连',
            '断',
            '深',
            '难',
            '近',
            '矿',
            '千',
            '周',
            '委',
            '素',
            '技',
            '备',
            '半',
            '办',
            '青',
            '省',
            '列',
            '习',
            '响',
            '约',
            '支',
            '般',
            '史',
            '感',
            '劳',
            '便',
            '团',
            '往',
            '酸',
            '历',
            '市',
            '克',
            '何',
            '除',
            '消',
            '构',
            '府',
            '称',
            '太',
            '准',
            '精',
            '值',
            '号',
            '率',
            '族',
            '维',
            '划',
            '选',
            '标',
            '写',
            '存',
            '候',
            '毛',
            '亲',
            '快',
            '效',
            '斯',
            '院',
            '查',
            '江',
            '型',
            '眼',
            '王',
            '按',
            '格',
            '养',
            '易',
            '置',
            '派',
            '层',
            '片',
            '始',
            '却',
            '专',
            '状',
            '育',
            '厂',
            '京',
            '识',
            '适',
            '属',
            '圆',
            '包',
            '火',
            '住',
            '调',
            '满',
            '县',
            '局',
            '照',
            '参',
            '红',
            '细',
            '引',
            '听',
            '该',
            '铁',
            '价',
            '严',
            '首',
            '底',
            '液',
            '官',
            '德',
            '随',
            '病',
            '苏',
            '失',
            '尔',
            '死',
            '讲',
            '配',
            '女',
            '黄',
            '推',
            '显',
            '谈',
            '罪',
            '神',
            '艺',
            '呢',
            '席',
            '含',
            '企',
            '望',
            '密',
            '批',
            '营',
            '项',
            '防',
            '举',
            '球',
            '英',
            '氧',
            '势',
            '告',
            '李',
            '台',
            '落',
            '木',
            '帮',
            '轮',
            '破',
            '亚',
            '师',
            '围',
            '注',
            '远',
            '字',
            '材',
            '排',
            '供',
            '河',
            '态',
            '封',
            '另',
            '施',
            '减',
            '树',
            '溶',
            '怎',
            '止',
            '案',
            '言',
            '士',
            '均',
            '武',
            '固',
            '叶',
            '鱼',
            '波',
            '视',
            '仅',
            '费',
            '紧',
            '爱',
            '左',
            '章',
            '早',
            '朝',
            '害',
            '续',
            '轻',
            '服',
            '试',
            '食',
            '充',
            '兵',
            '源',
            '判',
            '护',
            '司',
            '足',
            '某',
            '练',
            '差',
            '致',
            '板',
            '田',
            '降',
            '黑',
            '犯',
            '负',
            '击',
            '范',
            '继',
            '兴',
            '似',
            '余',
            '坚',
            '曲',
            '输',
            '修',
            '故',
            '城',
            '夫',
            '够',
            '送',
            '笔',
            '船',
            '占',
            '右',
            '财',
            '吃',
            '富',
            '春',
            '职',
            '觉',
            '汉',
            '画',
            '功',
            '巴',
            '跟',
            '虽',
            '杂',
            '飞',
            '检',
            '吸',
            '助',
            '升',
            '阳',
            '互',
            '初',
            '创',
            '抗',
            '考',
            '投',
            '坏',
            '策',
            '古',
            '径',
            '换',
            '未',
            '跑',
            '留',
            '钢',
            '曾',
            '端',
            '责',
            '站',
            '简',
            '述',
            '钱',
            '副',
            '尽',
            '帝',
            '射',
            '草',
            '冲',
            '承',
            '独',
            '令',
            '限',
            '阿',
            '宣',
            '环',
            '双',
            '请',
            '超',
            '微',
            '让',
            '控',
            '州',
            '良',
            '轴',
            '找',
            '否',
            '纪',
            '益',
            '依',
            '优',
            '顶',
            '础',
            '载',
            '倒',
            '房',
            '突',
            '坐',
            '粉',
            '敌',
            '略',
            '客',
            '袁',
            '冷',
            '胜',
            '绝',
            '析',
            '块',
            '剂',
            '测',
            '丝',
            '协',
            '诉',
            '念',
            '陈',
            '仍',
            '罗',
            '盐',
            '友',
            '洋',
            '错',
            '苦',
            '夜',
            '刑',
            '移',
            '频',
            '逐',
            '靠',
            '混',
            '母',
            '短',
            '皮',
            '终',
            '聚',
            '汽',
            '村',
            '云',
            '哪',
            '既',
            '距',
            '卫',
            '停',
            '烈',
            '央',
            '察',
            '烧',
            '迅',
            '境',
            '若',
            '印',
            '洲',
            '刻',
            '括',
            '激',
            '孔',
            '搞',
            '甚',
            '室',
            '待',
            '核',
            '校',
            '散',
            '侵',
            '吧',
            '甲',
            '游',
            '久',
            '菜',
            '味',
            '旧',
            '模',
            '湖',
            '货',
            '损',
            '预',
            '阻',
            '毫',
            '普',
            '稳',
            '乙',
            '妈',
            '植',
            '息',
            '扩',
            '银',
            '语',
            '挥',
            '酒',
            '守',
            '拿',
            '序',
            '纸',
            '医',
            '缺',
            '雨',
            '吗',
            '针',
            '刘',
            '啊',
            '急',
            '唱',
            '误',
            '训',
            '愿',
            '审',
            '附',
            '获',
            '茶',
            '鲜',
            '粮',
            '斤',
            '孩',
            '脱',
            '硫',
            '肥',
            '善',
            '龙',
            '演',
            '父',
            '渐',
            '血',
            '欢',
            '械',
            '掌',
            '歌',
            '沙',
            '刚',
            '攻',
            '谓',
            '盾',
            '讨',
            '晚',
            '粒',
            '乱',
            '燃',
            '矛',
            '乎',
            '杀',
            '药',
            '宁',
            '鲁',
            '贵',
            '钟',
            '煤',
            '读',
            '班',
            '伯',
            '香',
            '介',
            '迫',
            '句',
            '丰',
            '培',
            '握',
            '兰',
            '担',
            '弦',
            '蛋',
            '沉',
            '假',
            '穿',
            '执',
            '答',
            '乐',
            '谁',
            '顺',
            '烟',
            '缩',
            '征',
            '脸',
            '喜',
            '松',
            '脚',
            '困',
            '异',
            '免',
            '背',
            '星',
            '福',
            '买',
            '染',
            '井',
            '概',
            '慢',
            '怕',
            '磁',
            '倍',
            '祖',
            '皇',
            '促',
            '静',
            '补',
            '评',
            '翻',
            '肉',
            '践',
            '尼',
            '衣',
            '宽',
            '扬',
            '棉',
            '希',
            '伤',
            '操',
            '垂',
            '秋',
            '宜',
            '氢',
            '套',
            '督',
            '振',
            '架',
            '亮',
            '末',
            '宪',
            '庆',
            '编',
            '牛',
            '触',
            '映',
            '雷',
            '销',
            '诗',
            '座',
            '居',
            '抓',
            '裂',
            '胞',
            '呼',
            '娘',
            '景',
            '威',
            '绿',
            '晶',
            '厚',
            '盟',
            '衡',
            '鸡',
            '孙',
            '延',
            '危',
            '胶',
            '屋',
            '乡',
            '临',
            '陆',
            '顾',
            '掉',
            '呀',
            '灯',
            '岁',
            '措',
            '束',
            '耐',
            '剧',
            '玉',
            '赵',
            '跳',
            '哥',
            '季',
            '课',
            '凯',
            '胡',
            '额',
            '款',
            '绍',
            '卷',
            '齐',
            '伟',
            '蒸',
            '殖',
            '永',
            '宗',
            '苗',
            '川',
            '炉',
            '岩',
            '弱',
            '零',
            '杨',
            '奏',
            '沿',
            '露',
            '杆',
            '探',
            '滑',
            '镇',
            '饭',
            '浓',
            '航',
            '怀',
            '赶',
            '库',
            '夺',
            '伊',
            '灵',
            '税',
            '途',
            '灭',
            '赛',
            '归',
            '召',
            '鼓',
            '播',
            '盘',
            '裁',
            '险',
            '康',
            '唯',
            '录',
            '菌',
            '纯',
            '借',
            '糖',
            '盖',
            '横',
            '符',
            '私',
            '努',
            '堂',
            '域',
            '枪',
            '润',
            '幅',
            '哈',
            '竟',
            '熟',
            '虫',
            '泽',
            '脑',
            '壤',
            '碳',
            '欧',
            '遍',
            '侧',
            '寨',
            '敢',
            '彻',
            '虑',
            '斜',
            '薄',
            '庭',
            '纳',
            '弹',
            '饲',
            '伸',
            '折',
            '麦',
            '湿',
            '暗',
            '荷',
            '瓦',
            '塞',
            '床',
            '筑',
            '恶',
            '户',
            '访',
            '塔',
            '奇',
            '透',
            '梁',
            '刀',
            '旋',
            '迹',
            '卡',
            '氯',
            '遇',
            '份',
            '毒',
            '泥',
            '退',
            '洗',
            '摆',
            '灰',
            '彩',
            '卖',
            '耗',
            '夏',
            '择',
            '忙',
            '铜',
            '献',
            '硬',
            '予',
            '繁',
            '圈',
            '雪',
            '函',
            '亦',
            '抽',
            '篇',
            '阵',
            '阴',
            '丁',
            '尺',
            '追',
            '堆',
            '雄',
            '迎',
            '泛',
            '爸',
            '楼',
            '避',
            '谋',
            '吨',
            '野',
            '猪',
            '旗',
            '累',
            '偏',
            '典',
            '馆',
            '索',
            '秦',
            '脂',
            '潮',
            '爷',
            '豆',
            '忽',
            '托',
            '惊',
            '塑',
            '遗',
            '愈',
            '朱',
            '替',
            '纤',
            '粗',
            '倾',
            '尚',
            '痛',
            '楚',
            '谢',
            '奋',
            '购',
            '磨',
            '君',
            '池',
            '旁',
            '碎',
            '骨',
            '监',
            '捕',
            '弟',
            '暴',
            '割',
            '贯',
            '殊',
            '释',
            '词',
            '亡',
            '壁',
            '顿',
            '宝',
            '午',
            '尘',
            '闻',
            '揭',
            '炮',
            '残',
            '冬',
            '桥',
            '妇',
            '警',
            '综',
            '招',
            '吴',
            '付',
            '浮',
            '遭',
            '徐',
            '您',
            '摇',
            '谷',
            '赞',
            '箱',
            '隔',
            '订',
            '男',
            '吹',
            '园',
            '纷',
            '唐',
            '败',
            '宋',
            '玻',
            '巨',
            '耕',
            '坦',
            '荣',
            '闭',
            '湾',
            '键',
            '凡',
            '驻',
            '锅',
            '救',
            '恩',
            '剥',
            '凝',
            '碱',
            '齿',
            '截',
            '炼',
            '麻',
            '纺',
            '禁',
            '废',
            '盛',
            '版',
            '缓',
            '净',
            '睛',
            '昌',
            '婚',
            '涉',
            '筒',
            '嘴',
            '插',
            '岸',
            '朗',
            '庄',
            '街',
            '藏',
            '姑',
            '贸',
            '腐',
            '奴',
            '啦',
            '惯',
            '乘',
            '伙',
            '恢',
            '匀',
            '纱',
            '扎',
            '辩',
            '耳',
            '彪',
            '臣',
            '亿',
            '璃',
            '抵',
            '脉',
            '秀',
            '萨',
            '俄',
            '网',
            '舞',
            '店',
            '喷',
            '纵',
            '寸',
            '汗',
            '挂',
            '洪',
            '贺',
            '闪',
            '柬',
            '爆',
            '烯',
            '津',
            '稻',
            '墙',
            '软',
            '勇',
            '像',
            '滚',
            '厘',
            '蒙',
            '芳',
            '肯',
            '坡',
            '柱',
            '荡',
            '腿',
            '仪',
            '旅',
            '尾',
            '轧',
            '冰',
            '贡',
            '登',
            '黎',
            '削',
            '钻',
            '勒',
            '逃',
            '障',
            '氨',
            '郭',
            '峰',
            '币',
            '港',
            '伏',
            '轨',
            '亩',
            '毕',
            '擦',
            '莫',
            '刺',
            '浪',
            '秘',
            '援',
            '株',
            '健',
            '售',
            '股',
            '岛',
            '甘',
            '泡',
            '睡',
            '童',
            '铸',
            '汤',
            '阀',
            '休',
            '汇',
            '舍',
            '牧',
            '绕',
            '炸',
            '哲',
            '磷',
            '绩',
            '朋',
            '淡',
            '尖',
            '启',
            '陷',
            '柴',
            '呈',
            '徒',
            '颜',
            '泪',
            '稍',
            '忘',
            '泵',
            '蓝',
            '拖',
            '洞',
            '授',
            '镜',
            '辛',
            '壮',
            '锋',
            '贫',
            '虚',
            '弯',
            '摩',
            '泰',
            '幼',
            '廷',
            '尊',
            '窗',
            '纲',
            '弄',
            '隶',
            '疑',
            '氏',
            '宫',
            '姐',
            '震',
            '瑞',
            '怪',
            '尤',
            '琴',
            '循',
            '描',
            '膜',
            '违',
            '夹',
            '腰',
            '缘',
            '珠',
            '穷',
            '森',
            '枝',
            '竹',
            '沟',
            '催',
            '绳',
            '忆',
            '邦',
            '剩',
            '幸',
            '浆',
            '栏',
            '拥',
            '牙',
            '贮',
            '礼',
            '滤',
            '钠',
            '纹',
            '罢',
            '拍',
            '咱',
            '喊',
            '袖',
            '埃',
            '勤',
            '罚',
            '焦',
            '潜',
            '伍',
            '墨',
            '欲',
            '缝',
            '姓',
            '刊',
            '饱',
            '仿',
            '奖',
            '铝',
            '鬼',
            '丽',
            '跨',
            '默',
            '挖',
            '链',
            '扫',
            '喝',
            '袋',
            '炭',
            '污',
            '幕',
            '诸',
            '弧',
            '励',
            '梅',
            '奶',
            '洁',
            '灾',
            '舟',
            '鉴',
            '苯',
            '讼',
            '抱',
            '毁',
            '懂',
            '寒',
            '智',
            '埔',
            '寄',
            '届',
            '跃',
            '渡',
            '挑',
            '丹',
            '艰',
            '贝',
            '碰',
            '拔',
            '爹',
            '戴',
            '码',
            '梦',
            '芽',
            '熔',
            '赤',
            '渔',
            '哭',
            '敬',
            '颗',
            '奔',
            '铅',
            '仲',
            '虎',
            '稀',
            '妹',
            '乏',
            '珍',
            '申',
            '桌',
            '遵',
            '允',
            '隆',
            '螺',
            '仓',
            '魏',
            '锐',
            '晓',
            '氮',
            '兼',
            '隐',
            '碍',
            '赫',
            '拨',
            '忠',
            '肃',
            '缸',
            '牵',
            '抢',
            '博',
            '巧',
            '壳',
            '兄',
            '杜',
            '讯',
            '诚',
            '碧',
            '祥',
            '柯',
            '页',
            '巡',
            '矩',
            '悲',
            '灌',
            '龄',
            '伦',
            '票',
            '寻',
            '桂',
            '铺',
            '圣',
            '恐',
            '恰',
            '郑',
            '趣',
            '抬',
            '荒',
            '腾',
            '贴',
            '柔',
            '滴',
            '猛',
            '阔',
            '辆',
            '妻',
            '填',
            '撤',
            '储',
            '签',
            '闹',
            '扰',
            '紫',
            '砂',
            '递',
            '戏',
            '吊',
            '陶',
            '伐',
            '喂',
            '疗',
            '瓶',
            '婆',
            '抚',
            '臂',
            '摸',
            '忍',
            '虾',
            '蜡',
            '邻',
            '胸',
            '巩',
            '挤',
            '偶',
            '弃',
            '槽',
            '劲',
            '乳',
            '邓',
            '吉',
            '仁',
            '烂',
            '砖',
            '租',
            '乌',
            '舰',
            '伴',
            '瓜',
            '浅',
            '丙',
            '暂',
            '燥',
            '橡',
            '柳',
            '迷',
            '暖',
            '牌',
            '秧',
            '胆',
            '详',
            '簧',
            '踏',
            '瓷',
            '谱',
            '呆',
            '宾',
            '糊',
            '洛',
            '辉',
            '愤',
            '竞',
            '隙',
            '怒',
            '粘',
            '乃',
            '绪',
            '肩',
            '籍',
            '敏',
            '涂',
            '熙',
            '皆',
            '侦',
            '悬',
            '掘',
            '享',
            '纠',
            '醒',
            '狂',
            '锁',
            '淀',
            '恨',
            '牲',
            '霸',
            '爬',
            '赏',
            '逆',
            '玩',
            '陵',
            '祝',
            '秒',
            '浙',
            '貌',
            '役',
            '彼',
            '悉',
            '鸭',
            '趋',
            '凤',
            '晨',
            '畜',
            '辈',
            '秩',
            '卵',
            '署',
            '梯',
            '炎',
            '滩',
            '棋',
            '驱',
            '筛',
            '峡',
            '冒',
            '啥',
            '寿',
            '译',
            '浸',
            '泉',
            '帽',
            '迟',
            '硅',
            '疆',
            '贷',
            '漏',
            '稿',
            '冠',
            '嫩',
            '胁',
            '芯',
            '牢',
            '叛',
            '蚀',
            '奥',
            '鸣',
            '岭',
            '羊',
            '凭',
            '串',
            '塘',
            '绘',
            '酵',
            '融',
            '盆',
            '锡',
            '庙',
            '筹',
            '冻',
            '辅',
            '摄',
            '袭',
            '筋',
            '拒',
            '僚',
            '旱',
            '钾',
            '鸟',
            '漆',
            '沈',
            '眉',
            '疏',
            '添',
            '棒',
            '穗',
            '硝',
            '韩',
            '逼',
            '扭',
            '侨',
            '凉',
            '挺',
            '碗',
            '栽',
            '炒',
            '杯',
            '患',
            '馏',
            '劝',
            '豪',
            '辽',
            '勃',
            '鸿',
            '旦',
            '吏',
            '拜',
            '狗',
            '埋',
            '辊',
            '掩',
            '饮',
            '搬',
            '骂',
            '辞',
            '勾',
            '扣',
            '估',
            '蒋',
            '绒',
            '雾',
            '丈',
            '朵',
            '姆',
            '拟',
            '宇',
            '辑',
            '陕',
            '雕',
            '偿',
            '蓄',
            '崇',
            '剪',
            '倡',
            '厅',
            '咬',
            '驶',
            '薯',
            '刷',
            '斥',
            '番',
            '赋',
            '奉',
            '佛',
            '浇',
            '漫',
            '曼',
            '扇',
            '钙',
            '桃',
            '扶',
            '仔',
            '返',
            '俗',
            '亏',
            '腔',
            '鞋',
            '棱',
            '覆',
            '框',
            '悄',
            '叔',
            '撞',
            '骗',
            '勘',
            '旺',
            '沸',
            '孤',
            '吐',
            '孟',
            '渠',
            '屈',
            '疾',
            '妙',
            '惜',
            '仰',
            '狠',
            '胀',
            '谐',
            '抛',
            '霉',
            '桑',
            '岗',
            '嘛',
            '衰',
            '盗',
            '渗',
            '脏',
            '赖',
            '涌',
            '甜',
            '曹',
            '阅',
            '肌',
            '哩',
            '厉',
            '烃',
            '纬',
            '毅',
            '昨',
            '伪',
            '症',
            '煮',
            '叹',
            '钉',
            '搭',
            '茎',
            '笼',
            '酷',
            '偷',
            '弓',
            '锥',
            '恒',
            '杰',
            '坑',
            '鼻',
            '翼',
            '纶',
            '叙',
            '狱',
            '逮',
            '罐',
            '络',
            '棚',
            '抑',
            '膨',
            '蔬',
            '寺',
            '骤',
            '穆',
            '冶',
            '枯',
            '册',
            '尸',
            '凸',
            '绅',
            '坯',
            '牺',
            '焰',
            '轰',
            '欣',
            '晋',
            '瘦',
            '御',
            '锭',
            '锦',
            '丧',
            '旬',
            '锻',
            '垄',
            '搜',
            '扑',
            '邀',
            '亭',
            '酯',
            '迈',
            '舒',
            '脆',
            '酶',
            '闲',
            '忧',
            '酚',
            '顽',
            '羽',
            '涨',
            '卸',
            '仗',
            '陪',
            '辟',
            '惩',
            '杭',
            '姚',
            '肚',
            '捉',
            '飘',
            '漂',
            '昆',
            '欺',
            '吾',
            '郎',
            '烷',
            '汁',
            '呵',
            '饰',
            '萧',
            '雅',
            '邮',
            '迁',
            '燕',
            '撒',
            '姻',
            '赴',
            '宴',
            '烦',
            '债',
            '帐',
            '斑',
            '铃',
            '旨',
            '醇',
            '董',
            '饼',
            '雏',
            '姿',
            '拌',
            '傅',
            '腹',
            '妥',
            '揉',
            '贤',
            '拆',
            '歪',
            '葡',
            '胺',
            '丢',
            '浩',
            '徽',
            '昂',
            '垫',
            '挡',
            '览',
            '贪',
            '慰',
            '缴',
            '汪',
            '慌',
            '冯',
            '诺',
            '姜',
            '谊',
            '凶',
            '劣',
            '诬',
            '耀',
            '昏',
            '躺',
            '盈',
            '骑',
            '乔',
            '溪',
            '丛',
            '卢',
            '抹',
            '闷',
            '咨',
            '刮',
            '驾',
            '缆',
            '悟',
            '摘',
            '铒',
            '掷',
            '颇',
            '幻',
            '柄',
            '惠',
            '惨',
            '佳',
            '仇',
            '腊',
            '窝',
            '涤',
            '剑',
            '瞧',
            '堡',
            '泼',
            '葱',
            '罩',
            '霍',
            '捞',
            '胎',
            '苍',
            '滨',
            '俩',
            '捅',
            '湘',
            '砍',
            '霞',
            '邵',
            '萄',
            '疯',
            '淮',
            '遂',
            '熊',
            '粪',
            '烘',
            '宿',
            '档',
            '戈',
            '驳',
            '嫂',
            '裕',
            '徙',
            '箭',
            '捐',
            '肠',
            '撑',
            '晒',
            '辨',
            '殿',
            '莲',
            '摊',
            '搅',
            '酱',
            '屏',
            '疫',
            '哀',
            '蔡',
            '堵',
            '沫',
            '皱',
            '畅',
            '叠',
            '阁',
            '莱',
            '敲',
            '辖',
            '钩',
            '痕',
            '坝',
            '巷',
            '饿',
            '祸',
            '丘',
            '玄',
            '溜',
            '曰',
            '逻',
            '彭',
            '尝',
            '卿',
            '妨',
            '艇',
            '吞',
            '韦',
            '怨',
            '矮',
            '歇'
          ];
        },
        {}
      ],
      80: [
        function(require, module, exports) {
          module.exports = [
            '的',
            '一',
            '是',
            '在',
            '不',
            '了',
            '有',
            '和',
            '人',
            '這',
            '中',
            '大',
            '為',
            '上',
            '個',
            '國',
            '我',
            '以',
            '要',
            '他',
            '時',
            '來',
            '用',
            '們',
            '生',
            '到',
            '作',
            '地',
            '於',
            '出',
            '就',
            '分',
            '對',
            '成',
            '會',
            '可',
            '主',
            '發',
            '年',
            '動',
            '同',
            '工',
            '也',
            '能',
            '下',
            '過',
            '子',
            '說',
            '產',
            '種',
            '面',
            '而',
            '方',
            '後',
            '多',
            '定',
            '行',
            '學',
            '法',
            '所',
            '民',
            '得',
            '經',
            '十',
            '三',
            '之',
            '進',
            '著',
            '等',
            '部',
            '度',
            '家',
            '電',
            '力',
            '裡',
            '如',
            '水',
            '化',
            '高',
            '自',
            '二',
            '理',
            '起',
            '小',
            '物',
            '現',
            '實',
            '加',
            '量',
            '都',
            '兩',
            '體',
            '制',
            '機',
            '當',
            '使',
            '點',
            '從',
            '業',
            '本',
            '去',
            '把',
            '性',
            '好',
            '應',
            '開',
            '它',
            '合',
            '還',
            '因',
            '由',
            '其',
            '些',
            '然',
            '前',
            '外',
            '天',
            '政',
            '四',
            '日',
            '那',
            '社',
            '義',
            '事',
            '平',
            '形',
            '相',
            '全',
            '表',
            '間',
            '樣',
            '與',
            '關',
            '各',
            '重',
            '新',
            '線',
            '內',
            '數',
            '正',
            '心',
            '反',
            '你',
            '明',
            '看',
            '原',
            '又',
            '麼',
            '利',
            '比',
            '或',
            '但',
            '質',
            '氣',
            '第',
            '向',
            '道',
            '命',
            '此',
            '變',
            '條',
            '只',
            '沒',
            '結',
            '解',
            '問',
            '意',
            '建',
            '月',
            '公',
            '無',
            '系',
            '軍',
            '很',
            '情',
            '者',
            '最',
            '立',
            '代',
            '想',
            '已',
            '通',
            '並',
            '提',
            '直',
            '題',
            '黨',
            '程',
            '展',
            '五',
            '果',
            '料',
            '象',
            '員',
            '革',
            '位',
            '入',
            '常',
            '文',
            '總',
            '次',
            '品',
            '式',
            '活',
            '設',
            '及',
            '管',
            '特',
            '件',
            '長',
            '求',
            '老',
            '頭',
            '基',
            '資',
            '邊',
            '流',
            '路',
            '級',
            '少',
            '圖',
            '山',
            '統',
            '接',
            '知',
            '較',
            '將',
            '組',
            '見',
            '計',
            '別',
            '她',
            '手',
            '角',
            '期',
            '根',
            '論',
            '運',
            '農',
            '指',
            '幾',
            '九',
            '區',
            '強',
            '放',
            '決',
            '西',
            '被',
            '幹',
            '做',
            '必',
            '戰',
            '先',
            '回',
            '則',
            '任',
            '取',
            '據',
            '處',
            '隊',
            '南',
            '給',
            '色',
            '光',
            '門',
            '即',
            '保',
            '治',
            '北',
            '造',
            '百',
            '規',
            '熱',
            '領',
            '七',
            '海',
            '口',
            '東',
            '導',
            '器',
            '壓',
            '志',
            '世',
            '金',
            '增',
            '爭',
            '濟',
            '階',
            '油',
            '思',
            '術',
            '極',
            '交',
            '受',
            '聯',
            '什',
            '認',
            '六',
            '共',
            '權',
            '收',
            '證',
            '改',
            '清',
            '美',
            '再',
            '採',
            '轉',
            '更',
            '單',
            '風',
            '切',
            '打',
            '白',
            '教',
            '速',
            '花',
            '帶',
            '安',
            '場',
            '身',
            '車',
            '例',
            '真',
            '務',
            '具',
            '萬',
            '每',
            '目',
            '至',
            '達',
            '走',
            '積',
            '示',
            '議',
            '聲',
            '報',
            '鬥',
            '完',
            '類',
            '八',
            '離',
            '華',
            '名',
            '確',
            '才',
            '科',
            '張',
            '信',
            '馬',
            '節',
            '話',
            '米',
            '整',
            '空',
            '元',
            '況',
            '今',
            '集',
            '溫',
            '傳',
            '土',
            '許',
            '步',
            '群',
            '廣',
            '石',
            '記',
            '需',
            '段',
            '研',
            '界',
            '拉',
            '林',
            '律',
            '叫',
            '且',
            '究',
            '觀',
            '越',
            '織',
            '裝',
            '影',
            '算',
            '低',
            '持',
            '音',
            '眾',
            '書',
            '布',
            '复',
            '容',
            '兒',
            '須',
            '際',
            '商',
            '非',
            '驗',
            '連',
            '斷',
            '深',
            '難',
            '近',
            '礦',
            '千',
            '週',
            '委',
            '素',
            '技',
            '備',
            '半',
            '辦',
            '青',
            '省',
            '列',
            '習',
            '響',
            '約',
            '支',
            '般',
            '史',
            '感',
            '勞',
            '便',
            '團',
            '往',
            '酸',
            '歷',
            '市',
            '克',
            '何',
            '除',
            '消',
            '構',
            '府',
            '稱',
            '太',
            '準',
            '精',
            '值',
            '號',
            '率',
            '族',
            '維',
            '劃',
            '選',
            '標',
            '寫',
            '存',
            '候',
            '毛',
            '親',
            '快',
            '效',
            '斯',
            '院',
            '查',
            '江',
            '型',
            '眼',
            '王',
            '按',
            '格',
            '養',
            '易',
            '置',
            '派',
            '層',
            '片',
            '始',
            '卻',
            '專',
            '狀',
            '育',
            '廠',
            '京',
            '識',
            '適',
            '屬',
            '圓',
            '包',
            '火',
            '住',
            '調',
            '滿',
            '縣',
            '局',
            '照',
            '參',
            '紅',
            '細',
            '引',
            '聽',
            '該',
            '鐵',
            '價',
            '嚴',
            '首',
            '底',
            '液',
            '官',
            '德',
            '隨',
            '病',
            '蘇',
            '失',
            '爾',
            '死',
            '講',
            '配',
            '女',
            '黃',
            '推',
            '顯',
            '談',
            '罪',
            '神',
            '藝',
            '呢',
            '席',
            '含',
            '企',
            '望',
            '密',
            '批',
            '營',
            '項',
            '防',
            '舉',
            '球',
            '英',
            '氧',
            '勢',
            '告',
            '李',
            '台',
            '落',
            '木',
            '幫',
            '輪',
            '破',
            '亞',
            '師',
            '圍',
            '注',
            '遠',
            '字',
            '材',
            '排',
            '供',
            '河',
            '態',
            '封',
            '另',
            '施',
            '減',
            '樹',
            '溶',
            '怎',
            '止',
            '案',
            '言',
            '士',
            '均',
            '武',
            '固',
            '葉',
            '魚',
            '波',
            '視',
            '僅',
            '費',
            '緊',
            '愛',
            '左',
            '章',
            '早',
            '朝',
            '害',
            '續',
            '輕',
            '服',
            '試',
            '食',
            '充',
            '兵',
            '源',
            '判',
            '護',
            '司',
            '足',
            '某',
            '練',
            '差',
            '致',
            '板',
            '田',
            '降',
            '黑',
            '犯',
            '負',
            '擊',
            '范',
            '繼',
            '興',
            '似',
            '餘',
            '堅',
            '曲',
            '輸',
            '修',
            '故',
            '城',
            '夫',
            '夠',
            '送',
            '筆',
            '船',
            '佔',
            '右',
            '財',
            '吃',
            '富',
            '春',
            '職',
            '覺',
            '漢',
            '畫',
            '功',
            '巴',
            '跟',
            '雖',
            '雜',
            '飛',
            '檢',
            '吸',
            '助',
            '昇',
            '陽',
            '互',
            '初',
            '創',
            '抗',
            '考',
            '投',
            '壞',
            '策',
            '古',
            '徑',
            '換',
            '未',
            '跑',
            '留',
            '鋼',
            '曾',
            '端',
            '責',
            '站',
            '簡',
            '述',
            '錢',
            '副',
            '盡',
            '帝',
            '射',
            '草',
            '衝',
            '承',
            '獨',
            '令',
            '限',
            '阿',
            '宣',
            '環',
            '雙',
            '請',
            '超',
            '微',
            '讓',
            '控',
            '州',
            '良',
            '軸',
            '找',
            '否',
            '紀',
            '益',
            '依',
            '優',
            '頂',
            '礎',
            '載',
            '倒',
            '房',
            '突',
            '坐',
            '粉',
            '敵',
            '略',
            '客',
            '袁',
            '冷',
            '勝',
            '絕',
            '析',
            '塊',
            '劑',
            '測',
            '絲',
            '協',
            '訴',
            '念',
            '陳',
            '仍',
            '羅',
            '鹽',
            '友',
            '洋',
            '錯',
            '苦',
            '夜',
            '刑',
            '移',
            '頻',
            '逐',
            '靠',
            '混',
            '母',
            '短',
            '皮',
            '終',
            '聚',
            '汽',
            '村',
            '雲',
            '哪',
            '既',
            '距',
            '衛',
            '停',
            '烈',
            '央',
            '察',
            '燒',
            '迅',
            '境',
            '若',
            '印',
            '洲',
            '刻',
            '括',
            '激',
            '孔',
            '搞',
            '甚',
            '室',
            '待',
            '核',
            '校',
            '散',
            '侵',
            '吧',
            '甲',
            '遊',
            '久',
            '菜',
            '味',
            '舊',
            '模',
            '湖',
            '貨',
            '損',
            '預',
            '阻',
            '毫',
            '普',
            '穩',
            '乙',
            '媽',
            '植',
            '息',
            '擴',
            '銀',
            '語',
            '揮',
            '酒',
            '守',
            '拿',
            '序',
            '紙',
            '醫',
            '缺',
            '雨',
            '嗎',
            '針',
            '劉',
            '啊',
            '急',
            '唱',
            '誤',
            '訓',
            '願',
            '審',
            '附',
            '獲',
            '茶',
            '鮮',
            '糧',
            '斤',
            '孩',
            '脫',
            '硫',
            '肥',
            '善',
            '龍',
            '演',
            '父',
            '漸',
            '血',
            '歡',
            '械',
            '掌',
            '歌',
            '沙',
            '剛',
            '攻',
            '謂',
            '盾',
            '討',
            '晚',
            '粒',
            '亂',
            '燃',
            '矛',
            '乎',
            '殺',
            '藥',
            '寧',
            '魯',
            '貴',
            '鐘',
            '煤',
            '讀',
            '班',
            '伯',
            '香',
            '介',
            '迫',
            '句',
            '豐',
            '培',
            '握',
            '蘭',
            '擔',
            '弦',
            '蛋',
            '沉',
            '假',
            '穿',
            '執',
            '答',
            '樂',
            '誰',
            '順',
            '煙',
            '縮',
            '徵',
            '臉',
            '喜',
            '松',
            '腳',
            '困',
            '異',
            '免',
            '背',
            '星',
            '福',
            '買',
            '染',
            '井',
            '概',
            '慢',
            '怕',
            '磁',
            '倍',
            '祖',
            '皇',
            '促',
            '靜',
            '補',
            '評',
            '翻',
            '肉',
            '踐',
            '尼',
            '衣',
            '寬',
            '揚',
            '棉',
            '希',
            '傷',
            '操',
            '垂',
            '秋',
            '宜',
            '氫',
            '套',
            '督',
            '振',
            '架',
            '亮',
            '末',
            '憲',
            '慶',
            '編',
            '牛',
            '觸',
            '映',
            '雷',
            '銷',
            '詩',
            '座',
            '居',
            '抓',
            '裂',
            '胞',
            '呼',
            '娘',
            '景',
            '威',
            '綠',
            '晶',
            '厚',
            '盟',
            '衡',
            '雞',
            '孫',
            '延',
            '危',
            '膠',
            '屋',
            '鄉',
            '臨',
            '陸',
            '顧',
            '掉',
            '呀',
            '燈',
            '歲',
            '措',
            '束',
            '耐',
            '劇',
            '玉',
            '趙',
            '跳',
            '哥',
            '季',
            '課',
            '凱',
            '胡',
            '額',
            '款',
            '紹',
            '卷',
            '齊',
            '偉',
            '蒸',
            '殖',
            '永',
            '宗',
            '苗',
            '川',
            '爐',
            '岩',
            '弱',
            '零',
            '楊',
            '奏',
            '沿',
            '露',
            '桿',
            '探',
            '滑',
            '鎮',
            '飯',
            '濃',
            '航',
            '懷',
            '趕',
            '庫',
            '奪',
            '伊',
            '靈',
            '稅',
            '途',
            '滅',
            '賽',
            '歸',
            '召',
            '鼓',
            '播',
            '盤',
            '裁',
            '險',
            '康',
            '唯',
            '錄',
            '菌',
            '純',
            '借',
            '糖',
            '蓋',
            '橫',
            '符',
            '私',
            '努',
            '堂',
            '域',
            '槍',
            '潤',
            '幅',
            '哈',
            '竟',
            '熟',
            '蟲',
            '澤',
            '腦',
            '壤',
            '碳',
            '歐',
            '遍',
            '側',
            '寨',
            '敢',
            '徹',
            '慮',
            '斜',
            '薄',
            '庭',
            '納',
            '彈',
            '飼',
            '伸',
            '折',
            '麥',
            '濕',
            '暗',
            '荷',
            '瓦',
            '塞',
            '床',
            '築',
            '惡',
            '戶',
            '訪',
            '塔',
            '奇',
            '透',
            '梁',
            '刀',
            '旋',
            '跡',
            '卡',
            '氯',
            '遇',
            '份',
            '毒',
            '泥',
            '退',
            '洗',
            '擺',
            '灰',
            '彩',
            '賣',
            '耗',
            '夏',
            '擇',
            '忙',
            '銅',
            '獻',
            '硬',
            '予',
            '繁',
            '圈',
            '雪',
            '函',
            '亦',
            '抽',
            '篇',
            '陣',
            '陰',
            '丁',
            '尺',
            '追',
            '堆',
            '雄',
            '迎',
            '泛',
            '爸',
            '樓',
            '避',
            '謀',
            '噸',
            '野',
            '豬',
            '旗',
            '累',
            '偏',
            '典',
            '館',
            '索',
            '秦',
            '脂',
            '潮',
            '爺',
            '豆',
            '忽',
            '托',
            '驚',
            '塑',
            '遺',
            '愈',
            '朱',
            '替',
            '纖',
            '粗',
            '傾',
            '尚',
            '痛',
            '楚',
            '謝',
            '奮',
            '購',
            '磨',
            '君',
            '池',
            '旁',
            '碎',
            '骨',
            '監',
            '捕',
            '弟',
            '暴',
            '割',
            '貫',
            '殊',
            '釋',
            '詞',
            '亡',
            '壁',
            '頓',
            '寶',
            '午',
            '塵',
            '聞',
            '揭',
            '炮',
            '殘',
            '冬',
            '橋',
            '婦',
            '警',
            '綜',
            '招',
            '吳',
            '付',
            '浮',
            '遭',
            '徐',
            '您',
            '搖',
            '谷',
            '贊',
            '箱',
            '隔',
            '訂',
            '男',
            '吹',
            '園',
            '紛',
            '唐',
            '敗',
            '宋',
            '玻',
            '巨',
            '耕',
            '坦',
            '榮',
            '閉',
            '灣',
            '鍵',
            '凡',
            '駐',
            '鍋',
            '救',
            '恩',
            '剝',
            '凝',
            '鹼',
            '齒',
            '截',
            '煉',
            '麻',
            '紡',
            '禁',
            '廢',
            '盛',
            '版',
            '緩',
            '淨',
            '睛',
            '昌',
            '婚',
            '涉',
            '筒',
            '嘴',
            '插',
            '岸',
            '朗',
            '莊',
            '街',
            '藏',
            '姑',
            '貿',
            '腐',
            '奴',
            '啦',
            '慣',
            '乘',
            '夥',
            '恢',
            '勻',
            '紗',
            '扎',
            '辯',
            '耳',
            '彪',
            '臣',
            '億',
            '璃',
            '抵',
            '脈',
            '秀',
            '薩',
            '俄',
            '網',
            '舞',
            '店',
            '噴',
            '縱',
            '寸',
            '汗',
            '掛',
            '洪',
            '賀',
            '閃',
            '柬',
            '爆',
            '烯',
            '津',
            '稻',
            '牆',
            '軟',
            '勇',
            '像',
            '滾',
            '厘',
            '蒙',
            '芳',
            '肯',
            '坡',
            '柱',
            '盪',
            '腿',
            '儀',
            '旅',
            '尾',
            '軋',
            '冰',
            '貢',
            '登',
            '黎',
            '削',
            '鑽',
            '勒',
            '逃',
            '障',
            '氨',
            '郭',
            '峰',
            '幣',
            '港',
            '伏',
            '軌',
            '畝',
            '畢',
            '擦',
            '莫',
            '刺',
            '浪',
            '秘',
            '援',
            '株',
            '健',
            '售',
            '股',
            '島',
            '甘',
            '泡',
            '睡',
            '童',
            '鑄',
            '湯',
            '閥',
            '休',
            '匯',
            '舍',
            '牧',
            '繞',
            '炸',
            '哲',
            '磷',
            '績',
            '朋',
            '淡',
            '尖',
            '啟',
            '陷',
            '柴',
            '呈',
            '徒',
            '顏',
            '淚',
            '稍',
            '忘',
            '泵',
            '藍',
            '拖',
            '洞',
            '授',
            '鏡',
            '辛',
            '壯',
            '鋒',
            '貧',
            '虛',
            '彎',
            '摩',
            '泰',
            '幼',
            '廷',
            '尊',
            '窗',
            '綱',
            '弄',
            '隸',
            '疑',
            '氏',
            '宮',
            '姐',
            '震',
            '瑞',
            '怪',
            '尤',
            '琴',
            '循',
            '描',
            '膜',
            '違',
            '夾',
            '腰',
            '緣',
            '珠',
            '窮',
            '森',
            '枝',
            '竹',
            '溝',
            '催',
            '繩',
            '憶',
            '邦',
            '剩',
            '幸',
            '漿',
            '欄',
            '擁',
            '牙',
            '貯',
            '禮',
            '濾',
            '鈉',
            '紋',
            '罷',
            '拍',
            '咱',
            '喊',
            '袖',
            '埃',
            '勤',
            '罰',
            '焦',
            '潛',
            '伍',
            '墨',
            '欲',
            '縫',
            '姓',
            '刊',
            '飽',
            '仿',
            '獎',
            '鋁',
            '鬼',
            '麗',
            '跨',
            '默',
            '挖',
            '鏈',
            '掃',
            '喝',
            '袋',
            '炭',
            '污',
            '幕',
            '諸',
            '弧',
            '勵',
            '梅',
            '奶',
            '潔',
            '災',
            '舟',
            '鑑',
            '苯',
            '訟',
            '抱',
            '毀',
            '懂',
            '寒',
            '智',
            '埔',
            '寄',
            '屆',
            '躍',
            '渡',
            '挑',
            '丹',
            '艱',
            '貝',
            '碰',
            '拔',
            '爹',
            '戴',
            '碼',
            '夢',
            '芽',
            '熔',
            '赤',
            '漁',
            '哭',
            '敬',
            '顆',
            '奔',
            '鉛',
            '仲',
            '虎',
            '稀',
            '妹',
            '乏',
            '珍',
            '申',
            '桌',
            '遵',
            '允',
            '隆',
            '螺',
            '倉',
            '魏',
            '銳',
            '曉',
            '氮',
            '兼',
            '隱',
            '礙',
            '赫',
            '撥',
            '忠',
            '肅',
            '缸',
            '牽',
            '搶',
            '博',
            '巧',
            '殼',
            '兄',
            '杜',
            '訊',
            '誠',
            '碧',
            '祥',
            '柯',
            '頁',
            '巡',
            '矩',
            '悲',
            '灌',
            '齡',
            '倫',
            '票',
            '尋',
            '桂',
            '鋪',
            '聖',
            '恐',
            '恰',
            '鄭',
            '趣',
            '抬',
            '荒',
            '騰',
            '貼',
            '柔',
            '滴',
            '猛',
            '闊',
            '輛',
            '妻',
            '填',
            '撤',
            '儲',
            '簽',
            '鬧',
            '擾',
            '紫',
            '砂',
            '遞',
            '戲',
            '吊',
            '陶',
            '伐',
            '餵',
            '療',
            '瓶',
            '婆',
            '撫',
            '臂',
            '摸',
            '忍',
            '蝦',
            '蠟',
            '鄰',
            '胸',
            '鞏',
            '擠',
            '偶',
            '棄',
            '槽',
            '勁',
            '乳',
            '鄧',
            '吉',
            '仁',
            '爛',
            '磚',
            '租',
            '烏',
            '艦',
            '伴',
            '瓜',
            '淺',
            '丙',
            '暫',
            '燥',
            '橡',
            '柳',
            '迷',
            '暖',
            '牌',
            '秧',
            '膽',
            '詳',
            '簧',
            '踏',
            '瓷',
            '譜',
            '呆',
            '賓',
            '糊',
            '洛',
            '輝',
            '憤',
            '競',
            '隙',
            '怒',
            '粘',
            '乃',
            '緒',
            '肩',
            '籍',
            '敏',
            '塗',
            '熙',
            '皆',
            '偵',
            '懸',
            '掘',
            '享',
            '糾',
            '醒',
            '狂',
            '鎖',
            '淀',
            '恨',
            '牲',
            '霸',
            '爬',
            '賞',
            '逆',
            '玩',
            '陵',
            '祝',
            '秒',
            '浙',
            '貌',
            '役',
            '彼',
            '悉',
            '鴨',
            '趨',
            '鳳',
            '晨',
            '畜',
            '輩',
            '秩',
            '卵',
            '署',
            '梯',
            '炎',
            '灘',
            '棋',
            '驅',
            '篩',
            '峽',
            '冒',
            '啥',
            '壽',
            '譯',
            '浸',
            '泉',
            '帽',
            '遲',
            '矽',
            '疆',
            '貸',
            '漏',
            '稿',
            '冠',
            '嫩',
            '脅',
            '芯',
            '牢',
            '叛',
            '蝕',
            '奧',
            '鳴',
            '嶺',
            '羊',
            '憑',
            '串',
            '塘',
            '繪',
            '酵',
            '融',
            '盆',
            '錫',
            '廟',
            '籌',
            '凍',
            '輔',
            '攝',
            '襲',
            '筋',
            '拒',
            '僚',
            '旱',
            '鉀',
            '鳥',
            '漆',
            '沈',
            '眉',
            '疏',
            '添',
            '棒',
            '穗',
            '硝',
            '韓',
            '逼',
            '扭',
            '僑',
            '涼',
            '挺',
            '碗',
            '栽',
            '炒',
            '杯',
            '患',
            '餾',
            '勸',
            '豪',
            '遼',
            '勃',
            '鴻',
            '旦',
            '吏',
            '拜',
            '狗',
            '埋',
            '輥',
            '掩',
            '飲',
            '搬',
            '罵',
            '辭',
            '勾',
            '扣',
            '估',
            '蔣',
            '絨',
            '霧',
            '丈',
            '朵',
            '姆',
            '擬',
            '宇',
            '輯',
            '陝',
            '雕',
            '償',
            '蓄',
            '崇',
            '剪',
            '倡',
            '廳',
            '咬',
            '駛',
            '薯',
            '刷',
            '斥',
            '番',
            '賦',
            '奉',
            '佛',
            '澆',
            '漫',
            '曼',
            '扇',
            '鈣',
            '桃',
            '扶',
            '仔',
            '返',
            '俗',
            '虧',
            '腔',
            '鞋',
            '棱',
            '覆',
            '框',
            '悄',
            '叔',
            '撞',
            '騙',
            '勘',
            '旺',
            '沸',
            '孤',
            '吐',
            '孟',
            '渠',
            '屈',
            '疾',
            '妙',
            '惜',
            '仰',
            '狠',
            '脹',
            '諧',
            '拋',
            '黴',
            '桑',
            '崗',
            '嘛',
            '衰',
            '盜',
            '滲',
            '臟',
            '賴',
            '湧',
            '甜',
            '曹',
            '閱',
            '肌',
            '哩',
            '厲',
            '烴',
            '緯',
            '毅',
            '昨',
            '偽',
            '症',
            '煮',
            '嘆',
            '釘',
            '搭',
            '莖',
            '籠',
            '酷',
            '偷',
            '弓',
            '錐',
            '恆',
            '傑',
            '坑',
            '鼻',
            '翼',
            '綸',
            '敘',
            '獄',
            '逮',
            '罐',
            '絡',
            '棚',
            '抑',
            '膨',
            '蔬',
            '寺',
            '驟',
            '穆',
            '冶',
            '枯',
            '冊',
            '屍',
            '凸',
            '紳',
            '坯',
            '犧',
            '焰',
            '轟',
            '欣',
            '晉',
            '瘦',
            '禦',
            '錠',
            '錦',
            '喪',
            '旬',
            '鍛',
            '壟',
            '搜',
            '撲',
            '邀',
            '亭',
            '酯',
            '邁',
            '舒',
            '脆',
            '酶',
            '閒',
            '憂',
            '酚',
            '頑',
            '羽',
            '漲',
            '卸',
            '仗',
            '陪',
            '闢',
            '懲',
            '杭',
            '姚',
            '肚',
            '捉',
            '飄',
            '漂',
            '昆',
            '欺',
            '吾',
            '郎',
            '烷',
            '汁',
            '呵',
            '飾',
            '蕭',
            '雅',
            '郵',
            '遷',
            '燕',
            '撒',
            '姻',
            '赴',
            '宴',
            '煩',
            '債',
            '帳',
            '斑',
            '鈴',
            '旨',
            '醇',
            '董',
            '餅',
            '雛',
            '姿',
            '拌',
            '傅',
            '腹',
            '妥',
            '揉',
            '賢',
            '拆',
            '歪',
            '葡',
            '胺',
            '丟',
            '浩',
            '徽',
            '昂',
            '墊',
            '擋',
            '覽',
            '貪',
            '慰',
            '繳',
            '汪',
            '慌',
            '馮',
            '諾',
            '姜',
            '誼',
            '兇',
            '劣',
            '誣',
            '耀',
            '昏',
            '躺',
            '盈',
            '騎',
            '喬',
            '溪',
            '叢',
            '盧',
            '抹',
            '悶',
            '諮',
            '刮',
            '駕',
            '纜',
            '悟',
            '摘',
            '鉺',
            '擲',
            '頗',
            '幻',
            '柄',
            '惠',
            '慘',
            '佳',
            '仇',
            '臘',
            '窩',
            '滌',
            '劍',
            '瞧',
            '堡',
            '潑',
            '蔥',
            '罩',
            '霍',
            '撈',
            '胎',
            '蒼',
            '濱',
            '倆',
            '捅',
            '湘',
            '砍',
            '霞',
            '邵',
            '萄',
            '瘋',
            '淮',
            '遂',
            '熊',
            '糞',
            '烘',
            '宿',
            '檔',
            '戈',
            '駁',
            '嫂',
            '裕',
            '徙',
            '箭',
            '捐',
            '腸',
            '撐',
            '曬',
            '辨',
            '殿',
            '蓮',
            '攤',
            '攪',
            '醬',
            '屏',
            '疫',
            '哀',
            '蔡',
            '堵',
            '沫',
            '皺',
            '暢',
            '疊',
            '閣',
            '萊',
            '敲',
            '轄',
            '鉤',
            '痕',
            '壩',
            '巷',
            '餓',
            '禍',
            '丘',
            '玄',
            '溜',
            '曰',
            '邏',
            '彭',
            '嘗',
            '卿',
            '妨',
            '艇',
            '吞',
            '韋',
            '怨',
            '矮',
            '歇'
          ];
        },
        {}
      ],
      81: [
        function(require, module, exports) {
          module.exports = [
            'abandon',
            'ability',
            'able',
            'about',
            'above',
            'absent',
            'absorb',
            'abstract',
            'absurd',
            'abuse',
            'access',
            'accident',
            'account',
            'accuse',
            'achieve',
            'acid',
            'acoustic',
            'acquire',
            'across',
            'act',
            'action',
            'actor',
            'actress',
            'actual',
            'adapt',
            'add',
            'addict',
            'address',
            'adjust',
            'admit',
            'adult',
            'advance',
            'advice',
            'aerobic',
            'affair',
            'afford',
            'afraid',
            'again',
            'age',
            'agent',
            'agree',
            'ahead',
            'aim',
            'air',
            'airport',
            'aisle',
            'alarm',
            'album',
            'alcohol',
            'alert',
            'alien',
            'all',
            'alley',
            'allow',
            'almost',
            'alone',
            'alpha',
            'already',
            'also',
            'alter',
            'always',
            'amateur',
            'amazing',
            'among',
            'amount',
            'amused',
            'analyst',
            'anchor',
            'ancient',
            'anger',
            'angle',
            'angry',
            'animal',
            'ankle',
            'announce',
            'annual',
            'another',
            'answer',
            'antenna',
            'antique',
            'anxiety',
            'any',
            'apart',
            'apology',
            'appear',
            'apple',
            'approve',
            'april',
            'arch',
            'arctic',
            'area',
            'arena',
            'argue',
            'arm',
            'armed',
            'armor',
            'army',
            'around',
            'arrange',
            'arrest',
            'arrive',
            'arrow',
            'art',
            'artefact',
            'artist',
            'artwork',
            'ask',
            'aspect',
            'assault',
            'asset',
            'assist',
            'assume',
            'asthma',
            'athlete',
            'atom',
            'attack',
            'attend',
            'attitude',
            'attract',
            'auction',
            'audit',
            'august',
            'aunt',
            'author',
            'auto',
            'autumn',
            'average',
            'avocado',
            'avoid',
            'awake',
            'aware',
            'away',
            'awesome',
            'awful',
            'awkward',
            'axis',
            'baby',
            'bachelor',
            'bacon',
            'badge',
            'bag',
            'balance',
            'balcony',
            'ball',
            'bamboo',
            'banana',
            'banner',
            'bar',
            'barely',
            'bargain',
            'barrel',
            'base',
            'basic',
            'basket',
            'battle',
            'beach',
            'bean',
            'beauty',
            'because',
            'become',
            'beef',
            'before',
            'begin',
            'behave',
            'behind',
            'believe',
            'below',
            'belt',
            'bench',
            'benefit',
            'best',
            'betray',
            'better',
            'between',
            'beyond',
            'bicycle',
            'bid',
            'bike',
            'bind',
            'biology',
            'bird',
            'birth',
            'bitter',
            'black',
            'blade',
            'blame',
            'blanket',
            'blast',
            'bleak',
            'bless',
            'blind',
            'blood',
            'blossom',
            'blouse',
            'blue',
            'blur',
            'blush',
            'board',
            'boat',
            'body',
            'boil',
            'bomb',
            'bone',
            'bonus',
            'book',
            'boost',
            'border',
            'boring',
            'borrow',
            'boss',
            'bottom',
            'bounce',
            'box',
            'boy',
            'bracket',
            'brain',
            'brand',
            'brass',
            'brave',
            'bread',
            'breeze',
            'brick',
            'bridge',
            'brief',
            'bright',
            'bring',
            'brisk',
            'broccoli',
            'broken',
            'bronze',
            'broom',
            'brother',
            'brown',
            'brush',
            'bubble',
            'buddy',
            'budget',
            'buffalo',
            'build',
            'bulb',
            'bulk',
            'bullet',
            'bundle',
            'bunker',
            'burden',
            'burger',
            'burst',
            'bus',
            'business',
            'busy',
            'butter',
            'buyer',
            'buzz',
            'cabbage',
            'cabin',
            'cable',
            'cactus',
            'cage',
            'cake',
            'call',
            'calm',
            'camera',
            'camp',
            'can',
            'canal',
            'cancel',
            'candy',
            'cannon',
            'canoe',
            'canvas',
            'canyon',
            'capable',
            'capital',
            'captain',
            'car',
            'carbon',
            'card',
            'cargo',
            'carpet',
            'carry',
            'cart',
            'case',
            'cash',
            'casino',
            'castle',
            'casual',
            'cat',
            'catalog',
            'catch',
            'category',
            'cattle',
            'caught',
            'cause',
            'caution',
            'cave',
            'ceiling',
            'celery',
            'cement',
            'census',
            'century',
            'cereal',
            'certain',
            'chair',
            'chalk',
            'champion',
            'change',
            'chaos',
            'chapter',
            'charge',
            'chase',
            'chat',
            'cheap',
            'check',
            'cheese',
            'chef',
            'cherry',
            'chest',
            'chicken',
            'chief',
            'child',
            'chimney',
            'choice',
            'choose',
            'chronic',
            'chuckle',
            'chunk',
            'churn',
            'cigar',
            'cinnamon',
            'circle',
            'citizen',
            'city',
            'civil',
            'claim',
            'clap',
            'clarify',
            'claw',
            'clay',
            'clean',
            'clerk',
            'clever',
            'click',
            'client',
            'cliff',
            'climb',
            'clinic',
            'clip',
            'clock',
            'clog',
            'close',
            'cloth',
            'cloud',
            'clown',
            'club',
            'clump',
            'cluster',
            'clutch',
            'coach',
            'coast',
            'coconut',
            'code',
            'coffee',
            'coil',
            'coin',
            'collect',
            'color',
            'column',
            'combine',
            'come',
            'comfort',
            'comic',
            'common',
            'company',
            'concert',
            'conduct',
            'confirm',
            'congress',
            'connect',
            'consider',
            'control',
            'convince',
            'cook',
            'cool',
            'copper',
            'copy',
            'coral',
            'core',
            'corn',
            'correct',
            'cost',
            'cotton',
            'couch',
            'country',
            'couple',
            'course',
            'cousin',
            'cover',
            'coyote',
            'crack',
            'cradle',
            'craft',
            'cram',
            'crane',
            'crash',
            'crater',
            'crawl',
            'crazy',
            'cream',
            'credit',
            'creek',
            'crew',
            'cricket',
            'crime',
            'crisp',
            'critic',
            'crop',
            'cross',
            'crouch',
            'crowd',
            'crucial',
            'cruel',
            'cruise',
            'crumble',
            'crunch',
            'crush',
            'cry',
            'crystal',
            'cube',
            'culture',
            'cup',
            'cupboard',
            'curious',
            'current',
            'curtain',
            'curve',
            'cushion',
            'custom',
            'cute',
            'cycle',
            'dad',
            'damage',
            'damp',
            'dance',
            'danger',
            'daring',
            'dash',
            'daughter',
            'dawn',
            'day',
            'deal',
            'debate',
            'debris',
            'decade',
            'december',
            'decide',
            'decline',
            'decorate',
            'decrease',
            'deer',
            'defense',
            'define',
            'defy',
            'degree',
            'delay',
            'deliver',
            'demand',
            'demise',
            'denial',
            'dentist',
            'deny',
            'depart',
            'depend',
            'deposit',
            'depth',
            'deputy',
            'derive',
            'describe',
            'desert',
            'design',
            'desk',
            'despair',
            'destroy',
            'detail',
            'detect',
            'develop',
            'device',
            'devote',
            'diagram',
            'dial',
            'diamond',
            'diary',
            'dice',
            'diesel',
            'diet',
            'differ',
            'digital',
            'dignity',
            'dilemma',
            'dinner',
            'dinosaur',
            'direct',
            'dirt',
            'disagree',
            'discover',
            'disease',
            'dish',
            'dismiss',
            'disorder',
            'display',
            'distance',
            'divert',
            'divide',
            'divorce',
            'dizzy',
            'doctor',
            'document',
            'dog',
            'doll',
            'dolphin',
            'domain',
            'donate',
            'donkey',
            'donor',
            'door',
            'dose',
            'double',
            'dove',
            'draft',
            'dragon',
            'drama',
            'drastic',
            'draw',
            'dream',
            'dress',
            'drift',
            'drill',
            'drink',
            'drip',
            'drive',
            'drop',
            'drum',
            'dry',
            'duck',
            'dumb',
            'dune',
            'during',
            'dust',
            'dutch',
            'duty',
            'dwarf',
            'dynamic',
            'eager',
            'eagle',
            'early',
            'earn',
            'earth',
            'easily',
            'east',
            'easy',
            'echo',
            'ecology',
            'economy',
            'edge',
            'edit',
            'educate',
            'effort',
            'egg',
            'eight',
            'either',
            'elbow',
            'elder',
            'electric',
            'elegant',
            'element',
            'elephant',
            'elevator',
            'elite',
            'else',
            'embark',
            'embody',
            'embrace',
            'emerge',
            'emotion',
            'employ',
            'empower',
            'empty',
            'enable',
            'enact',
            'end',
            'endless',
            'endorse',
            'enemy',
            'energy',
            'enforce',
            'engage',
            'engine',
            'enhance',
            'enjoy',
            'enlist',
            'enough',
            'enrich',
            'enroll',
            'ensure',
            'enter',
            'entire',
            'entry',
            'envelope',
            'episode',
            'equal',
            'equip',
            'era',
            'erase',
            'erode',
            'erosion',
            'error',
            'erupt',
            'escape',
            'essay',
            'essence',
            'estate',
            'eternal',
            'ethics',
            'evidence',
            'evil',
            'evoke',
            'evolve',
            'exact',
            'example',
            'excess',
            'exchange',
            'excite',
            'exclude',
            'excuse',
            'execute',
            'exercise',
            'exhaust',
            'exhibit',
            'exile',
            'exist',
            'exit',
            'exotic',
            'expand',
            'expect',
            'expire',
            'explain',
            'expose',
            'express',
            'extend',
            'extra',
            'eye',
            'eyebrow',
            'fabric',
            'face',
            'faculty',
            'fade',
            'faint',
            'faith',
            'fall',
            'false',
            'fame',
            'family',
            'famous',
            'fan',
            'fancy',
            'fantasy',
            'farm',
            'fashion',
            'fat',
            'fatal',
            'father',
            'fatigue',
            'fault',
            'favorite',
            'feature',
            'february',
            'federal',
            'fee',
            'feed',
            'feel',
            'female',
            'fence',
            'festival',
            'fetch',
            'fever',
            'few',
            'fiber',
            'fiction',
            'field',
            'figure',
            'file',
            'film',
            'filter',
            'final',
            'find',
            'fine',
            'finger',
            'finish',
            'fire',
            'firm',
            'first',
            'fiscal',
            'fish',
            'fit',
            'fitness',
            'fix',
            'flag',
            'flame',
            'flash',
            'flat',
            'flavor',
            'flee',
            'flight',
            'flip',
            'float',
            'flock',
            'floor',
            'flower',
            'fluid',
            'flush',
            'fly',
            'foam',
            'focus',
            'fog',
            'foil',
            'fold',
            'follow',
            'food',
            'foot',
            'force',
            'forest',
            'forget',
            'fork',
            'fortune',
            'forum',
            'forward',
            'fossil',
            'foster',
            'found',
            'fox',
            'fragile',
            'frame',
            'frequent',
            'fresh',
            'friend',
            'fringe',
            'frog',
            'front',
            'frost',
            'frown',
            'frozen',
            'fruit',
            'fuel',
            'fun',
            'funny',
            'furnace',
            'fury',
            'future',
            'gadget',
            'gain',
            'galaxy',
            'gallery',
            'game',
            'gap',
            'garage',
            'garbage',
            'garden',
            'garlic',
            'garment',
            'gas',
            'gasp',
            'gate',
            'gather',
            'gauge',
            'gaze',
            'general',
            'genius',
            'genre',
            'gentle',
            'genuine',
            'gesture',
            'ghost',
            'giant',
            'gift',
            'giggle',
            'ginger',
            'giraffe',
            'girl',
            'give',
            'glad',
            'glance',
            'glare',
            'glass',
            'glide',
            'glimpse',
            'globe',
            'gloom',
            'glory',
            'glove',
            'glow',
            'glue',
            'goat',
            'goddess',
            'gold',
            'good',
            'goose',
            'gorilla',
            'gospel',
            'gossip',
            'govern',
            'gown',
            'grab',
            'grace',
            'grain',
            'grant',
            'grape',
            'grass',
            'gravity',
            'great',
            'green',
            'grid',
            'grief',
            'grit',
            'grocery',
            'group',
            'grow',
            'grunt',
            'guard',
            'guess',
            'guide',
            'guilt',
            'guitar',
            'gun',
            'gym',
            'habit',
            'hair',
            'half',
            'hammer',
            'hamster',
            'hand',
            'happy',
            'harbor',
            'hard',
            'harsh',
            'harvest',
            'hat',
            'have',
            'hawk',
            'hazard',
            'head',
            'health',
            'heart',
            'heavy',
            'hedgehog',
            'height',
            'hello',
            'helmet',
            'help',
            'hen',
            'hero',
            'hidden',
            'high',
            'hill',
            'hint',
            'hip',
            'hire',
            'history',
            'hobby',
            'hockey',
            'hold',
            'hole',
            'holiday',
            'hollow',
            'home',
            'honey',
            'hood',
            'hope',
            'horn',
            'horror',
            'horse',
            'hospital',
            'host',
            'hotel',
            'hour',
            'hover',
            'hub',
            'huge',
            'human',
            'humble',
            'humor',
            'hundred',
            'hungry',
            'hunt',
            'hurdle',
            'hurry',
            'hurt',
            'husband',
            'hybrid',
            'ice',
            'icon',
            'idea',
            'identify',
            'idle',
            'ignore',
            'ill',
            'illegal',
            'illness',
            'image',
            'imitate',
            'immense',
            'immune',
            'impact',
            'impose',
            'improve',
            'impulse',
            'inch',
            'include',
            'income',
            'increase',
            'index',
            'indicate',
            'indoor',
            'industry',
            'infant',
            'inflict',
            'inform',
            'inhale',
            'inherit',
            'initial',
            'inject',
            'injury',
            'inmate',
            'inner',
            'innocent',
            'input',
            'inquiry',
            'insane',
            'insect',
            'inside',
            'inspire',
            'install',
            'intact',
            'interest',
            'into',
            'invest',
            'invite',
            'involve',
            'iron',
            'island',
            'isolate',
            'issue',
            'item',
            'ivory',
            'jacket',
            'jaguar',
            'jar',
            'jazz',
            'jealous',
            'jeans',
            'jelly',
            'jewel',
            'job',
            'join',
            'joke',
            'journey',
            'joy',
            'judge',
            'juice',
            'jump',
            'jungle',
            'junior',
            'junk',
            'just',
            'kangaroo',
            'keen',
            'keep',
            'ketchup',
            'key',
            'kick',
            'kid',
            'kidney',
            'kind',
            'kingdom',
            'kiss',
            'kit',
            'kitchen',
            'kite',
            'kitten',
            'kiwi',
            'knee',
            'knife',
            'knock',
            'know',
            'lab',
            'label',
            'labor',
            'ladder',
            'lady',
            'lake',
            'lamp',
            'language',
            'laptop',
            'large',
            'later',
            'latin',
            'laugh',
            'laundry',
            'lava',
            'law',
            'lawn',
            'lawsuit',
            'layer',
            'lazy',
            'leader',
            'leaf',
            'learn',
            'leave',
            'lecture',
            'left',
            'leg',
            'legal',
            'legend',
            'leisure',
            'lemon',
            'lend',
            'length',
            'lens',
            'leopard',
            'lesson',
            'letter',
            'level',
            'liar',
            'liberty',
            'library',
            'license',
            'life',
            'lift',
            'light',
            'like',
            'limb',
            'limit',
            'link',
            'lion',
            'liquid',
            'list',
            'little',
            'live',
            'lizard',
            'load',
            'loan',
            'lobster',
            'local',
            'lock',
            'logic',
            'lonely',
            'long',
            'loop',
            'lottery',
            'loud',
            'lounge',
            'love',
            'loyal',
            'lucky',
            'luggage',
            'lumber',
            'lunar',
            'lunch',
            'luxury',
            'lyrics',
            'machine',
            'mad',
            'magic',
            'magnet',
            'maid',
            'mail',
            'main',
            'major',
            'make',
            'mammal',
            'man',
            'manage',
            'mandate',
            'mango',
            'mansion',
            'manual',
            'maple',
            'marble',
            'march',
            'margin',
            'marine',
            'market',
            'marriage',
            'mask',
            'mass',
            'master',
            'match',
            'material',
            'math',
            'matrix',
            'matter',
            'maximum',
            'maze',
            'meadow',
            'mean',
            'measure',
            'meat',
            'mechanic',
            'medal',
            'media',
            'melody',
            'melt',
            'member',
            'memory',
            'mention',
            'menu',
            'mercy',
            'merge',
            'merit',
            'merry',
            'mesh',
            'message',
            'metal',
            'method',
            'middle',
            'midnight',
            'milk',
            'million',
            'mimic',
            'mind',
            'minimum',
            'minor',
            'minute',
            'miracle',
            'mirror',
            'misery',
            'miss',
            'mistake',
            'mix',
            'mixed',
            'mixture',
            'mobile',
            'model',
            'modify',
            'mom',
            'moment',
            'monitor',
            'monkey',
            'monster',
            'month',
            'moon',
            'moral',
            'more',
            'morning',
            'mosquito',
            'mother',
            'motion',
            'motor',
            'mountain',
            'mouse',
            'move',
            'movie',
            'much',
            'muffin',
            'mule',
            'multiply',
            'muscle',
            'museum',
            'mushroom',
            'music',
            'must',
            'mutual',
            'myself',
            'mystery',
            'myth',
            'naive',
            'name',
            'napkin',
            'narrow',
            'nasty',
            'nation',
            'nature',
            'near',
            'neck',
            'need',
            'negative',
            'neglect',
            'neither',
            'nephew',
            'nerve',
            'nest',
            'net',
            'network',
            'neutral',
            'never',
            'news',
            'next',
            'nice',
            'night',
            'noble',
            'noise',
            'nominee',
            'noodle',
            'normal',
            'north',
            'nose',
            'notable',
            'note',
            'nothing',
            'notice',
            'novel',
            'now',
            'nuclear',
            'number',
            'nurse',
            'nut',
            'oak',
            'obey',
            'object',
            'oblige',
            'obscure',
            'observe',
            'obtain',
            'obvious',
            'occur',
            'ocean',
            'october',
            'odor',
            'off',
            'offer',
            'office',
            'often',
            'oil',
            'okay',
            'old',
            'olive',
            'olympic',
            'omit',
            'once',
            'one',
            'onion',
            'online',
            'only',
            'open',
            'opera',
            'opinion',
            'oppose',
            'option',
            'orange',
            'orbit',
            'orchard',
            'order',
            'ordinary',
            'organ',
            'orient',
            'original',
            'orphan',
            'ostrich',
            'other',
            'outdoor',
            'outer',
            'output',
            'outside',
            'oval',
            'oven',
            'over',
            'own',
            'owner',
            'oxygen',
            'oyster',
            'ozone',
            'pact',
            'paddle',
            'page',
            'pair',
            'palace',
            'palm',
            'panda',
            'panel',
            'panic',
            'panther',
            'paper',
            'parade',
            'parent',
            'park',
            'parrot',
            'party',
            'pass',
            'patch',
            'path',
            'patient',
            'patrol',
            'pattern',
            'pause',
            'pave',
            'payment',
            'peace',
            'peanut',
            'pear',
            'peasant',
            'pelican',
            'pen',
            'penalty',
            'pencil',
            'people',
            'pepper',
            'perfect',
            'permit',
            'person',
            'pet',
            'phone',
            'photo',
            'phrase',
            'physical',
            'piano',
            'picnic',
            'picture',
            'piece',
            'pig',
            'pigeon',
            'pill',
            'pilot',
            'pink',
            'pioneer',
            'pipe',
            'pistol',
            'pitch',
            'pizza',
            'place',
            'planet',
            'plastic',
            'plate',
            'play',
            'please',
            'pledge',
            'pluck',
            'plug',
            'plunge',
            'poem',
            'poet',
            'point',
            'polar',
            'pole',
            'police',
            'pond',
            'pony',
            'pool',
            'popular',
            'portion',
            'position',
            'possible',
            'post',
            'potato',
            'pottery',
            'poverty',
            'powder',
            'power',
            'practice',
            'praise',
            'predict',
            'prefer',
            'prepare',
            'present',
            'pretty',
            'prevent',
            'price',
            'pride',
            'primary',
            'print',
            'priority',
            'prison',
            'private',
            'prize',
            'problem',
            'process',
            'produce',
            'profit',
            'program',
            'project',
            'promote',
            'proof',
            'property',
            'prosper',
            'protect',
            'proud',
            'provide',
            'public',
            'pudding',
            'pull',
            'pulp',
            'pulse',
            'pumpkin',
            'punch',
            'pupil',
            'puppy',
            'purchase',
            'purity',
            'purpose',
            'purse',
            'push',
            'put',
            'puzzle',
            'pyramid',
            'quality',
            'quantum',
            'quarter',
            'question',
            'quick',
            'quit',
            'quiz',
            'quote',
            'rabbit',
            'raccoon',
            'race',
            'rack',
            'radar',
            'radio',
            'rail',
            'rain',
            'raise',
            'rally',
            'ramp',
            'ranch',
            'random',
            'range',
            'rapid',
            'rare',
            'rate',
            'rather',
            'raven',
            'raw',
            'razor',
            'ready',
            'real',
            'reason',
            'rebel',
            'rebuild',
            'recall',
            'receive',
            'recipe',
            'record',
            'recycle',
            'reduce',
            'reflect',
            'reform',
            'refuse',
            'region',
            'regret',
            'regular',
            'reject',
            'relax',
            'release',
            'relief',
            'rely',
            'remain',
            'remember',
            'remind',
            'remove',
            'render',
            'renew',
            'rent',
            'reopen',
            'repair',
            'repeat',
            'replace',
            'report',
            'require',
            'rescue',
            'resemble',
            'resist',
            'resource',
            'response',
            'result',
            'retire',
            'retreat',
            'return',
            'reunion',
            'reveal',
            'review',
            'reward',
            'rhythm',
            'rib',
            'ribbon',
            'rice',
            'rich',
            'ride',
            'ridge',
            'rifle',
            'right',
            'rigid',
            'ring',
            'riot',
            'ripple',
            'risk',
            'ritual',
            'rival',
            'river',
            'road',
            'roast',
            'robot',
            'robust',
            'rocket',
            'romance',
            'roof',
            'rookie',
            'room',
            'rose',
            'rotate',
            'rough',
            'round',
            'route',
            'royal',
            'rubber',
            'rude',
            'rug',
            'rule',
            'run',
            'runway',
            'rural',
            'sad',
            'saddle',
            'sadness',
            'safe',
            'sail',
            'salad',
            'salmon',
            'salon',
            'salt',
            'salute',
            'same',
            'sample',
            'sand',
            'satisfy',
            'satoshi',
            'sauce',
            'sausage',
            'save',
            'say',
            'scale',
            'scan',
            'scare',
            'scatter',
            'scene',
            'scheme',
            'school',
            'science',
            'scissors',
            'scorpion',
            'scout',
            'scrap',
            'screen',
            'script',
            'scrub',
            'sea',
            'search',
            'season',
            'seat',
            'second',
            'secret',
            'section',
            'security',
            'seed',
            'seek',
            'segment',
            'select',
            'sell',
            'seminar',
            'senior',
            'sense',
            'sentence',
            'series',
            'service',
            'session',
            'settle',
            'setup',
            'seven',
            'shadow',
            'shaft',
            'shallow',
            'share',
            'shed',
            'shell',
            'sheriff',
            'shield',
            'shift',
            'shine',
            'ship',
            'shiver',
            'shock',
            'shoe',
            'shoot',
            'shop',
            'short',
            'shoulder',
            'shove',
            'shrimp',
            'shrug',
            'shuffle',
            'shy',
            'sibling',
            'sick',
            'side',
            'siege',
            'sight',
            'sign',
            'silent',
            'silk',
            'silly',
            'silver',
            'similar',
            'simple',
            'since',
            'sing',
            'siren',
            'sister',
            'situate',
            'six',
            'size',
            'skate',
            'sketch',
            'ski',
            'skill',
            'skin',
            'skirt',
            'skull',
            'slab',
            'slam',
            'sleep',
            'slender',
            'slice',
            'slide',
            'slight',
            'slim',
            'slogan',
            'slot',
            'slow',
            'slush',
            'small',
            'smart',
            'smile',
            'smoke',
            'smooth',
            'snack',
            'snake',
            'snap',
            'sniff',
            'snow',
            'soap',
            'soccer',
            'social',
            'sock',
            'soda',
            'soft',
            'solar',
            'soldier',
            'solid',
            'solution',
            'solve',
            'someone',
            'song',
            'soon',
            'sorry',
            'sort',
            'soul',
            'sound',
            'soup',
            'source',
            'south',
            'space',
            'spare',
            'spatial',
            'spawn',
            'speak',
            'special',
            'speed',
            'spell',
            'spend',
            'sphere',
            'spice',
            'spider',
            'spike',
            'spin',
            'spirit',
            'split',
            'spoil',
            'sponsor',
            'spoon',
            'sport',
            'spot',
            'spray',
            'spread',
            'spring',
            'spy',
            'square',
            'squeeze',
            'squirrel',
            'stable',
            'stadium',
            'staff',
            'stage',
            'stairs',
            'stamp',
            'stand',
            'start',
            'state',
            'stay',
            'steak',
            'steel',
            'stem',
            'step',
            'stereo',
            'stick',
            'still',
            'sting',
            'stock',
            'stomach',
            'stone',
            'stool',
            'story',
            'stove',
            'strategy',
            'street',
            'strike',
            'strong',
            'struggle',
            'student',
            'stuff',
            'stumble',
            'style',
            'subject',
            'submit',
            'subway',
            'success',
            'such',
            'sudden',
            'suffer',
            'sugar',
            'suggest',
            'suit',
            'summer',
            'sun',
            'sunny',
            'sunset',
            'super',
            'supply',
            'supreme',
            'sure',
            'surface',
            'surge',
            'surprise',
            'surround',
            'survey',
            'suspect',
            'sustain',
            'swallow',
            'swamp',
            'swap',
            'swarm',
            'swear',
            'sweet',
            'swift',
            'swim',
            'swing',
            'switch',
            'sword',
            'symbol',
            'symptom',
            'syrup',
            'system',
            'table',
            'tackle',
            'tag',
            'tail',
            'talent',
            'talk',
            'tank',
            'tape',
            'target',
            'task',
            'taste',
            'tattoo',
            'taxi',
            'teach',
            'team',
            'tell',
            'ten',
            'tenant',
            'tennis',
            'tent',
            'term',
            'test',
            'text',
            'thank',
            'that',
            'theme',
            'then',
            'theory',
            'there',
            'they',
            'thing',
            'this',
            'thought',
            'three',
            'thrive',
            'throw',
            'thumb',
            'thunder',
            'ticket',
            'tide',
            'tiger',
            'tilt',
            'timber',
            'time',
            'tiny',
            'tip',
            'tired',
            'tissue',
            'title',
            'toast',
            'tobacco',
            'today',
            'toddler',
            'toe',
            'together',
            'toilet',
            'token',
            'tomato',
            'tomorrow',
            'tone',
            'tongue',
            'tonight',
            'tool',
            'tooth',
            'top',
            'topic',
            'topple',
            'torch',
            'tornado',
            'tortoise',
            'toss',
            'total',
            'tourist',
            'toward',
            'tower',
            'town',
            'toy',
            'track',
            'trade',
            'traffic',
            'tragic',
            'train',
            'transfer',
            'trap',
            'trash',
            'travel',
            'tray',
            'treat',
            'tree',
            'trend',
            'trial',
            'tribe',
            'trick',
            'trigger',
            'trim',
            'trip',
            'trophy',
            'trouble',
            'truck',
            'true',
            'truly',
            'trumpet',
            'trust',
            'truth',
            'try',
            'tube',
            'tuition',
            'tumble',
            'tuna',
            'tunnel',
            'turkey',
            'turn',
            'turtle',
            'twelve',
            'twenty',
            'twice',
            'twin',
            'twist',
            'two',
            'type',
            'typical',
            'ugly',
            'umbrella',
            'unable',
            'unaware',
            'uncle',
            'uncover',
            'under',
            'undo',
            'unfair',
            'unfold',
            'unhappy',
            'uniform',
            'unique',
            'unit',
            'universe',
            'unknown',
            'unlock',
            'until',
            'unusual',
            'unveil',
            'update',
            'upgrade',
            'uphold',
            'upon',
            'upper',
            'upset',
            'urban',
            'urge',
            'usage',
            'use',
            'used',
            'useful',
            'useless',
            'usual',
            'utility',
            'vacant',
            'vacuum',
            'vague',
            'valid',
            'valley',
            'valve',
            'van',
            'vanish',
            'vapor',
            'various',
            'vast',
            'vault',
            'vehicle',
            'velvet',
            'vendor',
            'venture',
            'venue',
            'verb',
            'verify',
            'version',
            'very',
            'vessel',
            'veteran',
            'viable',
            'vibrant',
            'vicious',
            'victory',
            'video',
            'view',
            'village',
            'vintage',
            'violin',
            'virtual',
            'virus',
            'visa',
            'visit',
            'visual',
            'vital',
            'vivid',
            'vocal',
            'voice',
            'void',
            'volcano',
            'volume',
            'vote',
            'voyage',
            'wage',
            'wagon',
            'wait',
            'walk',
            'wall',
            'walnut',
            'want',
            'warfare',
            'warm',
            'warrior',
            'wash',
            'wasp',
            'waste',
            'water',
            'wave',
            'way',
            'wealth',
            'weapon',
            'wear',
            'weasel',
            'weather',
            'web',
            'wedding',
            'weekend',
            'weird',
            'welcome',
            'west',
            'wet',
            'whale',
            'what',
            'wheat',
            'wheel',
            'when',
            'where',
            'whip',
            'whisper',
            'wide',
            'width',
            'wife',
            'wild',
            'will',
            'win',
            'window',
            'wine',
            'wing',
            'wink',
            'winner',
            'winter',
            'wire',
            'wisdom',
            'wise',
            'wish',
            'witness',
            'wolf',
            'woman',
            'wonder',
            'wood',
            'wool',
            'word',
            'work',
            'world',
            'worry',
            'worth',
            'wrap',
            'wreck',
            'wrestle',
            'wrist',
            'write',
            'wrong',
            'yard',
            'year',
            'yellow',
            'you',
            'young',
            'youth',
            'zebra',
            'zero',
            'zone',
            'zoo'
          ];
        },
        {}
      ],
      82: [
        function(require, module, exports) {
          module.exports = [
            'abaisser',
            'abandon',
            'abdiquer',
            'abeille',
            'abolir',
            'aborder',
            'aboutir',
            'aboyer',
            'abrasif',
            'abreuver',
            'abriter',
            'abroger',
            'abrupt',
            'absence',
            'absolu',
            'absurde',
            'abusif',
            'abyssal',
            'académie',
            'acajou',
            'acarien',
            'accabler',
            'accepter',
            'acclamer',
            'accolade',
            'accroche',
            'accuser',
            'acerbe',
            'achat',
            'acheter',
            'aciduler',
            'acier',
            'acompte',
            'acquérir',
            'acronyme',
            'acteur',
            'actif',
            'actuel',
            'adepte',
            'adéquat',
            'adhésif',
            'adjectif',
            'adjuger',
            'admettre',
            'admirer',
            'adopter',
            'adorer',
            'adoucir',
            'adresse',
            'adroit',
            'adulte',
            'adverbe',
            'aérer',
            'aéronef',
            'affaire',
            'affecter',
            'affiche',
            'affreux',
            'affubler',
            'agacer',
            'agencer',
            'agile',
            'agiter',
            'agrafer',
            'agréable',
            'agrume',
            'aider',
            'aiguille',
            'ailier',
            'aimable',
            'aisance',
            'ajouter',
            'ajuster',
            'alarmer',
            'alchimie',
            'alerte',
            'algèbre',
            'algue',
            'aliéner',
            'aliment',
            'alléger',
            'alliage',
            'allouer',
            'allumer',
            'alourdir',
            'alpaga',
            'altesse',
            'alvéole',
            'amateur',
            'ambigu',
            'ambre',
            'aménager',
            'amertume',
            'amidon',
            'amiral',
            'amorcer',
            'amour',
            'amovible',
            'amphibie',
            'ampleur',
            'amusant',
            'analyse',
            'anaphore',
            'anarchie',
            'anatomie',
            'ancien',
            'anéantir',
            'angle',
            'angoisse',
            'anguleux',
            'animal',
            'annexer',
            'annonce',
            'annuel',
            'anodin',
            'anomalie',
            'anonyme',
            'anormal',
            'antenne',
            'antidote',
            'anxieux',
            'apaiser',
            'apéritif',
            'aplanir',
            'apologie',
            'appareil',
            'appeler',
            'apporter',
            'appuyer',
            'aquarium',
            'aqueduc',
            'arbitre',
            'arbuste',
            'ardeur',
            'ardoise',
            'argent',
            'arlequin',
            'armature',
            'armement',
            'armoire',
            'armure',
            'arpenter',
            'arracher',
            'arriver',
            'arroser',
            'arsenic',
            'artériel',
            'article',
            'aspect',
            'asphalte',
            'aspirer',
            'assaut',
            'asservir',
            'assiette',
            'associer',
            'assurer',
            'asticot',
            'astre',
            'astuce',
            'atelier',
            'atome',
            'atrium',
            'atroce',
            'attaque',
            'attentif',
            'attirer',
            'attraper',
            'aubaine',
            'auberge',
            'audace',
            'audible',
            'augurer',
            'aurore',
            'automne',
            'autruche',
            'avaler',
            'avancer',
            'avarice',
            'avenir',
            'averse',
            'aveugle',
            'aviateur',
            'avide',
            'avion',
            'aviser',
            'avoine',
            'avouer',
            'avril',
            'axial',
            'axiome',
            'badge',
            'bafouer',
            'bagage',
            'baguette',
            'baignade',
            'balancer',
            'balcon',
            'baleine',
            'balisage',
            'bambin',
            'bancaire',
            'bandage',
            'banlieue',
            'bannière',
            'banquier',
            'barbier',
            'baril',
            'baron',
            'barque',
            'barrage',
            'bassin',
            'bastion',
            'bataille',
            'bateau',
            'batterie',
            'baudrier',
            'bavarder',
            'belette',
            'bélier',
            'belote',
            'bénéfice',
            'berceau',
            'berger',
            'berline',
            'bermuda',
            'besace',
            'besogne',
            'bétail',
            'beurre',
            'biberon',
            'bicycle',
            'bidule',
            'bijou',
            'bilan',
            'bilingue',
            'billard',
            'binaire',
            'biologie',
            'biopsie',
            'biotype',
            'biscuit',
            'bison',
            'bistouri',
            'bitume',
            'bizarre',
            'blafard',
            'blague',
            'blanchir',
            'blessant',
            'blinder',
            'blond',
            'bloquer',
            'blouson',
            'bobard',
            'bobine',
            'boire',
            'boiser',
            'bolide',
            'bonbon',
            'bondir',
            'bonheur',
            'bonifier',
            'bonus',
            'bordure',
            'borne',
            'botte',
            'boucle',
            'boueux',
            'bougie',
            'boulon',
            'bouquin',
            'bourse',
            'boussole',
            'boutique',
            'boxeur',
            'branche',
            'brasier',
            'brave',
            'brebis',
            'brèche',
            'breuvage',
            'bricoler',
            'brigade',
            'brillant',
            'brioche',
            'brique',
            'brochure',
            'broder',
            'bronzer',
            'brousse',
            'broyeur',
            'brume',
            'brusque',
            'brutal',
            'bruyant',
            'buffle',
            'buisson',
            'bulletin',
            'bureau',
            'burin',
            'bustier',
            'butiner',
            'butoir',
            'buvable',
            'buvette',
            'cabanon',
            'cabine',
            'cachette',
            'cadeau',
            'cadre',
            'caféine',
            'caillou',
            'caisson',
            'calculer',
            'calepin',
            'calibre',
            'calmer',
            'calomnie',
            'calvaire',
            'camarade',
            'caméra',
            'camion',
            'campagne',
            'canal',
            'caneton',
            'canon',
            'cantine',
            'canular',
            'capable',
            'caporal',
            'caprice',
            'capsule',
            'capter',
            'capuche',
            'carabine',
            'carbone',
            'caresser',
            'caribou',
            'carnage',
            'carotte',
            'carreau',
            'carton',
            'cascade',
            'casier',
            'casque',
            'cassure',
            'causer',
            'caution',
            'cavalier',
            'caverne',
            'caviar',
            'cédille',
            'ceinture',
            'céleste',
            'cellule',
            'cendrier',
            'censurer',
            'central',
            'cercle',
            'cérébral',
            'cerise',
            'cerner',
            'cerveau',
            'cesser',
            'chagrin',
            'chaise',
            'chaleur',
            'chambre',
            'chance',
            'chapitre',
            'charbon',
            'chasseur',
            'chaton',
            'chausson',
            'chavirer',
            'chemise',
            'chenille',
            'chéquier',
            'chercher',
            'cheval',
            'chien',
            'chiffre',
            'chignon',
            'chimère',
            'chiot',
            'chlorure',
            'chocolat',
            'choisir',
            'chose',
            'chouette',
            'chrome',
            'chute',
            'cigare',
            'cigogne',
            'cimenter',
            'cinéma',
            'cintrer',
            'circuler',
            'cirer',
            'cirque',
            'citerne',
            'citoyen',
            'citron',
            'civil',
            'clairon',
            'clameur',
            'claquer',
            'classe',
            'clavier',
            'client',
            'cligner',
            'climat',
            'clivage',
            'cloche',
            'clonage',
            'cloporte',
            'cobalt',
            'cobra',
            'cocasse',
            'cocotier',
            'coder',
            'codifier',
            'coffre',
            'cogner',
            'cohésion',
            'coiffer',
            'coincer',
            'colère',
            'colibri',
            'colline',
            'colmater',
            'colonel',
            'combat',
            'comédie',
            'commande',
            'compact',
            'concert',
            'conduire',
            'confier',
            'congeler',
            'connoter',
            'consonne',
            'contact',
            'convexe',
            'copain',
            'copie',
            'corail',
            'corbeau',
            'cordage',
            'corniche',
            'corpus',
            'correct',
            'cortège',
            'cosmique',
            'costume',
            'coton',
            'coude',
            'coupure',
            'courage',
            'couteau',
            'couvrir',
            'coyote',
            'crabe',
            'crainte',
            'cravate',
            'crayon',
            'créature',
            'créditer',
            'crémeux',
            'creuser',
            'crevette',
            'cribler',
            'crier',
            'cristal',
            'critère',
            'croire',
            'croquer',
            'crotale',
            'crucial',
            'cruel',
            'crypter',
            'cubique',
            'cueillir',
            'cuillère',
            'cuisine',
            'cuivre',
            'culminer',
            'cultiver',
            'cumuler',
            'cupide',
            'curatif',
            'curseur',
            'cyanure',
            'cycle',
            'cylindre',
            'cynique',
            'daigner',
            'damier',
            'danger',
            'danseur',
            'dauphin',
            'débattre',
            'débiter',
            'déborder',
            'débrider',
            'débutant',
            'décaler',
            'décembre',
            'déchirer',
            'décider',
            'déclarer',
            'décorer',
            'décrire',
            'décupler',
            'dédale',
            'déductif',
            'déesse',
            'défensif',
            'défiler',
            'défrayer',
            'dégager',
            'dégivrer',
            'déglutir',
            'dégrafer',
            'déjeuner',
            'délice',
            'déloger',
            'demander',
            'demeurer',
            'démolir',
            'dénicher',
            'dénouer',
            'dentelle',
            'dénuder',
            'départ',
            'dépenser',
            'déphaser',
            'déplacer',
            'déposer',
            'déranger',
            'dérober',
            'désastre',
            'descente',
            'désert',
            'désigner',
            'désobéir',
            'dessiner',
            'destrier',
            'détacher',
            'détester',
            'détourer',
            'détresse',
            'devancer',
            'devenir',
            'deviner',
            'devoir',
            'diable',
            'dialogue',
            'diamant',
            'dicter',
            'différer',
            'digérer',
            'digital',
            'digne',
            'diluer',
            'dimanche',
            'diminuer',
            'dioxyde',
            'directif',
            'diriger',
            'discuter',
            'disposer',
            'dissiper',
            'distance',
            'divertir',
            'diviser',
            'docile',
            'docteur',
            'dogme',
            'doigt',
            'domaine',
            'domicile',
            'dompter',
            'donateur',
            'donjon',
            'donner',
            'dopamine',
            'dortoir',
            'dorure',
            'dosage',
            'doseur',
            'dossier',
            'dotation',
            'douanier',
            'double',
            'douceur',
            'douter',
            'doyen',
            'dragon',
            'draper',
            'dresser',
            'dribbler',
            'droiture',
            'duperie',
            'duplexe',
            'durable',
            'durcir',
            'dynastie',
            'éblouir',
            'écarter',
            'écharpe',
            'échelle',
            'éclairer',
            'éclipse',
            'éclore',
            'écluse',
            'école',
            'économie',
            'écorce',
            'écouter',
            'écraser',
            'écrémer',
            'écrivain',
            'écrou',
            'écume',
            'écureuil',
            'édifier',
            'éduquer',
            'effacer',
            'effectif',
            'effigie',
            'effort',
            'effrayer',
            'effusion',
            'égaliser',
            'égarer',
            'éjecter',
            'élaborer',
            'élargir',
            'électron',
            'élégant',
            'éléphant',
            'élève',
            'éligible',
            'élitisme',
            'éloge',
            'élucider',
            'éluder',
            'emballer',
            'embellir',
            'embryon',
            'émeraude',
            'émission',
            'emmener',
            'émotion',
            'émouvoir',
            'empereur',
            'employer',
            'emporter',
            'emprise',
            'émulsion',
            'encadrer',
            'enchère',
            'enclave',
            'encoche',
            'endiguer',
            'endosser',
            'endroit',
            'enduire',
            'énergie',
            'enfance',
            'enfermer',
            'enfouir',
            'engager',
            'engin',
            'englober',
            'énigme',
            'enjamber',
            'enjeu',
            'enlever',
            'ennemi',
            'ennuyeux',
            'enrichir',
            'enrobage',
            'enseigne',
            'entasser',
            'entendre',
            'entier',
            'entourer',
            'entraver',
            'énumérer',
            'envahir',
            'enviable',
            'envoyer',
            'enzyme',
            'éolien',
            'épaissir',
            'épargne',
            'épatant',
            'épaule',
            'épicerie',
            'épidémie',
            'épier',
            'épilogue',
            'épine',
            'épisode',
            'épitaphe',
            'époque',
            'épreuve',
            'éprouver',
            'épuisant',
            'équerre',
            'équipe',
            'ériger',
            'érosion',
            'erreur',
            'éruption',
            'escalier',
            'espadon',
            'espèce',
            'espiègle',
            'espoir',
            'esprit',
            'esquiver',
            'essayer',
            'essence',
            'essieu',
            'essorer',
            'estime',
            'estomac',
            'estrade',
            'étagère',
            'étaler',
            'étanche',
            'étatique',
            'éteindre',
            'étendoir',
            'éternel',
            'éthanol',
            'éthique',
            'ethnie',
            'étirer',
            'étoffer',
            'étoile',
            'étonnant',
            'étourdir',
            'étrange',
            'étroit',
            'étude',
            'euphorie',
            'évaluer',
            'évasion',
            'éventail',
            'évidence',
            'éviter',
            'évolutif',
            'évoquer',
            'exact',
            'exagérer',
            'exaucer',
            'exceller',
            'excitant',
            'exclusif',
            'excuse',
            'exécuter',
            'exemple',
            'exercer',
            'exhaler',
            'exhorter',
            'exigence',
            'exiler',
            'exister',
            'exotique',
            'expédier',
            'explorer',
            'exposer',
            'exprimer',
            'exquis',
            'extensif',
            'extraire',
            'exulter',
            'fable',
            'fabuleux',
            'facette',
            'facile',
            'facture',
            'faiblir',
            'falaise',
            'fameux',
            'famille',
            'farceur',
            'farfelu',
            'farine',
            'farouche',
            'fasciner',
            'fatal',
            'fatigue',
            'faucon',
            'fautif',
            'faveur',
            'favori',
            'fébrile',
            'féconder',
            'fédérer',
            'félin',
            'femme',
            'fémur',
            'fendoir',
            'féodal',
            'fermer',
            'féroce',
            'ferveur',
            'festival',
            'feuille',
            'feutre',
            'février',
            'fiasco',
            'ficeler',
            'fictif',
            'fidèle',
            'figure',
            'filature',
            'filetage',
            'filière',
            'filleul',
            'filmer',
            'filou',
            'filtrer',
            'financer',
            'finir',
            'fiole',
            'firme',
            'fissure',
            'fixer',
            'flairer',
            'flamme',
            'flasque',
            'flatteur',
            'fléau',
            'flèche',
            'fleur',
            'flexion',
            'flocon',
            'flore',
            'fluctuer',
            'fluide',
            'fluvial',
            'folie',
            'fonderie',
            'fongible',
            'fontaine',
            'forcer',
            'forgeron',
            'formuler',
            'fortune',
            'fossile',
            'foudre',
            'fougère',
            'fouiller',
            'foulure',
            'fourmi',
            'fragile',
            'fraise',
            'franchir',
            'frapper',
            'frayeur',
            'frégate',
            'freiner',
            'frelon',
            'frémir',
            'frénésie',
            'frère',
            'friable',
            'friction',
            'frisson',
            'frivole',
            'froid',
            'fromage',
            'frontal',
            'frotter',
            'fruit',
            'fugitif',
            'fuite',
            'fureur',
            'furieux',
            'furtif',
            'fusion',
            'futur',
            'gagner',
            'galaxie',
            'galerie',
            'gambader',
            'garantir',
            'gardien',
            'garnir',
            'garrigue',
            'gazelle',
            'gazon',
            'géant',
            'gélatine',
            'gélule',
            'gendarme',
            'général',
            'génie',
            'genou',
            'gentil',
            'géologie',
            'géomètre',
            'géranium',
            'germe',
            'gestuel',
            'geyser',
            'gibier',
            'gicler',
            'girafe',
            'givre',
            'glace',
            'glaive',
            'glisser',
            'globe',
            'gloire',
            'glorieux',
            'golfeur',
            'gomme',
            'gonfler',
            'gorge',
            'gorille',
            'goudron',
            'gouffre',
            'goulot',
            'goupille',
            'gourmand',
            'goutte',
            'graduel',
            'graffiti',
            'graine',
            'grand',
            'grappin',
            'gratuit',
            'gravir',
            'grenat',
            'griffure',
            'griller',
            'grimper',
            'grogner',
            'gronder',
            'grotte',
            'groupe',
            'gruger',
            'grutier',
            'gruyère',
            'guépard',
            'guerrier',
            'guide',
            'guimauve',
            'guitare',
            'gustatif',
            'gymnaste',
            'gyrostat',
            'habitude',
            'hachoir',
            'halte',
            'hameau',
            'hangar',
            'hanneton',
            'haricot',
            'harmonie',
            'harpon',
            'hasard',
            'hélium',
            'hématome',
            'herbe',
            'hérisson',
            'hermine',
            'héron',
            'hésiter',
            'heureux',
            'hiberner',
            'hibou',
            'hilarant',
            'histoire',
            'hiver',
            'homard',
            'hommage',
            'homogène',
            'honneur',
            'honorer',
            'honteux',
            'horde',
            'horizon',
            'horloge',
            'hormone',
            'horrible',
            'houleux',
            'housse',
            'hublot',
            'huileux',
            'humain',
            'humble',
            'humide',
            'humour',
            'hurler',
            'hydromel',
            'hygiène',
            'hymne',
            'hypnose',
            'idylle',
            'ignorer',
            'iguane',
            'illicite',
            'illusion',
            'image',
            'imbiber',
            'imiter',
            'immense',
            'immobile',
            'immuable',
            'impact',
            'impérial',
            'implorer',
            'imposer',
            'imprimer',
            'imputer',
            'incarner',
            'incendie',
            'incident',
            'incliner',
            'incolore',
            'indexer',
            'indice',
            'inductif',
            'inédit',
            'ineptie',
            'inexact',
            'infini',
            'infliger',
            'informer',
            'infusion',
            'ingérer',
            'inhaler',
            'inhiber',
            'injecter',
            'injure',
            'innocent',
            'inoculer',
            'inonder',
            'inscrire',
            'insecte',
            'insigne',
            'insolite',
            'inspirer',
            'instinct',
            'insulter',
            'intact',
            'intense',
            'intime',
            'intrigue',
            'intuitif',
            'inutile',
            'invasion',
            'inventer',
            'inviter',
            'invoquer',
            'ironique',
            'irradier',
            'irréel',
            'irriter',
            'isoler',
            'ivoire',
            'ivresse',
            'jaguar',
            'jaillir',
            'jambe',
            'janvier',
            'jardin',
            'jauger',
            'jaune',
            'javelot',
            'jetable',
            'jeton',
            'jeudi',
            'jeunesse',
            'joindre',
            'joncher',
            'jongler',
            'joueur',
            'jouissif',
            'journal',
            'jovial',
            'joyau',
            'joyeux',
            'jubiler',
            'jugement',
            'junior',
            'jupon',
            'juriste',
            'justice',
            'juteux',
            'juvénile',
            'kayak',
            'kimono',
            'kiosque',
            'label',
            'labial',
            'labourer',
            'lacérer',
            'lactose',
            'lagune',
            'laine',
            'laisser',
            'laitier',
            'lambeau',
            'lamelle',
            'lampe',
            'lanceur',
            'langage',
            'lanterne',
            'lapin',
            'largeur',
            'larme',
            'laurier',
            'lavabo',
            'lavoir',
            'lecture',
            'légal',
            'léger',
            'légume',
            'lessive',
            'lettre',
            'levier',
            'lexique',
            'lézard',
            'liasse',
            'libérer',
            'libre',
            'licence',
            'licorne',
            'liège',
            'lièvre',
            'ligature',
            'ligoter',
            'ligue',
            'limer',
            'limite',
            'limonade',
            'limpide',
            'linéaire',
            'lingot',
            'lionceau',
            'liquide',
            'lisière',
            'lister',
            'lithium',
            'litige',
            'littoral',
            'livreur',
            'logique',
            'lointain',
            'loisir',
            'lombric',
            'loterie',
            'louer',
            'lourd',
            'loutre',
            'louve',
            'loyal',
            'lubie',
            'lucide',
            'lucratif',
            'lueur',
            'lugubre',
            'luisant',
            'lumière',
            'lunaire',
            'lundi',
            'luron',
            'lutter',
            'luxueux',
            'machine',
            'magasin',
            'magenta',
            'magique',
            'maigre',
            'maillon',
            'maintien',
            'mairie',
            'maison',
            'majorer',
            'malaxer',
            'maléfice',
            'malheur',
            'malice',
            'mallette',
            'mammouth',
            'mandater',
            'maniable',
            'manquant',
            'manteau',
            'manuel',
            'marathon',
            'marbre',
            'marchand',
            'mardi',
            'maritime',
            'marqueur',
            'marron',
            'marteler',
            'mascotte',
            'massif',
            'matériel',
            'matière',
            'matraque',
            'maudire',
            'maussade',
            'mauve',
            'maximal',
            'méchant',
            'méconnu',
            'médaille',
            'médecin',
            'méditer',
            'méduse',
            'meilleur',
            'mélange',
            'mélodie',
            'membre',
            'mémoire',
            'menacer',
            'mener',
            'menhir',
            'mensonge',
            'mentor',
            'mercredi',
            'mérite',
            'merle',
            'messager',
            'mesure',
            'métal',
            'météore',
            'méthode',
            'métier',
            'meuble',
            'miauler',
            'microbe',
            'miette',
            'mignon',
            'migrer',
            'milieu',
            'million',
            'mimique',
            'mince',
            'minéral',
            'minimal',
            'minorer',
            'minute',
            'miracle',
            'miroiter',
            'missile',
            'mixte',
            'mobile',
            'moderne',
            'moelleux',
            'mondial',
            'moniteur',
            'monnaie',
            'monotone',
            'monstre',
            'montagne',
            'monument',
            'moqueur',
            'morceau',
            'morsure',
            'mortier',
            'moteur',
            'motif',
            'mouche',
            'moufle',
            'moulin',
            'mousson',
            'mouton',
            'mouvant',
            'multiple',
            'munition',
            'muraille',
            'murène',
            'murmure',
            'muscle',
            'muséum',
            'musicien',
            'mutation',
            'muter',
            'mutuel',
            'myriade',
            'myrtille',
            'mystère',
            'mythique',
            'nageur',
            'nappe',
            'narquois',
            'narrer',
            'natation',
            'nation',
            'nature',
            'naufrage',
            'nautique',
            'navire',
            'nébuleux',
            'nectar',
            'néfaste',
            'négation',
            'négliger',
            'négocier',
            'neige',
            'nerveux',
            'nettoyer',
            'neurone',
            'neutron',
            'neveu',
            'niche',
            'nickel',
            'nitrate',
            'niveau',
            'noble',
            'nocif',
            'nocturne',
            'noirceur',
            'noisette',
            'nomade',
            'nombreux',
            'nommer',
            'normatif',
            'notable',
            'notifier',
            'notoire',
            'nourrir',
            'nouveau',
            'novateur',
            'novembre',
            'novice',
            'nuage',
            'nuancer',
            'nuire',
            'nuisible',
            'numéro',
            'nuptial',
            'nuque',
            'nutritif',
            'obéir',
            'objectif',
            'obliger',
            'obscur',
            'observer',
            'obstacle',
            'obtenir',
            'obturer',
            'occasion',
            'occuper',
            'océan',
            'octobre',
            'octroyer',
            'octupler',
            'oculaire',
            'odeur',
            'odorant',
            'offenser',
            'officier',
            'offrir',
            'ogive',
            'oiseau',
            'oisillon',
            'olfactif',
            'olivier',
            'ombrage',
            'omettre',
            'onctueux',
            'onduler',
            'onéreux',
            'onirique',
            'opale',
            'opaque',
            'opérer',
            'opinion',
            'opportun',
            'opprimer',
            'opter',
            'optique',
            'orageux',
            'orange',
            'orbite',
            'ordonner',
            'oreille',
            'organe',
            'orgueil',
            'orifice',
            'ornement',
            'orque',
            'ortie',
            'osciller',
            'osmose',
            'ossature',
            'otarie',
            'ouragan',
            'ourson',
            'outil',
            'outrager',
            'ouvrage',
            'ovation',
            'oxyde',
            'oxygène',
            'ozone',
            'paisible',
            'palace',
            'palmarès',
            'palourde',
            'palper',
            'panache',
            'panda',
            'pangolin',
            'paniquer',
            'panneau',
            'panorama',
            'pantalon',
            'papaye',
            'papier',
            'papoter',
            'papyrus',
            'paradoxe',
            'parcelle',
            'paresse',
            'parfumer',
            'parler',
            'parole',
            'parrain',
            'parsemer',
            'partager',
            'parure',
            'parvenir',
            'passion',
            'pastèque',
            'paternel',
            'patience',
            'patron',
            'pavillon',
            'pavoiser',
            'payer',
            'paysage',
            'peigne',
            'peintre',
            'pelage',
            'pélican',
            'pelle',
            'pelouse',
            'peluche',
            'pendule',
            'pénétrer',
            'pénible',
            'pensif',
            'pénurie',
            'pépite',
            'péplum',
            'perdrix',
            'perforer',
            'période',
            'permuter',
            'perplexe',
            'persil',
            'perte',
            'peser',
            'pétale',
            'petit',
            'pétrir',
            'peuple',
            'pharaon',
            'phobie',
            'phoque',
            'photon',
            'phrase',
            'physique',
            'piano',
            'pictural',
            'pièce',
            'pierre',
            'pieuvre',
            'pilote',
            'pinceau',
            'pipette',
            'piquer',
            'pirogue',
            'piscine',
            'piston',
            'pivoter',
            'pixel',
            'pizza',
            'placard',
            'plafond',
            'plaisir',
            'planer',
            'plaque',
            'plastron',
            'plateau',
            'pleurer',
            'plexus',
            'pliage',
            'plomb',
            'plonger',
            'pluie',
            'plumage',
            'pochette',
            'poésie',
            'poète',
            'pointe',
            'poirier',
            'poisson',
            'poivre',
            'polaire',
            'policier',
            'pollen',
            'polygone',
            'pommade',
            'pompier',
            'ponctuel',
            'pondérer',
            'poney',
            'portique',
            'position',
            'posséder',
            'posture',
            'potager',
            'poteau',
            'potion',
            'pouce',
            'poulain',
            'poumon',
            'pourpre',
            'poussin',
            'pouvoir',
            'prairie',
            'pratique',
            'précieux',
            'prédire',
            'préfixe',
            'prélude',
            'prénom',
            'présence',
            'prétexte',
            'prévoir',
            'primitif',
            'prince',
            'prison',
            'priver',
            'problème',
            'procéder',
            'prodige',
            'profond',
            'progrès',
            'proie',
            'projeter',
            'prologue',
            'promener',
            'propre',
            'prospère',
            'protéger',
            'prouesse',
            'proverbe',
            'prudence',
            'pruneau',
            'psychose',
            'public',
            'puceron',
            'puiser',
            'pulpe',
            'pulsar',
            'punaise',
            'punitif',
            'pupitre',
            'purifier',
            'puzzle',
            'pyramide',
            'quasar',
            'querelle',
            'question',
            'quiétude',
            'quitter',
            'quotient',
            'racine',
            'raconter',
            'radieux',
            'ragondin',
            'raideur',
            'raisin',
            'ralentir',
            'rallonge',
            'ramasser',
            'rapide',
            'rasage',
            'ratisser',
            'ravager',
            'ravin',
            'rayonner',
            'réactif',
            'réagir',
            'réaliser',
            'réanimer',
            'recevoir',
            'réciter',
            'réclamer',
            'récolter',
            'recruter',
            'reculer',
            'recycler',
            'rédiger',
            'redouter',
            'refaire',
            'réflexe',
            'réformer',
            'refrain',
            'refuge',
            'régalien',
            'région',
            'réglage',
            'régulier',
            'réitérer',
            'rejeter',
            'rejouer',
            'relatif',
            'relever',
            'relief',
            'remarque',
            'remède',
            'remise',
            'remonter',
            'remplir',
            'remuer',
            'renard',
            'renfort',
            'renifler',
            'renoncer',
            'rentrer',
            'renvoi',
            'replier',
            'reporter',
            'reprise',
            'reptile',
            'requin',
            'réserve',
            'résineux',
            'résoudre',
            'respect',
            'rester',
            'résultat',
            'rétablir',
            'retenir',
            'réticule',
            'retomber',
            'retracer',
            'réunion',
            'réussir',
            'revanche',
            'revivre',
            'révolte',
            'révulsif',
            'richesse',
            'rideau',
            'rieur',
            'rigide',
            'rigoler',
            'rincer',
            'riposter',
            'risible',
            'risque',
            'rituel',
            'rival',
            'rivière',
            'rocheux',
            'romance',
            'rompre',
            'ronce',
            'rondin',
            'roseau',
            'rosier',
            'rotatif',
            'rotor',
            'rotule',
            'rouge',
            'rouille',
            'rouleau',
            'routine',
            'royaume',
            'ruban',
            'rubis',
            'ruche',
            'ruelle',
            'rugueux',
            'ruiner',
            'ruisseau',
            'ruser',
            'rustique',
            'rythme',
            'sabler',
            'saboter',
            'sabre',
            'sacoche',
            'safari',
            'sagesse',
            'saisir',
            'salade',
            'salive',
            'salon',
            'saluer',
            'samedi',
            'sanction',
            'sanglier',
            'sarcasme',
            'sardine',
            'saturer',
            'saugrenu',
            'saumon',
            'sauter',
            'sauvage',
            'savant',
            'savonner',
            'scalpel',
            'scandale',
            'scélérat',
            'scénario',
            'sceptre',
            'schéma',
            'science',
            'scinder',
            'score',
            'scrutin',
            'sculpter',
            'séance',
            'sécable',
            'sécher',
            'secouer',
            'sécréter',
            'sédatif',
            'séduire',
            'seigneur',
            'séjour',
            'sélectif',
            'semaine',
            'sembler',
            'semence',
            'séminal',
            'sénateur',
            'sensible',
            'sentence',
            'séparer',
            'séquence',
            'serein',
            'sergent',
            'sérieux',
            'serrure',
            'sérum',
            'service',
            'sésame',
            'sévir',
            'sevrage',
            'sextuple',
            'sidéral',
            'siècle',
            'siéger',
            'siffler',
            'sigle',
            'signal',
            'silence',
            'silicium',
            'simple',
            'sincère',
            'sinistre',
            'siphon',
            'sirop',
            'sismique',
            'situer',
            'skier',
            'social',
            'socle',
            'sodium',
            'soigneux',
            'soldat',
            'soleil',
            'solitude',
            'soluble',
            'sombre',
            'sommeil',
            'somnoler',
            'sonde',
            'songeur',
            'sonnette',
            'sonore',
            'sorcier',
            'sortir',
            'sosie',
            'sottise',
            'soucieux',
            'soudure',
            'souffle',
            'soulever',
            'soupape',
            'source',
            'soutirer',
            'souvenir',
            'spacieux',
            'spatial',
            'spécial',
            'sphère',
            'spiral',
            'stable',
            'station',
            'sternum',
            'stimulus',
            'stipuler',
            'strict',
            'studieux',
            'stupeur',
            'styliste',
            'sublime',
            'substrat',
            'subtil',
            'subvenir',
            'succès',
            'sucre',
            'suffixe',
            'suggérer',
            'suiveur',
            'sulfate',
            'superbe',
            'supplier',
            'surface',
            'suricate',
            'surmener',
            'surprise',
            'sursaut',
            'survie',
            'suspect',
            'syllabe',
            'symbole',
            'symétrie',
            'synapse',
            'syntaxe',
            'système',
            'tabac',
            'tablier',
            'tactile',
            'tailler',
            'talent',
            'talisman',
            'talonner',
            'tambour',
            'tamiser',
            'tangible',
            'tapis',
            'taquiner',
            'tarder',
            'tarif',
            'tartine',
            'tasse',
            'tatami',
            'tatouage',
            'taupe',
            'taureau',
            'taxer',
            'témoin',
            'temporel',
            'tenaille',
            'tendre',
            'teneur',
            'tenir',
            'tension',
            'terminer',
            'terne',
            'terrible',
            'tétine',
            'texte',
            'thème',
            'théorie',
            'thérapie',
            'thorax',
            'tibia',
            'tiède',
            'timide',
            'tirelire',
            'tiroir',
            'tissu',
            'titane',
            'titre',
            'tituber',
            'toboggan',
            'tolérant',
            'tomate',
            'tonique',
            'tonneau',
            'toponyme',
            'torche',
            'tordre',
            'tornade',
            'torpille',
            'torrent',
            'torse',
            'tortue',
            'totem',
            'toucher',
            'tournage',
            'tousser',
            'toxine',
            'traction',
            'trafic',
            'tragique',
            'trahir',
            'train',
            'trancher',
            'travail',
            'trèfle',
            'tremper',
            'trésor',
            'treuil',
            'triage',
            'tribunal',
            'tricoter',
            'trilogie',
            'triomphe',
            'tripler',
            'triturer',
            'trivial',
            'trombone',
            'tronc',
            'tropical',
            'troupeau',
            'tuile',
            'tulipe',
            'tumulte',
            'tunnel',
            'turbine',
            'tuteur',
            'tutoyer',
            'tuyau',
            'tympan',
            'typhon',
            'typique',
            'tyran',
            'ubuesque',
            'ultime',
            'ultrason',
            'unanime',
            'unifier',
            'union',
            'unique',
            'unitaire',
            'univers',
            'uranium',
            'urbain',
            'urticant',
            'usage',
            'usine',
            'usuel',
            'usure',
            'utile',
            'utopie',
            'vacarme',
            'vaccin',
            'vagabond',
            'vague',
            'vaillant',
            'vaincre',
            'vaisseau',
            'valable',
            'valise',
            'vallon',
            'valve',
            'vampire',
            'vanille',
            'vapeur',
            'varier',
            'vaseux',
            'vassal',
            'vaste',
            'vecteur',
            'vedette',
            'végétal',
            'véhicule',
            'veinard',
            'véloce',
            'vendredi',
            'vénérer',
            'venger',
            'venimeux',
            'ventouse',
            'verdure',
            'vérin',
            'vernir',
            'verrou',
            'verser',
            'vertu',
            'veston',
            'vétéran',
            'vétuste',
            'vexant',
            'vexer',
            'viaduc',
            'viande',
            'victoire',
            'vidange',
            'vidéo',
            'vignette',
            'vigueur',
            'vilain',
            'village',
            'vinaigre',
            'violon',
            'vipère',
            'virement',
            'virtuose',
            'virus',
            'visage',
            'viseur',
            'vision',
            'visqueux',
            'visuel',
            'vital',
            'vitesse',
            'viticole',
            'vitrine',
            'vivace',
            'vivipare',
            'vocation',
            'voguer',
            'voile',
            'voisin',
            'voiture',
            'volaille',
            'volcan',
            'voltiger',
            'volume',
            'vorace',
            'vortex',
            'voter',
            'vouloir',
            'voyage',
            'voyelle',
            'wagon',
            'xénon',
            'yacht',
            'zèbre',
            'zénith',
            'zeste',
            'zoologie'
          ];
        },
        {}
      ],
      83: [
        function(require, module, exports) {
          module.exports = [
            'abaco',
            'abbaglio',
            'abbinato',
            'abete',
            'abisso',
            'abolire',
            'abrasivo',
            'abrogato',
            'accadere',
            'accenno',
            'accusato',
            'acetone',
            'achille',
            'acido',
            'acqua',
            'acre',
            'acrilico',
            'acrobata',
            'acuto',
            'adagio',
            'addebito',
            'addome',
            'adeguato',
            'aderire',
            'adipe',
            'adottare',
            'adulare',
            'affabile',
            'affetto',
            'affisso',
            'affranto',
            'aforisma',
            'afoso',
            'africano',
            'agave',
            'agente',
            'agevole',
            'aggancio',
            'agire',
            'agitare',
            'agonismo',
            'agricolo',
            'agrumeto',
            'aguzzo',
            'alabarda',
            'alato',
            'albatro',
            'alberato',
            'albo',
            'albume',
            'alce',
            'alcolico',
            'alettone',
            'alfa',
            'algebra',
            'aliante',
            'alibi',
            'alimento',
            'allagato',
            'allegro',
            'allievo',
            'allodola',
            'allusivo',
            'almeno',
            'alogeno',
            'alpaca',
            'alpestre',
            'altalena',
            'alterno',
            'alticcio',
            'altrove',
            'alunno',
            'alveolo',
            'alzare',
            'amalgama',
            'amanita',
            'amarena',
            'ambito',
            'ambrato',
            'ameba',
            'america',
            'ametista',
            'amico',
            'ammasso',
            'ammenda',
            'ammirare',
            'ammonito',
            'amore',
            'ampio',
            'ampliare',
            'amuleto',
            'anacardo',
            'anagrafe',
            'analista',
            'anarchia',
            'anatra',
            'anca',
            'ancella',
            'ancora',
            'andare',
            'andrea',
            'anello',
            'angelo',
            'angolare',
            'angusto',
            'anima',
            'annegare',
            'annidato',
            'anno',
            'annuncio',
            'anonimo',
            'anticipo',
            'anzi',
            'apatico',
            'apertura',
            'apode',
            'apparire',
            'appetito',
            'appoggio',
            'approdo',
            'appunto',
            'aprile',
            'arabica',
            'arachide',
            'aragosta',
            'araldica',
            'arancio',
            'aratura',
            'arazzo',
            'arbitro',
            'archivio',
            'ardito',
            'arenile',
            'argento',
            'argine',
            'arguto',
            'aria',
            'armonia',
            'arnese',
            'arredato',
            'arringa',
            'arrosto',
            'arsenico',
            'arso',
            'artefice',
            'arzillo',
            'asciutto',
            'ascolto',
            'asepsi',
            'asettico',
            'asfalto',
            'asino',
            'asola',
            'aspirato',
            'aspro',
            'assaggio',
            'asse',
            'assoluto',
            'assurdo',
            'asta',
            'astenuto',
            'astice',
            'astratto',
            'atavico',
            'ateismo',
            'atomico',
            'atono',
            'attesa',
            'attivare',
            'attorno',
            'attrito',
            'attuale',
            'ausilio',
            'austria',
            'autista',
            'autonomo',
            'autunno',
            'avanzato',
            'avere',
            'avvenire',
            'avviso',
            'avvolgere',
            'azione',
            'azoto',
            'azzimo',
            'azzurro',
            'babele',
            'baccano',
            'bacino',
            'baco',
            'badessa',
            'badilata',
            'bagnato',
            'baita',
            'balcone',
            'baldo',
            'balena',
            'ballata',
            'balzano',
            'bambino',
            'bandire',
            'baraonda',
            'barbaro',
            'barca',
            'baritono',
            'barlume',
            'barocco',
            'basilico',
            'basso',
            'batosta',
            'battuto',
            'baule',
            'bava',
            'bavosa',
            'becco',
            'beffa',
            'belgio',
            'belva',
            'benda',
            'benevole',
            'benigno',
            'benzina',
            'bere',
            'berlina',
            'beta',
            'bibita',
            'bici',
            'bidone',
            'bifido',
            'biga',
            'bilancia',
            'bimbo',
            'binocolo',
            'biologo',
            'bipede',
            'bipolare',
            'birbante',
            'birra',
            'biscotto',
            'bisesto',
            'bisnonno',
            'bisonte',
            'bisturi',
            'bizzarro',
            'blando',
            'blatta',
            'bollito',
            'bonifico',
            'bordo',
            'bosco',
            'botanico',
            'bottino',
            'bozzolo',
            'braccio',
            'bradipo',
            'brama',
            'branca',
            'bravura',
            'bretella',
            'brevetto',
            'brezza',
            'briglia',
            'brillante',
            'brindare',
            'broccolo',
            'brodo',
            'bronzina',
            'brullo',
            'bruno',
            'bubbone',
            'buca',
            'budino',
            'buffone',
            'buio',
            'bulbo',
            'buono',
            'burlone',
            'burrasca',
            'bussola',
            'busta',
            'cadetto',
            'caduco',
            'calamaro',
            'calcolo',
            'calesse',
            'calibro',
            'calmo',
            'caloria',
            'cambusa',
            'camerata',
            'camicia',
            'cammino',
            'camola',
            'campale',
            'canapa',
            'candela',
            'cane',
            'canino',
            'canotto',
            'cantina',
            'capace',
            'capello',
            'capitolo',
            'capogiro',
            'cappero',
            'capra',
            'capsula',
            'carapace',
            'carcassa',
            'cardo',
            'carisma',
            'carovana',
            'carretto',
            'cartolina',
            'casaccio',
            'cascata',
            'caserma',
            'caso',
            'cassone',
            'castello',
            'casuale',
            'catasta',
            'catena',
            'catrame',
            'cauto',
            'cavillo',
            'cedibile',
            'cedrata',
            'cefalo',
            'celebre',
            'cellulare',
            'cena',
            'cenone',
            'centesimo',
            'ceramica',
            'cercare',
            'certo',
            'cerume',
            'cervello',
            'cesoia',
            'cespo',
            'ceto',
            'chela',
            'chiaro',
            'chicca',
            'chiedere',
            'chimera',
            'china',
            'chirurgo',
            'chitarra',
            'ciao',
            'ciclismo',
            'cifrare',
            'cigno',
            'cilindro',
            'ciottolo',
            'circa',
            'cirrosi',
            'citrico',
            'cittadino',
            'ciuffo',
            'civetta',
            'civile',
            'classico',
            'clinica',
            'cloro',
            'cocco',
            'codardo',
            'codice',
            'coerente',
            'cognome',
            'collare',
            'colmato',
            'colore',
            'colposo',
            'coltivato',
            'colza',
            'coma',
            'cometa',
            'commando',
            'comodo',
            'computer',
            'comune',
            'conciso',
            'condurre',
            'conferma',
            'congelare',
            'coniuge',
            'connesso',
            'conoscere',
            'consumo',
            'continuo',
            'convegno',
            'coperto',
            'copione',
            'coppia',
            'copricapo',
            'corazza',
            'cordata',
            'coricato',
            'cornice',
            'corolla',
            'corpo',
            'corredo',
            'corsia',
            'cortese',
            'cosmico',
            'costante',
            'cottura',
            'covato',
            'cratere',
            'cravatta',
            'creato',
            'credere',
            'cremoso',
            'crescita',
            'creta',
            'criceto',
            'crinale',
            'crisi',
            'critico',
            'croce',
            'cronaca',
            'crostata',
            'cruciale',
            'crusca',
            'cucire',
            'cuculo',
            'cugino',
            'cullato',
            'cupola',
            'curatore',
            'cursore',
            'curvo',
            'cuscino',
            'custode',
            'dado',
            'daino',
            'dalmata',
            'damerino',
            'daniela',
            'dannoso',
            'danzare',
            'datato',
            'davanti',
            'davvero',
            'debutto',
            'decennio',
            'deciso',
            'declino',
            'decollo',
            'decreto',
            'dedicato',
            'definito',
            'deforme',
            'degno',
            'delegare',
            'delfino',
            'delirio',
            'delta',
            'demenza',
            'denotato',
            'dentro',
            'deposito',
            'derapata',
            'derivare',
            'deroga',
            'descritto',
            'deserto',
            'desiderio',
            'desumere',
            'detersivo',
            'devoto',
            'diametro',
            'dicembre',
            'diedro',
            'difeso',
            'diffuso',
            'digerire',
            'digitale',
            'diluvio',
            'dinamico',
            'dinnanzi',
            'dipinto',
            'diploma',
            'dipolo',
            'diradare',
            'dire',
            'dirotto',
            'dirupo',
            'disagio',
            'discreto',
            'disfare',
            'disgelo',
            'disposto',
            'distanza',
            'disumano',
            'dito',
            'divano',
            'divelto',
            'dividere',
            'divorato',
            'doblone',
            'docente',
            'doganale',
            'dogma',
            'dolce',
            'domato',
            'domenica',
            'dominare',
            'dondolo',
            'dono',
            'dormire',
            'dote',
            'dottore',
            'dovuto',
            'dozzina',
            'drago',
            'druido',
            'dubbio',
            'dubitare',
            'ducale',
            'duna',
            'duomo',
            'duplice',
            'duraturo',
            'ebano',
            'eccesso',
            'ecco',
            'eclissi',
            'economia',
            'edera',
            'edicola',
            'edile',
            'editoria',
            'educare',
            'egemonia',
            'egli',
            'egoismo',
            'egregio',
            'elaborato',
            'elargire',
            'elegante',
            'elencato',
            'eletto',
            'elevare',
            'elfico',
            'elica',
            'elmo',
            'elsa',
            'eluso',
            'emanato',
            'emblema',
            'emesso',
            'emiro',
            'emotivo',
            'emozione',
            'empirico',
            'emulo',
            'endemico',
            'enduro',
            'energia',
            'enfasi',
            'enoteca',
            'entrare',
            'enzima',
            'epatite',
            'epilogo',
            'episodio',
            'epocale',
            'eppure',
            'equatore',
            'erario',
            'erba',
            'erboso',
            'erede',
            'eremita',
            'erigere',
            'ermetico',
            'eroe',
            'erosivo',
            'errante',
            'esagono',
            'esame',
            'esanime',
            'esaudire',
            'esca',
            'esempio',
            'esercito',
            'esibito',
            'esigente',
            'esistere',
            'esito',
            'esofago',
            'esortato',
            'esoso',
            'espanso',
            'espresso',
            'essenza',
            'esso',
            'esteso',
            'estimare',
            'estonia',
            'estroso',
            'esultare',
            'etilico',
            'etnico',
            'etrusco',
            'etto',
            'euclideo',
            'europa',
            'evaso',
            'evidenza',
            'evitato',
            'evoluto',
            'evviva',
            'fabbrica',
            'faccenda',
            'fachiro',
            'falco',
            'famiglia',
            'fanale',
            'fanfara',
            'fango',
            'fantasma',
            'fare',
            'farfalla',
            'farinoso',
            'farmaco',
            'fascia',
            'fastoso',
            'fasullo',
            'faticare',
            'fato',
            'favoloso',
            'febbre',
            'fecola',
            'fede',
            'fegato',
            'felpa',
            'feltro',
            'femmina',
            'fendere',
            'fenomeno',
            'fermento',
            'ferro',
            'fertile',
            'fessura',
            'festivo',
            'fetta',
            'feudo',
            'fiaba',
            'fiducia',
            'fifa',
            'figurato',
            'filo',
            'finanza',
            'finestra',
            'finire',
            'fiore',
            'fiscale',
            'fisico',
            'fiume',
            'flacone',
            'flamenco',
            'flebo',
            'flemma',
            'florido',
            'fluente',
            'fluoro',
            'fobico',
            'focaccia',
            'focoso',
            'foderato',
            'foglio',
            'folata',
            'folclore',
            'folgore',
            'fondente',
            'fonetico',
            'fonia',
            'fontana',
            'forbito',
            'forchetta',
            'foresta',
            'formica',
            'fornaio',
            'foro',
            'fortezza',
            'forzare',
            'fosfato',
            'fosso',
            'fracasso',
            'frana',
            'frassino',
            'fratello',
            'freccetta',
            'frenata',
            'fresco',
            'frigo',
            'frollino',
            'fronde',
            'frugale',
            'frutta',
            'fucilata',
            'fucsia',
            'fuggente',
            'fulmine',
            'fulvo',
            'fumante',
            'fumetto',
            'fumoso',
            'fune',
            'funzione',
            'fuoco',
            'furbo',
            'furgone',
            'furore',
            'fuso',
            'futile',
            'gabbiano',
            'gaffe',
            'galateo',
            'gallina',
            'galoppo',
            'gambero',
            'gamma',
            'garanzia',
            'garbo',
            'garofano',
            'garzone',
            'gasdotto',
            'gasolio',
            'gastrico',
            'gatto',
            'gaudio',
            'gazebo',
            'gazzella',
            'geco',
            'gelatina',
            'gelso',
            'gemello',
            'gemmato',
            'gene',
            'genitore',
            'gennaio',
            'genotipo',
            'gergo',
            'ghepardo',
            'ghiaccio',
            'ghisa',
            'giallo',
            'gilda',
            'ginepro',
            'giocare',
            'gioiello',
            'giorno',
            'giove',
            'girato',
            'girone',
            'gittata',
            'giudizio',
            'giurato',
            'giusto',
            'globulo',
            'glutine',
            'gnomo',
            'gobba',
            'golf',
            'gomito',
            'gommone',
            'gonfio',
            'gonna',
            'governo',
            'gracile',
            'grado',
            'grafico',
            'grammo',
            'grande',
            'grattare',
            'gravoso',
            'grazia',
            'greca',
            'gregge',
            'grifone',
            'grigio',
            'grinza',
            'grotta',
            'gruppo',
            'guadagno',
            'guaio',
            'guanto',
            'guardare',
            'gufo',
            'guidare',
            'ibernato',
            'icona',
            'identico',
            'idillio',
            'idolo',
            'idra',
            'idrico',
            'idrogeno',
            'igiene',
            'ignaro',
            'ignorato',
            'ilare',
            'illeso',
            'illogico',
            'illudere',
            'imballo',
            'imbevuto',
            'imbocco',
            'imbuto',
            'immane',
            'immerso',
            'immolato',
            'impacco',
            'impeto',
            'impiego',
            'importo',
            'impronta',
            'inalare',
            'inarcare',
            'inattivo',
            'incanto',
            'incendio',
            'inchino',
            'incisivo',
            'incluso',
            'incontro',
            'incrocio',
            'incubo',
            'indagine',
            'india',
            'indole',
            'inedito',
            'infatti',
            'infilare',
            'inflitto',
            'ingaggio',
            'ingegno',
            'inglese',
            'ingordo',
            'ingrosso',
            'innesco',
            'inodore',
            'inoltrare',
            'inondato',
            'insano',
            'insetto',
            'insieme',
            'insonnia',
            'insulina',
            'intasato',
            'intero',
            'intonaco',
            'intuito',
            'inumidire',
            'invalido',
            'invece',
            'invito',
            'iperbole',
            'ipnotico',
            'ipotesi',
            'ippica',
            'iride',
            'irlanda',
            'ironico',
            'irrigato',
            'irrorare',
            'isolato',
            'isotopo',
            'isterico',
            'istituto',
            'istrice',
            'italia',
            'iterare',
            'labbro',
            'labirinto',
            'lacca',
            'lacerato',
            'lacrima',
            'lacuna',
            'laddove',
            'lago',
            'lampo',
            'lancetta',
            'lanterna',
            'lardoso',
            'larga',
            'laringe',
            'lastra',
            'latenza',
            'latino',
            'lattuga',
            'lavagna',
            'lavoro',
            'legale',
            'leggero',
            'lembo',
            'lentezza',
            'lenza',
            'leone',
            'lepre',
            'lesivo',
            'lessato',
            'lesto',
            'letterale',
            'leva',
            'levigato',
            'libero',
            'lido',
            'lievito',
            'lilla',
            'limatura',
            'limitare',
            'limpido',
            'lineare',
            'lingua',
            'liquido',
            'lira',
            'lirica',
            'lisca',
            'lite',
            'litigio',
            'livrea',
            'locanda',
            'lode',
            'logica',
            'lombare',
            'londra',
            'longevo',
            'loquace',
            'lorenzo',
            'loto',
            'lotteria',
            'luce',
            'lucidato',
            'lumaca',
            'luminoso',
            'lungo',
            'lupo',
            'luppolo',
            'lusinga',
            'lusso',
            'lutto',
            'macabro',
            'macchina',
            'macero',
            'macinato',
            'madama',
            'magico',
            'maglia',
            'magnete',
            'magro',
            'maiolica',
            'malafede',
            'malgrado',
            'malinteso',
            'malsano',
            'malto',
            'malumore',
            'mana',
            'mancia',
            'mandorla',
            'mangiare',
            'manifesto',
            'mannaro',
            'manovra',
            'mansarda',
            'mantide',
            'manubrio',
            'mappa',
            'maratona',
            'marcire',
            'maretta',
            'marmo',
            'marsupio',
            'maschera',
            'massaia',
            'mastino',
            'materasso',
            'matricola',
            'mattone',
            'maturo',
            'mazurca',
            'meandro',
            'meccanico',
            'mecenate',
            'medesimo',
            'meditare',
            'mega',
            'melassa',
            'melis',
            'melodia',
            'meninge',
            'meno',
            'mensola',
            'mercurio',
            'merenda',
            'merlo',
            'meschino',
            'mese',
            'messere',
            'mestolo',
            'metallo',
            'metodo',
            'mettere',
            'miagolare',
            'mica',
            'micelio',
            'michele',
            'microbo',
            'midollo',
            'miele',
            'migliore',
            'milano',
            'milite',
            'mimosa',
            'minerale',
            'mini',
            'minore',
            'mirino',
            'mirtillo',
            'miscela',
            'missiva',
            'misto',
            'misurare',
            'mitezza',
            'mitigare',
            'mitra',
            'mittente',
            'mnemonico',
            'modello',
            'modifica',
            'modulo',
            'mogano',
            'mogio',
            'mole',
            'molosso',
            'monastero',
            'monco',
            'mondina',
            'monetario',
            'monile',
            'monotono',
            'monsone',
            'montato',
            'monviso',
            'mora',
            'mordere',
            'morsicato',
            'mostro',
            'motivato',
            'motosega',
            'motto',
            'movenza',
            'movimento',
            'mozzo',
            'mucca',
            'mucosa',
            'muffa',
            'mughetto',
            'mugnaio',
            'mulatto',
            'mulinello',
            'multiplo',
            'mummia',
            'munto',
            'muovere',
            'murale',
            'musa',
            'muscolo',
            'musica',
            'mutevole',
            'muto',
            'nababbo',
            'nafta',
            'nanometro',
            'narciso',
            'narice',
            'narrato',
            'nascere',
            'nastrare',
            'naturale',
            'nautica',
            'naviglio',
            'nebulosa',
            'necrosi',
            'negativo',
            'negozio',
            'nemmeno',
            'neofita',
            'neretto',
            'nervo',
            'nessuno',
            'nettuno',
            'neutrale',
            'neve',
            'nevrotico',
            'nicchia',
            'ninfa',
            'nitido',
            'nobile',
            'nocivo',
            'nodo',
            'nome',
            'nomina',
            'nordico',
            'normale',
            'norvegese',
            'nostrano',
            'notare',
            'notizia',
            'notturno',
            'novella',
            'nucleo',
            'nulla',
            'numero',
            'nuovo',
            'nutrire',
            'nuvola',
            'nuziale',
            'oasi',
            'obbedire',
            'obbligo',
            'obelisco',
            'oblio',
            'obolo',
            'obsoleto',
            'occasione',
            'occhio',
            'occidente',
            'occorrere',
            'occultare',
            'ocra',
            'oculato',
            'odierno',
            'odorare',
            'offerta',
            'offrire',
            'offuscato',
            'oggetto',
            'oggi',
            'ognuno',
            'olandese',
            'olfatto',
            'oliato',
            'oliva',
            'ologramma',
            'oltre',
            'omaggio',
            'ombelico',
            'ombra',
            'omega',
            'omissione',
            'ondoso',
            'onere',
            'onice',
            'onnivoro',
            'onorevole',
            'onta',
            'operato',
            'opinione',
            'opposto',
            'oracolo',
            'orafo',
            'ordine',
            'orecchino',
            'orefice',
            'orfano',
            'organico',
            'origine',
            'orizzonte',
            'orma',
            'ormeggio',
            'ornativo',
            'orologio',
            'orrendo',
            'orribile',
            'ortensia',
            'ortica',
            'orzata',
            'orzo',
            'osare',
            'oscurare',
            'osmosi',
            'ospedale',
            'ospite',
            'ossa',
            'ossidare',
            'ostacolo',
            'oste',
            'otite',
            'otre',
            'ottagono',
            'ottimo',
            'ottobre',
            'ovale',
            'ovest',
            'ovino',
            'oviparo',
            'ovocito',
            'ovunque',
            'ovviare',
            'ozio',
            'pacchetto',
            'pace',
            'pacifico',
            'padella',
            'padrone',
            'paese',
            'paga',
            'pagina',
            'palazzina',
            'palesare',
            'pallido',
            'palo',
            'palude',
            'pandoro',
            'pannello',
            'paolo',
            'paonazzo',
            'paprica',
            'parabola',
            'parcella',
            'parere',
            'pargolo',
            'pari',
            'parlato',
            'parola',
            'partire',
            'parvenza',
            'parziale',
            'passivo',
            'pasticca',
            'patacca',
            'patologia',
            'pattume',
            'pavone',
            'peccato',
            'pedalare',
            'pedonale',
            'peggio',
            'peloso',
            'penare',
            'pendice',
            'penisola',
            'pennuto',
            'penombra',
            'pensare',
            'pentola',
            'pepe',
            'pepita',
            'perbene',
            'percorso',
            'perdonato',
            'perforare',
            'pergamena',
            'periodo',
            'permesso',
            'perno',
            'perplesso',
            'persuaso',
            'pertugio',
            'pervaso',
            'pesatore',
            'pesista',
            'peso',
            'pestifero',
            'petalo',
            'pettine',
            'petulante',
            'pezzo',
            'piacere',
            'pianta',
            'piattino',
            'piccino',
            'picozza',
            'piega',
            'pietra',
            'piffero',
            'pigiama',
            'pigolio',
            'pigro',
            'pila',
            'pilifero',
            'pillola',
            'pilota',
            'pimpante',
            'pineta',
            'pinna',
            'pinolo',
            'pioggia',
            'piombo',
            'piramide',
            'piretico',
            'pirite',
            'pirolisi',
            'pitone',
            'pizzico',
            'placebo',
            'planare',
            'plasma',
            'platano',
            'plenario',
            'pochezza',
            'poderoso',
            'podismo',
            'poesia',
            'poggiare',
            'polenta',
            'poligono',
            'pollice',
            'polmonite',
            'polpetta',
            'polso',
            'poltrona',
            'polvere',
            'pomice',
            'pomodoro',
            'ponte',
            'popoloso',
            'porfido',
            'poroso',
            'porpora',
            'porre',
            'portata',
            'posa',
            'positivo',
            'possesso',
            'postulato',
            'potassio',
            'potere',
            'pranzo',
            'prassi',
            'pratica',
            'precluso',
            'predica',
            'prefisso',
            'pregiato',
            'prelievo',
            'premere',
            'prenotare',
            'preparato',
            'presenza',
            'pretesto',
            'prevalso',
            'prima',
            'principe',
            'privato',
            'problema',
            'procura',
            'produrre',
            'profumo',
            'progetto',
            'prolunga',
            'promessa',
            'pronome',
            'proposta',
            'proroga',
            'proteso',
            'prova',
            'prudente',
            'prugna',
            'prurito',
            'psiche',
            'pubblico',
            'pudica',
            'pugilato',
            'pugno',
            'pulce',
            'pulito',
            'pulsante',
            'puntare',
            'pupazzo',
            'pupilla',
            'puro',
            'quadro',
            'qualcosa',
            'quasi',
            'querela',
            'quota',
            'raccolto',
            'raddoppio',
            'radicale',
            'radunato',
            'raffica',
            'ragazzo',
            'ragione',
            'ragno',
            'ramarro',
            'ramingo',
            'ramo',
            'randagio',
            'rantolare',
            'rapato',
            'rapina',
            'rappreso',
            'rasatura',
            'raschiato',
            'rasente',
            'rassegna',
            'rastrello',
            'rata',
            'ravveduto',
            'reale',
            'recepire',
            'recinto',
            'recluta',
            'recondito',
            'recupero',
            'reddito',
            'redimere',
            'regalato',
            'registro',
            'regola',
            'regresso',
            'relazione',
            'remare',
            'remoto',
            'renna',
            'replica',
            'reprimere',
            'reputare',
            'resa',
            'residente',
            'responso',
            'restauro',
            'rete',
            'retina',
            'retorica',
            'rettifica',
            'revocato',
            'riassunto',
            'ribadire',
            'ribelle',
            'ribrezzo',
            'ricarica',
            'ricco',
            'ricevere',
            'riciclato',
            'ricordo',
            'ricreduto',
            'ridicolo',
            'ridurre',
            'rifasare',
            'riflesso',
            'riforma',
            'rifugio',
            'rigare',
            'rigettato',
            'righello',
            'rilassato',
            'rilevato',
            'rimanere',
            'rimbalzo',
            'rimedio',
            'rimorchio',
            'rinascita',
            'rincaro',
            'rinforzo',
            'rinnovo',
            'rinomato',
            'rinsavito',
            'rintocco',
            'rinuncia',
            'rinvenire',
            'riparato',
            'ripetuto',
            'ripieno',
            'riportare',
            'ripresa',
            'ripulire',
            'risata',
            'rischio',
            'riserva',
            'risibile',
            'riso',
            'rispetto',
            'ristoro',
            'risultato',
            'risvolto',
            'ritardo',
            'ritegno',
            'ritmico',
            'ritrovo',
            'riunione',
            'riva',
            'riverso',
            'rivincita',
            'rivolto',
            'rizoma',
            'roba',
            'robotico',
            'robusto',
            'roccia',
            'roco',
            'rodaggio',
            'rodere',
            'roditore',
            'rogito',
            'rollio',
            'romantico',
            'rompere',
            'ronzio',
            'rosolare',
            'rospo',
            'rotante',
            'rotondo',
            'rotula',
            'rovescio',
            'rubizzo',
            'rubrica',
            'ruga',
            'rullino',
            'rumine',
            'rumoroso',
            'ruolo',
            'rupe',
            'russare',
            'rustico',
            'sabato',
            'sabbiare',
            'sabotato',
            'sagoma',
            'salasso',
            'saldatura',
            'salgemma',
            'salivare',
            'salmone',
            'salone',
            'saltare',
            'saluto',
            'salvo',
            'sapere',
            'sapido',
            'saporito',
            'saraceno',
            'sarcasmo',
            'sarto',
            'sassoso',
            'satellite',
            'satira',
            'satollo',
            'saturno',
            'savana',
            'savio',
            'saziato',
            'sbadiglio',
            'sbalzo',
            'sbancato',
            'sbarra',
            'sbattere',
            'sbavare',
            'sbendare',
            'sbirciare',
            'sbloccato',
            'sbocciato',
            'sbrinare',
            'sbruffone',
            'sbuffare',
            'scabroso',
            'scadenza',
            'scala',
            'scambiare',
            'scandalo',
            'scapola',
            'scarso',
            'scatenare',
            'scavato',
            'scelto',
            'scenico',
            'scettro',
            'scheda',
            'schiena',
            'sciarpa',
            'scienza',
            'scindere',
            'scippo',
            'sciroppo',
            'scivolo',
            'sclerare',
            'scodella',
            'scolpito',
            'scomparto',
            'sconforto',
            'scoprire',
            'scorta',
            'scossone',
            'scozzese',
            'scriba',
            'scrollare',
            'scrutinio',
            'scuderia',
            'scultore',
            'scuola',
            'scuro',
            'scusare',
            'sdebitare',
            'sdoganare',
            'seccatura',
            'secondo',
            'sedano',
            'seggiola',
            'segnalato',
            'segregato',
            'seguito',
            'selciato',
            'selettivo',
            'sella',
            'selvaggio',
            'semaforo',
            'sembrare',
            'seme',
            'seminato',
            'sempre',
            'senso',
            'sentire',
            'sepolto',
            'sequenza',
            'serata',
            'serbato',
            'sereno',
            'serio',
            'serpente',
            'serraglio',
            'servire',
            'sestina',
            'setola',
            'settimana',
            'sfacelo',
            'sfaldare',
            'sfamato',
            'sfarzoso',
            'sfaticato',
            'sfera',
            'sfida',
            'sfilato',
            'sfinge',
            'sfocato',
            'sfoderare',
            'sfogo',
            'sfoltire',
            'sforzato',
            'sfratto',
            'sfruttato',
            'sfuggito',
            'sfumare',
            'sfuso',
            'sgabello',
            'sgarbato',
            'sgonfiare',
            'sgorbio',
            'sgrassato',
            'sguardo',
            'sibilo',
            'siccome',
            'sierra',
            'sigla',
            'signore',
            'silenzio',
            'sillaba',
            'simbolo',
            'simpatico',
            'simulato',
            'sinfonia',
            'singolo',
            'sinistro',
            'sino',
            'sintesi',
            'sinusoide',
            'sipario',
            'sisma',
            'sistole',
            'situato',
            'slitta',
            'slogatura',
            'sloveno',
            'smarrito',
            'smemorato',
            'smentito',
            'smeraldo',
            'smilzo',
            'smontare',
            'smottato',
            'smussato',
            'snellire',
            'snervato',
            'snodo',
            'sobbalzo',
            'sobrio',
            'soccorso',
            'sociale',
            'sodale',
            'soffitto',
            'sogno',
            'soldato',
            'solenne',
            'solido',
            'sollazzo',
            'solo',
            'solubile',
            'solvente',
            'somatico',
            'somma',
            'sonda',
            'sonetto',
            'sonnifero',
            'sopire',
            'soppeso',
            'sopra',
            'sorgere',
            'sorpasso',
            'sorriso',
            'sorso',
            'sorteggio',
            'sorvolato',
            'sospiro',
            'sosta',
            'sottile',
            'spada',
            'spalla',
            'spargere',
            'spatola',
            'spavento',
            'spazzola',
            'specie',
            'spedire',
            'spegnere',
            'spelatura',
            'speranza',
            'spessore',
            'spettrale',
            'spezzato',
            'spia',
            'spigoloso',
            'spillato',
            'spinoso',
            'spirale',
            'splendido',
            'sportivo',
            'sposo',
            'spranga',
            'sprecare',
            'spronato',
            'spruzzo',
            'spuntino',
            'squillo',
            'sradicare',
            'srotolato',
            'stabile',
            'stacco',
            'staffa',
            'stagnare',
            'stampato',
            'stantio',
            'starnuto',
            'stasera',
            'statuto',
            'stelo',
            'steppa',
            'sterzo',
            'stiletto',
            'stima',
            'stirpe',
            'stivale',
            'stizzoso',
            'stonato',
            'storico',
            'strappo',
            'stregato',
            'stridulo',
            'strozzare',
            'strutto',
            'stuccare',
            'stufo',
            'stupendo',
            'subentro',
            'succoso',
            'sudore',
            'suggerito',
            'sugo',
            'sultano',
            'suonare',
            'superbo',
            'supporto',
            'surgelato',
            'surrogato',
            'sussurro',
            'sutura',
            'svagare',
            'svedese',
            'sveglio',
            'svelare',
            'svenuto',
            'svezia',
            'sviluppo',
            'svista',
            'svizzera',
            'svolta',
            'svuotare',
            'tabacco',
            'tabulato',
            'tacciare',
            'taciturno',
            'tale',
            'talismano',
            'tampone',
            'tannino',
            'tara',
            'tardivo',
            'targato',
            'tariffa',
            'tarpare',
            'tartaruga',
            'tasto',
            'tattico',
            'taverna',
            'tavolata',
            'tazza',
            'teca',
            'tecnico',
            'telefono',
            'temerario',
            'tempo',
            'temuto',
            'tendone',
            'tenero',
            'tensione',
            'tentacolo',
            'teorema',
            'terme',
            'terrazzo',
            'terzetto',
            'tesi',
            'tesserato',
            'testato',
            'tetro',
            'tettoia',
            'tifare',
            'tigella',
            'timbro',
            'tinto',
            'tipico',
            'tipografo',
            'tiraggio',
            'tiro',
            'titanio',
            'titolo',
            'titubante',
            'tizio',
            'tizzone',
            'toccare',
            'tollerare',
            'tolto',
            'tombola',
            'tomo',
            'tonfo',
            'tonsilla',
            'topazio',
            'topologia',
            'toppa',
            'torba',
            'tornare',
            'torrone',
            'tortora',
            'toscano',
            'tossire',
            'tostatura',
            'totano',
            'trabocco',
            'trachea',
            'trafila',
            'tragedia',
            'tralcio',
            'tramonto',
            'transito',
            'trapano',
            'trarre',
            'trasloco',
            'trattato',
            'trave',
            'treccia',
            'tremolio',
            'trespolo',
            'tributo',
            'tricheco',
            'trifoglio',
            'trillo',
            'trincea',
            'trio',
            'tristezza',
            'triturato',
            'trivella',
            'tromba',
            'trono',
            'troppo',
            'trottola',
            'trovare',
            'truccato',
            'tubatura',
            'tuffato',
            'tulipano',
            'tumulto',
            'tunisia',
            'turbare',
            'turchino',
            'tuta',
            'tutela',
            'ubicato',
            'uccello',
            'uccisore',
            'udire',
            'uditivo',
            'uffa',
            'ufficio',
            'uguale',
            'ulisse',
            'ultimato',
            'umano',
            'umile',
            'umorismo',
            'uncinetto',
            'ungere',
            'ungherese',
            'unicorno',
            'unificato',
            'unisono',
            'unitario',
            'unte',
            'uovo',
            'upupa',
            'uragano',
            'urgenza',
            'urlo',
            'usanza',
            'usato',
            'uscito',
            'usignolo',
            'usuraio',
            'utensile',
            'utilizzo',
            'utopia',
            'vacante',
            'vaccinato',
            'vagabondo',
            'vagliato',
            'valanga',
            'valgo',
            'valico',
            'valletta',
            'valoroso',
            'valutare',
            'valvola',
            'vampata',
            'vangare',
            'vanitoso',
            'vano',
            'vantaggio',
            'vanvera',
            'vapore',
            'varano',
            'varcato',
            'variante',
            'vasca',
            'vedetta',
            'vedova',
            'veduto',
            'vegetale',
            'veicolo',
            'velcro',
            'velina',
            'velluto',
            'veloce',
            'venato',
            'vendemmia',
            'vento',
            'verace',
            'verbale',
            'vergogna',
            'verifica',
            'vero',
            'verruca',
            'verticale',
            'vescica',
            'vessillo',
            'vestale',
            'veterano',
            'vetrina',
            'vetusto',
            'viandante',
            'vibrante',
            'vicenda',
            'vichingo',
            'vicinanza',
            'vidimare',
            'vigilia',
            'vigneto',
            'vigore',
            'vile',
            'villano',
            'vimini',
            'vincitore',
            'viola',
            'vipera',
            'virgola',
            'virologo',
            'virulento',
            'viscoso',
            'visione',
            'vispo',
            'vissuto',
            'visura',
            'vita',
            'vitello',
            'vittima',
            'vivanda',
            'vivido',
            'viziare',
            'voce',
            'voga',
            'volatile',
            'volere',
            'volpe',
            'voragine',
            'vulcano',
            'zampogna',
            'zanna',
            'zappato',
            'zattera',
            'zavorra',
            'zefiro',
            'zelante',
            'zelo',
            'zenzero',
            'zerbino',
            'zibetto',
            'zinco',
            'zircone',
            'zitto',
            'zolla',
            'zotico',
            'zucchero',
            'zufolo',
            'zulu',
            'zuppa'
          ];
        },
        {}
      ],
      84: [
        function(require, module, exports) {
          module.exports = [
            'あいこくしん',
            'あいさつ',
            'あいだ',
            'あおぞら',
            'あかちゃん',
            'あきる',
            'あけがた',
            'あける',
            'あこがれる',
            'あさい',
            'あさひ',
            'あしあと',
            'あじわう',
            'あずかる',
            'あずき',
            'あそぶ',
            'あたえる',
            'あたためる',
            'あたりまえ',
            'あたる',
            'あつい',
            'あつかう',
            'あっしゅく',
            'あつまり',
            'あつめる',
            'あてな',
            'あてはまる',
            'あひる',
            'あぶら',
            'あぶる',
            'あふれる',
            'あまい',
            'あまど',
            'あまやかす',
            'あまり',
            'あみもの',
            'あめりか',
            'あやまる',
            'あゆむ',
            'あらいぐま',
            'あらし',
            'あらすじ',
            'あらためる',
            'あらゆる',
            'あらわす',
            'ありがとう',
            'あわせる',
            'あわてる',
            'あんい',
            'あんがい',
            'あんこ',
            'あんぜん',
            'あんてい',
            'あんない',
            'あんまり',
            'いいだす',
            'いおん',
            'いがい',
            'いがく',
            'いきおい',
            'いきなり',
            'いきもの',
            'いきる',
            'いくじ',
            'いくぶん',
            'いけばな',
            'いけん',
            'いこう',
            'いこく',
            'いこつ',
            'いさましい',
            'いさん',
            'いしき',
            'いじゅう',
            'いじょう',
            'いじわる',
            'いずみ',
            'いずれ',
            'いせい',
            'いせえび',
            'いせかい',
            'いせき',
            'いぜん',
            'いそうろう',
            'いそがしい',
            'いだい',
            'いだく',
            'いたずら',
            'いたみ',
            'いたりあ',
            'いちおう',
            'いちじ',
            'いちど',
            'いちば',
            'いちぶ',
            'いちりゅう',
            'いつか',
            'いっしゅん',
            'いっせい',
            'いっそう',
            'いったん',
            'いっち',
            'いってい',
            'いっぽう',
            'いてざ',
            'いてん',
            'いどう',
            'いとこ',
            'いない',
            'いなか',
            'いねむり',
            'いのち',
            'いのる',
            'いはつ',
            'いばる',
            'いはん',
            'いびき',
            'いひん',
            'いふく',
            'いへん',
            'いほう',
            'いみん',
            'いもうと',
            'いもたれ',
            'いもり',
            'いやがる',
            'いやす',
            'いよかん',
            'いよく',
            'いらい',
            'いらすと',
            'いりぐち',
            'いりょう',
            'いれい',
            'いれもの',
            'いれる',
            'いろえんぴつ',
            'いわい',
            'いわう',
            'いわかん',
            'いわば',
            'いわゆる',
            'いんげんまめ',
            'いんさつ',
            'いんしょう',
            'いんよう',
            'うえき',
            'うえる',
            'うおざ',
            'うがい',
            'うかぶ',
            'うかべる',
            'うきわ',
            'うくらいな',
            'うくれれ',
            'うけたまわる',
            'うけつけ',
            'うけとる',
            'うけもつ',
            'うける',
            'うごかす',
            'うごく',
            'うこん',
            'うさぎ',
            'うしなう',
            'うしろがみ',
            'うすい',
            'うすぎ',
            'うすぐらい',
            'うすめる',
            'うせつ',
            'うちあわせ',
            'うちがわ',
            'うちき',
            'うちゅう',
            'うっかり',
            'うつくしい',
            'うったえる',
            'うつる',
            'うどん',
            'うなぎ',
            'うなじ',
            'うなずく',
            'うなる',
            'うねる',
            'うのう',
            'うぶげ',
            'うぶごえ',
            'うまれる',
            'うめる',
            'うもう',
            'うやまう',
            'うよく',
            'うらがえす',
            'うらぐち',
            'うらない',
            'うりあげ',
            'うりきれ',
            'うるさい',
            'うれしい',
            'うれゆき',
            'うれる',
            'うろこ',
            'うわき',
            'うわさ',
            'うんこう',
            'うんちん',
            'うんてん',
            'うんどう',
            'えいえん',
            'えいが',
            'えいきょう',
            'えいご',
            'えいせい',
            'えいぶん',
            'えいよう',
            'えいわ',
            'えおり',
            'えがお',
            'えがく',
            'えきたい',
            'えくせる',
            'えしゃく',
            'えすて',
            'えつらん',
            'えのぐ',
            'えほうまき',
            'えほん',
            'えまき',
            'えもじ',
            'えもの',
            'えらい',
            'えらぶ',
            'えりあ',
            'えんえん',
            'えんかい',
            'えんぎ',
            'えんげき',
            'えんしゅう',
            'えんぜつ',
            'えんそく',
            'えんちょう',
            'えんとつ',
            'おいかける',
            'おいこす',
            'おいしい',
            'おいつく',
            'おうえん',
            'おうさま',
            'おうじ',
            'おうせつ',
            'おうたい',
            'おうふく',
            'おうべい',
            'おうよう',
            'おえる',
            'おおい',
            'おおう',
            'おおどおり',
            'おおや',
            'おおよそ',
            'おかえり',
            'おかず',
            'おがむ',
            'おかわり',
            'おぎなう',
            'おきる',
            'おくさま',
            'おくじょう',
            'おくりがな',
            'おくる',
            'おくれる',
            'おこす',
            'おこなう',
            'おこる',
            'おさえる',
            'おさない',
            'おさめる',
            'おしいれ',
            'おしえる',
            'おじぎ',
            'おじさん',
            'おしゃれ',
            'おそらく',
            'おそわる',
            'おたがい',
            'おたく',
            'おだやか',
            'おちつく',
            'おっと',
            'おつり',
            'おでかけ',
            'おとしもの',
            'おとなしい',
            'おどり',
            'おどろかす',
            'おばさん',
            'おまいり',
            'おめでとう',
            'おもいで',
            'おもう',
            'おもたい',
            'おもちゃ',
            'おやつ',
            'おやゆび',
            'およぼす',
            'おらんだ',
            'おろす',
            'おんがく',
            'おんけい',
            'おんしゃ',
            'おんせん',
            'おんだん',
            'おんちゅう',
            'おんどけい',
            'かあつ',
            'かいが',
            'がいき',
            'がいけん',
            'がいこう',
            'かいさつ',
            'かいしゃ',
            'かいすいよく',
            'かいぜん',
            'かいぞうど',
            'かいつう',
            'かいてん',
            'かいとう',
            'かいふく',
            'がいへき',
            'かいほう',
            'かいよう',
            'がいらい',
            'かいわ',
            'かえる',
            'かおり',
            'かかえる',
            'かがく',
            'かがし',
            'かがみ',
            'かくご',
            'かくとく',
            'かざる',
            'がぞう',
            'かたい',
            'かたち',
            'がちょう',
            'がっきゅう',
            'がっこう',
            'がっさん',
            'がっしょう',
            'かなざわし',
            'かのう',
            'がはく',
            'かぶか',
            'かほう',
            'かほご',
            'かまう',
            'かまぼこ',
            'かめれおん',
            'かゆい',
            'かようび',
            'からい',
            'かるい',
            'かろう',
            'かわく',
            'かわら',
            'がんか',
            'かんけい',
            'かんこう',
            'かんしゃ',
            'かんそう',
            'かんたん',
            'かんち',
            'がんばる',
            'きあい',
            'きあつ',
            'きいろ',
            'ぎいん',
            'きうい',
            'きうん',
            'きえる',
            'きおう',
            'きおく',
            'きおち',
            'きおん',
            'きかい',
            'きかく',
            'きかんしゃ',
            'ききて',
            'きくばり',
            'きくらげ',
            'きけんせい',
            'きこう',
            'きこえる',
            'きこく',
            'きさい',
            'きさく',
            'きさま',
            'きさらぎ',
            'ぎじかがく',
            'ぎしき',
            'ぎじたいけん',
            'ぎじにってい',
            'ぎじゅつしゃ',
            'きすう',
            'きせい',
            'きせき',
            'きせつ',
            'きそう',
            'きぞく',
            'きぞん',
            'きたえる',
            'きちょう',
            'きつえん',
            'ぎっちり',
            'きつつき',
            'きつね',
            'きてい',
            'きどう',
            'きどく',
            'きない',
            'きなが',
            'きなこ',
            'きぬごし',
            'きねん',
            'きのう',
            'きのした',
            'きはく',
            'きびしい',
            'きひん',
            'きふく',
            'きぶん',
            'きぼう',
            'きほん',
            'きまる',
            'きみつ',
            'きむずかしい',
            'きめる',
            'きもだめし',
            'きもち',
            'きもの',
            'きゃく',
            'きやく',
            'ぎゅうにく',
            'きよう',
            'きょうりゅう',
            'きらい',
            'きらく',
            'きりん',
            'きれい',
            'きれつ',
            'きろく',
            'ぎろん',
            'きわめる',
            'ぎんいろ',
            'きんかくじ',
            'きんじょ',
            'きんようび',
            'ぐあい',
            'くいず',
            'くうかん',
            'くうき',
            'くうぐん',
            'くうこう',
            'ぐうせい',
            'くうそう',
            'ぐうたら',
            'くうふく',
            'くうぼ',
            'くかん',
            'くきょう',
            'くげん',
            'ぐこう',
            'くさい',
            'くさき',
            'くさばな',
            'くさる',
            'くしゃみ',
            'くしょう',
            'くすのき',
            'くすりゆび',
            'くせげ',
            'くせん',
            'ぐたいてき',
            'くださる',
            'くたびれる',
            'くちこみ',
            'くちさき',
            'くつした',
            'ぐっすり',
            'くつろぐ',
            'くとうてん',
            'くどく',
            'くなん',
            'くねくね',
            'くのう',
            'くふう',
            'くみあわせ',
            'くみたてる',
            'くめる',
            'くやくしょ',
            'くらす',
            'くらべる',
            'くるま',
            'くれる',
            'くろう',
            'くわしい',
            'ぐんかん',
            'ぐんしょく',
            'ぐんたい',
            'ぐんて',
            'けあな',
            'けいかく',
            'けいけん',
            'けいこ',
            'けいさつ',
            'げいじゅつ',
            'けいたい',
            'げいのうじん',
            'けいれき',
            'けいろ',
            'けおとす',
            'けおりもの',
            'げきか',
            'げきげん',
            'げきだん',
            'げきちん',
            'げきとつ',
            'げきは',
            'げきやく',
            'げこう',
            'げこくじょう',
            'げざい',
            'けさき',
            'げざん',
            'けしき',
            'けしごむ',
            'けしょう',
            'げすと',
            'けたば',
            'けちゃっぷ',
            'けちらす',
            'けつあつ',
            'けつい',
            'けつえき',
            'けっこん',
            'けつじょ',
            'けっせき',
            'けってい',
            'けつまつ',
            'げつようび',
            'げつれい',
            'けつろん',
            'げどく',
            'けとばす',
            'けとる',
            'けなげ',
            'けなす',
            'けなみ',
            'けぬき',
            'げねつ',
            'けねん',
            'けはい',
            'げひん',
            'けぶかい',
            'げぼく',
            'けまり',
            'けみかる',
            'けむし',
            'けむり',
            'けもの',
            'けらい',
            'けろけろ',
            'けわしい',
            'けんい',
            'けんえつ',
            'けんお',
            'けんか',
            'げんき',
            'けんげん',
            'けんこう',
            'けんさく',
            'けんしゅう',
            'けんすう',
            'げんそう',
            'けんちく',
            'けんてい',
            'けんとう',
            'けんない',
            'けんにん',
            'げんぶつ',
            'けんま',
            'けんみん',
            'けんめい',
            'けんらん',
            'けんり',
            'こあくま',
            'こいぬ',
            'こいびと',
            'ごうい',
            'こうえん',
            'こうおん',
            'こうかん',
            'ごうきゅう',
            'ごうけい',
            'こうこう',
            'こうさい',
            'こうじ',
            'こうすい',
            'ごうせい',
            'こうそく',
            'こうたい',
            'こうちゃ',
            'こうつう',
            'こうてい',
            'こうどう',
            'こうない',
            'こうはい',
            'ごうほう',
            'ごうまん',
            'こうもく',
            'こうりつ',
            'こえる',
            'こおり',
            'ごかい',
            'ごがつ',
            'ごかん',
            'こくご',
            'こくさい',
            'こくとう',
            'こくない',
            'こくはく',
            'こぐま',
            'こけい',
            'こける',
            'ここのか',
            'こころ',
            'こさめ',
            'こしつ',
            'こすう',
            'こせい',
            'こせき',
            'こぜん',
            'こそだて',
            'こたい',
            'こたえる',
            'こたつ',
            'こちょう',
            'こっか',
            'こつこつ',
            'こつばん',
            'こつぶ',
            'こてい',
            'こてん',
            'ことがら',
            'ことし',
            'ことば',
            'ことり',
            'こなごな',
            'こねこね',
            'このまま',
            'このみ',
            'このよ',
            'ごはん',
            'こひつじ',
            'こふう',
            'こふん',
            'こぼれる',
            'ごまあぶら',
            'こまかい',
            'ごますり',
            'こまつな',
            'こまる',
            'こむぎこ',
            'こもじ',
            'こもち',
            'こもの',
            'こもん',
            'こやく',
            'こやま',
            'こゆう',
            'こゆび',
            'こよい',
            'こよう',
            'こりる',
            'これくしょん',
            'ころっけ',
            'こわもて',
            'こわれる',
            'こんいん',
            'こんかい',
            'こんき',
            'こんしゅう',
            'こんすい',
            'こんだて',
            'こんとん',
            'こんなん',
            'こんびに',
            'こんぽん',
            'こんまけ',
            'こんや',
            'こんれい',
            'こんわく',
            'ざいえき',
            'さいかい',
            'さいきん',
            'ざいげん',
            'ざいこ',
            'さいしょ',
            'さいせい',
            'ざいたく',
            'ざいちゅう',
            'さいてき',
            'ざいりょう',
            'さうな',
            'さかいし',
            'さがす',
            'さかな',
            'さかみち',
            'さがる',
            'さぎょう',
            'さくし',
            'さくひん',
            'さくら',
            'さこく',
            'さこつ',
            'さずかる',
            'ざせき',
            'さたん',
            'さつえい',
            'ざつおん',
            'ざっか',
            'ざつがく',
            'さっきょく',
            'ざっし',
            'さつじん',
            'ざっそう',
            'さつたば',
            'さつまいも',
            'さてい',
            'さといも',
            'さとう',
            'さとおや',
            'さとし',
            'さとる',
            'さのう',
            'さばく',
            'さびしい',
            'さべつ',
            'さほう',
            'さほど',
            'さます',
            'さみしい',
            'さみだれ',
            'さむけ',
            'さめる',
            'さやえんどう',
            'さゆう',
            'さよう',
            'さよく',
            'さらだ',
            'ざるそば',
            'さわやか',
            'さわる',
            'さんいん',
            'さんか',
            'さんきゃく',
            'さんこう',
            'さんさい',
            'ざんしょ',
            'さんすう',
            'さんせい',
            'さんそ',
            'さんち',
            'さんま',
            'さんみ',
            'さんらん',
            'しあい',
            'しあげ',
            'しあさって',
            'しあわせ',
            'しいく',
            'しいん',
            'しうち',
            'しえい',
            'しおけ',
            'しかい',
            'しかく',
            'じかん',
            'しごと',
            'しすう',
            'じだい',
            'したうけ',
            'したぎ',
            'したて',
            'したみ',
            'しちょう',
            'しちりん',
            'しっかり',
            'しつじ',
            'しつもん',
            'してい',
            'してき',
            'してつ',
            'じてん',
            'じどう',
            'しなぎれ',
            'しなもの',
            'しなん',
            'しねま',
            'しねん',
            'しのぐ',
            'しのぶ',
            'しはい',
            'しばかり',
            'しはつ',
            'しはらい',
            'しはん',
            'しひょう',
            'しふく',
            'じぶん',
            'しへい',
            'しほう',
            'しほん',
            'しまう',
            'しまる',
            'しみん',
            'しむける',
            'じむしょ',
            'しめい',
            'しめる',
            'しもん',
            'しゃいん',
            'しゃうん',
            'しゃおん',
            'じゃがいも',
            'しやくしょ',
            'しゃくほう',
            'しゃけん',
            'しゃこ',
            'しゃざい',
            'しゃしん',
            'しゃせん',
            'しゃそう',
            'しゃたい',
            'しゃちょう',
            'しゃっきん',
            'じゃま',
            'しゃりん',
            'しゃれい',
            'じゆう',
            'じゅうしょ',
            'しゅくはく',
            'じゅしん',
            'しゅっせき',
            'しゅみ',
            'しゅらば',
            'じゅんばん',
            'しょうかい',
            'しょくたく',
            'しょっけん',
            'しょどう',
            'しょもつ',
            'しらせる',
            'しらべる',
            'しんか',
            'しんこう',
            'じんじゃ',
            'しんせいじ',
            'しんちく',
            'しんりん',
            'すあげ',
            'すあし',
            'すあな',
            'ずあん',
            'すいえい',
            'すいか',
            'すいとう',
            'ずいぶん',
            'すいようび',
            'すうがく',
            'すうじつ',
            'すうせん',
            'すおどり',
            'すきま',
            'すくう',
            'すくない',
            'すける',
            'すごい',
            'すこし',
            'ずさん',
            'すずしい',
            'すすむ',
            'すすめる',
            'すっかり',
            'ずっしり',
            'ずっと',
            'すてき',
            'すてる',
            'すねる',
            'すのこ',
            'すはだ',
            'すばらしい',
            'ずひょう',
            'ずぶぬれ',
            'すぶり',
            'すふれ',
            'すべて',
            'すべる',
            'ずほう',
            'すぼん',
            'すまい',
            'すめし',
            'すもう',
            'すやき',
            'すらすら',
            'するめ',
            'すれちがう',
            'すろっと',
            'すわる',
            'すんぜん',
            'すんぽう',
            'せあぶら',
            'せいかつ',
            'せいげん',
            'せいじ',
            'せいよう',
            'せおう',
            'せかいかん',
            'せきにん',
            'せきむ',
            'せきゆ',
            'せきらんうん',
            'せけん',
            'せこう',
            'せすじ',
            'せたい',
            'せたけ',
            'せっかく',
            'せっきゃく',
            'ぜっく',
            'せっけん',
            'せっこつ',
            'せっさたくま',
            'せつぞく',
            'せつだん',
            'せつでん',
            'せっぱん',
            'せつび',
            'せつぶん',
            'せつめい',
            'せつりつ',
            'せなか',
            'せのび',
            'せはば',
            'せびろ',
            'せぼね',
            'せまい',
            'せまる',
            'せめる',
            'せもたれ',
            'せりふ',
            'ぜんあく',
            'せんい',
            'せんえい',
            'せんか',
            'せんきょ',
            'せんく',
            'せんげん',
            'ぜんご',
            'せんさい',
            'せんしゅ',
            'せんすい',
            'せんせい',
            'せんぞ',
            'せんたく',
            'せんちょう',
            'せんてい',
            'せんとう',
            'せんぬき',
            'せんねん',
            'せんぱい',
            'ぜんぶ',
            'ぜんぽう',
            'せんむ',
            'せんめんじょ',
            'せんもん',
            'せんやく',
            'せんゆう',
            'せんよう',
            'ぜんら',
            'ぜんりゃく',
            'せんれい',
            'せんろ',
            'そあく',
            'そいとげる',
            'そいね',
            'そうがんきょう',
            'そうき',
            'そうご',
            'そうしん',
            'そうだん',
            'そうなん',
            'そうび',
            'そうめん',
            'そうり',
            'そえもの',
            'そえん',
            'そがい',
            'そげき',
            'そこう',
            'そこそこ',
            'そざい',
            'そしな',
            'そせい',
            'そせん',
            'そそぐ',
            'そだてる',
            'そつう',
            'そつえん',
            'そっかん',
            'そつぎょう',
            'そっけつ',
            'そっこう',
            'そっせん',
            'そっと',
            'そとがわ',
            'そとづら',
            'そなえる',
            'そなた',
            'そふぼ',
            'そぼく',
            'そぼろ',
            'そまつ',
            'そまる',
            'そむく',
            'そむりえ',
            'そめる',
            'そもそも',
            'そよかぜ',
            'そらまめ',
            'そろう',
            'そんかい',
            'そんけい',
            'そんざい',
            'そんしつ',
            'そんぞく',
            'そんちょう',
            'ぞんび',
            'ぞんぶん',
            'そんみん',
            'たあい',
            'たいいん',
            'たいうん',
            'たいえき',
            'たいおう',
            'だいがく',
            'たいき',
            'たいぐう',
            'たいけん',
            'たいこ',
            'たいざい',
            'だいじょうぶ',
            'だいすき',
            'たいせつ',
            'たいそう',
            'だいたい',
            'たいちょう',
            'たいてい',
            'だいどころ',
            'たいない',
            'たいねつ',
            'たいのう',
            'たいはん',
            'だいひょう',
            'たいふう',
            'たいへん',
            'たいほ',
            'たいまつばな',
            'たいみんぐ',
            'たいむ',
            'たいめん',
            'たいやき',
            'たいよう',
            'たいら',
            'たいりょく',
            'たいる',
            'たいわん',
            'たうえ',
            'たえる',
            'たおす',
            'たおる',
            'たおれる',
            'たかい',
            'たかね',
            'たきび',
            'たくさん',
            'たこく',
            'たこやき',
            'たさい',
            'たしざん',
            'だじゃれ',
            'たすける',
            'たずさわる',
            'たそがれ',
            'たたかう',
            'たたく',
            'ただしい',
            'たたみ',
            'たちばな',
            'だっかい',
            'だっきゃく',
            'だっこ',
            'だっしゅつ',
            'だったい',
            'たてる',
            'たとえる',
            'たなばた',
            'たにん',
            'たぬき',
            'たのしみ',
            'たはつ',
            'たぶん',
            'たべる',
            'たぼう',
            'たまご',
            'たまる',
            'だむる',
            'ためいき',
            'ためす',
            'ためる',
            'たもつ',
            'たやすい',
            'たよる',
            'たらす',
            'たりきほんがん',
            'たりょう',
            'たりる',
            'たると',
            'たれる',
            'たれんと',
            'たろっと',
            'たわむれる',
            'だんあつ',
            'たんい',
            'たんおん',
            'たんか',
            'たんき',
            'たんけん',
            'たんご',
            'たんさん',
            'たんじょうび',
            'だんせい',
            'たんそく',
            'たんたい',
            'だんち',
            'たんてい',
            'たんとう',
            'だんな',
            'たんにん',
            'だんねつ',
            'たんのう',
            'たんぴん',
            'だんぼう',
            'たんまつ',
            'たんめい',
            'だんれつ',
            'だんろ',
            'だんわ',
            'ちあい',
            'ちあん',
            'ちいき',
            'ちいさい',
            'ちえん',
            'ちかい',
            'ちから',
            'ちきゅう',
            'ちきん',
            'ちけいず',
            'ちけん',
            'ちこく',
            'ちさい',
            'ちしき',
            'ちしりょう',
            'ちせい',
            'ちそう',
            'ちたい',
            'ちたん',
            'ちちおや',
            'ちつじょ',
            'ちてき',
            'ちてん',
            'ちぬき',
            'ちぬり',
            'ちのう',
            'ちひょう',
            'ちへいせん',
            'ちほう',
            'ちまた',
            'ちみつ',
            'ちみどろ',
            'ちめいど',
            'ちゃんこなべ',
            'ちゅうい',
            'ちゆりょく',
            'ちょうし',
            'ちょさくけん',
            'ちらし',
            'ちらみ',
            'ちりがみ',
            'ちりょう',
            'ちるど',
            'ちわわ',
            'ちんたい',
            'ちんもく',
            'ついか',
            'ついたち',
            'つうか',
            'つうじょう',
            'つうはん',
            'つうわ',
            'つかう',
            'つかれる',
            'つくね',
            'つくる',
            'つけね',
            'つける',
            'つごう',
            'つたえる',
            'つづく',
            'つつじ',
            'つつむ',
            'つとめる',
            'つながる',
            'つなみ',
            'つねづね',
            'つのる',
            'つぶす',
            'つまらない',
            'つまる',
            'つみき',
            'つめたい',
            'つもり',
            'つもる',
            'つよい',
            'つるぼ',
            'つるみく',
            'つわもの',
            'つわり',
            'てあし',
            'てあて',
            'てあみ',
            'ていおん',
            'ていか',
            'ていき',
            'ていけい',
            'ていこく',
            'ていさつ',
            'ていし',
            'ていせい',
            'ていたい',
            'ていど',
            'ていねい',
            'ていひょう',
            'ていへん',
            'ていぼう',
            'てうち',
            'ておくれ',
            'てきとう',
            'てくび',
            'でこぼこ',
            'てさぎょう',
            'てさげ',
            'てすり',
            'てそう',
            'てちがい',
            'てちょう',
            'てつがく',
            'てつづき',
            'でっぱ',
            'てつぼう',
            'てつや',
            'でぬかえ',
            'てぬき',
            'てぬぐい',
            'てのひら',
            'てはい',
            'てぶくろ',
            'てふだ',
            'てほどき',
            'てほん',
            'てまえ',
            'てまきずし',
            'てみじか',
            'てみやげ',
            'てらす',
            'てれび',
            'てわけ',
            'てわたし',
            'でんあつ',
            'てんいん',
            'てんかい',
            'てんき',
            'てんぐ',
            'てんけん',
            'てんごく',
            'てんさい',
            'てんし',
            'てんすう',
            'でんち',
            'てんてき',
            'てんとう',
            'てんない',
            'てんぷら',
            'てんぼうだい',
            'てんめつ',
            'てんらんかい',
            'でんりょく',
            'でんわ',
            'どあい',
            'といれ',
            'どうかん',
            'とうきゅう',
            'どうぐ',
            'とうし',
            'とうむぎ',
            'とおい',
            'とおか',
            'とおく',
            'とおす',
            'とおる',
            'とかい',
            'とかす',
            'ときおり',
            'ときどき',
            'とくい',
            'とくしゅう',
            'とくてん',
            'とくに',
            'とくべつ',
            'とけい',
            'とける',
            'とこや',
            'とさか',
            'としょかん',
            'とそう',
            'とたん',
            'とちゅう',
            'とっきゅう',
            'とっくん',
            'とつぜん',
            'とつにゅう',
            'とどける',
            'ととのえる',
            'とない',
            'となえる',
            'となり',
            'とのさま',
            'とばす',
            'どぶがわ',
            'とほう',
            'とまる',
            'とめる',
            'ともだち',
            'ともる',
            'どようび',
            'とらえる',
            'とんかつ',
            'どんぶり',
            'ないかく',
            'ないこう',
            'ないしょ',
            'ないす',
            'ないせん',
            'ないそう',
            'なおす',
            'ながい',
            'なくす',
            'なげる',
            'なこうど',
            'なさけ',
            'なたでここ',
            'なっとう',
            'なつやすみ',
            'ななおし',
            'なにごと',
            'なにもの',
            'なにわ',
            'なのか',
            'なふだ',
            'なまいき',
            'なまえ',
            'なまみ',
            'なみだ',
            'なめらか',
            'なめる',
            'なやむ',
            'ならう',
            'ならび',
            'ならぶ',
            'なれる',
            'なわとび',
            'なわばり',
            'にあう',
            'にいがた',
            'にうけ',
            'におい',
            'にかい',
            'にがて',
            'にきび',
            'にくしみ',
            'にくまん',
            'にげる',
            'にさんかたんそ',
            'にしき',
            'にせもの',
            'にちじょう',
            'にちようび',
            'にっか',
            'にっき',
            'にっけい',
            'にっこう',
            'にっさん',
            'にっしょく',
            'にっすう',
            'にっせき',
            'にってい',
            'になう',
            'にほん',
            'にまめ',
            'にもつ',
            'にやり',
            'にゅういん',
            'にりんしゃ',
            'にわとり',
            'にんい',
            'にんか',
            'にんき',
            'にんげん',
            'にんしき',
            'にんずう',
            'にんそう',
            'にんたい',
            'にんち',
            'にんてい',
            'にんにく',
            'にんぷ',
            'にんまり',
            'にんむ',
            'にんめい',
            'にんよう',
            'ぬいくぎ',
            'ぬかす',
            'ぬぐいとる',
            'ぬぐう',
            'ぬくもり',
            'ぬすむ',
            'ぬまえび',
            'ぬめり',
            'ぬらす',
            'ぬんちゃく',
            'ねあげ',
            'ねいき',
            'ねいる',
            'ねいろ',
            'ねぐせ',
            'ねくたい',
            'ねくら',
            'ねこぜ',
            'ねこむ',
            'ねさげ',
            'ねすごす',
            'ねそべる',
            'ねだん',
            'ねつい',
            'ねっしん',
            'ねつぞう',
            'ねったいぎょ',
            'ねぶそく',
            'ねふだ',
            'ねぼう',
            'ねほりはほり',
            'ねまき',
            'ねまわし',
            'ねみみ',
            'ねむい',
            'ねむたい',
            'ねもと',
            'ねらう',
            'ねわざ',
            'ねんいり',
            'ねんおし',
            'ねんかん',
            'ねんきん',
            'ねんぐ',
            'ねんざ',
            'ねんし',
            'ねんちゃく',
            'ねんど',
            'ねんぴ',
            'ねんぶつ',
            'ねんまつ',
            'ねんりょう',
            'ねんれい',
            'のいず',
            'のおづま',
            'のがす',
            'のきなみ',
            'のこぎり',
            'のこす',
            'のこる',
            'のせる',
            'のぞく',
            'のぞむ',
            'のたまう',
            'のちほど',
            'のっく',
            'のばす',
            'のはら',
            'のべる',
            'のぼる',
            'のみもの',
            'のやま',
            'のらいぬ',
            'のらねこ',
            'のりもの',
            'のりゆき',
            'のれん',
            'のんき',
            'ばあい',
            'はあく',
            'ばあさん',
            'ばいか',
            'ばいく',
            'はいけん',
            'はいご',
            'はいしん',
            'はいすい',
            'はいせん',
            'はいそう',
            'はいち',
            'ばいばい',
            'はいれつ',
            'はえる',
            'はおる',
            'はかい',
            'ばかり',
            'はかる',
            'はくしゅ',
            'はけん',
            'はこぶ',
            'はさみ',
            'はさん',
            'はしご',
            'ばしょ',
            'はしる',
            'はせる',
            'ぱそこん',
            'はそん',
            'はたん',
            'はちみつ',
            'はつおん',
            'はっかく',
            'はづき',
            'はっきり',
            'はっくつ',
            'はっけん',
            'はっこう',
            'はっさん',
            'はっしん',
            'はったつ',
            'はっちゅう',
            'はってん',
            'はっぴょう',
            'はっぽう',
            'はなす',
            'はなび',
            'はにかむ',
            'はぶらし',
            'はみがき',
            'はむかう',
            'はめつ',
            'はやい',
            'はやし',
            'はらう',
            'はろうぃん',
            'はわい',
            'はんい',
            'はんえい',
            'はんおん',
            'はんかく',
            'はんきょう',
            'ばんぐみ',
            'はんこ',
            'はんしゃ',
            'はんすう',
            'はんだん',
            'ぱんち',
            'ぱんつ',
            'はんてい',
            'はんとし',
            'はんのう',
            'はんぱ',
            'はんぶん',
            'はんぺん',
            'はんぼうき',
            'はんめい',
            'はんらん',
            'はんろん',
            'ひいき',
            'ひうん',
            'ひえる',
            'ひかく',
            'ひかり',
            'ひかる',
            'ひかん',
            'ひくい',
            'ひけつ',
            'ひこうき',
            'ひこく',
            'ひさい',
            'ひさしぶり',
            'ひさん',
            'びじゅつかん',
            'ひしょ',
            'ひそか',
            'ひそむ',
            'ひたむき',
            'ひだり',
            'ひたる',
            'ひつぎ',
            'ひっこし',
            'ひっし',
            'ひつじゅひん',
            'ひっす',
            'ひつぜん',
            'ぴったり',
            'ぴっちり',
            'ひつよう',
            'ひてい',
            'ひとごみ',
            'ひなまつり',
            'ひなん',
            'ひねる',
            'ひはん',
            'ひびく',
            'ひひょう',
            'ひほう',
            'ひまわり',
            'ひまん',
            'ひみつ',
            'ひめい',
            'ひめじし',
            'ひやけ',
            'ひやす',
            'ひよう',
            'びょうき',
            'ひらがな',
            'ひらく',
            'ひりつ',
            'ひりょう',
            'ひるま',
            'ひるやすみ',
            'ひれい',
            'ひろい',
            'ひろう',
            'ひろき',
            'ひろゆき',
            'ひんかく',
            'ひんけつ',
            'ひんこん',
            'ひんしゅ',
            'ひんそう',
            'ぴんち',
            'ひんぱん',
            'びんぼう',
            'ふあん',
            'ふいうち',
            'ふうけい',
            'ふうせん',
            'ぷうたろう',
            'ふうとう',
            'ふうふ',
            'ふえる',
            'ふおん',
            'ふかい',
            'ふきん',
            'ふくざつ',
            'ふくぶくろ',
            'ふこう',
            'ふさい',
            'ふしぎ',
            'ふじみ',
            'ふすま',
            'ふせい',
            'ふせぐ',
            'ふそく',
            'ぶたにく',
            'ふたん',
            'ふちょう',
            'ふつう',
            'ふつか',
            'ふっかつ',
            'ふっき',
            'ふっこく',
            'ぶどう',
            'ふとる',
            'ふとん',
            'ふのう',
            'ふはい',
            'ふひょう',
            'ふへん',
            'ふまん',
            'ふみん',
            'ふめつ',
            'ふめん',
            'ふよう',
            'ふりこ',
            'ふりる',
            'ふるい',
            'ふんいき',
            'ぶんがく',
            'ぶんぐ',
            'ふんしつ',
            'ぶんせき',
            'ふんそう',
            'ぶんぽう',
            'へいあん',
            'へいおん',
            'へいがい',
            'へいき',
            'へいげん',
            'へいこう',
            'へいさ',
            'へいしゃ',
            'へいせつ',
            'へいそ',
            'へいたく',
            'へいてん',
            'へいねつ',
            'へいわ',
            'へきが',
            'へこむ',
            'べにいろ',
            'べにしょうが',
            'へらす',
            'へんかん',
            'べんきょう',
            'べんごし',
            'へんさい',
            'へんたい',
            'べんり',
            'ほあん',
            'ほいく',
            'ぼうぎょ',
            'ほうこく',
            'ほうそう',
            'ほうほう',
            'ほうもん',
            'ほうりつ',
            'ほえる',
            'ほおん',
            'ほかん',
            'ほきょう',
            'ぼきん',
            'ほくろ',
            'ほけつ',
            'ほけん',
            'ほこう',
            'ほこる',
            'ほしい',
            'ほしつ',
            'ほしゅ',
            'ほしょう',
            'ほせい',
            'ほそい',
            'ほそく',
            'ほたて',
            'ほたる',
            'ぽちぶくろ',
            'ほっきょく',
            'ほっさ',
            'ほったん',
            'ほとんど',
            'ほめる',
            'ほんい',
            'ほんき',
            'ほんけ',
            'ほんしつ',
            'ほんやく',
            'まいにち',
            'まかい',
            'まかせる',
            'まがる',
            'まける',
            'まこと',
            'まさつ',
            'まじめ',
            'ますく',
            'まぜる',
            'まつり',
            'まとめ',
            'まなぶ',
            'まぬけ',
            'まねく',
            'まほう',
            'まもる',
            'まゆげ',
            'まよう',
            'まろやか',
            'まわす',
            'まわり',
            'まわる',
            'まんが',
            'まんきつ',
            'まんぞく',
            'まんなか',
            'みいら',
            'みうち',
            'みえる',
            'みがく',
            'みかた',
            'みかん',
            'みけん',
            'みこん',
            'みじかい',
            'みすい',
            'みすえる',
            'みせる',
            'みっか',
            'みつかる',
            'みつける',
            'みてい',
            'みとめる',
            'みなと',
            'みなみかさい',
            'みねらる',
            'みのう',
            'みのがす',
            'みほん',
            'みもと',
            'みやげ',
            'みらい',
            'みりょく',
            'みわく',
            'みんか',
            'みんぞく',
            'むいか',
            'むえき',
            'むえん',
            'むかい',
            'むかう',
            'むかえ',
            'むかし',
            'むぎちゃ',
            'むける',
            'むげん',
            'むさぼる',
            'むしあつい',
            'むしば',
            'むじゅん',
            'むしろ',
            'むすう',
            'むすこ',
            'むすぶ',
            'むすめ',
            'むせる',
            'むせん',
            'むちゅう',
            'むなしい',
            'むのう',
            'むやみ',
            'むよう',
            'むらさき',
            'むりょう',
            'むろん',
            'めいあん',
            'めいうん',
            'めいえん',
            'めいかく',
            'めいきょく',
            'めいさい',
            'めいし',
            'めいそう',
            'めいぶつ',
            'めいれい',
            'めいわく',
            'めぐまれる',
            'めざす',
            'めした',
            'めずらしい',
            'めだつ',
            'めまい',
            'めやす',
            'めんきょ',
            'めんせき',
            'めんどう',
            'もうしあげる',
            'もうどうけん',
            'もえる',
            'もくし',
            'もくてき',
            'もくようび',
            'もちろん',
            'もどる',
            'もらう',
            'もんく',
            'もんだい',
            'やおや',
            'やける',
            'やさい',
            'やさしい',
            'やすい',
            'やすたろう',
            'やすみ',
            'やせる',
            'やそう',
            'やたい',
            'やちん',
            'やっと',
            'やっぱり',
            'やぶる',
            'やめる',
            'ややこしい',
            'やよい',
            'やわらかい',
            'ゆうき',
            'ゆうびんきょく',
            'ゆうべ',
            'ゆうめい',
            'ゆけつ',
            'ゆしゅつ',
            'ゆせん',
            'ゆそう',
            'ゆたか',
            'ゆちゃく',
            'ゆでる',
            'ゆにゅう',
            'ゆびわ',
            'ゆらい',
            'ゆれる',
            'ようい',
            'ようか',
            'ようきゅう',
            'ようじ',
            'ようす',
            'ようちえん',
            'よかぜ',
            'よかん',
            'よきん',
            'よくせい',
            'よくぼう',
            'よけい',
            'よごれる',
            'よさん',
            'よしゅう',
            'よそう',
            'よそく',
            'よっか',
            'よてい',
            'よどがわく',
            'よねつ',
            'よやく',
            'よゆう',
            'よろこぶ',
            'よろしい',
            'らいう',
            'らくがき',
            'らくご',
            'らくさつ',
            'らくだ',
            'らしんばん',
            'らせん',
            'らぞく',
            'らたい',
            'らっか',
            'られつ',
            'りえき',
            'りかい',
            'りきさく',
            'りきせつ',
            'りくぐん',
            'りくつ',
            'りけん',
            'りこう',
            'りせい',
            'りそう',
            'りそく',
            'りてん',
            'りねん',
            'りゆう',
            'りゅうがく',
            'りよう',
            'りょうり',
            'りょかん',
            'りょくちゃ',
            'りょこう',
            'りりく',
            'りれき',
            'りろん',
            'りんご',
            'るいけい',
            'るいさい',
            'るいじ',
            'るいせき',
            'るすばん',
            'るりがわら',
            'れいかん',
            'れいぎ',
            'れいせい',
            'れいぞうこ',
            'れいとう',
            'れいぼう',
            'れきし',
            'れきだい',
            'れんあい',
            'れんけい',
            'れんこん',
            'れんさい',
            'れんしゅう',
            'れんぞく',
            'れんらく',
            'ろうか',
            'ろうご',
            'ろうじん',
            'ろうそく',
            'ろくが',
            'ろこつ',
            'ろじうら',
            'ろしゅつ',
            'ろせん',
            'ろてん',
            'ろめん',
            'ろれつ',
            'ろんぎ',
            'ろんぱ',
            'ろんぶん',
            'ろんり',
            'わかす',
            'わかめ',
            'わかやま',
            'わかれる',
            'わしつ',
            'わじまし',
            'わすれもの',
            'わらう',
            'われる'
          ];
        },
        {}
      ],
      85: [
        function(require, module, exports) {
          module.exports = [
            '가격',
            '가끔',
            '가난',
            '가능',
            '가득',
            '가르침',
            '가뭄',
            '가방',
            '가상',
            '가슴',
            '가운데',
            '가을',
            '가이드',
            '가입',
            '가장',
            '가정',
            '가족',
            '가죽',
            '각오',
            '각자',
            '간격',
            '간부',
            '간섭',
            '간장',
            '간접',
            '간판',
            '갈등',
            '갈비',
            '갈색',
            '갈증',
            '감각',
            '감기',
            '감소',
            '감수성',
            '감자',
            '감정',
            '갑자기',
            '강남',
            '강당',
            '강도',
            '강력히',
            '강변',
            '강북',
            '강사',
            '강수량',
            '강아지',
            '강원도',
            '강의',
            '강제',
            '강조',
            '같이',
            '개구리',
            '개나리',
            '개방',
            '개별',
            '개선',
            '개성',
            '개인',
            '객관적',
            '거실',
            '거액',
            '거울',
            '거짓',
            '거품',
            '걱정',
            '건강',
            '건물',
            '건설',
            '건조',
            '건축',
            '걸음',
            '검사',
            '검토',
            '게시판',
            '게임',
            '겨울',
            '견해',
            '결과',
            '결국',
            '결론',
            '결석',
            '결승',
            '결심',
            '결정',
            '결혼',
            '경계',
            '경고',
            '경기',
            '경력',
            '경복궁',
            '경비',
            '경상도',
            '경영',
            '경우',
            '경쟁',
            '경제',
            '경주',
            '경찰',
            '경치',
            '경향',
            '경험',
            '계곡',
            '계단',
            '계란',
            '계산',
            '계속',
            '계약',
            '계절',
            '계층',
            '계획',
            '고객',
            '고구려',
            '고궁',
            '고급',
            '고등학생',
            '고무신',
            '고민',
            '고양이',
            '고장',
            '고전',
            '고집',
            '고춧가루',
            '고통',
            '고향',
            '곡식',
            '골목',
            '골짜기',
            '골프',
            '공간',
            '공개',
            '공격',
            '공군',
            '공급',
            '공기',
            '공동',
            '공무원',
            '공부',
            '공사',
            '공식',
            '공업',
            '공연',
            '공원',
            '공장',
            '공짜',
            '공책',
            '공통',
            '공포',
            '공항',
            '공휴일',
            '과목',
            '과일',
            '과장',
            '과정',
            '과학',
            '관객',
            '관계',
            '관광',
            '관념',
            '관람',
            '관련',
            '관리',
            '관습',
            '관심',
            '관점',
            '관찰',
            '광경',
            '광고',
            '광장',
            '광주',
            '괴로움',
            '굉장히',
            '교과서',
            '교문',
            '교복',
            '교실',
            '교양',
            '교육',
            '교장',
            '교직',
            '교통',
            '교환',
            '교훈',
            '구경',
            '구름',
            '구멍',
            '구별',
            '구분',
            '구석',
            '구성',
            '구속',
            '구역',
            '구입',
            '구청',
            '구체적',
            '국가',
            '국기',
            '국내',
            '국립',
            '국물',
            '국민',
            '국수',
            '국어',
            '국왕',
            '국적',
            '국제',
            '국회',
            '군대',
            '군사',
            '군인',
            '궁극적',
            '권리',
            '권위',
            '권투',
            '귀국',
            '귀신',
            '규정',
            '규칙',
            '균형',
            '그날',
            '그냥',
            '그늘',
            '그러나',
            '그룹',
            '그릇',
            '그림',
            '그제서야',
            '그토록',
            '극복',
            '극히',
            '근거',
            '근교',
            '근래',
            '근로',
            '근무',
            '근본',
            '근원',
            '근육',
            '근처',
            '글씨',
            '글자',
            '금강산',
            '금고',
            '금년',
            '금메달',
            '금액',
            '금연',
            '금요일',
            '금지',
            '긍정적',
            '기간',
            '기관',
            '기념',
            '기능',
            '기독교',
            '기둥',
            '기록',
            '기름',
            '기법',
            '기본',
            '기분',
            '기쁨',
            '기숙사',
            '기술',
            '기억',
            '기업',
            '기온',
            '기운',
            '기원',
            '기적',
            '기준',
            '기침',
            '기혼',
            '기획',
            '긴급',
            '긴장',
            '길이',
            '김밥',
            '김치',
            '김포공항',
            '깍두기',
            '깜빡',
            '깨달음',
            '깨소금',
            '껍질',
            '꼭대기',
            '꽃잎',
            '나들이',
            '나란히',
            '나머지',
            '나물',
            '나침반',
            '나흘',
            '낙엽',
            '난방',
            '날개',
            '날씨',
            '날짜',
            '남녀',
            '남대문',
            '남매',
            '남산',
            '남자',
            '남편',
            '남학생',
            '낭비',
            '낱말',
            '내년',
            '내용',
            '내일',
            '냄비',
            '냄새',
            '냇물',
            '냉동',
            '냉면',
            '냉방',
            '냉장고',
            '넥타이',
            '넷째',
            '노동',
            '노란색',
            '노력',
            '노인',
            '녹음',
            '녹차',
            '녹화',
            '논리',
            '논문',
            '논쟁',
            '놀이',
            '농구',
            '농담',
            '농민',
            '농부',
            '농업',
            '농장',
            '농촌',
            '높이',
            '눈동자',
            '눈물',
            '눈썹',
            '뉴욕',
            '느낌',
            '늑대',
            '능동적',
            '능력',
            '다방',
            '다양성',
            '다음',
            '다이어트',
            '다행',
            '단계',
            '단골',
            '단독',
            '단맛',
            '단순',
            '단어',
            '단위',
            '단점',
            '단체',
            '단추',
            '단편',
            '단풍',
            '달걀',
            '달러',
            '달력',
            '달리',
            '닭고기',
            '담당',
            '담배',
            '담요',
            '담임',
            '답변',
            '답장',
            '당근',
            '당분간',
            '당연히',
            '당장',
            '대규모',
            '대낮',
            '대단히',
            '대답',
            '대도시',
            '대략',
            '대량',
            '대륙',
            '대문',
            '대부분',
            '대신',
            '대응',
            '대장',
            '대전',
            '대접',
            '대중',
            '대책',
            '대출',
            '대충',
            '대통령',
            '대학',
            '대한민국',
            '대합실',
            '대형',
            '덩어리',
            '데이트',
            '도대체',
            '도덕',
            '도둑',
            '도망',
            '도서관',
            '도심',
            '도움',
            '도입',
            '도자기',
            '도저히',
            '도전',
            '도중',
            '도착',
            '독감',
            '독립',
            '독서',
            '독일',
            '독창적',
            '동화책',
            '뒷모습',
            '뒷산',
            '딸아이',
            '마누라',
            '마늘',
            '마당',
            '마라톤',
            '마련',
            '마무리',
            '마사지',
            '마약',
            '마요네즈',
            '마을',
            '마음',
            '마이크',
            '마중',
            '마지막',
            '마찬가지',
            '마찰',
            '마흔',
            '막걸리',
            '막내',
            '막상',
            '만남',
            '만두',
            '만세',
            '만약',
            '만일',
            '만점',
            '만족',
            '만화',
            '많이',
            '말기',
            '말씀',
            '말투',
            '맘대로',
            '망원경',
            '매년',
            '매달',
            '매력',
            '매번',
            '매스컴',
            '매일',
            '매장',
            '맥주',
            '먹이',
            '먼저',
            '먼지',
            '멀리',
            '메일',
            '며느리',
            '며칠',
            '면담',
            '멸치',
            '명단',
            '명령',
            '명예',
            '명의',
            '명절',
            '명칭',
            '명함',
            '모금',
            '모니터',
            '모델',
            '모든',
            '모범',
            '모습',
            '모양',
            '모임',
            '모조리',
            '모집',
            '모퉁이',
            '목걸이',
            '목록',
            '목사',
            '목소리',
            '목숨',
            '목적',
            '목표',
            '몰래',
            '몸매',
            '몸무게',
            '몸살',
            '몸속',
            '몸짓',
            '몸통',
            '몹시',
            '무관심',
            '무궁화',
            '무더위',
            '무덤',
            '무릎',
            '무슨',
            '무엇',
            '무역',
            '무용',
            '무조건',
            '무지개',
            '무척',
            '문구',
            '문득',
            '문법',
            '문서',
            '문제',
            '문학',
            '문화',
            '물가',
            '물건',
            '물결',
            '물고기',
            '물론',
            '물리학',
            '물음',
            '물질',
            '물체',
            '미국',
            '미디어',
            '미사일',
            '미술',
            '미역',
            '미용실',
            '미움',
            '미인',
            '미팅',
            '미혼',
            '민간',
            '민족',
            '민주',
            '믿음',
            '밀가루',
            '밀리미터',
            '밑바닥',
            '바가지',
            '바구니',
            '바나나',
            '바늘',
            '바닥',
            '바닷가',
            '바람',
            '바이러스',
            '바탕',
            '박물관',
            '박사',
            '박수',
            '반대',
            '반드시',
            '반말',
            '반발',
            '반성',
            '반응',
            '반장',
            '반죽',
            '반지',
            '반찬',
            '받침',
            '발가락',
            '발걸음',
            '발견',
            '발달',
            '발레',
            '발목',
            '발바닥',
            '발생',
            '발음',
            '발자국',
            '발전',
            '발톱',
            '발표',
            '밤하늘',
            '밥그릇',
            '밥맛',
            '밥상',
            '밥솥',
            '방금',
            '방면',
            '방문',
            '방바닥',
            '방법',
            '방송',
            '방식',
            '방안',
            '방울',
            '방지',
            '방학',
            '방해',
            '방향',
            '배경',
            '배꼽',
            '배달',
            '배드민턴',
            '백두산',
            '백색',
            '백성',
            '백인',
            '백제',
            '백화점',
            '버릇',
            '버섯',
            '버튼',
            '번개',
            '번역',
            '번지',
            '번호',
            '벌금',
            '벌레',
            '벌써',
            '범위',
            '범인',
            '범죄',
            '법률',
            '법원',
            '법적',
            '법칙',
            '베이징',
            '벨트',
            '변경',
            '변동',
            '변명',
            '변신',
            '변호사',
            '변화',
            '별도',
            '별명',
            '별일',
            '병실',
            '병아리',
            '병원',
            '보관',
            '보너스',
            '보라색',
            '보람',
            '보름',
            '보상',
            '보안',
            '보자기',
            '보장',
            '보전',
            '보존',
            '보통',
            '보편적',
            '보험',
            '복도',
            '복사',
            '복숭아',
            '복습',
            '볶음',
            '본격적',
            '본래',
            '본부',
            '본사',
            '본성',
            '본인',
            '본질',
            '볼펜',
            '봉사',
            '봉지',
            '봉투',
            '부근',
            '부끄러움',
            '부담',
            '부동산',
            '부문',
            '부분',
            '부산',
            '부상',
            '부엌',
            '부인',
            '부작용',
            '부장',
            '부정',
            '부족',
            '부지런히',
            '부친',
            '부탁',
            '부품',
            '부회장',
            '북부',
            '북한',
            '분노',
            '분량',
            '분리',
            '분명',
            '분석',
            '분야',
            '분위기',
            '분필',
            '분홍색',
            '불고기',
            '불과',
            '불교',
            '불꽃',
            '불만',
            '불법',
            '불빛',
            '불안',
            '불이익',
            '불행',
            '브랜드',
            '비극',
            '비난',
            '비닐',
            '비둘기',
            '비디오',
            '비로소',
            '비만',
            '비명',
            '비밀',
            '비바람',
            '비빔밥',
            '비상',
            '비용',
            '비율',
            '비중',
            '비타민',
            '비판',
            '빌딩',
            '빗물',
            '빗방울',
            '빗줄기',
            '빛깔',
            '빨간색',
            '빨래',
            '빨리',
            '사건',
            '사계절',
            '사나이',
            '사냥',
            '사람',
            '사랑',
            '사립',
            '사모님',
            '사물',
            '사방',
            '사상',
            '사생활',
            '사설',
            '사슴',
            '사실',
            '사업',
            '사용',
            '사월',
            '사장',
            '사전',
            '사진',
            '사촌',
            '사춘기',
            '사탕',
            '사투리',
            '사흘',
            '산길',
            '산부인과',
            '산업',
            '산책',
            '살림',
            '살인',
            '살짝',
            '삼계탕',
            '삼국',
            '삼십',
            '삼월',
            '삼촌',
            '상관',
            '상금',
            '상대',
            '상류',
            '상반기',
            '상상',
            '상식',
            '상업',
            '상인',
            '상자',
            '상점',
            '상처',
            '상추',
            '상태',
            '상표',
            '상품',
            '상황',
            '새벽',
            '색깔',
            '색연필',
            '생각',
            '생명',
            '생물',
            '생방송',
            '생산',
            '생선',
            '생신',
            '생일',
            '생활',
            '서랍',
            '서른',
            '서명',
            '서민',
            '서비스',
            '서양',
            '서울',
            '서적',
            '서점',
            '서쪽',
            '서클',
            '석사',
            '석유',
            '선거',
            '선물',
            '선배',
            '선생',
            '선수',
            '선원',
            '선장',
            '선전',
            '선택',
            '선풍기',
            '설거지',
            '설날',
            '설렁탕',
            '설명',
            '설문',
            '설사',
            '설악산',
            '설치',
            '설탕',
            '섭씨',
            '성공',
            '성당',
            '성명',
            '성별',
            '성인',
            '성장',
            '성적',
            '성질',
            '성함',
            '세금',
            '세미나',
            '세상',
            '세월',
            '세종대왕',
            '세탁',
            '센터',
            '센티미터',
            '셋째',
            '소규모',
            '소극적',
            '소금',
            '소나기',
            '소년',
            '소득',
            '소망',
            '소문',
            '소설',
            '소속',
            '소아과',
            '소용',
            '소원',
            '소음',
            '소중히',
            '소지품',
            '소질',
            '소풍',
            '소형',
            '속담',
            '속도',
            '속옷',
            '손가락',
            '손길',
            '손녀',
            '손님',
            '손등',
            '손목',
            '손뼉',
            '손실',
            '손질',
            '손톱',
            '손해',
            '솔직히',
            '솜씨',
            '송아지',
            '송이',
            '송편',
            '쇠고기',
            '쇼핑',
            '수건',
            '수년',
            '수단',
            '수돗물',
            '수동적',
            '수면',
            '수명',
            '수박',
            '수상',
            '수석',
            '수술',
            '수시로',
            '수업',
            '수염',
            '수영',
            '수입',
            '수준',
            '수집',
            '수출',
            '수컷',
            '수필',
            '수학',
            '수험생',
            '수화기',
            '숙녀',
            '숙소',
            '숙제',
            '순간',
            '순서',
            '순수',
            '순식간',
            '순위',
            '숟가락',
            '술병',
            '술집',
            '숫자',
            '스님',
            '스물',
            '스스로',
            '스승',
            '스웨터',
            '스위치',
            '스케이트',
            '스튜디오',
            '스트레스',
            '스포츠',
            '슬쩍',
            '슬픔',
            '습관',
            '습기',
            '승객',
            '승리',
            '승부',
            '승용차',
            '승진',
            '시각',
            '시간',
            '시골',
            '시금치',
            '시나리오',
            '시댁',
            '시리즈',
            '시멘트',
            '시민',
            '시부모',
            '시선',
            '시설',
            '시스템',
            '시아버지',
            '시어머니',
            '시월',
            '시인',
            '시일',
            '시작',
            '시장',
            '시절',
            '시점',
            '시중',
            '시즌',
            '시집',
            '시청',
            '시합',
            '시험',
            '식구',
            '식기',
            '식당',
            '식량',
            '식료품',
            '식물',
            '식빵',
            '식사',
            '식생활',
            '식초',
            '식탁',
            '식품',
            '신고',
            '신규',
            '신념',
            '신문',
            '신발',
            '신비',
            '신사',
            '신세',
            '신용',
            '신제품',
            '신청',
            '신체',
            '신화',
            '실감',
            '실내',
            '실력',
            '실례',
            '실망',
            '실수',
            '실습',
            '실시',
            '실장',
            '실정',
            '실질적',
            '실천',
            '실체',
            '실컷',
            '실태',
            '실패',
            '실험',
            '실현',
            '심리',
            '심부름',
            '심사',
            '심장',
            '심정',
            '심판',
            '쌍둥이',
            '씨름',
            '씨앗',
            '아가씨',
            '아나운서',
            '아드님',
            '아들',
            '아쉬움',
            '아스팔트',
            '아시아',
            '아울러',
            '아저씨',
            '아줌마',
            '아직',
            '아침',
            '아파트',
            '아프리카',
            '아픔',
            '아홉',
            '아흔',
            '악기',
            '악몽',
            '악수',
            '안개',
            '안경',
            '안과',
            '안내',
            '안녕',
            '안동',
            '안방',
            '안부',
            '안주',
            '알루미늄',
            '알코올',
            '암시',
            '암컷',
            '압력',
            '앞날',
            '앞문',
            '애인',
            '애정',
            '액수',
            '앨범',
            '야간',
            '야단',
            '야옹',
            '약간',
            '약국',
            '약속',
            '약수',
            '약점',
            '약품',
            '약혼녀',
            '양념',
            '양력',
            '양말',
            '양배추',
            '양주',
            '양파',
            '어둠',
            '어려움',
            '어른',
            '어젯밤',
            '어쨌든',
            '어쩌다가',
            '어쩐지',
            '언니',
            '언덕',
            '언론',
            '언어',
            '얼굴',
            '얼른',
            '얼음',
            '얼핏',
            '엄마',
            '업무',
            '업종',
            '업체',
            '엉덩이',
            '엉망',
            '엉터리',
            '엊그제',
            '에너지',
            '에어컨',
            '엔진',
            '여건',
            '여고생',
            '여관',
            '여군',
            '여권',
            '여대생',
            '여덟',
            '여동생',
            '여든',
            '여론',
            '여름',
            '여섯',
            '여성',
            '여왕',
            '여인',
            '여전히',
            '여직원',
            '여학생',
            '여행',
            '역사',
            '역시',
            '역할',
            '연결',
            '연구',
            '연극',
            '연기',
            '연락',
            '연설',
            '연세',
            '연속',
            '연습',
            '연애',
            '연예인',
            '연인',
            '연장',
            '연주',
            '연출',
            '연필',
            '연합',
            '연휴',
            '열기',
            '열매',
            '열쇠',
            '열심히',
            '열정',
            '열차',
            '열흘',
            '염려',
            '엽서',
            '영국',
            '영남',
            '영상',
            '영양',
            '영역',
            '영웅',
            '영원히',
            '영하',
            '영향',
            '영혼',
            '영화',
            '옆구리',
            '옆방',
            '옆집',
            '예감',
            '예금',
            '예방',
            '예산',
            '예상',
            '예선',
            '예술',
            '예습',
            '예식장',
            '예약',
            '예전',
            '예절',
            '예정',
            '예컨대',
            '옛날',
            '오늘',
            '오락',
            '오랫동안',
            '오렌지',
            '오로지',
            '오른발',
            '오븐',
            '오십',
            '오염',
            '오월',
            '오전',
            '오직',
            '오징어',
            '오페라',
            '오피스텔',
            '오히려',
            '옥상',
            '옥수수',
            '온갖',
            '온라인',
            '온몸',
            '온종일',
            '온통',
            '올가을',
            '올림픽',
            '올해',
            '옷차림',
            '와이셔츠',
            '와인',
            '완성',
            '완전',
            '왕비',
            '왕자',
            '왜냐하면',
            '왠지',
            '외갓집',
            '외국',
            '외로움',
            '외삼촌',
            '외출',
            '외침',
            '외할머니',
            '왼발',
            '왼손',
            '왼쪽',
            '요금',
            '요일',
            '요즘',
            '요청',
            '용기',
            '용서',
            '용어',
            '우산',
            '우선',
            '우승',
            '우연히',
            '우정',
            '우체국',
            '우편',
            '운동',
            '운명',
            '운반',
            '운전',
            '운행',
            '울산',
            '울음',
            '움직임',
            '웃어른',
            '웃음',
            '워낙',
            '원고',
            '원래',
            '원서',
            '원숭이',
            '원인',
            '원장',
            '원피스',
            '월급',
            '월드컵',
            '월세',
            '월요일',
            '웨이터',
            '위반',
            '위법',
            '위성',
            '위원',
            '위험',
            '위협',
            '윗사람',
            '유난히',
            '유럽',
            '유명',
            '유물',
            '유산',
            '유적',
            '유치원',
            '유학',
            '유행',
            '유형',
            '육군',
            '육상',
            '육십',
            '육체',
            '은행',
            '음력',
            '음료',
            '음반',
            '음성',
            '음식',
            '음악',
            '음주',
            '의견',
            '의논',
            '의문',
            '의복',
            '의식',
            '의심',
            '의외로',
            '의욕',
            '의원',
            '의학',
            '이것',
            '이곳',
            '이념',
            '이놈',
            '이달',
            '이대로',
            '이동',
            '이렇게',
            '이력서',
            '이론적',
            '이름',
            '이민',
            '이발소',
            '이별',
            '이불',
            '이빨',
            '이상',
            '이성',
            '이슬',
            '이야기',
            '이용',
            '이웃',
            '이월',
            '이윽고',
            '이익',
            '이전',
            '이중',
            '이튿날',
            '이틀',
            '이혼',
            '인간',
            '인격',
            '인공',
            '인구',
            '인근',
            '인기',
            '인도',
            '인류',
            '인물',
            '인생',
            '인쇄',
            '인연',
            '인원',
            '인재',
            '인종',
            '인천',
            '인체',
            '인터넷',
            '인하',
            '인형',
            '일곱',
            '일기',
            '일단',
            '일대',
            '일등',
            '일반',
            '일본',
            '일부',
            '일상',
            '일생',
            '일손',
            '일요일',
            '일월',
            '일정',
            '일종',
            '일주일',
            '일찍',
            '일체',
            '일치',
            '일행',
            '일회용',
            '임금',
            '임무',
            '입대',
            '입력',
            '입맛',
            '입사',
            '입술',
            '입시',
            '입원',
            '입장',
            '입학',
            '자가용',
            '자격',
            '자극',
            '자동',
            '자랑',
            '자부심',
            '자식',
            '자신',
            '자연',
            '자원',
            '자율',
            '자전거',
            '자정',
            '자존심',
            '자판',
            '작가',
            '작년',
            '작성',
            '작업',
            '작용',
            '작은딸',
            '작품',
            '잔디',
            '잔뜩',
            '잔치',
            '잘못',
            '잠깐',
            '잠수함',
            '잠시',
            '잠옷',
            '잠자리',
            '잡지',
            '장관',
            '장군',
            '장기간',
            '장래',
            '장례',
            '장르',
            '장마',
            '장면',
            '장모',
            '장미',
            '장비',
            '장사',
            '장소',
            '장식',
            '장애인',
            '장인',
            '장점',
            '장차',
            '장학금',
            '재능',
            '재빨리',
            '재산',
            '재생',
            '재작년',
            '재정',
            '재채기',
            '재판',
            '재학',
            '재활용',
            '저것',
            '저고리',
            '저곳',
            '저녁',
            '저런',
            '저렇게',
            '저번',
            '저울',
            '저절로',
            '저축',
            '적극',
            '적당히',
            '적성',
            '적용',
            '적응',
            '전개',
            '전공',
            '전기',
            '전달',
            '전라도',
            '전망',
            '전문',
            '전반',
            '전부',
            '전세',
            '전시',
            '전용',
            '전자',
            '전쟁',
            '전주',
            '전철',
            '전체',
            '전통',
            '전혀',
            '전후',
            '절대',
            '절망',
            '절반',
            '절약',
            '절차',
            '점검',
            '점수',
            '점심',
            '점원',
            '점점',
            '점차',
            '접근',
            '접시',
            '접촉',
            '젓가락',
            '정거장',
            '정도',
            '정류장',
            '정리',
            '정말',
            '정면',
            '정문',
            '정반대',
            '정보',
            '정부',
            '정비',
            '정상',
            '정성',
            '정오',
            '정원',
            '정장',
            '정지',
            '정치',
            '정확히',
            '제공',
            '제과점',
            '제대로',
            '제목',
            '제발',
            '제법',
            '제삿날',
            '제안',
            '제일',
            '제작',
            '제주도',
            '제출',
            '제품',
            '제한',
            '조각',
            '조건',
            '조금',
            '조깅',
            '조명',
            '조미료',
            '조상',
            '조선',
            '조용히',
            '조절',
            '조정',
            '조직',
            '존댓말',
            '존재',
            '졸업',
            '졸음',
            '종교',
            '종로',
            '종류',
            '종소리',
            '종업원',
            '종종',
            '종합',
            '좌석',
            '죄인',
            '주관적',
            '주름',
            '주말',
            '주머니',
            '주먹',
            '주문',
            '주민',
            '주방',
            '주변',
            '주식',
            '주인',
            '주일',
            '주장',
            '주전자',
            '주택',
            '준비',
            '줄거리',
            '줄기',
            '줄무늬',
            '중간',
            '중계방송',
            '중국',
            '중년',
            '중단',
            '중독',
            '중반',
            '중부',
            '중세',
            '중소기업',
            '중순',
            '중앙',
            '중요',
            '중학교',
            '즉석',
            '즉시',
            '즐거움',
            '증가',
            '증거',
            '증권',
            '증상',
            '증세',
            '지각',
            '지갑',
            '지경',
            '지극히',
            '지금',
            '지급',
            '지능',
            '지름길',
            '지리산',
            '지방',
            '지붕',
            '지식',
            '지역',
            '지우개',
            '지원',
            '지적',
            '지점',
            '지진',
            '지출',
            '직선',
            '직업',
            '직원',
            '직장',
            '진급',
            '진동',
            '진로',
            '진료',
            '진리',
            '진짜',
            '진찰',
            '진출',
            '진통',
            '진행',
            '질문',
            '질병',
            '질서',
            '짐작',
            '집단',
            '집안',
            '집중',
            '짜증',
            '찌꺼기',
            '차남',
            '차라리',
            '차량',
            '차림',
            '차별',
            '차선',
            '차츰',
            '착각',
            '찬물',
            '찬성',
            '참가',
            '참기름',
            '참새',
            '참석',
            '참여',
            '참외',
            '참조',
            '찻잔',
            '창가',
            '창고',
            '창구',
            '창문',
            '창밖',
            '창작',
            '창조',
            '채널',
            '채점',
            '책가방',
            '책방',
            '책상',
            '책임',
            '챔피언',
            '처벌',
            '처음',
            '천국',
            '천둥',
            '천장',
            '천재',
            '천천히',
            '철도',
            '철저히',
            '철학',
            '첫날',
            '첫째',
            '청년',
            '청바지',
            '청소',
            '청춘',
            '체계',
            '체력',
            '체온',
            '체육',
            '체중',
            '체험',
            '초등학생',
            '초반',
            '초밥',
            '초상화',
            '초순',
            '초여름',
            '초원',
            '초저녁',
            '초점',
            '초청',
            '초콜릿',
            '촛불',
            '총각',
            '총리',
            '총장',
            '촬영',
            '최근',
            '최상',
            '최선',
            '최신',
            '최악',
            '최종',
            '추석',
            '추억',
            '추진',
            '추천',
            '추측',
            '축구',
            '축소',
            '축제',
            '축하',
            '출근',
            '출발',
            '출산',
            '출신',
            '출연',
            '출입',
            '출장',
            '출판',
            '충격',
            '충고',
            '충돌',
            '충분히',
            '충청도',
            '취업',
            '취직',
            '취향',
            '치약',
            '친구',
            '친척',
            '칠십',
            '칠월',
            '칠판',
            '침대',
            '침묵',
            '침실',
            '칫솔',
            '칭찬',
            '카메라',
            '카운터',
            '칼국수',
            '캐릭터',
            '캠퍼스',
            '캠페인',
            '커튼',
            '컨디션',
            '컬러',
            '컴퓨터',
            '코끼리',
            '코미디',
            '콘서트',
            '콜라',
            '콤플렉스',
            '콩나물',
            '쾌감',
            '쿠데타',
            '크림',
            '큰길',
            '큰딸',
            '큰소리',
            '큰아들',
            '큰어머니',
            '큰일',
            '큰절',
            '클래식',
            '클럽',
            '킬로',
            '타입',
            '타자기',
            '탁구',
            '탁자',
            '탄생',
            '태권도',
            '태양',
            '태풍',
            '택시',
            '탤런트',
            '터널',
            '터미널',
            '테니스',
            '테스트',
            '테이블',
            '텔레비전',
            '토론',
            '토마토',
            '토요일',
            '통계',
            '통과',
            '통로',
            '통신',
            '통역',
            '통일',
            '통장',
            '통제',
            '통증',
            '통합',
            '통화',
            '퇴근',
            '퇴원',
            '퇴직금',
            '튀김',
            '트럭',
            '특급',
            '특별',
            '특성',
            '특수',
            '특징',
            '특히',
            '튼튼히',
            '티셔츠',
            '파란색',
            '파일',
            '파출소',
            '판결',
            '판단',
            '판매',
            '판사',
            '팔십',
            '팔월',
            '팝송',
            '패션',
            '팩스',
            '팩시밀리',
            '팬티',
            '퍼센트',
            '페인트',
            '편견',
            '편의',
            '편지',
            '편히',
            '평가',
            '평균',
            '평생',
            '평소',
            '평양',
            '평일',
            '평화',
            '포스터',
            '포인트',
            '포장',
            '포함',
            '표면',
            '표정',
            '표준',
            '표현',
            '품목',
            '품질',
            '풍경',
            '풍속',
            '풍습',
            '프랑스',
            '프린터',
            '플라스틱',
            '피곤',
            '피망',
            '피아노',
            '필름',
            '필수',
            '필요',
            '필자',
            '필통',
            '핑계',
            '하느님',
            '하늘',
            '하드웨어',
            '하룻밤',
            '하반기',
            '하숙집',
            '하순',
            '하여튼',
            '하지만',
            '하천',
            '하품',
            '하필',
            '학과',
            '학교',
            '학급',
            '학기',
            '학년',
            '학력',
            '학번',
            '학부모',
            '학비',
            '학생',
            '학술',
            '학습',
            '학용품',
            '학원',
            '학위',
            '학자',
            '학점',
            '한계',
            '한글',
            '한꺼번에',
            '한낮',
            '한눈',
            '한동안',
            '한때',
            '한라산',
            '한마디',
            '한문',
            '한번',
            '한복',
            '한식',
            '한여름',
            '한쪽',
            '할머니',
            '할아버지',
            '할인',
            '함께',
            '함부로',
            '합격',
            '합리적',
            '항공',
            '항구',
            '항상',
            '항의',
            '해결',
            '해군',
            '해답',
            '해당',
            '해물',
            '해석',
            '해설',
            '해수욕장',
            '해안',
            '핵심',
            '핸드백',
            '햄버거',
            '햇볕',
            '햇살',
            '행동',
            '행복',
            '행사',
            '행운',
            '행위',
            '향기',
            '향상',
            '향수',
            '허락',
            '허용',
            '헬기',
            '현관',
            '현금',
            '현대',
            '현상',
            '현실',
            '현장',
            '현재',
            '현지',
            '혈액',
            '협력',
            '형부',
            '형사',
            '형수',
            '형식',
            '형제',
            '형태',
            '형편',
            '혜택',
            '호기심',
            '호남',
            '호랑이',
            '호박',
            '호텔',
            '호흡',
            '혹시',
            '홀로',
            '홈페이지',
            '홍보',
            '홍수',
            '홍차',
            '화면',
            '화분',
            '화살',
            '화요일',
            '화장',
            '화학',
            '확보',
            '확인',
            '확장',
            '확정',
            '환갑',
            '환경',
            '환영',
            '환율',
            '환자',
            '활기',
            '활동',
            '활발히',
            '활용',
            '활짝',
            '회견',
            '회관',
            '회복',
            '회색',
            '회원',
            '회장',
            '회전',
            '횟수',
            '횡단보도',
            '효율적',
            '후반',
            '후춧가루',
            '훈련',
            '훨씬',
            '휴식',
            '휴일',
            '흉내',
            '흐름',
            '흑백',
            '흑인',
            '흔적',
            '흔히',
            '흥미',
            '흥분',
            '희곡',
            '희망',
            '희생',
            '흰색',
            '힘껏'
          ];
        },
        {}
      ],
      86: [
        function(require, module, exports) {
          module.exports = [
            'ábaco',
            'abdomen',
            'abeja',
            'abierto',
            'abogado',
            'abono',
            'aborto',
            'abrazo',
            'abrir',
            'abuelo',
            'abuso',
            'acabar',
            'academia',
            'acceso',
            'acción',
            'aceite',
            'acelga',
            'acento',
            'aceptar',
            'ácido',
            'aclarar',
            'acné',
            'acoger',
            'acoso',
            'activo',
            'acto',
            'actriz',
            'actuar',
            'acudir',
            'acuerdo',
            'acusar',
            'adicto',
            'admitir',
            'adoptar',
            'adorno',
            'aduana',
            'adulto',
            'aéreo',
            'afectar',
            'afición',
            'afinar',
            'afirmar',
            'ágil',
            'agitar',
            'agonía',
            'agosto',
            'agotar',
            'agregar',
            'agrio',
            'agua',
            'agudo',
            'águila',
            'aguja',
            'ahogo',
            'ahorro',
            'aire',
            'aislar',
            'ajedrez',
            'ajeno',
            'ajuste',
            'alacrán',
            'alambre',
            'alarma',
            'alba',
            'álbum',
            'alcalde',
            'aldea',
            'alegre',
            'alejar',
            'alerta',
            'aleta',
            'alfiler',
            'alga',
            'algodón',
            'aliado',
            'aliento',
            'alivio',
            'alma',
            'almeja',
            'almíbar',
            'altar',
            'alteza',
            'altivo',
            'alto',
            'altura',
            'alumno',
            'alzar',
            'amable',
            'amante',
            'amapola',
            'amargo',
            'amasar',
            'ámbar',
            'ámbito',
            'ameno',
            'amigo',
            'amistad',
            'amor',
            'amparo',
            'amplio',
            'ancho',
            'anciano',
            'ancla',
            'andar',
            'andén',
            'anemia',
            'ángulo',
            'anillo',
            'ánimo',
            'anís',
            'anotar',
            'antena',
            'antiguo',
            'antojo',
            'anual',
            'anular',
            'anuncio',
            'añadir',
            'añejo',
            'año',
            'apagar',
            'aparato',
            'apetito',
            'apio',
            'aplicar',
            'apodo',
            'aporte',
            'apoyo',
            'aprender',
            'aprobar',
            'apuesta',
            'apuro',
            'arado',
            'araña',
            'arar',
            'árbitro',
            'árbol',
            'arbusto',
            'archivo',
            'arco',
            'arder',
            'ardilla',
            'arduo',
            'área',
            'árido',
            'aries',
            'armonía',
            'arnés',
            'aroma',
            'arpa',
            'arpón',
            'arreglo',
            'arroz',
            'arruga',
            'arte',
            'artista',
            'asa',
            'asado',
            'asalto',
            'ascenso',
            'asegurar',
            'aseo',
            'asesor',
            'asiento',
            'asilo',
            'asistir',
            'asno',
            'asombro',
            'áspero',
            'astilla',
            'astro',
            'astuto',
            'asumir',
            'asunto',
            'atajo',
            'ataque',
            'atar',
            'atento',
            'ateo',
            'ático',
            'atleta',
            'átomo',
            'atraer',
            'atroz',
            'atún',
            'audaz',
            'audio',
            'auge',
            'aula',
            'aumento',
            'ausente',
            'autor',
            'aval',
            'avance',
            'avaro',
            'ave',
            'avellana',
            'avena',
            'avestruz',
            'avión',
            'aviso',
            'ayer',
            'ayuda',
            'ayuno',
            'azafrán',
            'azar',
            'azote',
            'azúcar',
            'azufre',
            'azul',
            'baba',
            'babor',
            'bache',
            'bahía',
            'baile',
            'bajar',
            'balanza',
            'balcón',
            'balde',
            'bambú',
            'banco',
            'banda',
            'baño',
            'barba',
            'barco',
            'barniz',
            'barro',
            'báscula',
            'bastón',
            'basura',
            'batalla',
            'batería',
            'batir',
            'batuta',
            'baúl',
            'bazar',
            'bebé',
            'bebida',
            'bello',
            'besar',
            'beso',
            'bestia',
            'bicho',
            'bien',
            'bingo',
            'blanco',
            'bloque',
            'blusa',
            'boa',
            'bobina',
            'bobo',
            'boca',
            'bocina',
            'boda',
            'bodega',
            'boina',
            'bola',
            'bolero',
            'bolsa',
            'bomba',
            'bondad',
            'bonito',
            'bono',
            'bonsái',
            'borde',
            'borrar',
            'bosque',
            'bote',
            'botín',
            'bóveda',
            'bozal',
            'bravo',
            'brazo',
            'brecha',
            'breve',
            'brillo',
            'brinco',
            'brisa',
            'broca',
            'broma',
            'bronce',
            'brote',
            'bruja',
            'brusco',
            'bruto',
            'buceo',
            'bucle',
            'bueno',
            'buey',
            'bufanda',
            'bufón',
            'búho',
            'buitre',
            'bulto',
            'burbuja',
            'burla',
            'burro',
            'buscar',
            'butaca',
            'buzón',
            'caballo',
            'cabeza',
            'cabina',
            'cabra',
            'cacao',
            'cadáver',
            'cadena',
            'caer',
            'café',
            'caída',
            'caimán',
            'caja',
            'cajón',
            'cal',
            'calamar',
            'calcio',
            'caldo',
            'calidad',
            'calle',
            'calma',
            'calor',
            'calvo',
            'cama',
            'cambio',
            'camello',
            'camino',
            'campo',
            'cáncer',
            'candil',
            'canela',
            'canguro',
            'canica',
            'canto',
            'caña',
            'cañón',
            'caoba',
            'caos',
            'capaz',
            'capitán',
            'capote',
            'captar',
            'capucha',
            'cara',
            'carbón',
            'cárcel',
            'careta',
            'carga',
            'cariño',
            'carne',
            'carpeta',
            'carro',
            'carta',
            'casa',
            'casco',
            'casero',
            'caspa',
            'castor',
            'catorce',
            'catre',
            'caudal',
            'causa',
            'cazo',
            'cebolla',
            'ceder',
            'cedro',
            'celda',
            'célebre',
            'celoso',
            'célula',
            'cemento',
            'ceniza',
            'centro',
            'cerca',
            'cerdo',
            'cereza',
            'cero',
            'cerrar',
            'certeza',
            'césped',
            'cetro',
            'chacal',
            'chaleco',
            'champú',
            'chancla',
            'chapa',
            'charla',
            'chico',
            'chiste',
            'chivo',
            'choque',
            'choza',
            'chuleta',
            'chupar',
            'ciclón',
            'ciego',
            'cielo',
            'cien',
            'cierto',
            'cifra',
            'cigarro',
            'cima',
            'cinco',
            'cine',
            'cinta',
            'ciprés',
            'circo',
            'ciruela',
            'cisne',
            'cita',
            'ciudad',
            'clamor',
            'clan',
            'claro',
            'clase',
            'clave',
            'cliente',
            'clima',
            'clínica',
            'cobre',
            'cocción',
            'cochino',
            'cocina',
            'coco',
            'código',
            'codo',
            'cofre',
            'coger',
            'cohete',
            'cojín',
            'cojo',
            'cola',
            'colcha',
            'colegio',
            'colgar',
            'colina',
            'collar',
            'colmo',
            'columna',
            'combate',
            'comer',
            'comida',
            'cómodo',
            'compra',
            'conde',
            'conejo',
            'conga',
            'conocer',
            'consejo',
            'contar',
            'copa',
            'copia',
            'corazón',
            'corbata',
            'corcho',
            'cordón',
            'corona',
            'correr',
            'coser',
            'cosmos',
            'costa',
            'cráneo',
            'cráter',
            'crear',
            'crecer',
            'creído',
            'crema',
            'cría',
            'crimen',
            'cripta',
            'crisis',
            'cromo',
            'crónica',
            'croqueta',
            'crudo',
            'cruz',
            'cuadro',
            'cuarto',
            'cuatro',
            'cubo',
            'cubrir',
            'cuchara',
            'cuello',
            'cuento',
            'cuerda',
            'cuesta',
            'cueva',
            'cuidar',
            'culebra',
            'culpa',
            'culto',
            'cumbre',
            'cumplir',
            'cuna',
            'cuneta',
            'cuota',
            'cupón',
            'cúpula',
            'curar',
            'curioso',
            'curso',
            'curva',
            'cutis',
            'dama',
            'danza',
            'dar',
            'dardo',
            'dátil',
            'deber',
            'débil',
            'década',
            'decir',
            'dedo',
            'defensa',
            'definir',
            'dejar',
            'delfín',
            'delgado',
            'delito',
            'demora',
            'denso',
            'dental',
            'deporte',
            'derecho',
            'derrota',
            'desayuno',
            'deseo',
            'desfile',
            'desnudo',
            'destino',
            'desvío',
            'detalle',
            'detener',
            'deuda',
            'día',
            'diablo',
            'diadema',
            'diamante',
            'diana',
            'diario',
            'dibujo',
            'dictar',
            'diente',
            'dieta',
            'diez',
            'difícil',
            'digno',
            'dilema',
            'diluir',
            'dinero',
            'directo',
            'dirigir',
            'disco',
            'diseño',
            'disfraz',
            'diva',
            'divino',
            'doble',
            'doce',
            'dolor',
            'domingo',
            'don',
            'donar',
            'dorado',
            'dormir',
            'dorso',
            'dos',
            'dosis',
            'dragón',
            'droga',
            'ducha',
            'duda',
            'duelo',
            'dueño',
            'dulce',
            'dúo',
            'duque',
            'durar',
            'dureza',
            'duro',
            'ébano',
            'ebrio',
            'echar',
            'eco',
            'ecuador',
            'edad',
            'edición',
            'edificio',
            'editor',
            'educar',
            'efecto',
            'eficaz',
            'eje',
            'ejemplo',
            'elefante',
            'elegir',
            'elemento',
            'elevar',
            'elipse',
            'élite',
            'elixir',
            'elogio',
            'eludir',
            'embudo',
            'emitir',
            'emoción',
            'empate',
            'empeño',
            'empleo',
            'empresa',
            'enano',
            'encargo',
            'enchufe',
            'encía',
            'enemigo',
            'enero',
            'enfado',
            'enfermo',
            'engaño',
            'enigma',
            'enlace',
            'enorme',
            'enredo',
            'ensayo',
            'enseñar',
            'entero',
            'entrar',
            'envase',
            'envío',
            'época',
            'equipo',
            'erizo',
            'escala',
            'escena',
            'escolar',
            'escribir',
            'escudo',
            'esencia',
            'esfera',
            'esfuerzo',
            'espada',
            'espejo',
            'espía',
            'esposa',
            'espuma',
            'esquí',
            'estar',
            'este',
            'estilo',
            'estufa',
            'etapa',
            'eterno',
            'ética',
            'etnia',
            'evadir',
            'evaluar',
            'evento',
            'evitar',
            'exacto',
            'examen',
            'exceso',
            'excusa',
            'exento',
            'exigir',
            'exilio',
            'existir',
            'éxito',
            'experto',
            'explicar',
            'exponer',
            'extremo',
            'fábrica',
            'fábula',
            'fachada',
            'fácil',
            'factor',
            'faena',
            'faja',
            'falda',
            'fallo',
            'falso',
            'faltar',
            'fama',
            'familia',
            'famoso',
            'faraón',
            'farmacia',
            'farol',
            'farsa',
            'fase',
            'fatiga',
            'fauna',
            'favor',
            'fax',
            'febrero',
            'fecha',
            'feliz',
            'feo',
            'feria',
            'feroz',
            'fértil',
            'fervor',
            'festín',
            'fiable',
            'fianza',
            'fiar',
            'fibra',
            'ficción',
            'ficha',
            'fideo',
            'fiebre',
            'fiel',
            'fiera',
            'fiesta',
            'figura',
            'fijar',
            'fijo',
            'fila',
            'filete',
            'filial',
            'filtro',
            'fin',
            'finca',
            'fingir',
            'finito',
            'firma',
            'flaco',
            'flauta',
            'flecha',
            'flor',
            'flota',
            'fluir',
            'flujo',
            'flúor',
            'fobia',
            'foca',
            'fogata',
            'fogón',
            'folio',
            'folleto',
            'fondo',
            'forma',
            'forro',
            'fortuna',
            'forzar',
            'fosa',
            'foto',
            'fracaso',
            'frágil',
            'franja',
            'frase',
            'fraude',
            'freír',
            'freno',
            'fresa',
            'frío',
            'frito',
            'fruta',
            'fuego',
            'fuente',
            'fuerza',
            'fuga',
            'fumar',
            'función',
            'funda',
            'furgón',
            'furia',
            'fusil',
            'fútbol',
            'futuro',
            'gacela',
            'gafas',
            'gaita',
            'gajo',
            'gala',
            'galería',
            'gallo',
            'gamba',
            'ganar',
            'gancho',
            'ganga',
            'ganso',
            'garaje',
            'garza',
            'gasolina',
            'gastar',
            'gato',
            'gavilán',
            'gemelo',
            'gemir',
            'gen',
            'género',
            'genio',
            'gente',
            'geranio',
            'gerente',
            'germen',
            'gesto',
            'gigante',
            'gimnasio',
            'girar',
            'giro',
            'glaciar',
            'globo',
            'gloria',
            'gol',
            'golfo',
            'goloso',
            'golpe',
            'goma',
            'gordo',
            'gorila',
            'gorra',
            'gota',
            'goteo',
            'gozar',
            'grada',
            'gráfico',
            'grano',
            'grasa',
            'gratis',
            'grave',
            'grieta',
            'grillo',
            'gripe',
            'gris',
            'grito',
            'grosor',
            'grúa',
            'grueso',
            'grumo',
            'grupo',
            'guante',
            'guapo',
            'guardia',
            'guerra',
            'guía',
            'guiño',
            'guion',
            'guiso',
            'guitarra',
            'gusano',
            'gustar',
            'haber',
            'hábil',
            'hablar',
            'hacer',
            'hacha',
            'hada',
            'hallar',
            'hamaca',
            'harina',
            'haz',
            'hazaña',
            'hebilla',
            'hebra',
            'hecho',
            'helado',
            'helio',
            'hembra',
            'herir',
            'hermano',
            'héroe',
            'hervir',
            'hielo',
            'hierro',
            'hígado',
            'higiene',
            'hijo',
            'himno',
            'historia',
            'hocico',
            'hogar',
            'hoguera',
            'hoja',
            'hombre',
            'hongo',
            'honor',
            'honra',
            'hora',
            'hormiga',
            'horno',
            'hostil',
            'hoyo',
            'hueco',
            'huelga',
            'huerta',
            'hueso',
            'huevo',
            'huida',
            'huir',
            'humano',
            'húmedo',
            'humilde',
            'humo',
            'hundir',
            'huracán',
            'hurto',
            'icono',
            'ideal',
            'idioma',
            'ídolo',
            'iglesia',
            'iglú',
            'igual',
            'ilegal',
            'ilusión',
            'imagen',
            'imán',
            'imitar',
            'impar',
            'imperio',
            'imponer',
            'impulso',
            'incapaz',
            'índice',
            'inerte',
            'infiel',
            'informe',
            'ingenio',
            'inicio',
            'inmenso',
            'inmune',
            'innato',
            'insecto',
            'instante',
            'interés',
            'íntimo',
            'intuir',
            'inútil',
            'invierno',
            'ira',
            'iris',
            'ironía',
            'isla',
            'islote',
            'jabalí',
            'jabón',
            'jamón',
            'jarabe',
            'jardín',
            'jarra',
            'jaula',
            'jazmín',
            'jefe',
            'jeringa',
            'jinete',
            'jornada',
            'joroba',
            'joven',
            'joya',
            'juerga',
            'jueves',
            'juez',
            'jugador',
            'jugo',
            'juguete',
            'juicio',
            'junco',
            'jungla',
            'junio',
            'juntar',
            'júpiter',
            'jurar',
            'justo',
            'juvenil',
            'juzgar',
            'kilo',
            'koala',
            'labio',
            'lacio',
            'lacra',
            'lado',
            'ladrón',
            'lagarto',
            'lágrima',
            'laguna',
            'laico',
            'lamer',
            'lámina',
            'lámpara',
            'lana',
            'lancha',
            'langosta',
            'lanza',
            'lápiz',
            'largo',
            'larva',
            'lástima',
            'lata',
            'látex',
            'latir',
            'laurel',
            'lavar',
            'lazo',
            'leal',
            'lección',
            'leche',
            'lector',
            'leer',
            'legión',
            'legumbre',
            'lejano',
            'lengua',
            'lento',
            'leña',
            'león',
            'leopardo',
            'lesión',
            'letal',
            'letra',
            'leve',
            'leyenda',
            'libertad',
            'libro',
            'licor',
            'líder',
            'lidiar',
            'lienzo',
            'liga',
            'ligero',
            'lima',
            'límite',
            'limón',
            'limpio',
            'lince',
            'lindo',
            'línea',
            'lingote',
            'lino',
            'linterna',
            'líquido',
            'liso',
            'lista',
            'litera',
            'litio',
            'litro',
            'llaga',
            'llama',
            'llanto',
            'llave',
            'llegar',
            'llenar',
            'llevar',
            'llorar',
            'llover',
            'lluvia',
            'lobo',
            'loción',
            'loco',
            'locura',
            'lógica',
            'logro',
            'lombriz',
            'lomo',
            'lonja',
            'lote',
            'lucha',
            'lucir',
            'lugar',
            'lujo',
            'luna',
            'lunes',
            'lupa',
            'lustro',
            'luto',
            'luz',
            'maceta',
            'macho',
            'madera',
            'madre',
            'maduro',
            'maestro',
            'mafia',
            'magia',
            'mago',
            'maíz',
            'maldad',
            'maleta',
            'malla',
            'malo',
            'mamá',
            'mambo',
            'mamut',
            'manco',
            'mando',
            'manejar',
            'manga',
            'maniquí',
            'manjar',
            'mano',
            'manso',
            'manta',
            'mañana',
            'mapa',
            'máquina',
            'mar',
            'marco',
            'marea',
            'marfil',
            'margen',
            'marido',
            'mármol',
            'marrón',
            'martes',
            'marzo',
            'masa',
            'máscara',
            'masivo',
            'matar',
            'materia',
            'matiz',
            'matriz',
            'máximo',
            'mayor',
            'mazorca',
            'mecha',
            'medalla',
            'medio',
            'médula',
            'mejilla',
            'mejor',
            'melena',
            'melón',
            'memoria',
            'menor',
            'mensaje',
            'mente',
            'menú',
            'mercado',
            'merengue',
            'mérito',
            'mes',
            'mesón',
            'meta',
            'meter',
            'método',
            'metro',
            'mezcla',
            'miedo',
            'miel',
            'miembro',
            'miga',
            'mil',
            'milagro',
            'militar',
            'millón',
            'mimo',
            'mina',
            'minero',
            'mínimo',
            'minuto',
            'miope',
            'mirar',
            'misa',
            'miseria',
            'misil',
            'mismo',
            'mitad',
            'mito',
            'mochila',
            'moción',
            'moda',
            'modelo',
            'moho',
            'mojar',
            'molde',
            'moler',
            'molino',
            'momento',
            'momia',
            'monarca',
            'moneda',
            'monja',
            'monto',
            'moño',
            'morada',
            'morder',
            'moreno',
            'morir',
            'morro',
            'morsa',
            'mortal',
            'mosca',
            'mostrar',
            'motivo',
            'mover',
            'móvil',
            'mozo',
            'mucho',
            'mudar',
            'mueble',
            'muela',
            'muerte',
            'muestra',
            'mugre',
            'mujer',
            'mula',
            'muleta',
            'multa',
            'mundo',
            'muñeca',
            'mural',
            'muro',
            'músculo',
            'museo',
            'musgo',
            'música',
            'muslo',
            'nácar',
            'nación',
            'nadar',
            'naipe',
            'naranja',
            'nariz',
            'narrar',
            'nasal',
            'natal',
            'nativo',
            'natural',
            'náusea',
            'naval',
            'nave',
            'navidad',
            'necio',
            'néctar',
            'negar',
            'negocio',
            'negro',
            'neón',
            'nervio',
            'neto',
            'neutro',
            'nevar',
            'nevera',
            'nicho',
            'nido',
            'niebla',
            'nieto',
            'niñez',
            'niño',
            'nítido',
            'nivel',
            'nobleza',
            'noche',
            'nómina',
            'noria',
            'norma',
            'norte',
            'nota',
            'noticia',
            'novato',
            'novela',
            'novio',
            'nube',
            'nuca',
            'núcleo',
            'nudillo',
            'nudo',
            'nuera',
            'nueve',
            'nuez',
            'nulo',
            'número',
            'nutria',
            'oasis',
            'obeso',
            'obispo',
            'objeto',
            'obra',
            'obrero',
            'observar',
            'obtener',
            'obvio',
            'oca',
            'ocaso',
            'océano',
            'ochenta',
            'ocho',
            'ocio',
            'ocre',
            'octavo',
            'octubre',
            'oculto',
            'ocupar',
            'ocurrir',
            'odiar',
            'odio',
            'odisea',
            'oeste',
            'ofensa',
            'oferta',
            'oficio',
            'ofrecer',
            'ogro',
            'oído',
            'oír',
            'ojo',
            'ola',
            'oleada',
            'olfato',
            'olivo',
            'olla',
            'olmo',
            'olor',
            'olvido',
            'ombligo',
            'onda',
            'onza',
            'opaco',
            'opción',
            'ópera',
            'opinar',
            'oponer',
            'optar',
            'óptica',
            'opuesto',
            'oración',
            'orador',
            'oral',
            'órbita',
            'orca',
            'orden',
            'oreja',
            'órgano',
            'orgía',
            'orgullo',
            'oriente',
            'origen',
            'orilla',
            'oro',
            'orquesta',
            'oruga',
            'osadía',
            'oscuro',
            'osezno',
            'oso',
            'ostra',
            'otoño',
            'otro',
            'oveja',
            'óvulo',
            'óxido',
            'oxígeno',
            'oyente',
            'ozono',
            'pacto',
            'padre',
            'paella',
            'página',
            'pago',
            'país',
            'pájaro',
            'palabra',
            'palco',
            'paleta',
            'pálido',
            'palma',
            'paloma',
            'palpar',
            'pan',
            'panal',
            'pánico',
            'pantera',
            'pañuelo',
            'papá',
            'papel',
            'papilla',
            'paquete',
            'parar',
            'parcela',
            'pared',
            'parir',
            'paro',
            'párpado',
            'parque',
            'párrafo',
            'parte',
            'pasar',
            'paseo',
            'pasión',
            'paso',
            'pasta',
            'pata',
            'patio',
            'patria',
            'pausa',
            'pauta',
            'pavo',
            'payaso',
            'peatón',
            'pecado',
            'pecera',
            'pecho',
            'pedal',
            'pedir',
            'pegar',
            'peine',
            'pelar',
            'peldaño',
            'pelea',
            'peligro',
            'pellejo',
            'pelo',
            'peluca',
            'pena',
            'pensar',
            'peñón',
            'peón',
            'peor',
            'pepino',
            'pequeño',
            'pera',
            'percha',
            'perder',
            'pereza',
            'perfil',
            'perico',
            'perla',
            'permiso',
            'perro',
            'persona',
            'pesa',
            'pesca',
            'pésimo',
            'pestaña',
            'pétalo',
            'petróleo',
            'pez',
            'pezuña',
            'picar',
            'pichón',
            'pie',
            'piedra',
            'pierna',
            'pieza',
            'pijama',
            'pilar',
            'piloto',
            'pimienta',
            'pino',
            'pintor',
            'pinza',
            'piña',
            'piojo',
            'pipa',
            'pirata',
            'pisar',
            'piscina',
            'piso',
            'pista',
            'pitón',
            'pizca',
            'placa',
            'plan',
            'plata',
            'playa',
            'plaza',
            'pleito',
            'pleno',
            'plomo',
            'pluma',
            'plural',
            'pobre',
            'poco',
            'poder',
            'podio',
            'poema',
            'poesía',
            'poeta',
            'polen',
            'policía',
            'pollo',
            'polvo',
            'pomada',
            'pomelo',
            'pomo',
            'pompa',
            'poner',
            'porción',
            'portal',
            'posada',
            'poseer',
            'posible',
            'poste',
            'potencia',
            'potro',
            'pozo',
            'prado',
            'precoz',
            'pregunta',
            'premio',
            'prensa',
            'preso',
            'previo',
            'primo',
            'príncipe',
            'prisión',
            'privar',
            'proa',
            'probar',
            'proceso',
            'producto',
            'proeza',
            'profesor',
            'programa',
            'prole',
            'promesa',
            'pronto',
            'propio',
            'próximo',
            'prueba',
            'público',
            'puchero',
            'pudor',
            'pueblo',
            'puerta',
            'puesto',
            'pulga',
            'pulir',
            'pulmón',
            'pulpo',
            'pulso',
            'puma',
            'punto',
            'puñal',
            'puño',
            'pupa',
            'pupila',
            'puré',
            'quedar',
            'queja',
            'quemar',
            'querer',
            'queso',
            'quieto',
            'química',
            'quince',
            'quitar',
            'rábano',
            'rabia',
            'rabo',
            'ración',
            'radical',
            'raíz',
            'rama',
            'rampa',
            'rancho',
            'rango',
            'rapaz',
            'rápido',
            'rapto',
            'rasgo',
            'raspa',
            'rato',
            'rayo',
            'raza',
            'razón',
            'reacción',
            'realidad',
            'rebaño',
            'rebote',
            'recaer',
            'receta',
            'rechazo',
            'recoger',
            'recreo',
            'recto',
            'recurso',
            'red',
            'redondo',
            'reducir',
            'reflejo',
            'reforma',
            'refrán',
            'refugio',
            'regalo',
            'regir',
            'regla',
            'regreso',
            'rehén',
            'reino',
            'reír',
            'reja',
            'relato',
            'relevo',
            'relieve',
            'relleno',
            'reloj',
            'remar',
            'remedio',
            'remo',
            'rencor',
            'rendir',
            'renta',
            'reparto',
            'repetir',
            'reposo',
            'reptil',
            'res',
            'rescate',
            'resina',
            'respeto',
            'resto',
            'resumen',
            'retiro',
            'retorno',
            'retrato',
            'reunir',
            'revés',
            'revista',
            'rey',
            'rezar',
            'rico',
            'riego',
            'rienda',
            'riesgo',
            'rifa',
            'rígido',
            'rigor',
            'rincón',
            'riñón',
            'río',
            'riqueza',
            'risa',
            'ritmo',
            'rito',
            'rizo',
            'roble',
            'roce',
            'rociar',
            'rodar',
            'rodeo',
            'rodilla',
            'roer',
            'rojizo',
            'rojo',
            'romero',
            'romper',
            'ron',
            'ronco',
            'ronda',
            'ropa',
            'ropero',
            'rosa',
            'rosca',
            'rostro',
            'rotar',
            'rubí',
            'rubor',
            'rudo',
            'rueda',
            'rugir',
            'ruido',
            'ruina',
            'ruleta',
            'rulo',
            'rumbo',
            'rumor',
            'ruptura',
            'ruta',
            'rutina',
            'sábado',
            'saber',
            'sabio',
            'sable',
            'sacar',
            'sagaz',
            'sagrado',
            'sala',
            'saldo',
            'salero',
            'salir',
            'salmón',
            'salón',
            'salsa',
            'salto',
            'salud',
            'salvar',
            'samba',
            'sanción',
            'sandía',
            'sanear',
            'sangre',
            'sanidad',
            'sano',
            'santo',
            'sapo',
            'saque',
            'sardina',
            'sartén',
            'sastre',
            'satán',
            'sauna',
            'saxofón',
            'sección',
            'seco',
            'secreto',
            'secta',
            'sed',
            'seguir',
            'seis',
            'sello',
            'selva',
            'semana',
            'semilla',
            'senda',
            'sensor',
            'señal',
            'señor',
            'separar',
            'sepia',
            'sequía',
            'ser',
            'serie',
            'sermón',
            'servir',
            'sesenta',
            'sesión',
            'seta',
            'setenta',
            'severo',
            'sexo',
            'sexto',
            'sidra',
            'siesta',
            'siete',
            'siglo',
            'signo',
            'sílaba',
            'silbar',
            'silencio',
            'silla',
            'símbolo',
            'simio',
            'sirena',
            'sistema',
            'sitio',
            'situar',
            'sobre',
            'socio',
            'sodio',
            'sol',
            'solapa',
            'soldado',
            'soledad',
            'sólido',
            'soltar',
            'solución',
            'sombra',
            'sondeo',
            'sonido',
            'sonoro',
            'sonrisa',
            'sopa',
            'soplar',
            'soporte',
            'sordo',
            'sorpresa',
            'sorteo',
            'sostén',
            'sótano',
            'suave',
            'subir',
            'suceso',
            'sudor',
            'suegra',
            'suelo',
            'sueño',
            'suerte',
            'sufrir',
            'sujeto',
            'sultán',
            'sumar',
            'superar',
            'suplir',
            'suponer',
            'supremo',
            'sur',
            'surco',
            'sureño',
            'surgir',
            'susto',
            'sutil',
            'tabaco',
            'tabique',
            'tabla',
            'tabú',
            'taco',
            'tacto',
            'tajo',
            'talar',
            'talco',
            'talento',
            'talla',
            'talón',
            'tamaño',
            'tambor',
            'tango',
            'tanque',
            'tapa',
            'tapete',
            'tapia',
            'tapón',
            'taquilla',
            'tarde',
            'tarea',
            'tarifa',
            'tarjeta',
            'tarot',
            'tarro',
            'tarta',
            'tatuaje',
            'tauro',
            'taza',
            'tazón',
            'teatro',
            'techo',
            'tecla',
            'técnica',
            'tejado',
            'tejer',
            'tejido',
            'tela',
            'teléfono',
            'tema',
            'temor',
            'templo',
            'tenaz',
            'tender',
            'tener',
            'tenis',
            'tenso',
            'teoría',
            'terapia',
            'terco',
            'término',
            'ternura',
            'terror',
            'tesis',
            'tesoro',
            'testigo',
            'tetera',
            'texto',
            'tez',
            'tibio',
            'tiburón',
            'tiempo',
            'tienda',
            'tierra',
            'tieso',
            'tigre',
            'tijera',
            'tilde',
            'timbre',
            'tímido',
            'timo',
            'tinta',
            'tío',
            'típico',
            'tipo',
            'tira',
            'tirón',
            'titán',
            'títere',
            'título',
            'tiza',
            'toalla',
            'tobillo',
            'tocar',
            'tocino',
            'todo',
            'toga',
            'toldo',
            'tomar',
            'tono',
            'tonto',
            'topar',
            'tope',
            'toque',
            'tórax',
            'torero',
            'tormenta',
            'torneo',
            'toro',
            'torpedo',
            'torre',
            'torso',
            'tortuga',
            'tos',
            'tosco',
            'toser',
            'tóxico',
            'trabajo',
            'tractor',
            'traer',
            'tráfico',
            'trago',
            'traje',
            'tramo',
            'trance',
            'trato',
            'trauma',
            'trazar',
            'trébol',
            'tregua',
            'treinta',
            'tren',
            'trepar',
            'tres',
            'tribu',
            'trigo',
            'tripa',
            'triste',
            'triunfo',
            'trofeo',
            'trompa',
            'tronco',
            'tropa',
            'trote',
            'trozo',
            'truco',
            'trueno',
            'trufa',
            'tubería',
            'tubo',
            'tuerto',
            'tumba',
            'tumor',
            'túnel',
            'túnica',
            'turbina',
            'turismo',
            'turno',
            'tutor',
            'ubicar',
            'úlcera',
            'umbral',
            'unidad',
            'unir',
            'universo',
            'uno',
            'untar',
            'uña',
            'urbano',
            'urbe',
            'urgente',
            'urna',
            'usar',
            'usuario',
            'útil',
            'utopía',
            'uva',
            'vaca',
            'vacío',
            'vacuna',
            'vagar',
            'vago',
            'vaina',
            'vajilla',
            'vale',
            'válido',
            'valle',
            'valor',
            'válvula',
            'vampiro',
            'vara',
            'variar',
            'varón',
            'vaso',
            'vecino',
            'vector',
            'vehículo',
            'veinte',
            'vejez',
            'vela',
            'velero',
            'veloz',
            'vena',
            'vencer',
            'venda',
            'veneno',
            'vengar',
            'venir',
            'venta',
            'venus',
            'ver',
            'verano',
            'verbo',
            'verde',
            'vereda',
            'verja',
            'verso',
            'verter',
            'vía',
            'viaje',
            'vibrar',
            'vicio',
            'víctima',
            'vida',
            'vídeo',
            'vidrio',
            'viejo',
            'viernes',
            'vigor',
            'vil',
            'villa',
            'vinagre',
            'vino',
            'viñedo',
            'violín',
            'viral',
            'virgo',
            'virtud',
            'visor',
            'víspera',
            'vista',
            'vitamina',
            'viudo',
            'vivaz',
            'vivero',
            'vivir',
            'vivo',
            'volcán',
            'volumen',
            'volver',
            'voraz',
            'votar',
            'voto',
            'voz',
            'vuelo',
            'vulgar',
            'yacer',
            'yate',
            'yegua',
            'yema',
            'yerno',
            'yeso',
            'yodo',
            'yoga',
            'yogur',
            'zafiro',
            'zanja',
            'zapato',
            'zarza',
            'zona',
            'zorro',
            'zumo',
            'zurdo'
          ];
        },
        {}
      ],
      87: [
        function(require, module, exports) {
          var Buffer = require('safe-buffer').Buffer;
          function check(buffer) {
            if (buffer.length < 8) return false;
            if (buffer.length > 72) return false;
            if (buffer[0] !== 48) return false;
            if (buffer[1] !== buffer.length - 2) return false;
            if (buffer[2] !== 2) return false;
            var lenR = buffer[3];
            if (lenR === 0) return false;
            if (5 + lenR >= buffer.length) return false;
            if (buffer[4 + lenR] !== 2) return false;
            var lenS = buffer[5 + lenR];
            if (lenS === 0) return false;
            if (6 + lenR + lenS !== buffer.length) return false;
            if (buffer[4] & 128) return false;
            if (lenR > 1 && buffer[4] === 0 && !(buffer[5] & 128)) return false;
            if (buffer[lenR + 6] & 128) return false;
            if (lenS > 1 && buffer[lenR + 6] === 0 && !(buffer[lenR + 7] & 128))
              return false;
            return true;
          }
          function decode(buffer) {
            if (buffer.length < 8)
              throw new Error('DER sequence length is too short');
            if (buffer.length > 72)
              throw new Error('DER sequence length is too long');
            if (buffer[0] !== 48) throw new Error('Expected DER sequence');
            if (buffer[1] !== buffer.length - 2)
              throw new Error('DER sequence length is invalid');
            if (buffer[2] !== 2) throw new Error('Expected DER integer');
            var lenR = buffer[3];
            if (lenR === 0) throw new Error('R length is zero');
            if (5 + lenR >= buffer.length)
              throw new Error('R length is too long');
            if (buffer[4 + lenR] !== 2)
              throw new Error('Expected DER integer (2)');
            var lenS = buffer[5 + lenR];
            if (lenS === 0) throw new Error('S length is zero');
            if (6 + lenR + lenS !== buffer.length)
              throw new Error('S length is invalid');
            if (buffer[4] & 128) throw new Error('R value is negative');
            if (lenR > 1 && buffer[4] === 0 && !(buffer[5] & 128))
              throw new Error('R value excessively padded');
            if (buffer[lenR + 6] & 128) throw new Error('S value is negative');
            if (lenS > 1 && buffer[lenR + 6] === 0 && !(buffer[lenR + 7] & 128))
              throw new Error('S value excessively padded');
            return { r: buffer.slice(4, 4 + lenR), s: buffer.slice(6 + lenR) };
          }
          function encode(r, s) {
            var lenR = r.length;
            var lenS = s.length;
            if (lenR === 0) throw new Error('R length is zero');
            if (lenS === 0) throw new Error('S length is zero');
            if (lenR > 33) throw new Error('R length is too long');
            if (lenS > 33) throw new Error('S length is too long');
            if (r[0] & 128) throw new Error('R value is negative');
            if (s[0] & 128) throw new Error('S value is negative');
            if (lenR > 1 && r[0] === 0 && !(r[1] & 128))
              throw new Error('R value excessively padded');
            if (lenS > 1 && s[0] === 0 && !(s[1] & 128))
              throw new Error('S value excessively padded');
            var signature = Buffer.allocUnsafe(6 + lenR + lenS);
            signature[0] = 48;
            signature[1] = signature.length - 2;
            signature[2] = 2;
            signature[3] = r.length;
            r.copy(signature, 4);
            signature[4 + lenR] = 2;
            signature[5 + lenR] = s.length;
            s.copy(signature, 6 + lenR);
            return signature;
          }
          module.exports = { check: check, decode: decode, encode: encode };
        },
        { 'safe-buffer': 460 }
      ],
      88: [
        function(require, module, exports) {
          module.exports = {
            OP_FALSE: 0,
            OP_0: 0,
            OP_PUSHDATA1: 76,
            OP_PUSHDATA2: 77,
            OP_PUSHDATA4: 78,
            OP_1NEGATE: 79,
            OP_RESERVED: 80,
            OP_TRUE: 81,
            OP_1: 81,
            OP_2: 82,
            OP_3: 83,
            OP_4: 84,
            OP_5: 85,
            OP_6: 86,
            OP_7: 87,
            OP_8: 88,
            OP_9: 89,
            OP_10: 90,
            OP_11: 91,
            OP_12: 92,
            OP_13: 93,
            OP_14: 94,
            OP_15: 95,
            OP_16: 96,
            OP_NOP: 97,
            OP_VER: 98,
            OP_IF: 99,
            OP_NOTIF: 100,
            OP_VERIF: 101,
            OP_VERNOTIF: 102,
            OP_ELSE: 103,
            OP_ENDIF: 104,
            OP_VERIFY: 105,
            OP_RETURN: 106,
            OP_TOALTSTACK: 107,
            OP_FROMALTSTACK: 108,
            OP_2DROP: 109,
            OP_2DUP: 110,
            OP_3DUP: 111,
            OP_2OVER: 112,
            OP_2ROT: 113,
            OP_2SWAP: 114,
            OP_IFDUP: 115,
            OP_DEPTH: 116,
            OP_DROP: 117,
            OP_DUP: 118,
            OP_NIP: 119,
            OP_OVER: 120,
            OP_PICK: 121,
            OP_ROLL: 122,
            OP_ROT: 123,
            OP_SWAP: 124,
            OP_TUCK: 125,
            OP_CAT: 126,
            OP_SUBSTR: 127,
            OP_LEFT: 128,
            OP_RIGHT: 129,
            OP_SIZE: 130,
            OP_INVERT: 131,
            OP_AND: 132,
            OP_OR: 133,
            OP_XOR: 134,
            OP_EQUAL: 135,
            OP_EQUALVERIFY: 136,
            OP_RESERVED1: 137,
            OP_RESERVED2: 138,
            OP_1ADD: 139,
            OP_1SUB: 140,
            OP_2MUL: 141,
            OP_2DIV: 142,
            OP_NEGATE: 143,
            OP_ABS: 144,
            OP_NOT: 145,
            OP_0NOTEQUAL: 146,
            OP_ADD: 147,
            OP_SUB: 148,
            OP_MUL: 149,
            OP_DIV: 150,
            OP_MOD: 151,
            OP_LSHIFT: 152,
            OP_RSHIFT: 153,
            OP_BOOLAND: 154,
            OP_BOOLOR: 155,
            OP_NUMEQUAL: 156,
            OP_NUMEQUALVERIFY: 157,
            OP_NUMNOTEQUAL: 158,
            OP_LESSTHAN: 159,
            OP_GREATERTHAN: 160,
            OP_LESSTHANOREQUAL: 161,
            OP_GREATERTHANOREQUAL: 162,
            OP_MIN: 163,
            OP_MAX: 164,
            OP_WITHIN: 165,
            OP_RIPEMD160: 166,
            OP_SHA1: 167,
            OP_SHA256: 168,
            OP_HASH160: 169,
            OP_HASH256: 170,
            OP_CODESEPARATOR: 171,
            OP_CHECKSIG: 172,
            OP_CHECKSIGVERIFY: 173,
            OP_CHECKMULTISIG: 174,
            OP_CHECKMULTISIGVERIFY: 175,
            OP_NOP1: 176,
            OP_NOP2: 177,
            OP_CHECKLOCKTIMEVERIFY: 177,
            OP_NOP3: 178,
            OP_CHECKSEQUENCEVERIFY: 178,
            OP_NOP4: 179,
            OP_NOP5: 180,
            OP_NOP6: 181,
            OP_NOP7: 182,
            OP_NOP8: 183,
            OP_NOP9: 184,
            OP_NOP10: 185,
            OP_PUBKEYHASH: 253,
            OP_PUBKEY: 254,
            OP_INVALIDOPCODE: 255
          };
        },
        {}
      ],
      89: [
        function(require, module, exports) {
          var OPS = require('./index.json');
          var map = {};
          for (var op in OPS) {
            var code = OPS[op];
            map[code] = op;
          }
          module.exports = map;
        },
        { './index.json': 88 }
      ],
      90: [
        function(require, module, exports) {
          const Buffer = require('safe-buffer').Buffer;
          const bech32 = require('bech32');
          const bs58check = require('bs58check');
          const bscript = require('./script');
          const networks = require('./networks');
          const typeforce = require('typeforce');
          const types = require('./types');
          const payments = require('./payments');
          function fromBase58Check(address) {
            const payload = bs58check.decode(address);
            if (payload.length < 21)
              throw new TypeError(address + ' is too short');
            if (payload.length > 21)
              throw new TypeError(address + ' is too long');
            const version = payload.readUInt8(0);
            const hash = payload.slice(1);
            return { version: version, hash: hash };
          }
          function fromBech32(address) {
            const result = bech32.decode(address);
            const data = bech32.fromWords(result.words.slice(1));
            return {
              version: result.words[0],
              prefix: result.prefix,
              data: Buffer.from(data)
            };
          }
          function toBase58Check(hash, version) {
            typeforce(types.tuple(types.Hash160bit, types.UInt8), arguments);
            const payload = Buffer.allocUnsafe(21);
            payload.writeUInt8(version, 0);
            hash.copy(payload, 1);
            return bs58check.encode(payload);
          }
          function toBech32(data, version, prefix) {
            const words = bech32.toWords(data);
            words.unshift(version);
            return bech32.encode(prefix, words);
          }
          function fromOutputScript(output, network) {
            network = network || networks.bitcoin;
            try {
              return payments.p2pkh({ output: output, network: network })
                .address;
            } catch (e) {}
            try {
              return payments.p2sh({ output: output, network: network })
                .address;
            } catch (e) {}
            try {
              return payments.p2wpkh({ output: output, network: network })
                .address;
            } catch (e) {}
            try {
              return payments.p2wsh({ output: output, network: network })
                .address;
            } catch (e) {}
            throw new Error(bscript.toASM(output) + ' has no matching Address');
          }
          function toOutputScript(address, network) {
            network = network || networks.bitcoin;
            let decode;
            try {
              decode = fromBase58Check(address);
            } catch (e) {}
            if (decode) {
              if (decode.version === network.pubKeyHash)
                return payments.p2pkh({ hash: decode.hash }).output;
              if (decode.version === network.scriptHash)
                return payments.p2sh({ hash: decode.hash }).output;
            } else {
              try {
                decode = fromBech32(address);
              } catch (e) {}
              if (decode) {
                if (decode.prefix !== network.bech32)
                  throw new Error(address + ' has an invalid prefix');
                if (decode.version === 0) {
                  if (decode.data.length === 20)
                    return payments.p2wpkh({ hash: decode.data }).output;
                  if (decode.data.length === 32)
                    return payments.p2wsh({ hash: decode.data }).output;
                }
              }
            }
            throw new Error(address + ' has no matching Script');
          }
          module.exports = {
            fromBase58Check: fromBase58Check,
            fromBech32: fromBech32,
            fromOutputScript: fromOutputScript,
            toBase58Check: toBase58Check,
            toBech32: toBech32,
            toOutputScript: toOutputScript
          };
        },
        {
          './networks': 97,
          './payments': 99,
          './script': 107,
          './types': 133,
          bech32: 71,
          bs58check: 269,
          'safe-buffer': 460,
          typeforce: 499
        }
      ],
      91: [
        function(require, module, exports) {
          const Buffer = require('safe-buffer').Buffer;
          const bcrypto = require('./crypto');
          const fastMerkleRoot = require('merkle-lib/fastRoot');
          const typeforce = require('typeforce');
          const types = require('./types');
          const varuint = require('varuint-bitcoin');
          const Transaction = require('./transaction');
          function Block() {
            this.version = 1;
            this.prevHash = null;
            this.merkleRoot = null;
            this.timestamp = 0;
            this.bits = 0;
            this.nonce = 0;
          }
          Block.fromBuffer = function(buffer) {
            if (buffer.length < 80)
              throw new Error('Buffer too small (< 80 bytes)');
            let offset = 0;
            function readSlice(n) {
              offset += n;
              return buffer.slice(offset - n, offset);
            }
            function readUInt32() {
              const i = buffer.readUInt32LE(offset);
              offset += 4;
              return i;
            }
            function readInt32() {
              const i = buffer.readInt32LE(offset);
              offset += 4;
              return i;
            }
            const block = new Block();
            block.version = readInt32();
            block.prevHash = readSlice(32);
            block.merkleRoot = readSlice(32);
            block.timestamp = readUInt32();
            block.bits = readUInt32();
            block.nonce = readUInt32();
            if (buffer.length === 80) return block;
            function readVarInt() {
              const vi = varuint.decode(buffer, offset);
              offset += varuint.decode.bytes;
              return vi;
            }
            function readTransaction() {
              const tx = Transaction.fromBuffer(buffer.slice(offset), true);
              offset += tx.byteLength();
              return tx;
            }
            const nTransactions = readVarInt();
            block.transactions = [];
            for (var i = 0; i < nTransactions; ++i) {
              const tx = readTransaction();
              block.transactions.push(tx);
            }
            return block;
          };
          Block.prototype.byteLength = function(headersOnly) {
            if (headersOnly || !this.transactions) return 80;
            return (
              80 +
              varuint.encodingLength(this.transactions.length) +
              this.transactions.reduce(function(a, x) {
                return a + x.byteLength();
              }, 0)
            );
          };
          Block.fromHex = function(hex) {
            return Block.fromBuffer(Buffer.from(hex, 'hex'));
          };
          Block.prototype.getHash = function() {
            return bcrypto.hash256(this.toBuffer(true));
          };
          Block.prototype.getId = function() {
            return this.getHash()
              .reverse()
              .toString('hex');
          };
          Block.prototype.getUTCDate = function() {
            const date = new Date(0);
            date.setUTCSeconds(this.timestamp);
            return date;
          };
          Block.prototype.toBuffer = function(headersOnly) {
            const buffer = Buffer.allocUnsafe(this.byteLength(headersOnly));
            let offset = 0;
            function writeSlice(slice) {
              slice.copy(buffer, offset);
              offset += slice.length;
            }
            function writeInt32(i) {
              buffer.writeInt32LE(i, offset);
              offset += 4;
            }
            function writeUInt32(i) {
              buffer.writeUInt32LE(i, offset);
              offset += 4;
            }
            writeInt32(this.version);
            writeSlice(this.prevHash);
            writeSlice(this.merkleRoot);
            writeUInt32(this.timestamp);
            writeUInt32(this.bits);
            writeUInt32(this.nonce);
            if (headersOnly || !this.transactions) return buffer;
            varuint.encode(this.transactions.length, buffer, offset);
            offset += varuint.encode.bytes;
            this.transactions.forEach(function(tx) {
              const txSize = tx.byteLength();
              tx.toBuffer(buffer, offset);
              offset += txSize;
            });
            return buffer;
          };
          Block.prototype.toHex = function(headersOnly) {
            return this.toBuffer(headersOnly).toString('hex');
          };
          Block.calculateTarget = function(bits) {
            const exponent = ((bits & 4278190080) >> 24) - 3;
            const mantissa = bits & 8388607;
            const target = Buffer.alloc(32, 0);
            target.writeUInt32BE(mantissa, 28 - exponent);
            return target;
          };
          Block.calculateMerkleRoot = function(transactions) {
            typeforce([{ getHash: types.Function }], transactions);
            if (transactions.length === 0)
              throw TypeError(
                'Cannot compute merkle root for zero transactions'
              );
            const hashes = transactions.map(function(transaction) {
              return transaction.getHash();
            });
            return fastMerkleRoot(hashes, bcrypto.hash256);
          };
          Block.prototype.checkMerkleRoot = function() {
            if (!this.transactions) return false;
            const actualMerkleRoot = Block.calculateMerkleRoot(
              this.transactions
            );
            return this.merkleRoot.compare(actualMerkleRoot) === 0;
          };
          Block.prototype.checkProofOfWork = function() {
            const hash = this.getHash().reverse();
            const target = Block.calculateTarget(this.bits);
            return hash.compare(target) <= 0;
          };
          module.exports = Block;
        },
        {
          './crypto': 94,
          './transaction': 131,
          './types': 133,
          'merkle-lib/fastRoot': 440,
          'safe-buffer': 460,
          typeforce: 499,
          'varuint-bitcoin': 567
        }
      ],
      92: [
        function(require, module, exports) {
          function verifuint(value, max) {
            if (typeof value !== 'number')
              throw new Error('cannot write a non-number as a number');
            if (value < 0)
              throw new Error(
                'specified a negative value for writing an unsigned value'
              );
            if (value > max) throw new Error('RangeError: value out of range');
            if (Math.floor(value) !== value)
              throw new Error('value has a fractional component');
          }
          function readUInt64LE(buffer, offset) {
            const a = buffer.readUInt32LE(offset);
            let b = buffer.readUInt32LE(offset + 4);
            b *= 4294967296;
            verifuint(b + a, 9007199254740991);
            return b + a;
          }
          function writeUInt64LE(buffer, value, offset) {
            verifuint(value, 9007199254740991);
            buffer.writeInt32LE(value & -1, offset);
            buffer.writeUInt32LE(Math.floor(value / 4294967296), offset + 4);
            return offset + 8;
          }
          module.exports = {
            readUInt64LE: readUInt64LE,
            writeUInt64LE: writeUInt64LE
          };
        },
        {}
      ],
      93: [
        function(require, module, exports) {
          const decompile = require('./script').decompile;
          const multisig = require('./templates/multisig');
          const nullData = require('./templates/nulldata');
          const pubKey = require('./templates/pubkey');
          const pubKeyHash = require('./templates/pubkeyhash');
          const scriptHash = require('./templates/scripthash');
          const witnessPubKeyHash = require('./templates/witnesspubkeyhash');
          const witnessScriptHash = require('./templates/witnessscripthash');
          const witnessCommitment = require('./templates/witnesscommitment');
          const types = {
            MULTISIG: 'multisig',
            NONSTANDARD: 'nonstandard',
            NULLDATA: 'nulldata',
            P2PK: 'pubkey',
            P2PKH: 'pubkeyhash',
            P2SH: 'scripthash',
            P2WPKH: 'witnesspubkeyhash',
            P2WSH: 'witnessscripthash',
            WITNESS_COMMITMENT: 'witnesscommitment'
          };
          function classifyOutput(script) {
            if (witnessPubKeyHash.output.check(script)) return types.P2WPKH;
            if (witnessScriptHash.output.check(script)) return types.P2WSH;
            if (pubKeyHash.output.check(script)) return types.P2PKH;
            if (scriptHash.output.check(script)) return types.P2SH;
            const chunks = decompile(script);
            if (!chunks) throw new TypeError('Invalid script');
            if (multisig.output.check(chunks)) return types.MULTISIG;
            if (pubKey.output.check(chunks)) return types.P2PK;
            if (witnessCommitment.output.check(chunks))
              return types.WITNESS_COMMITMENT;
            if (nullData.output.check(chunks)) return types.NULLDATA;
            return types.NONSTANDARD;
          }
          function classifyInput(script, allowIncomplete) {
            const chunks = decompile(script);
            if (!chunks) throw new TypeError('Invalid script');
            if (pubKeyHash.input.check(chunks)) return types.P2PKH;
            if (scriptHash.input.check(chunks, allowIncomplete))
              return types.P2SH;
            if (multisig.input.check(chunks, allowIncomplete))
              return types.MULTISIG;
            if (pubKey.input.check(chunks)) return types.P2PK;
            return types.NONSTANDARD;
          }
          function classifyWitness(script, allowIncomplete) {
            const chunks = decompile(script);
            if (!chunks) throw new TypeError('Invalid script');
            if (witnessPubKeyHash.input.check(chunks)) return types.P2WPKH;
            if (witnessScriptHash.input.check(chunks, allowIncomplete))
              return types.P2WSH;
            return types.NONSTANDARD;
          }
          module.exports = {
            input: classifyInput,
            output: classifyOutput,
            witness: classifyWitness,
            types: types
          };
        },
        {
          './script': 107,
          './templates/multisig': 110,
          './templates/nulldata': 113,
          './templates/pubkey': 114,
          './templates/pubkeyhash': 117,
          './templates/scripthash': 120,
          './templates/witnesscommitment': 123,
          './templates/witnesspubkeyhash': 125,
          './templates/witnessscripthash': 128
        }
      ],
      94: [
        function(require, module, exports) {
          const createHash = require('create-hash');
          function ripemd160(buffer) {
            return createHash('rmd160')
              .update(buffer)
              .digest();
          }
          function sha1(buffer) {
            return createHash('sha1')
              .update(buffer)
              .digest();
          }
          function sha256(buffer) {
            return createHash('sha256')
              .update(buffer)
              .digest();
          }
          function hash160(buffer) {
            return ripemd160(sha256(buffer));
          }
          function hash256(buffer) {
            return sha256(sha256(buffer));
          }
          module.exports = {
            hash160: hash160,
            hash256: hash256,
            ripemd160: ripemd160,
            sha1: sha1,
            sha256: sha256
          };
        },
        { 'create-hash': 283 }
      ],
      95: [
        function(require, module, exports) {
          const ecc = require('tiny-secp256k1');
          const randomBytes = require('randombytes');
          const typeforce = require('typeforce');
          const types = require('./types');
          const wif = require('wif');
          const NETWORKS = require('./networks');
          function isPoint(x) {
            return ecc.isPoint(x);
          }
          const isOptions = typeforce.maybe(
            typeforce.compile({
              compressed: types.maybe(types.Boolean),
              network: types.maybe(types.Network)
            })
          );
          function ECPair(d, Q, options) {
            options = options || {};
            this.compressed =
              options.compressed === undefined ? true : options.compressed;
            this.network = options.network || NETWORKS.bitcoin;
            this.__d = d || null;
            this.__Q = null;
            if (Q) this.__Q = ecc.pointCompress(Q, this.compressed);
          }
          Object.defineProperty(ECPair.prototype, 'privateKey', {
            enumerable: false,
            get: function() {
              return this.__d;
            }
          });
          Object.defineProperty(ECPair.prototype, 'publicKey', {
            get: function() {
              if (!this.__Q)
                this.__Q = ecc.pointFromScalar(this.__d, this.compressed);
              return this.__Q;
            }
          });
          ECPair.prototype.toWIF = function() {
            if (!this.__d) throw new Error('Missing private key');
            return wif.encode(this.network.wif, this.__d, this.compressed);
          };
          ECPair.prototype.sign = function(hash) {
            if (!this.__d) throw new Error('Missing private key');
            return ecc.sign(hash, this.__d);
          };
          ECPair.prototype.verify = function(hash, signature) {
            return ecc.verify(hash, this.publicKey, signature);
          };
          function fromPrivateKey(buffer, options) {
            typeforce(types.Buffer256bit, buffer);
            if (!ecc.isPrivate(buffer))
              throw new TypeError('Private key not in range [1, n)');
            typeforce(isOptions, options);
            return new ECPair(buffer, null, options);
          }
          function fromPublicKey(buffer, options) {
            typeforce(isPoint, buffer);
            typeforce(isOptions, options);
            return new ECPair(null, buffer, options);
          }
          function fromWIF(string, network) {
            const decoded = wif.decode(string);
            const version = decoded.version;
            if (types.Array(network)) {
              network = network
                .filter(function(x) {
                  return version === x.wif;
                })
                .pop();
              if (!network) throw new Error('Unknown network version');
            } else {
              network = network || NETWORKS.bitcoin;
              if (version !== network.wif)
                throw new Error('Invalid network version');
            }
            return fromPrivateKey(decoded.privateKey, {
              compressed: decoded.compressed,
              network: network
            });
          }
          function makeRandom(options) {
            typeforce(isOptions, options);
            options = options || {};
            const rng = options.rng || randomBytes;
            let d;
            do {
              d = rng(32);
              typeforce(types.Buffer256bit, d);
            } while (!ecc.isPrivate(d));
            return fromPrivateKey(d, options);
          }
          module.exports = {
            makeRandom: makeRandom,
            fromPrivateKey: fromPrivateKey,
            fromPublicKey: fromPublicKey,
            fromWIF: fromWIF
          };
        },
        {
          './networks': 97,
          './types': 133,
          randombytes: 456,
          'tiny-secp256k1': 472,
          typeforce: 499,
          wif: 568
        }
      ],
      96: [
        function(require, module, exports) {
          const script = require('./script');
          module.exports = {
            Block: require('./block'),
            ECPair: require('./ecpair'),
            Transaction: require('./transaction'),
            TransactionBuilder: require('./transaction_builder'),
            address: require('./address'),
            bip32: require('bip32'),
            crypto: require('./crypto'),
            networks: require('./networks'),
            opcodes: require('bitcoin-ops'),
            payments: require('./payments'),
            script: script
          };
        },
        {
          './address': 90,
          './block': 91,
          './crypto': 94,
          './ecpair': 95,
          './networks': 97,
          './payments': 99,
          './script': 107,
          './transaction': 131,
          './transaction_builder': 132,
          bip32: 77,
          'bitcoin-ops': 88
        }
      ],
      97: [
        function(require, module, exports) {
          module.exports = {
            bitcoin: {
              messagePrefix: 'Bitcoin Signed Message:\n',
              bech32: 'bc',
              bip32: { public: 76067358, private: 76066276 },
              pubKeyHash: 0,
              scriptHash: 5,
              wif: 128
            },
            testnet: {
              messagePrefix: 'Bitcoin Signed Message:\n',
              bech32: 'tb',
              bip32: { public: 70617039, private: 70615956 },
              pubKeyHash: 111,
              scriptHash: 196,
              wif: 239
            }
          };
        },
        {}
      ],
      98: [
        function(require, module, exports) {
          const lazy = require('./lazy');
          const typef = require('typeforce');
          const OPS = require('bitcoin-ops');
          const bscript = require('../script');
          const BITCOIN_NETWORK = require('../networks').bitcoin;
          function stacksEqual(a, b) {
            if (a.length !== b.length) return false;
            return a.every(function(x, i) {
              return x.equals(b[i]);
            });
          }
          function p2data(a, opts) {
            if (!a.data && !a.output) throw new TypeError('Not enough data');
            opts = opts || { validate: true };
            typef(
              {
                network: typef.maybe(typef.Object),
                output: typef.maybe(typef.Buffer),
                data: typef.maybe(typef.arrayOf(typef.Buffer))
              },
              a
            );
            const network = a.network || BITCOIN_NETWORK;
            const o = { network: network };
            lazy.prop(o, 'output', function() {
              if (!a.data) return;
              return bscript.compile([OPS.OP_RETURN].concat(a.data));
            });
            lazy.prop(o, 'data', function() {
              if (!a.output) return;
              return bscript.decompile(a.output).slice(1);
            });
            if (opts.validate) {
              if (a.output) {
                const chunks = bscript.decompile(a.output);
                if (chunks[0] !== OPS.OP_RETURN)
                  throw new TypeError('Output is invalid');
                if (!chunks.slice(1).every(typef.Buffer))
                  throw new TypeError('Output is invalid');
                if (a.data && !stacksEqual(a.data, o.data))
                  throw new TypeError('Data mismatch');
              }
            }
            return Object.assign(o, a);
          }
          module.exports = p2data;
        },
        {
          '../networks': 97,
          '../script': 107,
          './lazy': 100,
          'bitcoin-ops': 88,
          typeforce: 499
        }
      ],
      99: [
        function(require, module, exports) {
          const embed = require('./embed');
          const p2ms = require('./p2ms');
          const p2pk = require('./p2pk');
          const p2pkh = require('./p2pkh');
          const p2sh = require('./p2sh');
          const p2wpkh = require('./p2wpkh');
          const p2wsh = require('./p2wsh');
          module.exports = {
            embed: embed,
            p2ms: p2ms,
            p2pk: p2pk,
            p2pkh: p2pkh,
            p2sh: p2sh,
            p2wpkh: p2wpkh,
            p2wsh: p2wsh
          };
        },
        {
          './embed': 98,
          './p2ms': 101,
          './p2pk': 102,
          './p2pkh': 103,
          './p2sh': 104,
          './p2wpkh': 105,
          './p2wsh': 106
        }
      ],
      100: [
        function(require, module, exports) {
          function prop(object, name, f) {
            Object.defineProperty(object, name, {
              configurable: true,
              enumerable: true,
              get: function() {
                let value = f.call(this);
                this[name] = value;
                return value;
              },
              set: function(value) {
                Object.defineProperty(this, name, {
                  configurable: true,
                  enumerable: true,
                  value: value,
                  writable: true
                });
              }
            });
          }
          function value(f) {
            let value;
            return function() {
              if (value !== undefined) return value;
              value = f();
              return value;
            };
          }
          module.exports = { prop: prop, value: value };
        },
        {}
      ],
      101: [
        function(require, module, exports) {
          const lazy = require('./lazy');
          const typef = require('typeforce');
          const OPS = require('bitcoin-ops');
          const ecc = require('tiny-secp256k1');
          const bscript = require('../script');
          const BITCOIN_NETWORK = require('../networks').bitcoin;
          const OP_INT_BASE = OPS.OP_RESERVED;
          function stacksEqual(a, b) {
            if (a.length !== b.length) return false;
            return a.every(function(x, i) {
              return x.equals(b[i]);
            });
          }
          function p2ms(a, opts) {
            if (
              !a.input &&
              !a.output &&
              !(a.pubkeys && a.m !== undefined) &&
              !a.signatures
            )
              throw new TypeError('Not enough data');
            opts = opts || { validate: true };
            function isAcceptableSignature(x) {
              return (
                bscript.isCanonicalScriptSignature(x) ||
                (opts.allowIncomplete && x === OPS.OP_0)
              );
            }
            typef(
              {
                network: typef.maybe(typef.Object),
                m: typef.maybe(typef.Number),
                n: typef.maybe(typef.Number),
                output: typef.maybe(typef.Buffer),
                pubkeys: typef.maybe(typef.arrayOf(ecc.isPoint)),
                signatures: typef.maybe(typef.arrayOf(isAcceptableSignature)),
                input: typef.maybe(typef.Buffer)
              },
              a
            );
            const network = a.network || BITCOIN_NETWORK;
            const o = { network: network };
            let chunks;
            let decoded = false;
            function decode(output) {
              if (decoded) return;
              decoded = true;
              chunks = bscript.decompile(output);
              o.m = chunks[0] - OP_INT_BASE;
              o.n = chunks[chunks.length - 2] - OP_INT_BASE;
              o.pubkeys = chunks.slice(1, -2);
            }
            lazy.prop(o, 'output', function() {
              if (!a.m) return;
              if (!o.n) return;
              if (!a.pubkeys) return;
              return bscript.compile(
                [].concat(
                  OP_INT_BASE + a.m,
                  a.pubkeys,
                  OP_INT_BASE + o.n,
                  OPS.OP_CHECKMULTISIG
                )
              );
            });
            lazy.prop(o, 'm', function() {
              if (!o.output) return;
              decode(o.output);
              return o.m;
            });
            lazy.prop(o, 'n', function() {
              if (!o.pubkeys) return;
              return o.pubkeys.length;
            });
            lazy.prop(o, 'pubkeys', function() {
              if (!a.output) return;
              decode(a.output);
              return o.pubkeys;
            });
            lazy.prop(o, 'signatures', function() {
              if (!a.input) return;
              return bscript.decompile(a.input).slice(1);
            });
            lazy.prop(o, 'input', function() {
              if (!a.signatures) return;
              return bscript.compile([OPS.OP_0].concat(a.signatures));
            });
            lazy.prop(o, 'witness', function() {
              if (!o.input) return;
              return [];
            });
            if (opts.validate) {
              if (a.output) {
                decode(a.output);
                if (!typef.Number(chunks[0]))
                  throw new TypeError('Output is invalid');
                if (!typef.Number(chunks[chunks.length - 2]))
                  throw new TypeError('Output is invalid');
                if (chunks[chunks.length - 1] !== OPS.OP_CHECKMULTISIG)
                  throw new TypeError('Output is invalid');
                if (
                  o.m <= 0 ||
                  o.n > 16 ||
                  o.m > o.n ||
                  o.n !== chunks.length - 3
                )
                  throw new TypeError('Output is invalid');
                if (!o.pubkeys.every(x => ecc.isPoint(x)))
                  throw new TypeError('Output is invalid');
                if (a.m !== undefined && a.m !== o.m)
                  throw new TypeError('m mismatch');
                if (a.n !== undefined && a.n !== o.n)
                  throw new TypeError('n mismatch');
                if (a.pubkeys && !stacksEqual(a.pubkeys, o.pubkeys))
                  throw new TypeError('Pubkeys mismatch');
              }
              if (a.pubkeys) {
                if (a.n !== undefined && a.n !== a.pubkeys.length)
                  throw new TypeError('Pubkey count mismatch');
                o.n = a.pubkeys.length;
                if (o.n < o.m)
                  throw new TypeError('Pubkey count cannot be less than m');
              }
              if (a.signatures) {
                if (a.signatures.length < o.m)
                  throw new TypeError('Not enough signatures provided');
                if (a.signatures.length > o.m)
                  throw new TypeError('Too many signatures provided');
              }
              if (a.input) {
                if (a.input[0] !== OPS.OP_0)
                  throw new TypeError('Input is invalid');
                if (
                  o.signatures.length === 0 ||
                  !o.signatures.every(isAcceptableSignature)
                )
                  throw new TypeError('Input has invalid signature(s)');
                if (
                  a.signatures &&
                  !stacksEqual(a.signatures.equals(o.signatures))
                )
                  throw new TypeError('Signature mismatch');
                if (a.m !== undefined && a.m !== a.signatures.length)
                  throw new TypeError('Signature count mismatch');
              }
            }
            return Object.assign(o, a);
          }
          module.exports = p2ms;
        },
        {
          '../networks': 97,
          '../script': 107,
          './lazy': 100,
          'bitcoin-ops': 88,
          'tiny-secp256k1': 472,
          typeforce: 499
        }
      ],
      102: [
        function(require, module, exports) {
          let lazy = require('./lazy');
          let typef = require('typeforce');
          let OPS = require('bitcoin-ops');
          let ecc = require('tiny-secp256k1');
          let bscript = require('../script');
          let BITCOIN_NETWORK = require('../networks').bitcoin;
          function p2pk(a, opts) {
            if (!a.input && !a.output && !a.pubkey && !a.input && !a.signature)
              throw new TypeError('Not enough data');
            opts = opts || { validate: true };
            typef(
              {
                network: typef.maybe(typef.Object),
                output: typef.maybe(typef.Buffer),
                pubkey: typef.maybe(ecc.isPoint),
                signature: typef.maybe(bscript.isCanonicalScriptSignature),
                input: typef.maybe(typef.Buffer)
              },
              a
            );
            let _chunks = lazy.value(function() {
              return bscript.decompile(a.input);
            });
            let network = a.network || BITCOIN_NETWORK;
            let o = { network: network };
            lazy.prop(o, 'output', function() {
              if (!a.pubkey) return;
              return bscript.compile([a.pubkey, OPS.OP_CHECKSIG]);
            });
            lazy.prop(o, 'pubkey', function() {
              if (!a.output) return;
              return a.output.slice(1, -1);
            });
            lazy.prop(o, 'signature', function() {
              if (!a.input) return;
              return _chunks()[0];
            });
            lazy.prop(o, 'input', function() {
              if (!a.signature) return;
              return bscript.compile([a.signature]);
            });
            lazy.prop(o, 'witness', function() {
              if (!o.input) return;
              return [];
            });
            if (opts.validate) {
              if (a.pubkey && a.output) {
                if (!a.pubkey.equals(o.pubkey))
                  throw new TypeError('Pubkey mismatch');
              }
              if (a.output) {
                if (a.output[a.output.length - 1] !== OPS.OP_CHECKSIG)
                  throw new TypeError('Output is invalid');
                if (!ecc.isPoint(o.pubkey))
                  throw new TypeError('Output pubkey is invalid');
              }
              if (a.signature) {
                if (a.input && !a.input.equals(o.input))
                  throw new TypeError('Input mismatch');
              }
              if (a.input) {
                if (_chunks().length !== 1)
                  throw new TypeError('Input is invalid');
                if (!bscript.isCanonicalScriptSignature(_chunks()[0]))
                  throw new TypeError('Input has invalid signature');
              }
            }
            return Object.assign(o, a);
          }
          module.exports = p2pk;
        },
        {
          '../networks': 97,
          '../script': 107,
          './lazy': 100,
          'bitcoin-ops': 88,
          'tiny-secp256k1': 472,
          typeforce: 499
        }
      ],
      103: [
        function(require, module, exports) {
          (function(Buffer) {
            const lazy = require('./lazy');
            const typef = require('typeforce');
            const OPS = require('bitcoin-ops');
            const ecc = require('tiny-secp256k1');
            const bcrypto = require('../crypto');
            const bscript = require('../script');
            const BITCOIN_NETWORK = require('../networks').bitcoin;
            const bs58check = require('bs58check');
            function p2pkh(a, opts) {
              if (!a.address && !a.hash && !a.output && !a.pubkey && !a.input)
                throw new TypeError('Not enough data');
              opts = opts || { validate: true };
              typef(
                {
                  network: typef.maybe(typef.Object),
                  address: typef.maybe(typef.String),
                  hash: typef.maybe(typef.BufferN(20)),
                  output: typef.maybe(typef.BufferN(25)),
                  pubkey: typef.maybe(ecc.isPoint),
                  signature: typef.maybe(bscript.isCanonicalScriptSignature),
                  input: typef.maybe(typef.Buffer)
                },
                a
              );
              const _address = lazy.value(function() {
                const payload = bs58check.decode(a.address);
                const version = payload.readUInt8(0);
                const hash = payload.slice(1);
                return { version: version, hash: hash };
              });
              const _chunks = lazy.value(function() {
                return bscript.decompile(a.input);
              });
              const network = a.network || BITCOIN_NETWORK;
              const o = { network: network };
              lazy.prop(o, 'address', function() {
                if (!o.hash) return;
                const payload = Buffer.allocUnsafe(21);
                payload.writeUInt8(network.pubKeyHash, 0);
                o.hash.copy(payload, 1);
                return bs58check.encode(payload);
              });
              lazy.prop(o, 'hash', function() {
                if (a.output) return a.output.slice(3, 23);
                if (a.address) return _address().hash;
                if (a.pubkey || o.pubkey)
                  return bcrypto.hash160(a.pubkey || o.pubkey);
              });
              lazy.prop(o, 'output', function() {
                if (!o.hash) return;
                return bscript.compile([
                  OPS.OP_DUP,
                  OPS.OP_HASH160,
                  o.hash,
                  OPS.OP_EQUALVERIFY,
                  OPS.OP_CHECKSIG
                ]);
              });
              lazy.prop(o, 'pubkey', function() {
                if (!a.input) return;
                return _chunks()[1];
              });
              lazy.prop(o, 'signature', function() {
                if (!a.input) return;
                return _chunks()[0];
              });
              lazy.prop(o, 'input', function() {
                if (!a.pubkey) return;
                if (!a.signature) return;
                return bscript.compile([a.signature, a.pubkey]);
              });
              lazy.prop(o, 'witness', function() {
                if (!o.input) return;
                return [];
              });
              if (opts.validate) {
                let hash;
                if (a.address) {
                  if (_address().version !== network.pubKeyHash)
                    throw new TypeError('Invalid version or Network mismatch');
                  if (_address().hash.length !== 20)
                    throw new TypeError('Invalid address');
                  hash = _address().hash;
                }
                if (a.hash) {
                  if (hash && !hash.equals(a.hash))
                    throw new TypeError('Hash mismatch');
                  else hash = a.hash;
                }
                if (a.output) {
                  if (
                    a.output.length !== 25 ||
                    a.output[0] !== OPS.OP_DUP ||
                    a.output[1] !== OPS.OP_HASH160 ||
                    a.output[2] !== 20 ||
                    a.output[23] !== OPS.OP_EQUALVERIFY ||
                    a.output[24] !== OPS.OP_CHECKSIG
                  )
                    throw new TypeError('Output is invalid');
                  if (hash && !hash.equals(a.output.slice(3, 23)))
                    throw new TypeError('Hash mismatch');
                  else hash = a.output.slice(3, 23);
                }
                if (a.pubkey) {
                  let pkh = bcrypto.hash160(a.pubkey);
                  if (hash && !hash.equals(pkh))
                    throw new TypeError('Hash mismatch');
                  else hash = pkh;
                }
                if (a.input) {
                  let chunks = _chunks();
                  if (chunks.length !== 2)
                    throw new TypeError('Input is invalid');
                  if (!bscript.isCanonicalScriptSignature(chunks[0]))
                    throw new TypeError('Input has invalid signature');
                  if (!ecc.isPoint(chunks[1]))
                    throw new TypeError('Input has invalid pubkey');
                  if (a.signature && !a.signature.equals(chunks[0]))
                    throw new TypeError('Signature mismatch');
                  if (a.pubkey && !a.pubkey.equals(chunks[1]))
                    throw new TypeError('Pubkey mismatch');
                  let pkh = bcrypto.hash160(chunks[1]);
                  if (hash && !hash.equals(pkh))
                    throw new TypeError('Hash mismatch');
                }
              }
              return Object.assign(o, a);
            }
            module.exports = p2pkh;
          }.call(this, require('buffer').Buffer));
        },
        {
          '../crypto': 94,
          '../networks': 97,
          '../script': 107,
          './lazy': 100,
          'bitcoin-ops': 88,
          bs58check: 269,
          buffer: 183,
          'tiny-secp256k1': 472,
          typeforce: 499
        }
      ],
      104: [
        function(require, module, exports) {
          (function(Buffer) {
            const lazy = require('./lazy');
            const typef = require('typeforce');
            const OPS = require('bitcoin-ops');
            const bcrypto = require('../crypto');
            const bscript = require('../script');
            const BITCOIN_NETWORK = require('../networks').bitcoin;
            const bs58check = require('bs58check');
            function stacksEqual(a, b) {
              if (a.length !== b.length) return false;
              return a.every(function(x, i) {
                return x.equals(b[i]);
              });
            }
            function p2sh(a, opts) {
              if (!a.address && !a.hash && !a.output && !a.redeem && !a.input)
                throw new TypeError('Not enough data');
              opts = opts || { validate: true };
              typef(
                {
                  network: typef.maybe(typef.Object),
                  address: typef.maybe(typef.String),
                  hash: typef.maybe(typef.BufferN(20)),
                  output: typef.maybe(typef.BufferN(23)),
                  redeem: typef.maybe({
                    network: typef.maybe(typef.Object),
                    output: typef.maybe(typef.Buffer),
                    input: typef.maybe(typef.Buffer),
                    witness: typef.maybe(typef.arrayOf(typef.Buffer))
                  }),
                  input: typef.maybe(typef.Buffer),
                  witness: typef.maybe(typef.arrayOf(typef.Buffer))
                },
                a
              );
              const network = a.network || BITCOIN_NETWORK;
              const o = { network: network };
              const _address = lazy.value(function() {
                const payload = bs58check.decode(a.address);
                const version = payload.readUInt8(0);
                const hash = payload.slice(1);
                return { version: version, hash: hash };
              });
              const _chunks = lazy.value(function() {
                return bscript.decompile(a.input);
              });
              const _redeem = lazy.value(function() {
                const chunks = _chunks();
                return {
                  network: network,
                  output: chunks[chunks.length - 1],
                  input: bscript.compile(chunks.slice(0, -1)),
                  witness: a.witness || []
                };
              });
              lazy.prop(o, 'address', function() {
                if (!o.hash) return;
                const payload = Buffer.allocUnsafe(21);
                payload.writeUInt8(network.scriptHash, 0);
                o.hash.copy(payload, 1);
                return bs58check.encode(payload);
              });
              lazy.prop(o, 'hash', function() {
                if (a.output) return a.output.slice(2, 22);
                if (a.address) return _address().hash;
                if (o.redeem && o.redeem.output)
                  return bcrypto.hash160(o.redeem.output);
              });
              lazy.prop(o, 'output', function() {
                if (!o.hash) return;
                return bscript.compile([OPS.OP_HASH160, o.hash, OPS.OP_EQUAL]);
              });
              lazy.prop(o, 'redeem', function() {
                if (!a.input) return;
                return _redeem();
              });
              lazy.prop(o, 'input', function() {
                if (!a.redeem || !a.redeem.input || !a.redeem.output) return;
                return bscript.compile(
                  [].concat(bscript.decompile(a.redeem.input), a.redeem.output)
                );
              });
              lazy.prop(o, 'witness', function() {
                if (o.redeem && o.redeem.witness) return o.redeem.witness;
                if (o.input) return [];
              });
              if (opts.validate) {
                let hash;
                if (a.address) {
                  if (_address().version !== network.scriptHash)
                    throw new TypeError('Invalid version or Network mismatch');
                  if (_address().hash.length !== 20)
                    throw new TypeError('Invalid address');
                  else hash = _address().hash;
                }
                if (a.hash) {
                  if (hash && !hash.equals(a.hash))
                    throw new TypeError('Hash mismatch');
                  else hash = a.hash;
                }
                if (a.output) {
                  if (
                    a.output.length !== 23 ||
                    a.output[0] !== OPS.OP_HASH160 ||
                    a.output[1] !== 20 ||
                    a.output[22] !== OPS.OP_EQUAL
                  )
                    throw new TypeError('Output is invalid');
                  const hash2 = a.output.slice(2, 22);
                  if (hash && !hash.equals(hash2))
                    throw new TypeError('Hash mismatch');
                  else hash = hash2;
                }
                const checkRedeem = function(redeem) {
                  if (redeem.output) {
                    const decompile = bscript.decompile(redeem.output);
                    if (!decompile || decompile.length < 1)
                      throw new TypeError('Redeem.output too short');
                    const hash2 = bcrypto.hash160(redeem.output);
                    if (hash && !hash.equals(hash2))
                      throw new TypeError('Hash mismatch');
                    else hash = hash2;
                  }
                  if (redeem.input) {
                    const hasInput = redeem.input.length > 0;
                    const hasWitness =
                      redeem.witness && redeem.witness.length > 0;
                    if (!hasInput && !hasWitness)
                      throw new TypeError('Empty input');
                    if (hasInput && hasWitness)
                      throw new TypeError('Input and witness provided');
                    if (hasInput) {
                      const richunks = bscript.decompile(redeem.input);
                      if (!bscript.isPushOnly(richunks))
                        throw new TypeError('Non push-only scriptSig');
                    }
                  }
                };
                if (a.input) {
                  const chunks = _chunks();
                  if (!chunks || chunks.length < 1)
                    throw new TypeError('Input too short');
                  if (!Buffer.isBuffer(_redeem().output))
                    throw new TypeError('Input is invalid');
                  checkRedeem(_redeem());
                }
                if (a.redeem) {
                  if (a.redeem.network && a.redeem.network !== network)
                    throw new TypeError('Network mismatch');
                  if (o.redeem) {
                    if (
                      a.redeem.output &&
                      !a.redeem.output.equals(o.redeem.output)
                    )
                      throw new TypeError('Redeem.output mismatch');
                    if (
                      a.redeem.input &&
                      !a.redeem.input.equals(o.redeem.input)
                    )
                      throw new TypeError('Redeem.input mismatch');
                  }
                  checkRedeem(a.redeem);
                }
                if (a.witness) {
                  if (
                    a.redeem &&
                    a.redeem.witness &&
                    !stacksEqual(a.redeem.witness, a.witness)
                  )
                    throw new TypeError('Witness and redeem.witness mismatch');
                }
              }
              return Object.assign(o, a);
            }
            module.exports = p2sh;
          }.call(this, require('buffer').Buffer));
        },
        {
          '../crypto': 94,
          '../networks': 97,
          '../script': 107,
          './lazy': 100,
          'bitcoin-ops': 88,
          bs58check: 269,
          buffer: 183,
          typeforce: 499
        }
      ],
      105: [
        function(require, module, exports) {
          (function(Buffer) {
            const lazy = require('./lazy');
            const typef = require('typeforce');
            const OPS = require('bitcoin-ops');
            const ecc = require('tiny-secp256k1');
            const bcrypto = require('../crypto');
            const bech32 = require('bech32');
            const bscript = require('../script');
            const BITCOIN_NETWORK = require('../networks').bitcoin;
            const EMPTY_BUFFER = Buffer.alloc(0);
            function p2wpkh(a, opts) {
              if (!a.address && !a.hash && !a.output && !a.pubkey && !a.witness)
                throw new TypeError('Not enough data');
              opts = opts || { validate: true };
              typef(
                {
                  address: typef.maybe(typef.String),
                  hash: typef.maybe(typef.BufferN(20)),
                  input: typef.maybe(typef.BufferN(0)),
                  network: typef.maybe(typef.Object),
                  output: typef.maybe(typef.BufferN(22)),
                  pubkey: typef.maybe(ecc.isPoint),
                  signature: typef.maybe(bscript.isCanonicalScriptSignature),
                  witness: typef.maybe(typef.arrayOf(typef.Buffer))
                },
                a
              );
              const _address = lazy.value(function() {
                const result = bech32.decode(a.address);
                const version = result.words.shift();
                const data = bech32.fromWords(result.words);
                return {
                  version: version,
                  prefix: result.prefix,
                  data: Buffer.from(data)
                };
              });
              const network = a.network || BITCOIN_NETWORK;
              const o = { network: network };
              lazy.prop(o, 'address', function() {
                if (!o.hash) return;
                const words = bech32.toWords(o.hash);
                words.unshift(0);
                return bech32.encode(network.bech32, words);
              });
              lazy.prop(o, 'hash', function() {
                if (a.output) return a.output.slice(2, 22);
                if (a.address) return _address().data;
                if (a.pubkey || o.pubkey)
                  return bcrypto.hash160(a.pubkey || o.pubkey);
              });
              lazy.prop(o, 'output', function() {
                if (!o.hash) return;
                return bscript.compile([OPS.OP_0, o.hash]);
              });
              lazy.prop(o, 'pubkey', function() {
                if (a.pubkey) return a.pubkey;
                if (!a.witness) return;
                return a.witness[1];
              });
              lazy.prop(o, 'signature', function() {
                if (!a.witness) return;
                return a.witness[0];
              });
              lazy.prop(o, 'input', function() {
                if (!o.witness) return;
                return EMPTY_BUFFER;
              });
              lazy.prop(o, 'witness', function() {
                if (!a.pubkey) return;
                if (!a.signature) return;
                return [a.signature, a.pubkey];
              });
              if (opts.validate) {
                let hash;
                if (a.address) {
                  if (network && network.bech32 !== _address().prefix)
                    throw new TypeError('Invalid prefix or Network mismatch');
                  if (_address().version !== 0)
                    throw new TypeError('Invalid address version');
                  if (_address().data.length !== 20)
                    throw new TypeError('Invalid address data');
                  hash = _address().data;
                }
                if (a.hash) {
                  if (hash && !hash.equals(a.hash))
                    throw new TypeError('Hash mismatch');
                  else hash = a.hash;
                }
                if (a.output) {
                  if (
                    a.output.length !== 22 ||
                    a.output[0] !== OPS.OP_0 ||
                    a.output[1] !== 20
                  )
                    throw new TypeError('Output is invalid');
                  if (hash && !hash.equals(a.output.slice(2)))
                    throw new TypeError('Hash mismatch');
                  else hash = a.output.slice(2);
                }
                if (a.pubkey) {
                  const pkh = bcrypto.hash160(a.pubkey);
                  if (hash && !hash.equals(pkh))
                    throw new TypeError('Hash mismatch');
                  else hash = pkh;
                }
                if (a.witness) {
                  if (a.witness.length !== 2)
                    throw new TypeError('Witness is invalid');
                  if (!bscript.isCanonicalScriptSignature(a.witness[0]))
                    throw new TypeError('Witness has invalid signature');
                  if (!ecc.isPoint(a.witness[1]))
                    throw new TypeError('Witness has invalid pubkey');
                  if (a.signature && !a.signature.equals(a.witness[0]))
                    throw new TypeError('Signature mismatch');
                  if (a.pubkey && !a.pubkey.equals(a.witness[1]))
                    throw new TypeError('Pubkey mismatch');
                  const pkh = bcrypto.hash160(a.witness[1]);
                  if (hash && !hash.equals(pkh))
                    throw new TypeError('Hash mismatch');
                }
              }
              return Object.assign(o, a);
            }
            module.exports = p2wpkh;
          }.call(this, require('buffer').Buffer));
        },
        {
          '../crypto': 94,
          '../networks': 97,
          '../script': 107,
          './lazy': 100,
          bech32: 71,
          'bitcoin-ops': 88,
          buffer: 183,
          'tiny-secp256k1': 472,
          typeforce: 499
        }
      ],
      106: [
        function(require, module, exports) {
          (function(Buffer) {
            const lazy = require('./lazy');
            const typef = require('typeforce');
            const OPS = require('bitcoin-ops');
            const bech32 = require('bech32');
            const bcrypto = require('../crypto');
            const bscript = require('../script');
            const BITCOIN_NETWORK = require('../networks').bitcoin;
            const EMPTY_BUFFER = Buffer.alloc(0);
            function stacksEqual(a, b) {
              if (a.length !== b.length) return false;
              return a.every(function(x, i) {
                return x.equals(b[i]);
              });
            }
            function p2wsh(a, opts) {
              if (!a.address && !a.hash && !a.output && !a.redeem && !a.witness)
                throw new TypeError('Not enough data');
              opts = opts || { validate: true };
              typef(
                {
                  network: typef.maybe(typef.Object),
                  address: typef.maybe(typef.String),
                  hash: typef.maybe(typef.BufferN(32)),
                  output: typef.maybe(typef.BufferN(34)),
                  redeem: typef.maybe({
                    input: typef.maybe(typef.Buffer),
                    network: typef.maybe(typef.Object),
                    output: typef.maybe(typef.Buffer),
                    witness: typef.maybe(typef.arrayOf(typef.Buffer))
                  }),
                  input: typef.maybe(typef.BufferN(0)),
                  witness: typef.maybe(typef.arrayOf(typef.Buffer))
                },
                a
              );
              const _address = lazy.value(function() {
                const result = bech32.decode(a.address);
                const version = result.words.shift();
                const data = bech32.fromWords(result.words);
                return {
                  version: version,
                  prefix: result.prefix,
                  data: Buffer.from(data)
                };
              });
              const _rchunks = lazy.value(function() {
                return bscript.decompile(a.redeem.input);
              });
              const network = a.network || BITCOIN_NETWORK;
              const o = { network: network };
              lazy.prop(o, 'address', function() {
                if (!o.hash) return;
                const words = bech32.toWords(o.hash);
                words.unshift(0);
                return bech32.encode(network.bech32, words);
              });
              lazy.prop(o, 'hash', function() {
                if (a.output) return a.output.slice(2);
                if (a.address) return _address().data;
                if (o.redeem && o.redeem.output)
                  return bcrypto.sha256(o.redeem.output);
              });
              lazy.prop(o, 'output', function() {
                if (!o.hash) return;
                return bscript.compile([OPS.OP_0, o.hash]);
              });
              lazy.prop(o, 'redeem', function() {
                if (!a.witness) return;
                return {
                  output: a.witness[a.witness.length - 1],
                  input: EMPTY_BUFFER,
                  witness: a.witness.slice(0, -1)
                };
              });
              lazy.prop(o, 'input', function() {
                if (!o.witness) return;
                return EMPTY_BUFFER;
              });
              lazy.prop(o, 'witness', function() {
                if (
                  a.redeem &&
                  a.redeem.input &&
                  a.redeem.input.length > 0 &&
                  a.redeem.output &&
                  a.redeem.output.length > 0
                ) {
                  const stack = bscript.toStack(_rchunks());
                  o.redeem = Object.assign({ witness: stack }, a.redeem);
                  o.redeem.input = EMPTY_BUFFER;
                  return [].concat(stack, a.redeem.output);
                }
                if (!a.redeem) return;
                if (!a.redeem.output) return;
                if (!a.redeem.witness) return;
                return [].concat(a.redeem.witness, a.redeem.output);
              });
              if (opts.validate) {
                let hash;
                if (a.address) {
                  if (_address().prefix !== network.bech32)
                    throw new TypeError('Invalid prefix or Network mismatch');
                  if (_address().version !== 0)
                    throw new TypeError('Invalid address version');
                  if (_address().data.length !== 32)
                    throw new TypeError('Invalid address data');
                  else hash = _address().data;
                }
                if (a.hash) {
                  if (hash && !hash.equals(a.hash))
                    throw new TypeError('Hash mismatch');
                  else hash = a.hash;
                }
                if (a.output) {
                  if (
                    a.output.length !== 34 ||
                    a.output[0] !== OPS.OP_0 ||
                    a.output[1] !== 32
                  )
                    throw new TypeError('Output is invalid');
                  const hash2 = a.output.slice(2);
                  if (hash && !hash.equals(hash2))
                    throw new TypeError('Hash mismatch');
                  else hash = hash2;
                }
                if (a.redeem) {
                  if (a.redeem.network && a.redeem.network !== network)
                    throw new TypeError('Network mismatch');
                  if (
                    a.redeem.input &&
                    a.redeem.input.length > 0 &&
                    a.redeem.witness &&
                    a.redeem.witness.length > 0
                  )
                    throw new TypeError('Ambiguous witness source');
                  if (a.redeem.output) {
                    if (bscript.decompile(a.redeem.output).length === 0)
                      throw new TypeError('Redeem.output is invalid');
                    const hash2 = bcrypto.sha256(a.redeem.output);
                    if (hash && !hash.equals(hash2))
                      throw new TypeError('Hash mismatch');
                    else hash = hash2;
                  }
                  if (a.redeem.input && !bscript.isPushOnly(_rchunks()))
                    throw new TypeError('Non push-only scriptSig');
                  if (
                    a.witness &&
                    a.redeem.witness &&
                    !stacksEqual(a.witness, a.redeem.witness)
                  )
                    throw new TypeError('Witness and redeem.witness mismatch');
                }
                if (a.witness) {
                  if (
                    a.redeem &&
                    a.redeem.output &&
                    !a.redeem.output.equals(a.witness[a.witness.length - 1])
                  )
                    throw new TypeError('Witness and redeem.output mismatch');
                }
              }
              return Object.assign(o, a);
            }
            module.exports = p2wsh;
          }.call(this, require('buffer').Buffer));
        },
        {
          '../crypto': 94,
          '../networks': 97,
          '../script': 107,
          './lazy': 100,
          bech32: 71,
          'bitcoin-ops': 88,
          buffer: 183,
          typeforce: 499
        }
      ],
      107: [
        function(require, module, exports) {
          const Buffer = require('safe-buffer').Buffer;
          const bip66 = require('bip66');
          const ecc = require('tiny-secp256k1');
          const pushdata = require('pushdata-bitcoin');
          const typeforce = require('typeforce');
          const types = require('./types');
          const scriptNumber = require('./script_number');
          const OPS = require('bitcoin-ops');
          const REVERSE_OPS = require('bitcoin-ops/map');
          const OP_INT_BASE = OPS.OP_RESERVED;
          function isOPInt(value) {
            return (
              types.Number(value) &&
              (value === OPS.OP_0 ||
                (value >= OPS.OP_1 && value <= OPS.OP_16) ||
                value === OPS.OP_1NEGATE)
            );
          }
          function isPushOnlyChunk(value) {
            return types.Buffer(value) || isOPInt(value);
          }
          function isPushOnly(value) {
            return types.Array(value) && value.every(isPushOnlyChunk);
          }
          function asMinimalOP(buffer) {
            if (buffer.length === 0) return OPS.OP_0;
            if (buffer.length !== 1) return;
            if (buffer[0] >= 1 && buffer[0] <= 16)
              return OP_INT_BASE + buffer[0];
            if (buffer[0] === 129) return OPS.OP_1NEGATE;
          }
          function compile(chunks) {
            if (Buffer.isBuffer(chunks)) return chunks;
            typeforce(types.Array, chunks);
            const bufferSize = chunks.reduce(function(accum, chunk) {
              if (Buffer.isBuffer(chunk)) {
                if (chunk.length === 1 && asMinimalOP(chunk) !== undefined) {
                  return accum + 1;
                }
                return (
                  accum + pushdata.encodingLength(chunk.length) + chunk.length
                );
              }
              return accum + 1;
            }, 0);
            const buffer = Buffer.allocUnsafe(bufferSize);
            let offset = 0;
            chunks.forEach(function(chunk) {
              if (Buffer.isBuffer(chunk)) {
                const opcode = asMinimalOP(chunk);
                if (opcode !== undefined) {
                  buffer.writeUInt8(opcode, offset);
                  offset += 1;
                  return;
                }
                offset += pushdata.encode(buffer, chunk.length, offset);
                chunk.copy(buffer, offset);
                offset += chunk.length;
              } else {
                buffer.writeUInt8(chunk, offset);
                offset += 1;
              }
            });
            if (offset !== buffer.length)
              throw new Error('Could not decode chunks');
            return buffer;
          }
          function decompile(buffer) {
            if (types.Array(buffer)) return buffer;
            typeforce(types.Buffer, buffer);
            const chunks = [];
            let i = 0;
            while (i < buffer.length) {
              const opcode = buffer[i];
              if (opcode > OPS.OP_0 && opcode <= OPS.OP_PUSHDATA4) {
                const d = pushdata.decode(buffer, i);
                if (d === null) return null;
                i += d.size;
                if (i + d.number > buffer.length) return null;
                const data = buffer.slice(i, i + d.number);
                i += d.number;
                const op = asMinimalOP(data);
                if (op !== undefined) {
                  chunks.push(op);
                } else {
                  chunks.push(data);
                }
              } else {
                chunks.push(opcode);
                i += 1;
              }
            }
            return chunks;
          }
          function toASM(chunks) {
            if (Buffer.isBuffer(chunks)) {
              chunks = decompile(chunks);
            }
            return chunks
              .map(function(chunk) {
                if (Buffer.isBuffer(chunk)) {
                  const op = asMinimalOP(chunk);
                  if (op === undefined) return chunk.toString('hex');
                  chunk = op;
                }
                return REVERSE_OPS[chunk];
              })
              .join(' ');
          }
          function fromASM(asm) {
            typeforce(types.String, asm);
            return compile(
              asm.split(' ').map(function(chunkStr) {
                if (OPS[chunkStr] !== undefined) return OPS[chunkStr];
                typeforce(types.Hex, chunkStr);
                return Buffer.from(chunkStr, 'hex');
              })
            );
          }
          function toStack(chunks) {
            chunks = decompile(chunks);
            typeforce(isPushOnly, chunks);
            return chunks.map(function(op) {
              if (Buffer.isBuffer(op)) return op;
              if (op === OPS.OP_0) return Buffer.allocUnsafe(0);
              return scriptNumber.encode(op - OP_INT_BASE);
            });
          }
          function isCanonicalPubKey(buffer) {
            return ecc.isPoint(buffer);
          }
          function isDefinedHashType(hashType) {
            const hashTypeMod = hashType & ~128;
            return hashTypeMod > 0 && hashTypeMod < 4;
          }
          function isCanonicalScriptSignature(buffer) {
            if (!Buffer.isBuffer(buffer)) return false;
            if (!isDefinedHashType(buffer[buffer.length - 1])) return false;
            return bip66.check(buffer.slice(0, -1));
          }
          module.exports = {
            compile: compile,
            decompile: decompile,
            fromASM: fromASM,
            toASM: toASM,
            toStack: toStack,
            number: require('./script_number'),
            signature: require('./script_signature'),
            isCanonicalPubKey: isCanonicalPubKey,
            isCanonicalScriptSignature: isCanonicalScriptSignature,
            isPushOnly: isPushOnly,
            isDefinedHashType: isDefinedHashType
          };
        },
        {
          './script_number': 108,
          './script_signature': 109,
          './types': 133,
          bip66: 87,
          'bitcoin-ops': 88,
          'bitcoin-ops/map': 89,
          'pushdata-bitcoin': 452,
          'safe-buffer': 460,
          'tiny-secp256k1': 472,
          typeforce: 499
        }
      ],
      108: [
        function(require, module, exports) {
          const Buffer = require('safe-buffer').Buffer;
          function decode(buffer, maxLength, minimal) {
            maxLength = maxLength || 4;
            minimal = minimal === undefined ? true : minimal;
            const length = buffer.length;
            if (length === 0) return 0;
            if (length > maxLength)
              throw new TypeError('Script number overflow');
            if (minimal) {
              if ((buffer[length - 1] & 127) === 0) {
                if (length <= 1 || (buffer[length - 2] & 128) === 0)
                  throw new Error('Non-minimally encoded script number');
              }
            }
            if (length === 5) {
              const a = buffer.readUInt32LE(0);
              const b = buffer.readUInt8(4);
              if (b & 128) return -((b & ~128) * 4294967296 + a);
              return b * 4294967296 + a;
            }
            let result = 0;
            for (var i = 0; i < length; ++i) {
              result |= buffer[i] << (8 * i);
            }
            if (buffer[length - 1] & 128)
              return -(result & ~(128 << (8 * (length - 1))));
            return result;
          }
          function scriptNumSize(i) {
            return i > 2147483647
              ? 5
              : i > 8388607
              ? 4
              : i > 32767
              ? 3
              : i > 127
              ? 2
              : i > 0
              ? 1
              : 0;
          }
          function encode(number) {
            let value = Math.abs(number);
            const size = scriptNumSize(value);
            const buffer = Buffer.allocUnsafe(size);
            const negative = number < 0;
            for (var i = 0; i < size; ++i) {
              buffer.writeUInt8(value & 255, i);
              value >>= 8;
            }
            if (buffer[size - 1] & 128) {
              buffer.writeUInt8(negative ? 128 : 0, size - 1);
            } else if (negative) {
              buffer[size - 1] |= 128;
            }
            return buffer;
          }
          module.exports = { decode: decode, encode: encode };
        },
        { 'safe-buffer': 460 }
      ],
      109: [
        function(require, module, exports) {
          const bip66 = require('bip66');
          const Buffer = require('safe-buffer').Buffer;
          const typeforce = require('typeforce');
          const types = require('./types');
          const ZERO = Buffer.alloc(1, 0);
          function toDER(x) {
            let i = 0;
            while (x[i] === 0) ++i;
            if (i === x.length) return ZERO;
            x = x.slice(i);
            if (x[0] & 128) return Buffer.concat([ZERO, x], 1 + x.length);
            return x;
          }
          function fromDER(x) {
            if (x[0] === 0) x = x.slice(1);
            const buffer = Buffer.alloc(32, 0);
            const bstart = Math.max(0, 32 - x.length);
            x.copy(buffer, bstart);
            return buffer;
          }
          function decode(buffer) {
            const hashType = buffer.readUInt8(buffer.length - 1);
            const hashTypeMod = hashType & ~128;
            if (hashTypeMod <= 0 || hashTypeMod >= 4)
              throw new Error('Invalid hashType ' + hashType);
            const decode = bip66.decode(buffer.slice(0, -1));
            const r = fromDER(decode.r);
            const s = fromDER(decode.s);
            return { signature: Buffer.concat([r, s], 64), hashType: hashType };
          }
          function encode(signature, hashType) {
            typeforce(
              { signature: types.BufferN(64), hashType: types.UInt8 },
              { signature: signature, hashType: hashType }
            );
            const hashTypeMod = hashType & ~128;
            if (hashTypeMod <= 0 || hashTypeMod >= 4)
              throw new Error('Invalid hashType ' + hashType);
            const hashTypeBuffer = Buffer.allocUnsafe(1);
            hashTypeBuffer.writeUInt8(hashType, 0);
            const r = toDER(signature.slice(0, 32));
            const s = toDER(signature.slice(32, 64));
            return Buffer.concat([bip66.encode(r, s), hashTypeBuffer]);
          }
          module.exports = { decode: decode, encode: encode };
        },
        { './types': 133, bip66: 87, 'safe-buffer': 460, typeforce: 499 }
      ],
      110: [
        function(require, module, exports) {
          module.exports = {
            input: require('./input'),
            output: require('./output')
          };
        },
        { './input': 111, './output': 112 }
      ],
      111: [
        function(require, module, exports) {
          const bscript = require('../../script');
          const OPS = require('bitcoin-ops');
          function partialSignature(value) {
            return (
              value === OPS.OP_0 || bscript.isCanonicalScriptSignature(value)
            );
          }
          function check(script, allowIncomplete) {
            const chunks = bscript.decompile(script);
            if (chunks.length < 2) return false;
            if (chunks[0] !== OPS.OP_0) return false;
            if (allowIncomplete) {
              return chunks.slice(1).every(partialSignature);
            }
            return chunks.slice(1).every(bscript.isCanonicalScriptSignature);
          }
          check.toJSON = function() {
            return 'multisig input';
          };
          module.exports = { check: check };
        },
        { '../../script': 107, 'bitcoin-ops': 88 }
      ],
      112: [
        function(require, module, exports) {
          const bscript = require('../../script');
          const types = require('../../types');
          const OPS = require('bitcoin-ops');
          const OP_INT_BASE = OPS.OP_RESERVED;
          function check(script, allowIncomplete) {
            const chunks = bscript.decompile(script);
            if (chunks.length < 4) return false;
            if (chunks[chunks.length - 1] !== OPS.OP_CHECKMULTISIG)
              return false;
            if (!types.Number(chunks[0])) return false;
            if (!types.Number(chunks[chunks.length - 2])) return false;
            const m = chunks[0] - OP_INT_BASE;
            const n = chunks[chunks.length - 2] - OP_INT_BASE;
            if (m <= 0) return false;
            if (n > 16) return false;
            if (m > n) return false;
            if (n !== chunks.length - 3) return false;
            if (allowIncomplete) return true;
            const keys = chunks.slice(1, -2);
            return keys.every(bscript.isCanonicalPubKey);
          }
          check.toJSON = function() {
            return 'multi-sig output';
          };
          module.exports = { check: check };
        },
        { '../../script': 107, '../../types': 133, 'bitcoin-ops': 88 }
      ],
      113: [
        function(require, module, exports) {
          const bscript = require('../script');
          const OPS = require('bitcoin-ops');
          function check(script) {
            const buffer = bscript.compile(script);
            return buffer.length > 1 && buffer[0] === OPS.OP_RETURN;
          }
          check.toJSON = function() {
            return 'null data output';
          };
          module.exports = { output: { check: check } };
        },
        { '../script': 107, 'bitcoin-ops': 88 }
      ],
      114: [
        function(require, module, exports) {
          arguments[4][110][0].apply(exports, arguments);
        },
        { './input': 115, './output': 116, dup: 110 }
      ],
      115: [
        function(require, module, exports) {
          const bscript = require('../../script');
          function check(script) {
            const chunks = bscript.decompile(script);
            return (
              chunks.length === 1 &&
              bscript.isCanonicalScriptSignature(chunks[0])
            );
          }
          check.toJSON = function() {
            return 'pubKey input';
          };
          module.exports = { check: check };
        },
        { '../../script': 107 }
      ],
      116: [
        function(require, module, exports) {
          const bscript = require('../../script');
          const OPS = require('bitcoin-ops');
          function check(script) {
            const chunks = bscript.decompile(script);
            return (
              chunks.length === 2 &&
              bscript.isCanonicalPubKey(chunks[0]) &&
              chunks[1] === OPS.OP_CHECKSIG
            );
          }
          check.toJSON = function() {
            return 'pubKey output';
          };
          module.exports = { check: check };
        },
        { '../../script': 107, 'bitcoin-ops': 88 }
      ],
      117: [
        function(require, module, exports) {
          arguments[4][110][0].apply(exports, arguments);
        },
        { './input': 118, './output': 119, dup: 110 }
      ],
      118: [
        function(require, module, exports) {
          const bscript = require('../../script');
          function check(script) {
            const chunks = bscript.decompile(script);
            return (
              chunks.length === 2 &&
              bscript.isCanonicalScriptSignature(chunks[0]) &&
              bscript.isCanonicalPubKey(chunks[1])
            );
          }
          check.toJSON = function() {
            return 'pubKeyHash input';
          };
          module.exports = { check: check };
        },
        { '../../script': 107 }
      ],
      119: [
        function(require, module, exports) {
          const bscript = require('../../script');
          const OPS = require('bitcoin-ops');
          function check(script) {
            const buffer = bscript.compile(script);
            return (
              buffer.length === 25 &&
              buffer[0] === OPS.OP_DUP &&
              buffer[1] === OPS.OP_HASH160 &&
              buffer[2] === 20 &&
              buffer[23] === OPS.OP_EQUALVERIFY &&
              buffer[24] === OPS.OP_CHECKSIG
            );
          }
          check.toJSON = function() {
            return 'pubKeyHash output';
          };
          module.exports = { check: check };
        },
        { '../../script': 107, 'bitcoin-ops': 88 }
      ],
      120: [
        function(require, module, exports) {
          arguments[4][110][0].apply(exports, arguments);
        },
        { './input': 121, './output': 122, dup: 110 }
      ],
      121: [
        function(require, module, exports) {
          const Buffer = require('safe-buffer').Buffer;
          const bscript = require('../../script');
          const p2ms = require('../multisig/');
          const p2pk = require('../pubkey/');
          const p2pkh = require('../pubkeyhash/');
          const p2wpkho = require('../witnesspubkeyhash/output');
          const p2wsho = require('../witnessscripthash/output');
          function check(script, allowIncomplete) {
            const chunks = bscript.decompile(script);
            if (chunks.length < 1) return false;
            const lastChunk = chunks[chunks.length - 1];
            if (!Buffer.isBuffer(lastChunk)) return false;
            const scriptSigChunks = bscript.decompile(
              bscript.compile(chunks.slice(0, -1))
            );
            const redeemScriptChunks = bscript.decompile(lastChunk);
            if (!redeemScriptChunks) return false;
            if (!bscript.isPushOnly(scriptSigChunks)) return false;
            if (chunks.length === 1) {
              return (
                p2wsho.check(redeemScriptChunks) ||
                p2wpkho.check(redeemScriptChunks)
              );
            }
            if (
              p2pkh.input.check(scriptSigChunks) &&
              p2pkh.output.check(redeemScriptChunks)
            )
              return true;
            if (
              p2ms.input.check(scriptSigChunks, allowIncomplete) &&
              p2ms.output.check(redeemScriptChunks)
            )
              return true;
            if (
              p2pk.input.check(scriptSigChunks) &&
              p2pk.output.check(redeemScriptChunks)
            )
              return true;
            return false;
          }
          check.toJSON = function() {
            return 'scriptHash input';
          };
          module.exports = { check: check };
        },
        {
          '../../script': 107,
          '../multisig/': 110,
          '../pubkey/': 114,
          '../pubkeyhash/': 117,
          '../witnesspubkeyhash/output': 127,
          '../witnessscripthash/output': 130,
          'safe-buffer': 460
        }
      ],
      122: [
        function(require, module, exports) {
          const bscript = require('../../script');
          const OPS = require('bitcoin-ops');
          function check(script) {
            const buffer = bscript.compile(script);
            return (
              buffer.length === 23 &&
              buffer[0] === OPS.OP_HASH160 &&
              buffer[1] === 20 &&
              buffer[22] === OPS.OP_EQUAL
            );
          }
          check.toJSON = function() {
            return 'scriptHash output';
          };
          module.exports = { check: check };
        },
        { '../../script': 107, 'bitcoin-ops': 88 }
      ],
      123: [
        function(require, module, exports) {
          module.exports = { output: require('./output') };
        },
        { './output': 124 }
      ],
      124: [
        function(require, module, exports) {
          const Buffer = require('safe-buffer').Buffer;
          const bscript = require('../../script');
          const types = require('../../types');
          const typeforce = require('typeforce');
          const OPS = require('bitcoin-ops');
          const HEADER = Buffer.from('aa21a9ed', 'hex');
          function check(script) {
            const buffer = bscript.compile(script);
            return (
              buffer.length > 37 &&
              buffer[0] === OPS.OP_RETURN &&
              buffer[1] === 36 &&
              buffer.slice(2, 6).equals(HEADER)
            );
          }
          check.toJSON = function() {
            return 'Witness commitment output';
          };
          function encode(commitment) {
            typeforce(types.Hash256bit, commitment);
            const buffer = Buffer.allocUnsafe(36);
            HEADER.copy(buffer, 0);
            commitment.copy(buffer, 4);
            return bscript.compile([OPS.OP_RETURN, buffer]);
          }
          function decode(buffer) {
            typeforce(check, buffer);
            return bscript.decompile(buffer)[1].slice(4, 36);
          }
          module.exports = { check: check, decode: decode, encode: encode };
        },
        {
          '../../script': 107,
          '../../types': 133,
          'bitcoin-ops': 88,
          'safe-buffer': 460,
          typeforce: 499
        }
      ],
      125: [
        function(require, module, exports) {
          arguments[4][110][0].apply(exports, arguments);
        },
        { './input': 126, './output': 127, dup: 110 }
      ],
      126: [
        function(require, module, exports) {
          const bscript = require('../../script');
          function isCompressedCanonicalPubKey(pubKey) {
            return bscript.isCanonicalPubKey(pubKey) && pubKey.length === 33;
          }
          function check(script) {
            const chunks = bscript.decompile(script);
            return (
              chunks.length === 2 &&
              bscript.isCanonicalScriptSignature(chunks[0]) &&
              isCompressedCanonicalPubKey(chunks[1])
            );
          }
          check.toJSON = function() {
            return 'witnessPubKeyHash input';
          };
          module.exports = { check: check };
        },
        { '../../script': 107 }
      ],
      127: [
        function(require, module, exports) {
          const bscript = require('../../script');
          const OPS = require('bitcoin-ops');
          function check(script) {
            const buffer = bscript.compile(script);
            return (
              buffer.length === 22 && buffer[0] === OPS.OP_0 && buffer[1] === 20
            );
          }
          check.toJSON = function() {
            return 'Witness pubKeyHash output';
          };
          module.exports = { check: check };
        },
        { '../../script': 107, 'bitcoin-ops': 88 }
      ],
      128: [
        function(require, module, exports) {
          arguments[4][110][0].apply(exports, arguments);
        },
        { './input': 129, './output': 130, dup: 110 }
      ],
      129: [
        function(require, module, exports) {
          (function(Buffer) {
            const bscript = require('../../script');
            const types = require('../../types');
            const typeforce = require('typeforce');
            const p2ms = require('../multisig/');
            const p2pk = require('../pubkey/');
            const p2pkh = require('../pubkeyhash/');
            function check(chunks, allowIncomplete) {
              typeforce(types.Array, chunks);
              if (chunks.length < 1) return false;
              const witnessScript = chunks[chunks.length - 1];
              if (!Buffer.isBuffer(witnessScript)) return false;
              const witnessScriptChunks = bscript.decompile(witnessScript);
              if (!witnessScriptChunks || witnessScriptChunks.length === 0)
                return false;
              const witnessRawScriptSig = bscript.compile(chunks.slice(0, -1));
              if (
                p2pkh.input.check(witnessRawScriptSig) &&
                p2pkh.output.check(witnessScriptChunks)
              )
                return true;
              if (
                p2ms.input.check(witnessRawScriptSig, allowIncomplete) &&
                p2ms.output.check(witnessScriptChunks)
              )
                return true;
              if (
                p2pk.input.check(witnessRawScriptSig) &&
                p2pk.output.check(witnessScriptChunks)
              )
                return true;
              return false;
            }
            check.toJSON = function() {
              return 'witnessScriptHash input';
            };
            module.exports = { check: check };
          }.call(this, {
            isBuffer: require('../../../../browserify/node_modules/is-buffer/index.js')
          }));
        },
        {
          '../../../../browserify/node_modules/is-buffer/index.js': 208,
          '../../script': 107,
          '../../types': 133,
          '../multisig/': 110,
          '../pubkey/': 114,
          '../pubkeyhash/': 117,
          typeforce: 499
        }
      ],
      130: [
        function(require, module, exports) {
          const bscript = require('../../script');
          const OPS = require('bitcoin-ops');
          function check(script) {
            const buffer = bscript.compile(script);
            return (
              buffer.length === 34 && buffer[0] === OPS.OP_0 && buffer[1] === 32
            );
          }
          check.toJSON = function() {
            return 'Witness scriptHash output';
          };
          module.exports = { check: check };
        },
        { '../../script': 107, 'bitcoin-ops': 88 }
      ],
      131: [
        function(require, module, exports) {
          const Buffer = require('safe-buffer').Buffer;
          const bcrypto = require('./crypto');
          const bscript = require('./script');
          const bufferutils = require('./bufferutils');
          const opcodes = require('bitcoin-ops');
          const typeforce = require('typeforce');
          const types = require('./types');
          const varuint = require('varuint-bitcoin');
          function varSliceSize(someScript) {
            const length = someScript.length;
            return varuint.encodingLength(length) + length;
          }
          function vectorSize(someVector) {
            const length = someVector.length;
            return (
              varuint.encodingLength(length) +
              someVector.reduce(function(sum, witness) {
                return sum + varSliceSize(witness);
              }, 0)
            );
          }
          function Transaction() {
            this.version = 1;
            this.locktime = 0;
            this.ins = [];
            this.outs = [];
          }
          Transaction.DEFAULT_SEQUENCE = 4294967295;
          Transaction.SIGHASH_ALL = 1;
          Transaction.SIGHASH_NONE = 2;
          Transaction.SIGHASH_SINGLE = 3;
          Transaction.SIGHASH_ANYONECANPAY = 128;
          Transaction.ADVANCED_TRANSACTION_MARKER = 0;
          Transaction.ADVANCED_TRANSACTION_FLAG = 1;
          const EMPTY_SCRIPT = Buffer.allocUnsafe(0);
          const EMPTY_WITNESS = [];
          const ZERO = Buffer.from(
            '0000000000000000000000000000000000000000000000000000000000000000',
            'hex'
          );
          const ONE = Buffer.from(
            '0000000000000000000000000000000000000000000000000000000000000001',
            'hex'
          );
          const VALUE_UINT64_MAX = Buffer.from('ffffffffffffffff', 'hex');
          const BLANK_OUTPUT = {
            script: EMPTY_SCRIPT,
            valueBuffer: VALUE_UINT64_MAX
          };
          Transaction.fromBuffer = function(buffer, __noStrict) {
            let offset = 0;
            function readSlice(n) {
              offset += n;
              return buffer.slice(offset - n, offset);
            }
            function readUInt32() {
              const i = buffer.readUInt32LE(offset);
              offset += 4;
              return i;
            }
            function readInt32() {
              const i = buffer.readInt32LE(offset);
              offset += 4;
              return i;
            }
            function readUInt64() {
              const i = bufferutils.readUInt64LE(buffer, offset);
              offset += 8;
              return i;
            }
            function readVarInt() {
              const vi = varuint.decode(buffer, offset);
              offset += varuint.decode.bytes;
              return vi;
            }
            function readVarSlice() {
              return readSlice(readVarInt());
            }
            function readVector() {
              const count = readVarInt();
              const vector = [];
              for (var i = 0; i < count; i++) vector.push(readVarSlice());
              return vector;
            }
            const tx = new Transaction();
            tx.version = readInt32();
            const marker = buffer.readUInt8(offset);
            const flag = buffer.readUInt8(offset + 1);
            let hasWitnesses = false;
            if (
              marker === Transaction.ADVANCED_TRANSACTION_MARKER &&
              flag === Transaction.ADVANCED_TRANSACTION_FLAG
            ) {
              offset += 2;
              hasWitnesses = true;
            }
            const vinLen = readVarInt();
            for (var i = 0; i < vinLen; ++i) {
              tx.ins.push({
                hash: readSlice(32),
                index: readUInt32(),
                script: readVarSlice(),
                sequence: readUInt32(),
                witness: EMPTY_WITNESS
              });
            }
            const voutLen = readVarInt();
            for (i = 0; i < voutLen; ++i) {
              tx.outs.push({ value: readUInt64(), script: readVarSlice() });
            }
            if (hasWitnesses) {
              for (i = 0; i < vinLen; ++i) {
                tx.ins[i].witness = readVector();
              }
              if (!tx.hasWitnesses())
                throw new Error('Transaction has superfluous witness data');
            }
            tx.locktime = readUInt32();
            if (__noStrict) return tx;
            if (offset !== buffer.length)
              throw new Error('Transaction has unexpected data');
            return tx;
          };
          Transaction.fromHex = function(hex) {
            return Transaction.fromBuffer(Buffer.from(hex, 'hex'));
          };
          Transaction.isCoinbaseHash = function(buffer) {
            typeforce(types.Hash256bit, buffer);
            for (var i = 0; i < 32; ++i) {
              if (buffer[i] !== 0) return false;
            }
            return true;
          };
          Transaction.prototype.isCoinbase = function() {
            return (
              this.ins.length === 1 &&
              Transaction.isCoinbaseHash(this.ins[0].hash)
            );
          };
          Transaction.prototype.addInput = function(
            hash,
            index,
            sequence,
            scriptSig
          ) {
            typeforce(
              types.tuple(
                types.Hash256bit,
                types.UInt32,
                types.maybe(types.UInt32),
                types.maybe(types.Buffer)
              ),
              arguments
            );
            if (types.Null(sequence)) {
              sequence = Transaction.DEFAULT_SEQUENCE;
            }
            return (
              this.ins.push({
                hash: hash,
                index: index,
                script: scriptSig || EMPTY_SCRIPT,
                sequence: sequence,
                witness: EMPTY_WITNESS
              }) - 1
            );
          };
          Transaction.prototype.addOutput = function(scriptPubKey, value) {
            typeforce(types.tuple(types.Buffer, types.Satoshi), arguments);
            return this.outs.push({ script: scriptPubKey, value: value }) - 1;
          };
          Transaction.prototype.hasWitnesses = function() {
            return this.ins.some(function(x) {
              return x.witness.length !== 0;
            });
          };
          Transaction.prototype.weight = function() {
            const base = this.__byteLength(false);
            const total = this.__byteLength(true);
            return base * 3 + total;
          };
          Transaction.prototype.virtualSize = function() {
            return Math.ceil(this.weight() / 4);
          };
          Transaction.prototype.byteLength = function() {
            return this.__byteLength(true);
          };
          Transaction.prototype.__byteLength = function(__allowWitness) {
            const hasWitnesses = __allowWitness && this.hasWitnesses();
            return (
              (hasWitnesses ? 10 : 8) +
              varuint.encodingLength(this.ins.length) +
              varuint.encodingLength(this.outs.length) +
              this.ins.reduce(function(sum, input) {
                return sum + 40 + varSliceSize(input.script);
              }, 0) +
              this.outs.reduce(function(sum, output) {
                return sum + 8 + varSliceSize(output.script);
              }, 0) +
              (hasWitnesses
                ? this.ins.reduce(function(sum, input) {
                    return sum + vectorSize(input.witness);
                  }, 0)
                : 0)
            );
          };
          Transaction.prototype.clone = function() {
            const newTx = new Transaction();
            newTx.version = this.version;
            newTx.locktime = this.locktime;
            newTx.ins = this.ins.map(function(txIn) {
              return {
                hash: txIn.hash,
                index: txIn.index,
                script: txIn.script,
                sequence: txIn.sequence,
                witness: txIn.witness
              };
            });
            newTx.outs = this.outs.map(function(txOut) {
              return { script: txOut.script, value: txOut.value };
            });
            return newTx;
          };
          Transaction.prototype.hashForSignature = function(
            inIndex,
            prevOutScript,
            hashType
          ) {
            typeforce(
              types.tuple(types.UInt32, types.Buffer, types.Number),
              arguments
            );
            if (inIndex >= this.ins.length) return ONE;
            const ourScript = bscript.compile(
              bscript.decompile(prevOutScript).filter(function(x) {
                return x !== opcodes.OP_CODESEPARATOR;
              })
            );
            const txTmp = this.clone();
            if ((hashType & 31) === Transaction.SIGHASH_NONE) {
              txTmp.outs = [];
              txTmp.ins.forEach(function(input, i) {
                if (i === inIndex) return;
                input.sequence = 0;
              });
            } else if ((hashType & 31) === Transaction.SIGHASH_SINGLE) {
              if (inIndex >= this.outs.length) return ONE;
              txTmp.outs.length = inIndex + 1;
              for (var i = 0; i < inIndex; i++) {
                txTmp.outs[i] = BLANK_OUTPUT;
              }
              txTmp.ins.forEach(function(input, y) {
                if (y === inIndex) return;
                input.sequence = 0;
              });
            }
            if (hashType & Transaction.SIGHASH_ANYONECANPAY) {
              txTmp.ins = [txTmp.ins[inIndex]];
              txTmp.ins[0].script = ourScript;
            } else {
              txTmp.ins.forEach(function(input) {
                input.script = EMPTY_SCRIPT;
              });
              txTmp.ins[inIndex].script = ourScript;
            }
            const buffer = Buffer.allocUnsafe(txTmp.__byteLength(false) + 4);
            buffer.writeInt32LE(hashType, buffer.length - 4);
            txTmp.__toBuffer(buffer, 0, false);
            return bcrypto.hash256(buffer);
          };
          Transaction.prototype.hashForWitnessV0 = function(
            inIndex,
            prevOutScript,
            value,
            hashType
          ) {
            typeforce(
              types.tuple(
                types.UInt32,
                types.Buffer,
                types.Satoshi,
                types.UInt32
              ),
              arguments
            );
            let tbuffer, toffset;
            function writeSlice(slice) {
              toffset += slice.copy(tbuffer, toffset);
            }
            function writeUInt32(i) {
              toffset = tbuffer.writeUInt32LE(i, toffset);
            }
            function writeUInt64(i) {
              toffset = bufferutils.writeUInt64LE(tbuffer, i, toffset);
            }
            function writeVarInt(i) {
              varuint.encode(i, tbuffer, toffset);
              toffset += varuint.encode.bytes;
            }
            function writeVarSlice(slice) {
              writeVarInt(slice.length);
              writeSlice(slice);
            }
            let hashOutputs = ZERO;
            let hashPrevouts = ZERO;
            let hashSequence = ZERO;
            if (!(hashType & Transaction.SIGHASH_ANYONECANPAY)) {
              tbuffer = Buffer.allocUnsafe(36 * this.ins.length);
              toffset = 0;
              this.ins.forEach(function(txIn) {
                writeSlice(txIn.hash);
                writeUInt32(txIn.index);
              });
              hashPrevouts = bcrypto.hash256(tbuffer);
            }
            if (
              !(hashType & Transaction.SIGHASH_ANYONECANPAY) &&
              (hashType & 31) !== Transaction.SIGHASH_SINGLE &&
              (hashType & 31) !== Transaction.SIGHASH_NONE
            ) {
              tbuffer = Buffer.allocUnsafe(4 * this.ins.length);
              toffset = 0;
              this.ins.forEach(function(txIn) {
                writeUInt32(txIn.sequence);
              });
              hashSequence = bcrypto.hash256(tbuffer);
            }
            if (
              (hashType & 31) !== Transaction.SIGHASH_SINGLE &&
              (hashType & 31) !== Transaction.SIGHASH_NONE
            ) {
              const txOutsSize = this.outs.reduce(function(sum, output) {
                return sum + 8 + varSliceSize(output.script);
              }, 0);
              tbuffer = Buffer.allocUnsafe(txOutsSize);
              toffset = 0;
              this.outs.forEach(function(out) {
                writeUInt64(out.value);
                writeVarSlice(out.script);
              });
              hashOutputs = bcrypto.hash256(tbuffer);
            } else if (
              (hashType & 31) === Transaction.SIGHASH_SINGLE &&
              inIndex < this.outs.length
            ) {
              const output = this.outs[inIndex];
              tbuffer = Buffer.allocUnsafe(8 + varSliceSize(output.script));
              toffset = 0;
              writeUInt64(output.value);
              writeVarSlice(output.script);
              hashOutputs = bcrypto.hash256(tbuffer);
            }
            tbuffer = Buffer.allocUnsafe(156 + varSliceSize(prevOutScript));
            toffset = 0;
            const input = this.ins[inIndex];
            writeUInt32(this.version);
            writeSlice(hashPrevouts);
            writeSlice(hashSequence);
            writeSlice(input.hash);
            writeUInt32(input.index);
            writeVarSlice(prevOutScript);
            writeUInt64(value);
            writeUInt32(input.sequence);
            writeSlice(hashOutputs);
            writeUInt32(this.locktime);
            writeUInt32(hashType);
            return bcrypto.hash256(tbuffer);
          };
          Transaction.prototype.getHash = function() {
            return bcrypto.hash256(
              this.__toBuffer(undefined, undefined, false)
            );
          };
          Transaction.prototype.getId = function() {
            return this.getHash()
              .reverse()
              .toString('hex');
          };
          Transaction.prototype.toBuffer = function(buffer, initialOffset) {
            return this.__toBuffer(buffer, initialOffset, true);
          };
          Transaction.prototype.__toBuffer = function(
            buffer,
            initialOffset,
            __allowWitness
          ) {
            if (!buffer)
              buffer = Buffer.allocUnsafe(this.__byteLength(__allowWitness));
            let offset = initialOffset || 0;
            function writeSlice(slice) {
              offset += slice.copy(buffer, offset);
            }
            function writeUInt8(i) {
              offset = buffer.writeUInt8(i, offset);
            }
            function writeUInt32(i) {
              offset = buffer.writeUInt32LE(i, offset);
            }
            function writeInt32(i) {
              offset = buffer.writeInt32LE(i, offset);
            }
            function writeUInt64(i) {
              offset = bufferutils.writeUInt64LE(buffer, i, offset);
            }
            function writeVarInt(i) {
              varuint.encode(i, buffer, offset);
              offset += varuint.encode.bytes;
            }
            function writeVarSlice(slice) {
              writeVarInt(slice.length);
              writeSlice(slice);
            }
            function writeVector(vector) {
              writeVarInt(vector.length);
              vector.forEach(writeVarSlice);
            }
            writeInt32(this.version);
            const hasWitnesses = __allowWitness && this.hasWitnesses();
            if (hasWitnesses) {
              writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER);
              writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG);
            }
            writeVarInt(this.ins.length);
            this.ins.forEach(function(txIn) {
              writeSlice(txIn.hash);
              writeUInt32(txIn.index);
              writeVarSlice(txIn.script);
              writeUInt32(txIn.sequence);
            });
            writeVarInt(this.outs.length);
            this.outs.forEach(function(txOut) {
              if (!txOut.valueBuffer) {
                writeUInt64(txOut.value);
              } else {
                writeSlice(txOut.valueBuffer);
              }
              writeVarSlice(txOut.script);
            });
            if (hasWitnesses) {
              this.ins.forEach(function(input) {
                writeVector(input.witness);
              });
            }
            writeUInt32(this.locktime);
            if (initialOffset !== undefined)
              return buffer.slice(initialOffset, offset);
            return buffer;
          };
          Transaction.prototype.toHex = function() {
            return this.toBuffer().toString('hex');
          };
          Transaction.prototype.setInputScript = function(index, scriptSig) {
            typeforce(types.tuple(types.Number, types.Buffer), arguments);
            this.ins[index].script = scriptSig;
          };
          Transaction.prototype.setWitness = function(index, witness) {
            typeforce(types.tuple(types.Number, [types.Buffer]), arguments);
            this.ins[index].witness = witness;
          };
          module.exports = Transaction;
        },
        {
          './bufferutils': 92,
          './crypto': 94,
          './script': 107,
          './types': 133,
          'bitcoin-ops': 88,
          'safe-buffer': 460,
          typeforce: 499,
          'varuint-bitcoin': 567
        }
      ],
      132: [
        function(require, module, exports) {
          const Buffer = require('safe-buffer').Buffer;
          const baddress = require('./address');
          const bcrypto = require('./crypto');
          const bscript = require('./script');
          const networks = require('./networks');
          const ops = require('bitcoin-ops');
          const payments = require('./payments');
          const typeforce = require('typeforce');
          const types = require('./types');
          const classify = require('./classify');
          const SCRIPT_TYPES = classify.types;
          const ECPair = require('./ecpair');
          const Transaction = require('./transaction');
          function expandInput(scriptSig, witnessStack, type, scriptPubKey) {
            if (scriptSig.length === 0 && witnessStack.length === 0) return {};
            if (!type) {
              let ssType = classify.input(scriptSig, true);
              let wsType = classify.witness(witnessStack, true);
              if (ssType === SCRIPT_TYPES.NONSTANDARD) ssType = undefined;
              if (wsType === SCRIPT_TYPES.NONSTANDARD) wsType = undefined;
              type = ssType || wsType;
            }
            switch (type) {
              case SCRIPT_TYPES.P2WPKH: {
                const {
                  output: output,
                  pubkey: pubkey,
                  signature: signature
                } = payments.p2wpkh({ witness: witnessStack });
                return {
                  prevOutScript: output,
                  prevOutType: SCRIPT_TYPES.P2WPKH,
                  pubkeys: [pubkey],
                  signatures: [signature]
                };
              }
              case SCRIPT_TYPES.P2PKH: {
                const {
                  output: output,
                  pubkey: pubkey,
                  signature: signature
                } = payments.p2pkh({ input: scriptSig });
                return {
                  prevOutScript: output,
                  prevOutType: SCRIPT_TYPES.P2PKH,
                  pubkeys: [pubkey],
                  signatures: [signature]
                };
              }
              case SCRIPT_TYPES.P2PK: {
                const { signature: signature } = payments.p2pk({
                  input: scriptSig
                });
                return {
                  prevOutType: SCRIPT_TYPES.P2PK,
                  pubkeys: [undefined],
                  signatures: [signature]
                };
              }
              case SCRIPT_TYPES.MULTISIG: {
                const {
                  pubkeys: pubkeys,
                  signatures: signatures
                } = payments.p2ms(
                  { input: scriptSig, output: scriptPubKey },
                  { allowIncomplete: true }
                );
                return {
                  prevOutType: SCRIPT_TYPES.MULTISIG,
                  pubkeys: pubkeys,
                  signatures: signatures
                };
              }
            }
            if (type === SCRIPT_TYPES.P2SH) {
              const { output: output, redeem: redeem } = payments.p2sh({
                input: scriptSig,
                witness: witnessStack
              });
              const outputType = classify.output(redeem.output);
              const expanded = expandInput(
                redeem.input,
                redeem.witness,
                outputType,
                redeem.output
              );
              if (!expanded.prevOutType) return {};
              return {
                prevOutScript: output,
                prevOutType: SCRIPT_TYPES.P2SH,
                redeemScript: redeem.output,
                redeemScriptType: expanded.prevOutType,
                witnessScript: expanded.witnessScript,
                witnessScriptType: expanded.witnessScriptType,
                pubkeys: expanded.pubkeys,
                signatures: expanded.signatures
              };
            }
            if (type === SCRIPT_TYPES.P2WSH) {
              const { output: output, redeem: redeem } = payments.p2wsh({
                input: scriptSig,
                witness: witnessStack
              });
              const outputType = classify.output(redeem.output);
              let expanded;
              if (outputType === SCRIPT_TYPES.P2WPKH) {
                expanded = expandInput(
                  redeem.input,
                  redeem.witness,
                  outputType
                );
              } else {
                expanded = expandInput(
                  bscript.compile(redeem.witness),
                  [],
                  outputType,
                  redeem.output
                );
              }
              if (!expanded.prevOutType) return {};
              return {
                prevOutScript: output,
                prevOutType: SCRIPT_TYPES.P2WSH,
                witnessScript: redeem.output,
                witnessScriptType: expanded.prevOutType,
                pubkeys: expanded.pubkeys,
                signatures: expanded.signatures
              };
            }
            return {
              prevOutType: SCRIPT_TYPES.NONSTANDARD,
              prevOutScript: scriptSig
            };
          }
          function fixMultisigOrder(input, transaction, vin) {
            if (
              input.redeemScriptType !== SCRIPT_TYPES.MULTISIG ||
              !input.redeemScript
            )
              return;
            if (input.pubkeys.length === input.signatures.length) return;
            const unmatched = input.signatures.concat();
            input.signatures = input.pubkeys.map(function(pubKey) {
              const keyPair = ECPair.fromPublicKey(pubKey);
              let match;
              unmatched.some(function(signature, i) {
                if (!signature) return false;
                const parsed = bscript.signature.decode(signature);
                const hash = transaction.hashForSignature(
                  vin,
                  input.redeemScript,
                  parsed.hashType
                );
                if (!keyPair.verify(hash, parsed.signature)) return false;
                unmatched[i] = undefined;
                match = signature;
                return true;
              });
              return match;
            });
          }
          function expandOutput(script, ourPubKey) {
            typeforce(types.Buffer, script);
            const type = classify.output(script);
            switch (type) {
              case SCRIPT_TYPES.P2PKH: {
                if (!ourPubKey) return { type: type };
                const pkh1 = payments.p2pkh({ output: script }).hash;
                const pkh2 = bcrypto.hash160(ourPubKey);
                if (!pkh1.equals(pkh2)) return { type: type };
                return {
                  type: type,
                  pubkeys: [ourPubKey],
                  signatures: [undefined]
                };
              }
              case SCRIPT_TYPES.P2WPKH: {
                if (!ourPubKey) return { type: type };
                const wpkh1 = payments.p2wpkh({ output: script }).hash;
                const wpkh2 = bcrypto.hash160(ourPubKey);
                if (!wpkh1.equals(wpkh2)) return { type: type };
                return {
                  type: type,
                  pubkeys: [ourPubKey],
                  signatures: [undefined]
                };
              }
              case SCRIPT_TYPES.P2PK: {
                const p2pk = payments.p2pk({ output: script });
                return {
                  type: type,
                  pubkeys: [p2pk.pubkey],
                  signatures: [undefined]
                };
              }
              case SCRIPT_TYPES.MULTISIG: {
                const p2ms = payments.p2ms({ output: script });
                return {
                  type: type,
                  pubkeys: p2ms.pubkeys,
                  signatures: p2ms.pubkeys.map(() => undefined)
                };
              }
            }
            return { type: type };
          }
          function prepareInput(
            input,
            ourPubKey,
            redeemScript,
            witnessValue,
            witnessScript
          ) {
            if (redeemScript && witnessScript) {
              const p2wsh = payments.p2wsh({
                redeem: { output: witnessScript }
              });
              const p2wshAlt = payments.p2wsh({ output: redeemScript });
              const p2sh = payments.p2sh({ redeem: { output: redeemScript } });
              const p2shAlt = payments.p2sh({ redeem: p2wsh });
              if (!p2wsh.hash.equals(p2wshAlt.hash))
                throw new Error(
                  'Witness script inconsistent with prevOutScript'
                );
              if (!p2sh.hash.equals(p2shAlt.hash))
                throw new Error(
                  'Redeem script inconsistent with prevOutScript'
                );
              const expanded = expandOutput(p2wsh.redeem.output, ourPubKey);
              if (!expanded.pubkeys)
                throw new Error(
                  expanded.type +
                    ' not supported as witnessScript (' +
                    bscript.toASM(witnessScript) +
                    ')'
                );
              if (input.signatures && input.signatures.some(x => x)) {
                expanded.signatures = input.signatures;
              }
              let signScript = witnessScript;
              if (expanded.type === SCRIPT_TYPES.P2WPKH)
                throw new Error('P2SH(P2WSH(P2WPKH)) is a consensus failure');
              return {
                redeemScript: redeemScript,
                redeemScriptType: SCRIPT_TYPES.P2WSH,
                witnessScript: witnessScript,
                witnessScriptType: expanded.type,
                prevOutType: SCRIPT_TYPES.P2SH,
                prevOutScript: p2sh.output,
                hasWitness: true,
                signScript: signScript,
                signType: expanded.type,
                pubkeys: expanded.pubkeys,
                signatures: expanded.signatures
              };
            }
            if (redeemScript) {
              const p2sh = payments.p2sh({ redeem: { output: redeemScript } });
              if (input.prevOutScript) {
                let p2shAlt;
                try {
                  p2shAlt = payments.p2sh({ output: input.prevOutScript });
                } catch (e) {
                  throw new Error('PrevOutScript must be P2SH');
                }
                if (!p2sh.hash.equals(p2shAlt.hash))
                  throw new Error(
                    'Redeem script inconsistent with prevOutScript'
                  );
              }
              const expanded = expandOutput(p2sh.redeem.output, ourPubKey);
              if (!expanded.pubkeys)
                throw new Error(
                  expanded.type +
                    ' not supported as redeemScript (' +
                    bscript.toASM(redeemScript) +
                    ')'
                );
              if (input.signatures && input.signatures.some(x => x)) {
                expanded.signatures = input.signatures;
              }
              let signScript = redeemScript;
              if (expanded.type === SCRIPT_TYPES.P2WPKH) {
                signScript = payments.p2pkh({ pubkey: expanded.pubkeys[0] })
                  .output;
              }
              return {
                redeemScript: redeemScript,
                redeemScriptType: expanded.type,
                prevOutType: SCRIPT_TYPES.P2SH,
                prevOutScript: p2sh.output,
                hasWitness: expanded.type === SCRIPT_TYPES.P2WPKH,
                signScript: signScript,
                signType: expanded.type,
                pubkeys: expanded.pubkeys,
                signatures: expanded.signatures
              };
            }
            if (witnessScript) {
              const p2wsh = payments.p2wsh({
                redeem: { output: witnessScript }
              });
              if (input.prevOutScript) {
                const p2wshAlt = payments.p2wsh({
                  output: input.prevOutScript
                });
                if (!p2wsh.hash.equals(p2wshAlt.hash))
                  throw new Error(
                    'Witness script inconsistent with prevOutScript'
                  );
              }
              const expanded = expandOutput(p2wsh.redeem.output, ourPubKey);
              if (!expanded.pubkeys)
                throw new Error(
                  expanded.type +
                    ' not supported as witnessScript (' +
                    bscript.toASM(witnessScript) +
                    ')'
                );
              if (input.signatures && input.signatures.some(x => x)) {
                expanded.signatures = input.signatures;
              }
              let signScript = witnessScript;
              if (expanded.type === SCRIPT_TYPES.P2WPKH)
                throw new Error('P2WSH(P2WPKH) is a consensus failure');
              return {
                witnessScript: witnessScript,
                witnessScriptType: expanded.type,
                prevOutType: SCRIPT_TYPES.P2WSH,
                prevOutScript: p2wsh.output,
                hasWitness: true,
                signScript: signScript,
                signType: expanded.type,
                pubkeys: expanded.pubkeys,
                signatures: expanded.signatures
              };
            }
            if (input.prevOutType && input.prevOutScript) {
              if (input.prevOutType === SCRIPT_TYPES.P2SH)
                throw new Error(
                  'PrevOutScript is ' +
                    input.prevOutType +
                    ', requires redeemScript'
                );
              if (input.prevOutType === SCRIPT_TYPES.P2WSH)
                throw new Error(
                  'PrevOutScript is ' +
                    input.prevOutType +
                    ', requires witnessScript'
                );
              if (!input.prevOutScript)
                throw new Error('PrevOutScript is missing');
              const expanded = expandOutput(input.prevOutScript, ourPubKey);
              if (!expanded.pubkeys)
                throw new Error(
                  expanded.type +
                    ' not supported (' +
                    bscript.toASM(input.prevOutScript) +
                    ')'
                );
              if (input.signatures && input.signatures.some(x => x)) {
                expanded.signatures = input.signatures;
              }
              let signScript = input.prevOutScript;
              if (expanded.type === SCRIPT_TYPES.P2WPKH) {
                signScript = payments.p2pkh({ pubkey: expanded.pubkeys[0] })
                  .output;
              }
              return {
                prevOutType: expanded.type,
                prevOutScript: input.prevOutScript,
                hasWitness: expanded.type === SCRIPT_TYPES.P2WPKH,
                signScript: signScript,
                signType: expanded.type,
                pubkeys: expanded.pubkeys,
                signatures: expanded.signatures
              };
            }
            const prevOutScript = payments.p2pkh({ pubkey: ourPubKey }).output;
            return {
              prevOutType: SCRIPT_TYPES.P2PKH,
              prevOutScript: prevOutScript,
              hasWitness: false,
              signScript: prevOutScript,
              signType: SCRIPT_TYPES.P2PKH,
              pubkeys: [ourPubKey],
              signatures: [undefined]
            };
          }
          function build(type, input, allowIncomplete) {
            const pubkeys = input.pubkeys || [];
            let signatures = input.signatures || [];
            switch (type) {
              case SCRIPT_TYPES.P2PKH: {
                if (pubkeys.length === 0) break;
                if (signatures.length === 0) break;
                return payments.p2pkh({
                  pubkey: pubkeys[0],
                  signature: signatures[0]
                });
              }
              case SCRIPT_TYPES.P2WPKH: {
                if (pubkeys.length === 0) break;
                if (signatures.length === 0) break;
                return payments.p2wpkh({
                  pubkey: pubkeys[0],
                  signature: signatures[0]
                });
              }
              case SCRIPT_TYPES.P2PK: {
                if (pubkeys.length === 0) break;
                if (signatures.length === 0) break;
                return payments.p2pk({ signature: signatures[0] });
              }
              case SCRIPT_TYPES.MULTISIG: {
                if (allowIncomplete) {
                  signatures = signatures.map(x => x || ops.OP_0);
                } else {
                  signatures = signatures.filter(x => x);
                }
                return payments.p2ms(
                  { signatures: signatures },
                  { allowIncomplete: allowIncomplete }
                );
              }
              case SCRIPT_TYPES.P2SH: {
                const redeem = build(
                  input.redeemScriptType,
                  input,
                  allowIncomplete
                );
                if (!redeem) return;
                return payments.p2sh({
                  redeem: {
                    output: redeem.output || input.redeemScript,
                    input: redeem.input,
                    witness: redeem.witness
                  }
                });
              }
              case SCRIPT_TYPES.P2WSH: {
                const redeem = build(
                  input.witnessScriptType,
                  input,
                  allowIncomplete
                );
                if (!redeem) return;
                return payments.p2wsh({
                  redeem: {
                    output: input.witnessScript,
                    input: redeem.input,
                    witness: redeem.witness
                  }
                });
              }
            }
          }
          function TransactionBuilder(network, maximumFeeRate) {
            this.__prevTxSet = {};
            this.network = network || networks.bitcoin;
            this.maximumFeeRate = maximumFeeRate || 2500;
            this.__inputs = [];
            this.__tx = new Transaction();
            this.__tx.version = 2;
          }
          TransactionBuilder.prototype.setLockTime = function(locktime) {
            typeforce(types.UInt32, locktime);
            if (
              this.__inputs.some(function(input) {
                if (!input.signatures) return false;
                return input.signatures.some(function(s) {
                  return s;
                });
              })
            ) {
              throw new Error('No, this would invalidate signatures');
            }
            this.__tx.locktime = locktime;
          };
          TransactionBuilder.prototype.setVersion = function(version) {
            typeforce(types.UInt32, version);
            this.__tx.version = version;
          };
          TransactionBuilder.fromTransaction = function(transaction, network) {
            const txb = new TransactionBuilder(network);
            txb.setVersion(transaction.version);
            txb.setLockTime(transaction.locktime);
            transaction.outs.forEach(function(txOut) {
              txb.addOutput(txOut.script, txOut.value);
            });
            transaction.ins.forEach(function(txIn) {
              txb.__addInputUnsafe(txIn.hash, txIn.index, {
                sequence: txIn.sequence,
                script: txIn.script,
                witness: txIn.witness
              });
            });
            txb.__inputs.forEach(function(input, i) {
              fixMultisigOrder(input, transaction, i);
            });
            return txb;
          };
          TransactionBuilder.prototype.addInput = function(
            txHash,
            vout,
            sequence,
            prevOutScript
          ) {
            if (!this.__canModifyInputs()) {
              throw new Error('No, this would invalidate signatures');
            }
            let value;
            if (typeof txHash === 'string') {
              txHash = Buffer.from(txHash, 'hex').reverse();
            } else if (txHash instanceof Transaction) {
              const txOut = txHash.outs[vout];
              prevOutScript = txOut.script;
              value = txOut.value;
              txHash = txHash.getHash();
            }
            return this.__addInputUnsafe(txHash, vout, {
              sequence: sequence,
              prevOutScript: prevOutScript,
              value: value
            });
          };
          TransactionBuilder.prototype.__addInputUnsafe = function(
            txHash,
            vout,
            options
          ) {
            if (Transaction.isCoinbaseHash(txHash)) {
              throw new Error('coinbase inputs not supported');
            }
            const prevTxOut = txHash.toString('hex') + ':' + vout;
            if (this.__prevTxSet[prevTxOut] !== undefined)
              throw new Error('Duplicate TxOut: ' + prevTxOut);
            let input = {};
            if (options.script !== undefined) {
              input = expandInput(options.script, options.witness || []);
            }
            if (options.value !== undefined) {
              input.value = options.value;
            }
            if (!input.prevOutScript && options.prevOutScript) {
              let prevOutType;
              if (!input.pubkeys && !input.signatures) {
                const expanded = expandOutput(options.prevOutScript);
                if (expanded.pubkeys) {
                  input.pubkeys = expanded.pubkeys;
                  input.signatures = expanded.signatures;
                }
                prevOutType = expanded.type;
              }
              input.prevOutScript = options.prevOutScript;
              input.prevOutType =
                prevOutType || classify.output(options.prevOutScript);
            }
            const vin = this.__tx.addInput(
              txHash,
              vout,
              options.sequence,
              options.scriptSig
            );
            this.__inputs[vin] = input;
            this.__prevTxSet[prevTxOut] = true;
            return vin;
          };
          TransactionBuilder.prototype.addOutput = function(
            scriptPubKey,
            value
          ) {
            if (!this.__canModifyOutputs()) {
              throw new Error('No, this would invalidate signatures');
            }
            if (typeof scriptPubKey === 'string') {
              scriptPubKey = baddress.toOutputScript(
                scriptPubKey,
                this.network
              );
            }
            return this.__tx.addOutput(scriptPubKey, value);
          };
          TransactionBuilder.prototype.build = function() {
            return this.__build(false);
          };
          TransactionBuilder.prototype.buildIncomplete = function() {
            return this.__build(true);
          };
          TransactionBuilder.prototype.__build = function(allowIncomplete) {
            if (!allowIncomplete) {
              if (!this.__tx.ins.length)
                throw new Error('Transaction has no inputs');
              if (!this.__tx.outs.length)
                throw new Error('Transaction has no outputs');
            }
            const tx = this.__tx.clone();
            this.__inputs.forEach(function(input, i) {
              if (!input.prevOutType && !allowIncomplete)
                throw new Error('Transaction is not complete');
              const result = build(input.prevOutType, input, allowIncomplete);
              if (!result) {
                if (
                  !allowIncomplete &&
                  input.prevOutType === SCRIPT_TYPES.NONSTANDARD
                )
                  throw new Error('Unknown input type');
                if (!allowIncomplete) throw new Error('Not enough information');
                return;
              }
              tx.setInputScript(i, result.input);
              tx.setWitness(i, result.witness);
            });
            if (!allowIncomplete) {
              if (this.__overMaximumFees(tx.virtualSize())) {
                throw new Error('Transaction has absurd fees');
              }
            }
            return tx;
          };
          function canSign(input) {
            return (
              input.signScript !== undefined &&
              input.signType !== undefined &&
              input.pubkeys !== undefined &&
              input.signatures !== undefined &&
              input.signatures.length === input.pubkeys.length &&
              input.pubkeys.length > 0 &&
              (input.hasWitness === false || input.value !== undefined)
            );
          }
          TransactionBuilder.prototype.sign = function(
            vin,
            keyPair,
            redeemScript,
            hashType,
            witnessValue,
            witnessScript
          ) {
            if (keyPair.network && keyPair.network !== this.network)
              throw new TypeError('Inconsistent network');
            if (!this.__inputs[vin])
              throw new Error('No input at index: ' + vin);
            hashType = hashType || Transaction.SIGHASH_ALL;
            const input = this.__inputs[vin];
            if (
              input.redeemScript !== undefined &&
              redeemScript &&
              !input.redeemScript.equals(redeemScript)
            ) {
              throw new Error('Inconsistent redeemScript');
            }
            const ourPubKey = keyPair.publicKey || keyPair.getPublicKey();
            if (!canSign(input)) {
              if (witnessValue !== undefined) {
                if (input.value !== undefined && input.value !== witnessValue)
                  throw new Error("Input didn't match witnessValue");
                typeforce(types.Satoshi, witnessValue);
                input.value = witnessValue;
              }
              if (!canSign(input)) {
                const prepared = prepareInput(
                  input,
                  ourPubKey,
                  redeemScript,
                  witnessValue,
                  witnessScript
                );
                Object.assign(input, prepared);
              }
              if (!canSign(input))
                throw Error(input.prevOutType + ' not supported');
            }
            let signatureHash;
            if (input.hasWitness) {
              signatureHash = this.__tx.hashForWitnessV0(
                vin,
                input.signScript,
                input.value,
                hashType
              );
            } else {
              signatureHash = this.__tx.hashForSignature(
                vin,
                input.signScript,
                hashType
              );
            }
            const signed = input.pubkeys.some(function(pubKey, i) {
              if (!ourPubKey.equals(pubKey)) return false;
              if (input.signatures[i])
                throw new Error('Signature already exists');
              if (ourPubKey.length !== 33 && input.hasWitness) {
                throw new Error(
                  'BIP143 rejects uncompressed public keys in P2WPKH or P2WSH'
                );
              }
              const signature = keyPair.sign(signatureHash);
              input.signatures[i] = bscript.signature.encode(
                signature,
                hashType
              );
              return true;
            });
            if (!signed) throw new Error('Key pair cannot sign for this input');
          };
          function signatureHashType(buffer) {
            return buffer.readUInt8(buffer.length - 1);
          }
          TransactionBuilder.prototype.__canModifyInputs = function() {
            return this.__inputs.every(function(input) {
              if (input.signatures === undefined) return true;
              return input.signatures.every(function(signature) {
                if (!signature) return true;
                const hashType = signatureHashType(signature);
                return hashType & Transaction.SIGHASH_ANYONECANPAY;
              });
            });
          };
          TransactionBuilder.prototype.__canModifyOutputs = function() {
            const nInputs = this.__tx.ins.length;
            const nOutputs = this.__tx.outs.length;
            return this.__inputs.every(function(input) {
              if (input.signatures === undefined) return true;
              return input.signatures.every(function(signature) {
                if (!signature) return true;
                const hashType = signatureHashType(signature);
                const hashTypeMod = hashType & 31;
                if (hashTypeMod === Transaction.SIGHASH_NONE) return true;
                if (hashTypeMod === Transaction.SIGHASH_SINGLE) {
                  return nInputs <= nOutputs;
                }
              });
            });
          };
          TransactionBuilder.prototype.__overMaximumFees = function(bytes) {
            const incoming = this.__inputs.reduce(function(a, x) {
              return a + (x.value >>> 0);
            }, 0);
            const outgoing = this.__tx.outs.reduce(function(a, x) {
              return a + x.value;
            }, 0);
            const fee = incoming - outgoing;
            const feeRate = fee / bytes;
            return feeRate > this.maximumFeeRate;
          };
          module.exports = TransactionBuilder;
        },
        {
          './address': 90,
          './classify': 93,
          './crypto': 94,
          './ecpair': 95,
          './networks': 97,
          './payments': 99,
          './script': 107,
          './transaction': 131,
          './types': 133,
          'bitcoin-ops': 88,
          'safe-buffer': 460,
          typeforce: 499
        }
      ],
      133: [
        function(require, module, exports) {
          const typeforce = require('typeforce');
          const UINT31_MAX = Math.pow(2, 31) - 1;
          function UInt31(value) {
            return typeforce.UInt32(value) && value <= UINT31_MAX;
          }
          function BIP32Path(value) {
            return (
              typeforce.String(value) && value.match(/^(m\/)?(\d+'?\/)*\d+'?$/)
            );
          }
          BIP32Path.toJSON = function() {
            return 'BIP32 derivation path';
          };
          const SATOSHI_MAX = 21 * 1e14;
          function Satoshi(value) {
            return typeforce.UInt53(value) && value <= SATOSHI_MAX;
          }
          const ECPoint = typeforce.quacksLike('Point');
          const Network = typeforce.compile({
            messagePrefix: typeforce.oneOf(typeforce.Buffer, typeforce.String),
            bip32: { public: typeforce.UInt32, private: typeforce.UInt32 },
            pubKeyHash: typeforce.UInt8,
            scriptHash: typeforce.UInt8,
            wif: typeforce.UInt8
          });
          const types = {
            BIP32Path: BIP32Path,
            Buffer256bit: typeforce.BufferN(32),
            ECPoint: ECPoint,
            Hash160bit: typeforce.BufferN(20),
            Hash256bit: typeforce.BufferN(32),
            Network: Network,
            Satoshi: Satoshi,
            UInt31: UInt31
          };
          for (var typeName in typeforce) {
            types[typeName] = typeforce[typeName];
          }
          module.exports = types;
        },
        { typeforce: 499 }
      ],
      134: [
        function(require, module, exports) {
          (function(module, exports) {
            'use strict';
            function assert(val, msg) {
              if (!val) throw new Error(msg || 'Assertion failed');
            }
            function inherits(ctor, superCtor) {
              ctor.super_ = superCtor;
              var TempCtor = function() {};
              TempCtor.prototype = superCtor.prototype;
              ctor.prototype = new TempCtor();
              ctor.prototype.constructor = ctor;
            }
            function BN(number, base, endian) {
              if (BN.isBN(number)) {
                return number;
              }
              this.negative = 0;
              this.words = null;
              this.length = 0;
              this.red = null;
              if (number !== null) {
                if (base === 'le' || base === 'be') {
                  endian = base;
                  base = 10;
                }
                this._init(number || 0, base || 10, endian || 'be');
              }
            }
            if (typeof module === 'object') {
              module.exports = BN;
            } else {
              exports.BN = BN;
            }
            BN.BN = BN;
            BN.wordSize = 26;
            var Buffer;
            try {
              Buffer = require('buffer').Buffer;
            } catch (e) {}
            BN.isBN = function isBN(num) {
              if (num instanceof BN) {
                return true;
              }
              return (
                num !== null &&
                typeof num === 'object' &&
                num.constructor.wordSize === BN.wordSize &&
                Array.isArray(num.words)
              );
            };
            BN.max = function max(left, right) {
              if (left.cmp(right) > 0) return left;
              return right;
            };
            BN.min = function min(left, right) {
              if (left.cmp(right) < 0) return left;
              return right;
            };
            BN.prototype._init = function init(number, base, endian) {
              if (typeof number === 'number') {
                return this._initNumber(number, base, endian);
              }
              if (typeof number === 'object') {
                return this._initArray(number, base, endian);
              }
              if (base === 'hex') {
                base = 16;
              }
              assert(base === (base | 0) && base >= 2 && base <= 36);
              number = number.toString().replace(/\s+/g, '');
              var start = 0;
              if (number[0] === '-') {
                start++;
              }
              if (base === 16) {
                this._parseHex(number, start);
              } else {
                this._parseBase(number, base, start);
              }
              if (number[0] === '-') {
                this.negative = 1;
              }
              this.strip();
              if (endian !== 'le') return;
              this._initArray(this.toArray(), base, endian);
            };
            BN.prototype._initNumber = function _initNumber(
              number,
              base,
              endian
            ) {
              if (number < 0) {
                this.negative = 1;
                number = -number;
              }
              if (number < 67108864) {
                this.words = [number & 67108863];
                this.length = 1;
              } else if (number < 4503599627370496) {
                this.words = [
                  number & 67108863,
                  (number / 67108864) & 67108863
                ];
                this.length = 2;
              } else {
                assert(number < 9007199254740992);
                this.words = [
                  number & 67108863,
                  (number / 67108864) & 67108863,
                  1
                ];
                this.length = 3;
              }
              if (endian !== 'le') return;
              this._initArray(this.toArray(), base, endian);
            };
            BN.prototype._initArray = function _initArray(
              number,
              base,
              endian
            ) {
              assert(typeof number.length === 'number');
              if (number.length <= 0) {
                this.words = [0];
                this.length = 1;
                return this;
              }
              this.length = Math.ceil(number.length / 3);
              this.words = new Array(this.length);
              for (var i = 0; i < this.length; i++) {
                this.words[i] = 0;
              }
              var j, w;
              var off = 0;
              if (endian === 'be') {
                for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
                  w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
                  this.words[j] |= (w << off) & 67108863;
                  this.words[j + 1] = (w >>> (26 - off)) & 67108863;
                  off += 24;
                  if (off >= 26) {
                    off -= 26;
                    j++;
                  }
                }
              } else if (endian === 'le') {
                for (i = 0, j = 0; i < number.length; i += 3) {
                  w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
                  this.words[j] |= (w << off) & 67108863;
                  this.words[j + 1] = (w >>> (26 - off)) & 67108863;
                  off += 24;
                  if (off >= 26) {
                    off -= 26;
                    j++;
                  }
                }
              }
              return this.strip();
            };
            function parseHex(str, start, end) {
              var r = 0;
              var len = Math.min(str.length, end);
              for (var i = start; i < len; i++) {
                var c = str.charCodeAt(i) - 48;
                r <<= 4;
                if (c >= 49 && c <= 54) {
                  r |= c - 49 + 10;
                } else if (c >= 17 && c <= 22) {
                  r |= c - 17 + 10;
                } else {
                  r |= c & 15;
                }
              }
              return r;
            }
            BN.prototype._parseHex = function _parseHex(number, start) {
              this.length = Math.ceil((number.length - start) / 6);
              this.words = new Array(this.length);
              for (var i = 0; i < this.length; i++) {
                this.words[i] = 0;
              }
              var j, w;
              var off = 0;
              for (i = number.length - 6, j = 0; i >= start; i -= 6) {
                w = parseHex(number, i, i + 6);
                this.words[j] |= (w << off) & 67108863;
                this.words[j + 1] |= (w >>> (26 - off)) & 4194303;
                off += 24;
                if (off >= 26) {
                  off -= 26;
                  j++;
                }
              }
              if (i + 6 !== start) {
                w = parseHex(number, start, i + 6);
                this.words[j] |= (w << off) & 67108863;
                this.words[j + 1] |= (w >>> (26 - off)) & 4194303;
              }
              this.strip();
            };
            function parseBase(str, start, end, mul) {
              var r = 0;
              var len = Math.min(str.length, end);
              for (var i = start; i < len; i++) {
                var c = str.charCodeAt(i) - 48;
                r *= mul;
                if (c >= 49) {
                  r += c - 49 + 10;
                } else if (c >= 17) {
                  r += c - 17 + 10;
                } else {
                  r += c;
                }
              }
              return r;
            }
            BN.prototype._parseBase = function _parseBase(number, base, start) {
              this.words = [0];
              this.length = 1;
              for (
                var limbLen = 0, limbPow = 1;
                limbPow <= 67108863;
                limbPow *= base
              ) {
                limbLen++;
              }
              limbLen--;
              limbPow = (limbPow / base) | 0;
              var total = number.length - start;
              var mod = total % limbLen;
              var end = Math.min(total, total - mod) + start;
              var word = 0;
              for (var i = start; i < end; i += limbLen) {
                word = parseBase(number, i, i + limbLen, base);
                this.imuln(limbPow);
                if (this.words[0] + word < 67108864) {
                  this.words[0] += word;
                } else {
                  this._iaddn(word);
                }
              }
              if (mod !== 0) {
                var pow = 1;
                word = parseBase(number, i, number.length, base);
                for (i = 0; i < mod; i++) {
                  pow *= base;
                }
                this.imuln(pow);
                if (this.words[0] + word < 67108864) {
                  this.words[0] += word;
                } else {
                  this._iaddn(word);
                }
              }
            };
            BN.prototype.copy = function copy(dest) {
              dest.words = new Array(this.length);
              for (var i = 0; i < this.length; i++) {
                dest.words[i] = this.words[i];
              }
              dest.length = this.length;
              dest.negative = this.negative;
              dest.red = this.red;
            };
            BN.prototype.clone = function clone() {
              var r = new BN(null);
              this.copy(r);
              return r;
            };
            BN.prototype._expand = function _expand(size) {
              while (this.length < size) {
                this.words[this.length++] = 0;
              }
              return this;
            };
            BN.prototype.strip = function strip() {
              while (this.length > 1 && this.words[this.length - 1] === 0) {
                this.length--;
              }
              return this._normSign();
            };
            BN.prototype._normSign = function _normSign() {
              if (this.length === 1 && this.words[0] === 0) {
                this.negative = 0;
              }
              return this;
            };
            BN.prototype.inspect = function inspect() {
              return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
            };
            var zeros = [
              '',
              '0',
              '00',
              '000',
              '0000',
              '00000',
              '000000',
              '0000000',
              '00000000',
              '000000000',
              '0000000000',
              '00000000000',
              '000000000000',
              '0000000000000',
              '00000000000000',
              '000000000000000',
              '0000000000000000',
              '00000000000000000',
              '000000000000000000',
              '0000000000000000000',
              '00000000000000000000',
              '000000000000000000000',
              '0000000000000000000000',
              '00000000000000000000000',
              '000000000000000000000000',
              '0000000000000000000000000'
            ];
            var groupSizes = [
              0,
              0,
              25,
              16,
              12,
              11,
              10,
              9,
              8,
              8,
              7,
              7,
              7,
              7,
              6,
              6,
              6,
              6,
              6,
              6,
              6,
              5,
              5,
              5,
              5,
              5,
              5,
              5,
              5,
              5,
              5,
              5,
              5,
              5,
              5,
              5,
              5
            ];
            var groupBases = [
              0,
              0,
              33554432,
              43046721,
              16777216,
              48828125,
              60466176,
              40353607,
              16777216,
              43046721,
              1e7,
              19487171,
              35831808,
              62748517,
              7529536,
              11390625,
              16777216,
              24137569,
              34012224,
              47045881,
              64e6,
              4084101,
              5153632,
              6436343,
              7962624,
              9765625,
              11881376,
              14348907,
              17210368,
              20511149,
              243e5,
              28629151,
              33554432,
              39135393,
              45435424,
              52521875,
              60466176
            ];
            BN.prototype.toString = function toString(base, padding) {
              base = base || 10;
              padding = padding | 0 || 1;
              var out;
              if (base === 16 || base === 'hex') {
                out = '';
                var off = 0;
                var carry = 0;
                for (var i = 0; i < this.length; i++) {
                  var w = this.words[i];
                  var word = (((w << off) | carry) & 16777215).toString(16);
                  carry = (w >>> (24 - off)) & 16777215;
                  if (carry !== 0 || i !== this.length - 1) {
                    out = zeros[6 - word.length] + word + out;
                  } else {
                    out = word + out;
                  }
                  off += 2;
                  if (off >= 26) {
                    off -= 26;
                    i--;
                  }
                }
                if (carry !== 0) {
                  out = carry.toString(16) + out;
                }
                while (out.length % padding !== 0) {
                  out = '0' + out;
                }
                if (this.negative !== 0) {
                  out = '-' + out;
                }
                return out;
              }
              if (base === (base | 0) && base >= 2 && base <= 36) {
                var groupSize = groupSizes[base];
                var groupBase = groupBases[base];
                out = '';
                var c = this.clone();
                c.negative = 0;
                while (!c.isZero()) {
                  var r = c.modn(groupBase).toString(base);
                  c = c.idivn(groupBase);
                  if (!c.isZero()) {
                    out = zeros[groupSize - r.length] + r + out;
                  } else {
                    out = r + out;
                  }
                }
                if (this.isZero()) {
                  out = '0' + out;
                }
                while (out.length % padding !== 0) {
                  out = '0' + out;
                }
                if (this.negative !== 0) {
                  out = '-' + out;
                }
                return out;
              }
              assert(false, 'Base should be between 2 and 36');
            };
            BN.prototype.toNumber = function toNumber() {
              var ret = this.words[0];
              if (this.length === 2) {
                ret += this.words[1] * 67108864;
              } else if (this.length === 3 && this.words[2] === 1) {
                ret += 4503599627370496 + this.words[1] * 67108864;
              } else if (this.length > 2) {
                assert(false, 'Number can only safely store up to 53 bits');
              }
              return this.negative !== 0 ? -ret : ret;
            };
            BN.prototype.toJSON = function toJSON() {
              return this.toString(16);
            };
            BN.prototype.toBuffer = function toBuffer(endian, length) {
              assert(typeof Buffer !== 'undefined');
              return this.toArrayLike(Buffer, endian, length);
            };
            BN.prototype.toArray = function toArray(endian, length) {
              return this.toArrayLike(Array, endian, length);
            };
            BN.prototype.toArrayLike = function toArrayLike(
              ArrayType,
              endian,
              length
            ) {
              var byteLength = this.byteLength();
              var reqLength = length || Math.max(1, byteLength);
              assert(
                byteLength <= reqLength,
                'byte array longer than desired length'
              );
              assert(reqLength > 0, 'Requested array length <= 0');
              this.strip();
              var littleEndian = endian === 'le';
              var res = new ArrayType(reqLength);
              var b, i;
              var q = this.clone();
              if (!littleEndian) {
                for (i = 0; i < reqLength - byteLength; i++) {
                  res[i] = 0;
                }
                for (i = 0; !q.isZero(); i++) {
                  b = q.andln(255);
                  q.iushrn(8);
                  res[reqLength - i - 1] = b;
                }
              } else {
                for (i = 0; !q.isZero(); i++) {
                  b = q.andln(255);
                  q.iushrn(8);
                  res[i] = b;
                }
                for (; i < reqLength; i++) {
                  res[i] = 0;
                }
              }
              return res;
            };
            if (Math.clz32) {
              BN.prototype._countBits = function _countBits(w) {
                return 32 - Math.clz32(w);
              };
            } else {
              BN.prototype._countBits = function _countBits(w) {
                var t = w;
                var r = 0;
                if (t >= 4096) {
                  r += 13;
                  t >>>= 13;
                }
                if (t >= 64) {
                  r += 7;
                  t >>>= 7;
                }
                if (t >= 8) {
                  r += 4;
                  t >>>= 4;
                }
                if (t >= 2) {
                  r += 2;
                  t >>>= 2;
                }
                return r + t;
              };
            }
            BN.prototype._zeroBits = function _zeroBits(w) {
              if (w === 0) return 26;
              var t = w;
              var r = 0;
              if ((t & 8191) === 0) {
                r += 13;
                t >>>= 13;
              }
              if ((t & 127) === 0) {
                r += 7;
                t >>>= 7;
              }
              if ((t & 15) === 0) {
                r += 4;
                t >>>= 4;
              }
              if ((t & 3) === 0) {
                r += 2;
                t >>>= 2;
              }
              if ((t & 1) === 0) {
                r++;
              }
              return r;
            };
            BN.prototype.bitLength = function bitLength() {
              var w = this.words[this.length - 1];
              var hi = this._countBits(w);
              return (this.length - 1) * 26 + hi;
            };
            function toBitArray(num) {
              var w = new Array(num.bitLength());
              for (var bit = 0; bit < w.length; bit++) {
                var off = (bit / 26) | 0;
                var wbit = bit % 26;
                w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
              }
              return w;
            }
            BN.prototype.zeroBits = function zeroBits() {
              if (this.isZero()) return 0;
              var r = 0;
              for (var i = 0; i < this.length; i++) {
                var b = this._zeroBits(this.words[i]);
                r += b;
                if (b !== 26) break;
              }
              return r;
            };
            BN.prototype.byteLength = function byteLength() {
              return Math.ceil(this.bitLength() / 8);
            };
            BN.prototype.toTwos = function toTwos(width) {
              if (this.negative !== 0) {
                return this.abs()
                  .inotn(width)
                  .iaddn(1);
              }
              return this.clone();
            };
            BN.prototype.fromTwos = function fromTwos(width) {
              if (this.testn(width - 1)) {
                return this.notn(width)
                  .iaddn(1)
                  .ineg();
              }
              return this.clone();
            };
            BN.prototype.isNeg = function isNeg() {
              return this.negative !== 0;
            };
            BN.prototype.neg = function neg() {
              return this.clone().ineg();
            };
            BN.prototype.ineg = function ineg() {
              if (!this.isZero()) {
                this.negative ^= 1;
              }
              return this;
            };
            BN.prototype.iuor = function iuor(num) {
              while (this.length < num.length) {
                this.words[this.length++] = 0;
              }
              for (var i = 0; i < num.length; i++) {
                this.words[i] = this.words[i] | num.words[i];
              }
              return this.strip();
            };
            BN.prototype.ior = function ior(num) {
              assert((this.negative | num.negative) === 0);
              return this.iuor(num);
            };
            BN.prototype.or = function or(num) {
              if (this.length > num.length) return this.clone().ior(num);
              return num.clone().ior(this);
            };
            BN.prototype.uor = function uor(num) {
              if (this.length > num.length) return this.clone().iuor(num);
              return num.clone().iuor(this);
            };
            BN.prototype.iuand = function iuand(num) {
              var b;
              if (this.length > num.length) {
                b = num;
              } else {
                b = this;
              }
              for (var i = 0; i < b.length; i++) {
                this.words[i] = this.words[i] & num.words[i];
              }
              this.length = b.length;
              return this.strip();
            };
            BN.prototype.iand = function iand(num) {
              assert((this.negative | num.negative) === 0);
              return this.iuand(num);
            };
            BN.prototype.and = function and(num) {
              if (this.length > num.length) return this.clone().iand(num);
              return num.clone().iand(this);
            };
            BN.prototype.uand = function uand(num) {
              if (this.length > num.length) return this.clone().iuand(num);
              return num.clone().iuand(this);
            };
            BN.prototype.iuxor = function iuxor(num) {
              var a;
              var b;
              if (this.length > num.length) {
                a = this;
                b = num;
              } else {
                a = num;
                b = this;
              }
              for (var i = 0; i < b.length; i++) {
                this.words[i] = a.words[i] ^ b.words[i];
              }
              if (this !== a) {
                for (; i < a.length; i++) {
                  this.words[i] = a.words[i];
                }
              }
              this.length = a.length;
              return this.strip();
            };
            BN.prototype.ixor = function ixor(num) {
              assert((this.negative | num.negative) === 0);
              return this.iuxor(num);
            };
            BN.prototype.xor = function xor(num) {
              if (this.length > num.length) return this.clone().ixor(num);
              return num.clone().ixor(this);
            };
            BN.prototype.uxor = function uxor(num) {
              if (this.length > num.length) return this.clone().iuxor(num);
              return num.clone().iuxor(this);
            };
            BN.prototype.inotn = function inotn(width) {
              assert(typeof width === 'number' && width >= 0);
              var bytesNeeded = Math.ceil(width / 26) | 0;
              var bitsLeft = width % 26;
              this._expand(bytesNeeded);
              if (bitsLeft > 0) {
                bytesNeeded--;
              }
              for (var i = 0; i < bytesNeeded; i++) {
                this.words[i] = ~this.words[i] & 67108863;
              }
              if (bitsLeft > 0) {
                this.words[i] = ~this.words[i] & (67108863 >> (26 - bitsLeft));
              }
              return this.strip();
            };
            BN.prototype.notn = function notn(width) {
              return this.clone().inotn(width);
            };
            BN.prototype.setn = function setn(bit, val) {
              assert(typeof bit === 'number' && bit >= 0);
              var off = (bit / 26) | 0;
              var wbit = bit % 26;
              this._expand(off + 1);
              if (val) {
                this.words[off] = this.words[off] | (1 << wbit);
              } else {
                this.words[off] = this.words[off] & ~(1 << wbit);
              }
              return this.strip();
            };
            BN.prototype.iadd = function iadd(num) {
              var r;
              if (this.negative !== 0 && num.negative === 0) {
                this.negative = 0;
                r = this.isub(num);
                this.negative ^= 1;
                return this._normSign();
              } else if (this.negative === 0 && num.negative !== 0) {
                num.negative = 0;
                r = this.isub(num);
                num.negative = 1;
                return r._normSign();
              }
              var a, b;
              if (this.length > num.length) {
                a = this;
                b = num;
              } else {
                a = num;
                b = this;
              }
              var carry = 0;
              for (var i = 0; i < b.length; i++) {
                r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
                this.words[i] = r & 67108863;
                carry = r >>> 26;
              }
              for (; carry !== 0 && i < a.length; i++) {
                r = (a.words[i] | 0) + carry;
                this.words[i] = r & 67108863;
                carry = r >>> 26;
              }
              this.length = a.length;
              if (carry !== 0) {
                this.words[this.length] = carry;
                this.length++;
              } else if (a !== this) {
                for (; i < a.length; i++) {
                  this.words[i] = a.words[i];
                }
              }
              return this;
            };
            BN.prototype.add = function add(num) {
              var res;
              if (num.negative !== 0 && this.negative === 0) {
                num.negative = 0;
                res = this.sub(num);
                num.negative ^= 1;
                return res;
              } else if (num.negative === 0 && this.negative !== 0) {
                this.negative = 0;
                res = num.sub(this);
                this.negative = 1;
                return res;
              }
              if (this.length > num.length) return this.clone().iadd(num);
              return num.clone().iadd(this);
            };
            BN.prototype.isub = function isub(num) {
              if (num.negative !== 0) {
                num.negative = 0;
                var r = this.iadd(num);
                num.negative = 1;
                return r._normSign();
              } else if (this.negative !== 0) {
                this.negative = 0;
                this.iadd(num);
                this.negative = 1;
                return this._normSign();
              }
              var cmp = this.cmp(num);
              if (cmp === 0) {
                this.negative = 0;
                this.length = 1;
                this.words[0] = 0;
                return this;
              }
              var a, b;
              if (cmp > 0) {
                a = this;
                b = num;
              } else {
                a = num;
                b = this;
              }
              var carry = 0;
              for (var i = 0; i < b.length; i++) {
                r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
                carry = r >> 26;
                this.words[i] = r & 67108863;
              }
              for (; carry !== 0 && i < a.length; i++) {
                r = (a.words[i] | 0) + carry;
                carry = r >> 26;
                this.words[i] = r & 67108863;
              }
              if (carry === 0 && i < a.length && a !== this) {
                for (; i < a.length; i++) {
                  this.words[i] = a.words[i];
                }
              }
              this.length = Math.max(this.length, i);
              if (a !== this) {
                this.negative = 1;
              }
              return this.strip();
            };
            BN.prototype.sub = function sub(num) {
              return this.clone().isub(num);
            };
            function smallMulTo(self, num, out) {
              out.negative = num.negative ^ self.negative;
              var len = (self.length + num.length) | 0;
              out.length = len;
              len = (len - 1) | 0;
              var a = self.words[0] | 0;
              var b = num.words[0] | 0;
              var r = a * b;
              var lo = r & 67108863;
              var carry = (r / 67108864) | 0;
              out.words[0] = lo;
              for (var k = 1; k < len; k++) {
                var ncarry = carry >>> 26;
                var rword = carry & 67108863;
                var maxJ = Math.min(k, num.length - 1);
                for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
                  var i = (k - j) | 0;
                  a = self.words[i] | 0;
                  b = num.words[j] | 0;
                  r = a * b + rword;
                  ncarry += (r / 67108864) | 0;
                  rword = r & 67108863;
                }
                out.words[k] = rword | 0;
                carry = ncarry | 0;
              }
              if (carry !== 0) {
                out.words[k] = carry | 0;
              } else {
                out.length--;
              }
              return out.strip();
            }
            var comb10MulTo = function comb10MulTo(self, num, out) {
              var a = self.words;
              var b = num.words;
              var o = out.words;
              var c = 0;
              var lo;
              var mid;
              var hi;
              var a0 = a[0] | 0;
              var al0 = a0 & 8191;
              var ah0 = a0 >>> 13;
              var a1 = a[1] | 0;
              var al1 = a1 & 8191;
              var ah1 = a1 >>> 13;
              var a2 = a[2] | 0;
              var al2 = a2 & 8191;
              var ah2 = a2 >>> 13;
              var a3 = a[3] | 0;
              var al3 = a3 & 8191;
              var ah3 = a3 >>> 13;
              var a4 = a[4] | 0;
              var al4 = a4 & 8191;
              var ah4 = a4 >>> 13;
              var a5 = a[5] | 0;
              var al5 = a5 & 8191;
              var ah5 = a5 >>> 13;
              var a6 = a[6] | 0;
              var al6 = a6 & 8191;
              var ah6 = a6 >>> 13;
              var a7 = a[7] | 0;
              var al7 = a7 & 8191;
              var ah7 = a7 >>> 13;
              var a8 = a[8] | 0;
              var al8 = a8 & 8191;
              var ah8 = a8 >>> 13;
              var a9 = a[9] | 0;
              var al9 = a9 & 8191;
              var ah9 = a9 >>> 13;
              var b0 = b[0] | 0;
              var bl0 = b0 & 8191;
              var bh0 = b0 >>> 13;
              var b1 = b[1] | 0;
              var bl1 = b1 & 8191;
              var bh1 = b1 >>> 13;
              var b2 = b[2] | 0;
              var bl2 = b2 & 8191;
              var bh2 = b2 >>> 13;
              var b3 = b[3] | 0;
              var bl3 = b3 & 8191;
              var bh3 = b3 >>> 13;
              var b4 = b[4] | 0;
              var bl4 = b4 & 8191;
              var bh4 = b4 >>> 13;
              var b5 = b[5] | 0;
              var bl5 = b5 & 8191;
              var bh5 = b5 >>> 13;
              var b6 = b[6] | 0;
              var bl6 = b6 & 8191;
              var bh6 = b6 >>> 13;
              var b7 = b[7] | 0;
              var bl7 = b7 & 8191;
              var bh7 = b7 >>> 13;
              var b8 = b[8] | 0;
              var bl8 = b8 & 8191;
              var bh8 = b8 >>> 13;
              var b9 = b[9] | 0;
              var bl9 = b9 & 8191;
              var bh9 = b9 >>> 13;
              out.negative = self.negative ^ num.negative;
              out.length = 19;
              lo = Math.imul(al0, bl0);
              mid = Math.imul(al0, bh0);
              mid = (mid + Math.imul(ah0, bl0)) | 0;
              hi = Math.imul(ah0, bh0);
              var w0 = (((c + lo) | 0) + ((mid & 8191) << 13)) | 0;
              c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
              w0 &= 67108863;
              lo = Math.imul(al1, bl0);
              mid = Math.imul(al1, bh0);
              mid = (mid + Math.imul(ah1, bl0)) | 0;
              hi = Math.imul(ah1, bh0);
              lo = (lo + Math.imul(al0, bl1)) | 0;
              mid = (mid + Math.imul(al0, bh1)) | 0;
              mid = (mid + Math.imul(ah0, bl1)) | 0;
              hi = (hi + Math.imul(ah0, bh1)) | 0;
              var w1 = (((c + lo) | 0) + ((mid & 8191) << 13)) | 0;
              c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
              w1 &= 67108863;
              lo = Math.imul(al2, bl0);
              mid = Math.imul(al2, bh0);
              mid = (mid + Math.imul(ah2, bl0)) | 0;
              hi = Math.imul(ah2, bh0);
              lo = (lo + Math.imul(al1, bl1)) | 0;
              mid = (mid + Math.imul(al1, bh1)) | 0;
              mid = (mid + Math.imul(ah1, bl1)) | 0;
              hi = (hi + Math.imul(ah1, bh1)) | 0;
              lo = (lo + Math.imul(al0, bl2)) | 0;
              mid = (mid + Math.imul(al0, bh2)) | 0;
              mid = (mid + Math.imul(ah0, bl2)) | 0;
              hi = (hi + Math.imul(ah0, bh2)) | 0;
              var w2 = (((c + lo) | 0) + ((mid & 8191) << 13)) | 0;
              c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
              w2 &= 67108863;
              lo = Math.imul(al3, bl0);
              mid = Math.imul(al3, bh0);
              mid = (mid + Math.imul(ah3, bl0)) | 0;
              hi = Math.imul(ah3, bh0);
              lo = (lo + Math.imul(al2, bl1)) | 0;
              mid = (mid + Math.imul(al2, bh1)) | 0;
              mid = (mid + Math.imul(ah2, bl1)) | 0;
              hi = (hi + Math.imul(ah2, bh1)) | 0;
              lo = (lo + Math.imul(al1, bl2)) | 0;
              mid = (mid + Math.imul(al1, bh2)) | 0;
              mid = (mid + Math.imul(ah1, bl2)) | 0;
              hi = (hi + Math.imul(ah1, bh2)) | 0;
              lo = (lo + Math.imul(al0, bl3)) | 0;
              mid = (mid + Math.imul(al0, bh3)) | 0;
              mid = (mid + Math.imul(ah0, bl3)) | 0;
              hi = (hi + Math.imul(ah0, bh3)) | 0;
              var w3 = (((c + lo) | 0) + ((mid & 8191) << 13)) | 0;
              c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
              w3 &= 67108863;
              lo = Math.imul(al4, bl0);
              mid = Math.imul(al4, bh0);
              mid = (mid + Math.imul(ah4, bl0)) | 0;
              hi = Math.imul(ah4, bh0);
              lo = (lo + Math.imul(al3, bl1)) | 0;
              mid = (mid + Math.imul(al3, bh1)) | 0;
              mid = (mid + Math.imul(ah3, bl1)) | 0;
              hi = (hi + Math.imul(ah3, bh1)) | 0;
              lo = (lo + Math.imul(al2, bl2)) | 0;
              mid = (mid + Math.imul(al2, bh2)) | 0;
              mid = (mid + Math.imul(ah2, bl2)) | 0;
              hi = (hi + Math.imul(ah2, bh2)) | 0;
              lo = (lo + Math.imul(al1, bl3)) | 0;
              mid = (mid + Math.imul(al1, bh3)) | 0;
              mid = (mid + Math.imul(ah1, bl3)) | 0;
              hi = (hi + Math.imul(ah1, bh3)) | 0;
              lo = (lo + Math.imul(al0, bl4)) | 0;
              mid = (mid + Math.imul(al0, bh4)) | 0;
              mid = (mid + Math.imul(ah0, bl4)) | 0;
              hi = (hi + Math.imul(ah0, bh4)) | 0;
              var w4 = (((c + lo) | 0) + ((mid & 8191) << 13)) | 0;
              c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
              w4 &= 67108863;
              lo = Math.imul(al5, bl0);
              mid = Math.imul(al5, bh0);
              mid = (mid + Math.imul(ah5, bl0)) | 0;
              hi = Math.imul(ah5, bh0);
              lo = (lo + Math.imul(al4, bl1)) | 0;
              mid = (mid + Math.imul(al4, bh1)) | 0;
              mid = (mid + Math.imul(ah4, bl1)) | 0;
              hi = (hi + Math.imul(ah4, bh1)) | 0;
              lo = (lo + Math.imul(al3, bl2)) | 0;
              mid = (mid + Math.imul(al3, bh2)) | 0;
              mid = (mid + Math.imul(ah3, bl2)) | 0;
              hi = (hi + Math.imul(ah3, bh2)) | 0;
              lo = (lo + Math.imul(al2, bl3)) | 0;
              mid = (mid + Math.imul(al2, bh3)) | 0;
              mid = (mid + Math.imul(ah2, bl3)) | 0;
              hi = (hi + Math.imul(ah2, bh3)) | 0;
              lo = (lo + Math.imul(al1, bl4)) | 0;
              mid = (mid + Math.imul(al1, bh4)) | 0;
              mid = (mid + Math.imul(ah1, bl4)) | 0;
              hi = (hi + Math.imul(ah1, bh4)) | 0;
              lo = (lo + Math.imul(al0, bl5)) | 0;
              mid = (mid + Math.imul(al0, bh5)) | 0;
              mid = (mid + Math.imul(ah0, bl5)) | 0;
              hi = (hi + Math.imul(ah0, bh5)) | 0;
              var w5 = (((c + lo) | 0) + ((mid & 8191) << 13)) | 0;
              c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
              w5 &= 67108863;
              lo = Math.imul(al6, bl0);
              mid = Math.imul(al6, bh0);
              mid = (mid + Math.imul(ah6, bl0)) | 0;
              hi = Math.imul(ah6, bh0);
              lo = (lo + Math.imul(al5, bl1)) | 0;
              mid = (mid + Math.imul(al5, bh1)) | 0;
              mid = (mid + Math.imul(ah5, bl1)) | 0;
              hi = (hi + Math.imul(ah5, bh1)) | 0;
              lo = (lo + Math.imul(al4, bl2)) | 0;
              mid = (mid + Math.imul(al4, bh2)) | 0;
              mid = (mid + Math.imul(ah4, bl2)) | 0;
              hi = (hi + Math.imul(ah4, bh2)) | 0;
              lo = (lo + Math.imul(al3, bl3)) | 0;
              mid = (mid + Math.imul(al3, bh3)) | 0;
              mid = (mid + Math.imul(ah3, bl3)) | 0;
              hi = (hi + Math.imul(ah3, bh3)) | 0;
              lo = (lo + Math.imul(al2, bl4)) | 0;
              mid = (mid + Math.imul(al2, bh4)) | 0;
              mid = (mid + Math.imul(ah2, bl4)) | 0;
              hi = (hi + Math.imul(ah2, bh4)) | 0;
              lo = (lo + Math.imul(al1, bl5)) | 0;
              mid = (mid + Math.imul(al1, bh5)) | 0;
              mid = (mid + Math.imul(ah1, bl5)) | 0;
              hi = (hi + Math.imul(ah1, bh5)) | 0;
              lo = (lo + Math.imul(al0, bl6)) | 0;
              mid = (mid + Math.imul(al0, bh6)) | 0;
              mid = (mid + Math.imul(ah0, bl6)) | 0;
              hi = (hi + Math.imul(ah0, bh6)) | 0;
              var w6 = (((c + lo) | 0) + ((mid & 8191) << 13)) | 0;
              c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
              w6 &= 67108863;
              lo = Math.imul(al7, bl0);
              mid = Math.imul(al7, bh0);
              mid = (mid + Math.imul(ah7, bl0)) | 0;
              hi = Math.imul(ah7, bh0);
              lo = (lo + Math.imul(al6, bl1)) | 0;
              mid = (mid + Math.imul(al6, bh1)) | 0;
              mid = (mid + Math.imul(ah6, bl1)) | 0;
              hi = (hi + Math.imul(ah6, bh1)) | 0;
              lo = (lo + Math.imul(al5, bl2)) | 0;
              mid = (mid + Math.imul(al5, bh2)) | 0;
              mid = (mid + Math.imul(ah5, bl2)) | 0;
              hi = (hi + Math.imul(ah5, bh2)) | 0;
              lo = (lo + Math.imul(al4, bl3)) | 0;
              mid = (mid + Math.imul(al4, bh3)) | 0;
              mid = (mid + Math.imul(ah4, bl3)) | 0;
              hi = (hi + Math.imul(ah4, bh3)) | 0;
              lo = (lo + Math.imul(al3, bl4)) | 0;
              mid = (mid + Math.imul(al3, bh4)) | 0;
              mid = (mid + Math.imul(ah3, bl4)) | 0;
              hi = (hi + Math.imul(ah3, bh4)) | 0;
              lo = (lo + Math.imul(al2, bl5)) | 0;
              mid = (mid + Math.imul(al2, bh5)) | 0;
              mid = (mid + Math.imul(ah2, bl5)) | 0;
              hi = (hi + Math.imul(ah2, bh5)) | 0;
              lo = (lo + Math.imul(al1, bl6)) | 0;
              mid = (mid + Math.imul(al1, bh6)) | 0;
              mid = (mid + Math.imul(ah1, bl6)) | 0;
              hi = (hi + Math.imul(ah1, bh6)) | 0;
              lo = (lo + Math.imul(al0, bl7)) | 0;
              mid = (mid + Math.imul(al0, bh7)) | 0;
              mid = (mid + Math.imul(ah0, bl7)) | 0;
              hi = (hi + Math.imul(ah0, bh7)) | 0;
              var w7 = (((c + lo) | 0) + ((mid & 8191) << 13)) | 0;
              c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
              w7 &= 67108863;
              lo = Math.imul(al8, bl0);
              mid = Math.imul(al8, bh0);
              mid = (mid + Math.imul(ah8, bl0)) | 0;
              hi = Math.imul(ah8, bh0);
              lo = (lo + Math.imul(al7, bl1)) | 0;
              mid = (mid + Math.imul(al7, bh1)) | 0;
              mid = (mid + Math.imul(ah7, bl1)) | 0;
              hi = (hi + Math.imul(ah7, bh1)) | 0;
              lo = (lo + Math.imul(al6, bl2)) | 0;
              mid = (mid + Math.imul(al6, bh2)) | 0;
              mid = (mid + Math.imul(ah6, bl2)) | 0;
              hi = (hi + Math.imul(ah6, bh2)) | 0;
              lo = (lo + Math.imul(al5, bl3)) | 0;
              mid = (mid + Math.imul(al5, bh3)) | 0;
              mid = (mid + Math.imul(ah5, bl3)) | 0;
              hi = (hi + Math.imul(ah5, bh3)) | 0;
              lo = (lo + Math.imul(al4, bl4)) | 0;
              mid = (mid + Math.imul(al4, bh4)) | 0;
              mid = (mid + Math.imul(ah4, bl4)) | 0;
              hi = (hi + Math.imul(ah4, bh4)) | 0;
              lo = (lo + Math.imul(al3, bl5)) | 0;
              mid = (mid + Math.imul(al3, bh5)) | 0;
              mid = (mid + Math.imul(ah3, bl5)) | 0;
              hi = (hi + Math.imul(ah3, bh5)) | 0;
              lo = (lo + Math.imul(al2, bl6)) | 0;
              mid = (mid + Math.imul(al2, bh6)) | 0;
              mid = (mid + Math.imul(ah2, bl6)) | 0;
              hi = (hi + Math.imul(ah2, bh6)) | 0;
              lo = (lo + Math.imul(al1, bl7)) | 0;
              mid = (mid + Math.imul(al1, bh7)) | 0;
              mid = (mid + Math.imul(ah1, bl7)) | 0;
              hi = (hi + Math.imul(ah1, bh7)) | 0;
              lo = (lo + Math.imul(al0, bl8)) | 0;
              mid = (mid + Math.imul(al0, bh8)) | 0;
              mid = (mid + Math.imul(ah0, bl8)) | 0;
              hi = (hi + Math.imul(ah0, bh8)) | 0;
              var w8 = (((c + lo) | 0) + ((mid & 8191) << 13)) | 0;
              c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
              w8 &= 67108863;
              lo = Math.imul(al9, bl0);
              mid = Math.imul(al9, bh0);
              mid = (mid + Math.imul(ah9, bl0)) | 0;
              hi = Math.imul(ah9, bh0);
              lo = (lo + Math.imul(al8, bl1)) | 0;
              mid = (mid + Math.imul(al8, bh1)) | 0;
              mid = (mid + Math.imul(ah8, bl1)) | 0;
              hi = (hi + Math.imul(ah8, bh1)) | 0;
              lo = (lo + Math.imul(al7, bl2)) | 0;
              mid = (mid + Math.imul(al7, bh2)) | 0;
              mid = (mid + Math.imul(ah7, bl2)) | 0;
              hi = (hi + Math.imul(ah7, bh2)) | 0;
              lo = (lo + Math.imul(al6, bl3)) | 0;
              mid = (mid + Math.imul(al6, bh3)) | 0;
              mid = (mid + Math.imul(ah6, bl3)) | 0;
              hi = (hi + Math.imul(ah6, bh3)) | 0;
              lo = (lo + Math.imul(al5, bl4)) | 0;
              mid = (mid + Math.imul(al5, bh4)) | 0;
              mid = (mid + Math.imul(ah5, bl4)) | 0;
              hi = (hi + Math.imul(ah5, bh4)) | 0;
              lo = (lo + Math.imul(al4, bl5)) | 0;
              mid = (mid + Math.imul(al4, bh5)) | 0;
              mid = (mid + Math.imul(ah4, bl5)) | 0;
              hi = (hi + Math.imul(ah4, bh5)) | 0;
              lo = (lo + Math.imul(al3, bl6)) | 0;
              mid = (mid + Math.imul(al3, bh6)) | 0;
              mid = (mid + Math.imul(ah3, bl6)) | 0;
              hi = (hi + Math.imul(ah3, bh6)) | 0;
              lo = (lo + Math.imul(al2, bl7)) | 0;
              mid = (mid + Math.imul(al2, bh7)) | 0;
              mid = (mid + Math.imul(ah2, bl7)) | 0;
              hi = (hi + Math.imul(ah2, bh7)) | 0;
              lo = (lo + Math.imul(al1, bl8)) | 0;
              mid = (mid + Math.imul(al1, bh8)) | 0;
              mid = (mid + Math.imul(ah1, bl8)) | 0;
              hi = (hi + Math.imul(ah1, bh8)) | 0;
              lo = (lo + Math.imul(al0, bl9)) | 0;
              mid = (mid + Math.imul(al0, bh9)) | 0;
              mid = (mid + Math.imul(ah0, bl9)) | 0;
              hi = (hi + Math.imul(ah0, bh9)) | 0;
              var w9 = (((c + lo) | 0) + ((mid & 8191) << 13)) | 0;
              c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
              w9 &= 67108863;
              lo = Math.imul(al9, bl1);
              mid = Math.imul(al9, bh1);
              mid = (mid + Math.imul(ah9, bl1)) | 0;
              hi = Math.imul(ah9, bh1);
              lo = (lo + Math.imul(al8, bl2)) | 0;
              mid = (mid + Math.imul(al8, bh2)) | 0;
              mid = (mid + Math.imul(ah8, bl2)) | 0;
              hi = (hi + Math.imul(ah8, bh2)) | 0;
              lo = (lo + Math.imul(al7, bl3)) | 0;
              mid = (mid + Math.imul(al7, bh3)) | 0;
              mid = (mid + Math.imul(ah7, bl3)) | 0;
              hi = (hi + Math.imul(ah7, bh3)) | 0;
              lo = (lo + Math.imul(al6, bl4)) | 0;
              mid = (mid + Math.imul(al6, bh4)) | 0;
              mid = (mid + Math.imul(ah6, bl4)) | 0;
              hi = (hi + Math.imul(ah6, bh4)) | 0;
              lo = (lo + Math.imul(al5, bl5)) | 0;
              mid = (mid + Math.imul(al5, bh5)) | 0;
              mid = (mid + Math.imul(ah5, bl5)) | 0;
              hi = (hi + Math.imul(ah5, bh5)) | 0;
              lo = (lo + Math.imul(al4, bl6)) | 0;
              mid = (mid + Math.imul(al4, bh6)) | 0;
              mid = (mid + Math.imul(ah4, bl6)) | 0;
              hi = (hi + Math.imul(ah4, bh6)) | 0;
              lo = (lo + Math.imul(al3, bl7)) | 0;
              mid = (mid + Math.imul(al3, bh7)) | 0;
              mid = (mid + Math.imul(ah3, bl7)) | 0;
              hi = (hi + Math.imul(ah3, bh7)) | 0;
              lo = (lo + Math.imul(al2, bl8)) | 0;
              mid = (mid + Math.imul(al2, bh8)) | 0;
              mid = (mid + Math.imul(ah2, bl8)) | 0;
              hi = (hi + Math.imul(ah2, bh8)) | 0;
              lo = (lo + Math.imul(al1, bl9)) | 0;
              mid = (mid + Math.imul(al1, bh9)) | 0;
              mid = (mid + Math.imul(ah1, bl9)) | 0;
              hi = (hi + Math.imul(ah1, bh9)) | 0;
              var w10 = (((c + lo) | 0) + ((mid & 8191) << 13)) | 0;
              c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
              w10 &= 67108863;
              lo = Math.imul(al9, bl2);
              mid = Math.imul(al9, bh2);
              mid = (mid + Math.imul(ah9, bl2)) | 0;
              hi = Math.imul(ah9, bh2);
              lo = (lo + Math.imul(al8, bl3)) | 0;
              mid = (mid + Math.imul(al8, bh3)) | 0;
              mid = (mid + Math.imul(ah8, bl3)) | 0;
              hi = (hi + Math.imul(ah8, bh3)) | 0;
              lo = (lo + Math.imul(al7, bl4)) | 0;
              mid = (mid + Math.imul(al7, bh4)) | 0;
              mid = (mid + Math.imul(ah7, bl4)) | 0;
              hi = (hi + Math.imul(ah7, bh4)) | 0;
              lo = (lo + Math.imul(al6, bl5)) | 0;
              mid = (mid + Math.imul(al6, bh5)) | 0;
              mid = (mid + Math.imul(ah6, bl5)) | 0;
              hi = (hi + Math.imul(ah6, bh5)) | 0;
              lo = (lo + Math.imul(al5, bl6)) | 0;
              mid = (mid + Math.imul(al5, bh6)) | 0;
              mid = (mid + Math.imul(ah5, bl6)) | 0;
              hi = (hi + Math.imul(ah5, bh6)) | 0;
              lo = (lo + Math.imul(al4, bl7)) | 0;
              mid = (mid + Math.imul(al4, bh7)) | 0;
              mid = (mid + Math.imul(ah4, bl7)) | 0;
              hi = (hi + Math.imul(ah4, bh7)) | 0;
              lo = (lo + Math.imul(al3, bl8)) | 0;
              mid = (mid + Math.imul(al3, bh8)) | 0;
              mid = (mid + Math.imul(ah3, bl8)) | 0;
              hi = (hi + Math.imul(ah3, bh8)) | 0;
              lo = (lo + Math.imul(al2, bl9)) | 0;
              mid = (mid + Math.imul(al2, bh9)) | 0;
              mid = (mid + Math.imul(ah2, bl9)) | 0;
              hi = (hi + Math.imul(ah2, bh9)) | 0;
              var w11 = (((c + lo) | 0) + ((mid & 8191) << 13)) | 0;
              c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
              w11 &= 67108863;
              lo = Math.imul(al9, bl3);
              mid = Math.imul(al9, bh3);
              mid = (mid + Math.imul(ah9, bl3)) | 0;
              hi = Math.imul(ah9, bh3);
              lo = (lo + Math.imul(al8, bl4)) | 0;
              mid = (mid + Math.imul(al8, bh4)) | 0;
              mid = (mid + Math.imul(ah8, bl4)) | 0;
              hi = (hi + Math.imul(ah8, bh4)) | 0;
              lo = (lo + Math.imul(al7, bl5)) | 0;
              mid = (mid + Math.imul(al7, bh5)) | 0;
              mid = (mid + Math.imul(ah7, bl5)) | 0;
              hi = (hi + Math.imul(ah7, bh5)) | 0;
              lo = (lo + Math.imul(al6, bl6)) | 0;
              mid = (mid + Math.imul(al6, bh6)) | 0;
              mid = (mid + Math.imul(ah6, bl6)) | 0;
              hi = (hi + Math.imul(ah6, bh6)) | 0;
              lo = (lo + Math.imul(al5, bl7)) | 0;
              mid = (mid + Math.imul(al5, bh7)) | 0;
              mid = (mid + Math.imul(ah5, bl7)) | 0;
              hi = (hi + Math.imul(ah5, bh7)) | 0;
              lo = (lo + Math.imul(al4, bl8)) | 0;
              mid = (mid + Math.imul(al4, bh8)) | 0;
              mid = (mid + Math.imul(ah4, bl8)) | 0;
              hi = (hi + Math.imul(ah4, bh8)) | 0;
              lo = (lo + Math.imul(al3, bl9)) | 0;
              mid = (mid + Math.imul(al3, bh9)) | 0;
              mid = (mid + Math.imul(ah3, bl9)) | 0;
              hi = (hi + Math.imul(ah3, bh9)) | 0;
              var w12 = (((c + lo) | 0) + ((mid & 8191) << 13)) | 0;
              c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
              w12 &= 67108863;
              lo = Math.imul(al9, bl4);
              mid = Math.imul(al9, bh4);
              mid = (mid + Math.imul(ah9, bl4)) | 0;
              hi = Math.imul(ah9, bh4);
              lo = (lo + Math.imul(al8, bl5)) | 0;
              mid = (mid + Math.imul(al8, bh5)) | 0;
              mid = (mid + Math.imul(ah8, bl5)) | 0;
              hi = (hi + Math.imul(ah8, bh5)) | 0;
              lo = (lo + Math.imul(al7, bl6)) | 0;
              mid = (mid + Math.imul(al7, bh6)) | 0;
              mid = (mid + Math.imul(ah7, bl6)) | 0;
              hi = (hi + Math.imul(ah7, bh6)) | 0;
              lo = (lo + Math.imul(al6, bl7)) | 0;
              mid = (mid + Math.imul(al6, bh7)) | 0;
              mid = (mid + Math.imul(ah6, bl7)) | 0;
              hi = (hi + Math.imul(ah6, bh7)) | 0;
              lo = (lo + Math.imul(al5, bl8)) | 0;
              mid = (mid + Math.imul(al5, bh8)) | 0;
              mid = (mid + Math.imul(ah5, bl8)) | 0;
              hi = (hi + Math.imul(ah5, bh8)) | 0;
              lo = (lo + Math.imul(al4, bl9)) | 0;
              mid = (mid + Math.imul(al4, bh9)) | 0;
              mid = (mid + Math.imul(ah4, bl9)) | 0;
              hi = (hi + Math.imul(ah4, bh9)) | 0;
              var w13 = (((c + lo) | 0) + ((mid & 8191) << 13)) | 0;
              c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
              w13 &= 67108863;
              lo = Math.imul(al9, bl5);
              mid = Math.imul(al9, bh5);
              mid = (mid + Math.imul(ah9, bl5)) | 0;
              hi = Math.imul(ah9, bh5);
              lo = (lo + Math.imul(al8, bl6)) | 0;
              mid = (mid + Math.imul(al8, bh6)) | 0;
              mid = (mid + Math.imul(ah8, bl6)) | 0;
              hi = (hi + Math.imul(ah8, bh6)) | 0;
              lo = (lo + Math.imul(al7, bl7)) | 0;
              mid = (mid + Math.imul(al7, bh7)) | 0;
              mid = (mid + Math.imul(ah7, bl7)) | 0;
              hi = (hi + Math.imul(ah7, bh7)) | 0;
              lo = (lo + Math.imul(al6, bl8)) | 0;
              mid = (mid + Math.imul(al6, bh8)) | 0;
              mid = (mid + Math.imul(ah6, bl8)) | 0;
              hi = (hi + Math.imul(ah6, bh8)) | 0;
              lo = (lo + Math.imul(al5, bl9)) | 0;
              mid = (mid + Math.imul(al5, bh9)) | 0;
              mid = (mid + Math.imul(ah5, bl9)) | 0;
              hi = (hi + Math.imul(ah5, bh9)) | 0;
              var w14 = (((c + lo) | 0) + ((mid & 8191) << 13)) | 0;
              c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
              w14 &= 67108863;
              lo = Math.imul(al9, bl6);
              mid = Math.imul(al9, bh6);
              mid = (mid + Math.imul(ah9, bl6)) | 0;
              hi = Math.imul(ah9, bh6);
              lo = (lo + Math.imul(al8, bl7)) | 0;
              mid = (mid + Math.imul(al8, bh7)) | 0;
              mid = (mid + Math.imul(ah8, bl7)) | 0;
              hi = (hi + Math.imul(ah8, bh7)) | 0;
              lo = (lo + Math.imul(al7, bl8)) | 0;
              mid = (mid + Math.imul(al7, bh8)) | 0;
              mid = (mid + Math.imul(ah7, bl8)) | 0;
              hi = (hi + Math.imul(ah7, bh8)) | 0;
              lo = (lo + Math.imul(al6, bl9)) | 0;
              mid = (mid + Math.imul(al6, bh9)) | 0;
              mid = (mid + Math.imul(ah6, bl9)) | 0;
              hi = (hi + Math.imul(ah6, bh9)) | 0;
              var w15 = (((c + lo) | 0) + ((mid & 8191) << 13)) | 0;
              c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
              w15 &= 67108863;
              lo = Math.imul(al9, bl7);
              mid = Math.imul(al9, bh7);
              mid = (mid + Math.imul(ah9, bl7)) | 0;
              hi = Math.imul(ah9, bh7);
              lo = (lo + Math.imul(al8, bl8)) | 0;
              mid = (mid + Math.imul(al8, bh8)) | 0;
              mid = (mid + Math.imul(ah8, bl8)) | 0;
              hi = (hi + Math.imul(ah8, bh8)) | 0;
              lo = (lo + Math.imul(al7, bl9)) | 0;
              mid = (mid + Math.imul(al7, bh9)) | 0;
              mid = (mid + Math.imul(ah7, bl9)) | 0;
              hi = (hi + Math.imul(ah7, bh9)) | 0;
              var w16 = (((c + lo) | 0) + ((mid & 8191) << 13)) | 0;
              c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
              w16 &= 67108863;
              lo = Math.imul(al9, bl8);
              mid = Math.imul(al9, bh8);
              mid = (mid + Math.imul(ah9, bl8)) | 0;
              hi = Math.imul(ah9, bh8);
              lo = (lo + Math.imul(al8, bl9)) | 0;
              mid = (mid + Math.imul(al8, bh9)) | 0;
              mid = (mid + Math.imul(ah8, bl9)) | 0;
              hi = (hi + Math.imul(ah8, bh9)) | 0;
              var w17 = (((c + lo) | 0) + ((mid & 8191) << 13)) | 0;
              c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
              w17 &= 67108863;
              lo = Math.imul(al9, bl9);
              mid = Math.imul(al9, bh9);
              mid = (mid + Math.imul(ah9, bl9)) | 0;
              hi = Math.imul(ah9, bh9);
              var w18 = (((c + lo) | 0) + ((mid & 8191) << 13)) | 0;
              c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
              w18 &= 67108863;
              o[0] = w0;
              o[1] = w1;
              o[2] = w2;
              o[3] = w3;
              o[4] = w4;
              o[5] = w5;
              o[6] = w6;
              o[7] = w7;
              o[8] = w8;
              o[9] = w9;
              o[10] = w10;
              o[11] = w11;
              o[12] = w12;
              o[13] = w13;
              o[14] = w14;
              o[15] = w15;
              o[16] = w16;
              o[17] = w17;
              o[18] = w18;
              if (c !== 0) {
                o[19] = c;
                out.length++;
              }
              return out;
            };
            if (!Math.imul) {
              comb10MulTo = smallMulTo;
            }
            function bigMulTo(self, num, out) {
              out.negative = num.negative ^ self.negative;
              out.length = self.length + num.length;
              var carry = 0;
              var hncarry = 0;
              for (var k = 0; k < out.length - 1; k++) {
                var ncarry = hncarry;
                hncarry = 0;
                var rword = carry & 67108863;
                var maxJ = Math.min(k, num.length - 1);
                for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
                  var i = k - j;
                  var a = self.words[i] | 0;
                  var b = num.words[j] | 0;
                  var r = a * b;
                  var lo = r & 67108863;
                  ncarry = (ncarry + ((r / 67108864) | 0)) | 0;
                  lo = (lo + rword) | 0;
                  rword = lo & 67108863;
                  ncarry = (ncarry + (lo >>> 26)) | 0;
                  hncarry += ncarry >>> 26;
                  ncarry &= 67108863;
                }
                out.words[k] = rword;
                carry = ncarry;
                ncarry = hncarry;
              }
              if (carry !== 0) {
                out.words[k] = carry;
              } else {
                out.length--;
              }
              return out.strip();
            }
            function jumboMulTo(self, num, out) {
              var fftm = new FFTM();
              return fftm.mulp(self, num, out);
            }
            BN.prototype.mulTo = function mulTo(num, out) {
              var res;
              var len = this.length + num.length;
              if (this.length === 10 && num.length === 10) {
                res = comb10MulTo(this, num, out);
              } else if (len < 63) {
                res = smallMulTo(this, num, out);
              } else if (len < 1024) {
                res = bigMulTo(this, num, out);
              } else {
                res = jumboMulTo(this, num, out);
              }
              return res;
            };
            function FFTM(x, y) {
              this.x = x;
              this.y = y;
            }
            FFTM.prototype.makeRBT = function makeRBT(N) {
              var t = new Array(N);
              var l = BN.prototype._countBits(N) - 1;
              for (var i = 0; i < N; i++) {
                t[i] = this.revBin(i, l, N);
              }
              return t;
            };
            FFTM.prototype.revBin = function revBin(x, l, N) {
              if (x === 0 || x === N - 1) return x;
              var rb = 0;
              for (var i = 0; i < l; i++) {
                rb |= (x & 1) << (l - i - 1);
                x >>= 1;
              }
              return rb;
            };
            FFTM.prototype.permute = function permute(
              rbt,
              rws,
              iws,
              rtws,
              itws,
              N
            ) {
              for (var i = 0; i < N; i++) {
                rtws[i] = rws[rbt[i]];
                itws[i] = iws[rbt[i]];
              }
            };
            FFTM.prototype.transform = function transform(
              rws,
              iws,
              rtws,
              itws,
              N,
              rbt
            ) {
              this.permute(rbt, rws, iws, rtws, itws, N);
              for (var s = 1; s < N; s <<= 1) {
                var l = s << 1;
                var rtwdf = Math.cos((2 * Math.PI) / l);
                var itwdf = Math.sin((2 * Math.PI) / l);
                for (var p = 0; p < N; p += l) {
                  var rtwdf_ = rtwdf;
                  var itwdf_ = itwdf;
                  for (var j = 0; j < s; j++) {
                    var re = rtws[p + j];
                    var ie = itws[p + j];
                    var ro = rtws[p + j + s];
                    var io = itws[p + j + s];
                    var rx = rtwdf_ * ro - itwdf_ * io;
                    io = rtwdf_ * io + itwdf_ * ro;
                    ro = rx;
                    rtws[p + j] = re + ro;
                    itws[p + j] = ie + io;
                    rtws[p + j + s] = re - ro;
                    itws[p + j + s] = ie - io;
                    if (j !== l) {
                      rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                      itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                      rtwdf_ = rx;
                    }
                  }
                }
              }
            };
            FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
              var N = Math.max(m, n) | 1;
              var odd = N & 1;
              var i = 0;
              for (N = (N / 2) | 0; N; N = N >>> 1) {
                i++;
              }
              return 1 << (i + 1 + odd);
            };
            FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
              if (N <= 1) return;
              for (var i = 0; i < N / 2; i++) {
                var t = rws[i];
                rws[i] = rws[N - i - 1];
                rws[N - i - 1] = t;
                t = iws[i];
                iws[i] = -iws[N - i - 1];
                iws[N - i - 1] = -t;
              }
            };
            FFTM.prototype.normalize13b = function normalize13b(ws, N) {
              var carry = 0;
              for (var i = 0; i < N / 2; i++) {
                var w =
                  Math.round(ws[2 * i + 1] / N) * 8192 +
                  Math.round(ws[2 * i] / N) +
                  carry;
                ws[i] = w & 67108863;
                if (w < 67108864) {
                  carry = 0;
                } else {
                  carry = (w / 67108864) | 0;
                }
              }
              return ws;
            };
            FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
              var carry = 0;
              for (var i = 0; i < len; i++) {
                carry = carry + (ws[i] | 0);
                rws[2 * i] = carry & 8191;
                carry = carry >>> 13;
                rws[2 * i + 1] = carry & 8191;
                carry = carry >>> 13;
              }
              for (i = 2 * len; i < N; ++i) {
                rws[i] = 0;
              }
              assert(carry === 0);
              assert((carry & ~8191) === 0);
            };
            FFTM.prototype.stub = function stub(N) {
              var ph = new Array(N);
              for (var i = 0; i < N; i++) {
                ph[i] = 0;
              }
              return ph;
            };
            FFTM.prototype.mulp = function mulp(x, y, out) {
              var N = 2 * this.guessLen13b(x.length, y.length);
              var rbt = this.makeRBT(N);
              var _ = this.stub(N);
              var rws = new Array(N);
              var rwst = new Array(N);
              var iwst = new Array(N);
              var nrws = new Array(N);
              var nrwst = new Array(N);
              var niwst = new Array(N);
              var rmws = out.words;
              rmws.length = N;
              this.convert13b(x.words, x.length, rws, N);
              this.convert13b(y.words, y.length, nrws, N);
              this.transform(rws, _, rwst, iwst, N, rbt);
              this.transform(nrws, _, nrwst, niwst, N, rbt);
              for (var i = 0; i < N; i++) {
                var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
                iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
                rwst[i] = rx;
              }
              this.conjugate(rwst, iwst, N);
              this.transform(rwst, iwst, rmws, _, N, rbt);
              this.conjugate(rmws, _, N);
              this.normalize13b(rmws, N);
              out.negative = x.negative ^ y.negative;
              out.length = x.length + y.length;
              return out.strip();
            };
            BN.prototype.mul = function mul(num) {
              var out = new BN(null);
              out.words = new Array(this.length + num.length);
              return this.mulTo(num, out);
            };
            BN.prototype.mulf = function mulf(num) {
              var out = new BN(null);
              out.words = new Array(this.length + num.length);
              return jumboMulTo(this, num, out);
            };
            BN.prototype.imul = function imul(num) {
              return this.clone().mulTo(num, this);
            };
            BN.prototype.imuln = function imuln(num) {
              assert(typeof num === 'number');
              assert(num < 67108864);
              var carry = 0;
              for (var i = 0; i < this.length; i++) {
                var w = (this.words[i] | 0) * num;
                var lo = (w & 67108863) + (carry & 67108863);
                carry >>= 26;
                carry += (w / 67108864) | 0;
                carry += lo >>> 26;
                this.words[i] = lo & 67108863;
              }
              if (carry !== 0) {
                this.words[i] = carry;
                this.length++;
              }
              return this;
            };
            BN.prototype.muln = function muln(num) {
              return this.clone().imuln(num);
            };
            BN.prototype.sqr = function sqr() {
              return this.mul(this);
            };
            BN.prototype.isqr = function isqr() {
              return this.imul(this.clone());
            };
            BN.prototype.pow = function pow(num) {
              var w = toBitArray(num);
              if (w.length === 0) return new BN(1);
              var res = this;
              for (var i = 0; i < w.length; i++, res = res.sqr()) {
                if (w[i] !== 0) break;
              }
              if (++i < w.length) {
                for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
                  if (w[i] === 0) continue;
                  res = res.mul(q);
                }
              }
              return res;
            };
            BN.prototype.iushln = function iushln(bits) {
              assert(typeof bits === 'number' && bits >= 0);
              var r = bits % 26;
              var s = (bits - r) / 26;
              var carryMask = (67108863 >>> (26 - r)) << (26 - r);
              var i;
              if (r !== 0) {
                var carry = 0;
                for (i = 0; i < this.length; i++) {
                  var newCarry = this.words[i] & carryMask;
                  var c = ((this.words[i] | 0) - newCarry) << r;
                  this.words[i] = c | carry;
                  carry = newCarry >>> (26 - r);
                }
                if (carry) {
                  this.words[i] = carry;
                  this.length++;
                }
              }
              if (s !== 0) {
                for (i = this.length - 1; i >= 0; i--) {
                  this.words[i + s] = this.words[i];
                }
                for (i = 0; i < s; i++) {
                  this.words[i] = 0;
                }
                this.length += s;
              }
              return this.strip();
            };
            BN.prototype.ishln = function ishln(bits) {
              assert(this.negative === 0);
              return this.iushln(bits);
            };
            BN.prototype.iushrn = function iushrn(bits, hint, extended) {
              assert(typeof bits === 'number' && bits >= 0);
              var h;
              if (hint) {
                h = (hint - (hint % 26)) / 26;
              } else {
                h = 0;
              }
              var r = bits % 26;
              var s = Math.min((bits - r) / 26, this.length);
              var mask = 67108863 ^ ((67108863 >>> r) << r);
              var maskedWords = extended;
              h -= s;
              h = Math.max(0, h);
              if (maskedWords) {
                for (var i = 0; i < s; i++) {
                  maskedWords.words[i] = this.words[i];
                }
                maskedWords.length = s;
              }
              if (s === 0) {
              } else if (this.length > s) {
                this.length -= s;
                for (i = 0; i < this.length; i++) {
                  this.words[i] = this.words[i + s];
                }
              } else {
                this.words[0] = 0;
                this.length = 1;
              }
              var carry = 0;
              for (
                i = this.length - 1;
                i >= 0 && (carry !== 0 || i >= h);
                i--
              ) {
                var word = this.words[i] | 0;
                this.words[i] = (carry << (26 - r)) | (word >>> r);
                carry = word & mask;
              }
              if (maskedWords && carry !== 0) {
                maskedWords.words[maskedWords.length++] = carry;
              }
              if (this.length === 0) {
                this.words[0] = 0;
                this.length = 1;
              }
              return this.strip();
            };
            BN.prototype.ishrn = function ishrn(bits, hint, extended) {
              assert(this.negative === 0);
              return this.iushrn(bits, hint, extended);
            };
            BN.prototype.shln = function shln(bits) {
              return this.clone().ishln(bits);
            };
            BN.prototype.ushln = function ushln(bits) {
              return this.clone().iushln(bits);
            };
            BN.prototype.shrn = function shrn(bits) {
              return this.clone().ishrn(bits);
            };
            BN.prototype.ushrn = function ushrn(bits) {
              return this.clone().iushrn(bits);
            };
            BN.prototype.testn = function testn(bit) {
              assert(typeof bit === 'number' && bit >= 0);
              var r = bit % 26;
              var s = (bit - r) / 26;
              var q = 1 << r;
              if (this.length <= s) return false;
              var w = this.words[s];
              return !!(w & q);
            };
            BN.prototype.imaskn = function imaskn(bits) {
              assert(typeof bits === 'number' && bits >= 0);
              var r = bits % 26;
              var s = (bits - r) / 26;
              assert(
                this.negative === 0,
                'imaskn works only with positive numbers'
              );
              if (this.length <= s) {
                return this;
              }
              if (r !== 0) {
                s++;
              }
              this.length = Math.min(s, this.length);
              if (r !== 0) {
                var mask = 67108863 ^ ((67108863 >>> r) << r);
                this.words[this.length - 1] &= mask;
              }
              return this.strip();
            };
            BN.prototype.maskn = function maskn(bits) {
              return this.clone().imaskn(bits);
            };
            BN.prototype.iaddn = function iaddn(num) {
              assert(typeof num === 'number');
              assert(num < 67108864);
              if (num < 0) return this.isubn(-num);
              if (this.negative !== 0) {
                if (this.length === 1 && (this.words[0] | 0) < num) {
                  this.words[0] = num - (this.words[0] | 0);
                  this.negative = 0;
                  return this;
                }
                this.negative = 0;
                this.isubn(num);
                this.negative = 1;
                return this;
              }
              return this._iaddn(num);
            };
            BN.prototype._iaddn = function _iaddn(num) {
              this.words[0] += num;
              for (
                var i = 0;
                i < this.length && this.words[i] >= 67108864;
                i++
              ) {
                this.words[i] -= 67108864;
                if (i === this.length - 1) {
                  this.words[i + 1] = 1;
                } else {
                  this.words[i + 1]++;
                }
              }
              this.length = Math.max(this.length, i + 1);
              return this;
            };
            BN.prototype.isubn = function isubn(num) {
              assert(typeof num === 'number');
              assert(num < 67108864);
              if (num < 0) return this.iaddn(-num);
              if (this.negative !== 0) {
                this.negative = 0;
                this.iaddn(num);
                this.negative = 1;
                return this;
              }
              this.words[0] -= num;
              if (this.length === 1 && this.words[0] < 0) {
                this.words[0] = -this.words[0];
                this.negative = 1;
              } else {
                for (var i = 0; i < this.length && this.words[i] < 0; i++) {
                  this.words[i] += 67108864;
                  this.words[i + 1] -= 1;
                }
              }
              return this.strip();
            };
            BN.prototype.addn = function addn(num) {
              return this.clone().iaddn(num);
            };
            BN.prototype.subn = function subn(num) {
              return this.clone().isubn(num);
            };
            BN.prototype.iabs = function iabs() {
              this.negative = 0;
              return this;
            };
            BN.prototype.abs = function abs() {
              return this.clone().iabs();
            };
            BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
              var len = num.length + shift;
              var i;
              this._expand(len);
              var w;
              var carry = 0;
              for (i = 0; i < num.length; i++) {
                w = (this.words[i + shift] | 0) + carry;
                var right = (num.words[i] | 0) * mul;
                w -= right & 67108863;
                carry = (w >> 26) - ((right / 67108864) | 0);
                this.words[i + shift] = w & 67108863;
              }
              for (; i < this.length - shift; i++) {
                w = (this.words[i + shift] | 0) + carry;
                carry = w >> 26;
                this.words[i + shift] = w & 67108863;
              }
              if (carry === 0) return this.strip();
              assert(carry === -1);
              carry = 0;
              for (i = 0; i < this.length; i++) {
                w = -(this.words[i] | 0) + carry;
                carry = w >> 26;
                this.words[i] = w & 67108863;
              }
              this.negative = 1;
              return this.strip();
            };
            BN.prototype._wordDiv = function _wordDiv(num, mode) {
              var shift = this.length - num.length;
              var a = this.clone();
              var b = num;
              var bhi = b.words[b.length - 1] | 0;
              var bhiBits = this._countBits(bhi);
              shift = 26 - bhiBits;
              if (shift !== 0) {
                b = b.ushln(shift);
                a.iushln(shift);
                bhi = b.words[b.length - 1] | 0;
              }
              var m = a.length - b.length;
              var q;
              if (mode !== 'mod') {
                q = new BN(null);
                q.length = m + 1;
                q.words = new Array(q.length);
                for (var i = 0; i < q.length; i++) {
                  q.words[i] = 0;
                }
              }
              var diff = a.clone()._ishlnsubmul(b, 1, m);
              if (diff.negative === 0) {
                a = diff;
                if (q) {
                  q.words[m] = 1;
                }
              }
              for (var j = m - 1; j >= 0; j--) {
                var qj =
                  (a.words[b.length + j] | 0) * 67108864 +
                  (a.words[b.length + j - 1] | 0);
                qj = Math.min((qj / bhi) | 0, 67108863);
                a._ishlnsubmul(b, qj, j);
                while (a.negative !== 0) {
                  qj--;
                  a.negative = 0;
                  a._ishlnsubmul(b, 1, j);
                  if (!a.isZero()) {
                    a.negative ^= 1;
                  }
                }
                if (q) {
                  q.words[j] = qj;
                }
              }
              if (q) {
                q.strip();
              }
              a.strip();
              if (mode !== 'div' && shift !== 0) {
                a.iushrn(shift);
              }
              return { div: q || null, mod: a };
            };
            BN.prototype.divmod = function divmod(num, mode, positive) {
              assert(!num.isZero());
              if (this.isZero()) {
                return { div: new BN(0), mod: new BN(0) };
              }
              var div, mod, res;
              if (this.negative !== 0 && num.negative === 0) {
                res = this.neg().divmod(num, mode);
                if (mode !== 'mod') {
                  div = res.div.neg();
                }
                if (mode !== 'div') {
                  mod = res.mod.neg();
                  if (positive && mod.negative !== 0) {
                    mod.iadd(num);
                  }
                }
                return { div: div, mod: mod };
              }
              if (this.negative === 0 && num.negative !== 0) {
                res = this.divmod(num.neg(), mode);
                if (mode !== 'mod') {
                  div = res.div.neg();
                }
                return { div: div, mod: res.mod };
              }
              if ((this.negative & num.negative) !== 0) {
                res = this.neg().divmod(num.neg(), mode);
                if (mode !== 'div') {
                  mod = res.mod.neg();
                  if (positive && mod.negative !== 0) {
                    mod.isub(num);
                  }
                }
                return { div: res.div, mod: mod };
              }
              if (num.length > this.length || this.cmp(num) < 0) {
                return { div: new BN(0), mod: this };
              }
              if (num.length === 1) {
                if (mode === 'div') {
                  return { div: this.divn(num.words[0]), mod: null };
                }
                if (mode === 'mod') {
                  return { div: null, mod: new BN(this.modn(num.words[0])) };
                }
                return {
                  div: this.divn(num.words[0]),
                  mod: new BN(this.modn(num.words[0]))
                };
              }
              return this._wordDiv(num, mode);
            };
            BN.prototype.div = function div(num) {
              return this.divmod(num, 'div', false).div;
            };
            BN.prototype.mod = function mod(num) {
              return this.divmod(num, 'mod', false).mod;
            };
            BN.prototype.umod = function umod(num) {
              return this.divmod(num, 'mod', true).mod;
            };
            BN.prototype.divRound = function divRound(num) {
              var dm = this.divmod(num);
              if (dm.mod.isZero()) return dm.div;
              var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
              var half = num.ushrn(1);
              var r2 = num.andln(1);
              var cmp = mod.cmp(half);
              if (cmp < 0 || (r2 === 1 && cmp === 0)) return dm.div;
              return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
            };
            BN.prototype.modn = function modn(num) {
              assert(num <= 67108863);
              var p = (1 << 26) % num;
              var acc = 0;
              for (var i = this.length - 1; i >= 0; i--) {
                acc = (p * acc + (this.words[i] | 0)) % num;
              }
              return acc;
            };
            BN.prototype.idivn = function idivn(num) {
              assert(num <= 67108863);
              var carry = 0;
              for (var i = this.length - 1; i >= 0; i--) {
                var w = (this.words[i] | 0) + carry * 67108864;
                this.words[i] = (w / num) | 0;
                carry = w % num;
              }
              return this.strip();
            };
            BN.prototype.divn = function divn(num) {
              return this.clone().idivn(num);
            };
            BN.prototype.egcd = function egcd(p) {
              assert(p.negative === 0);
              assert(!p.isZero());
              var x = this;
              var y = p.clone();
              if (x.negative !== 0) {
                x = x.umod(p);
              } else {
                x = x.clone();
              }
              var A = new BN(1);
              var B = new BN(0);
              var C = new BN(0);
              var D = new BN(1);
              var g = 0;
              while (x.isEven() && y.isEven()) {
                x.iushrn(1);
                y.iushrn(1);
                ++g;
              }
              var yp = y.clone();
              var xp = x.clone();
              while (!x.isZero()) {
                for (
                  var i = 0, im = 1;
                  (x.words[0] & im) === 0 && i < 26;
                  ++i, im <<= 1
                );
                if (i > 0) {
                  x.iushrn(i);
                  while (i-- > 0) {
                    if (A.isOdd() || B.isOdd()) {
                      A.iadd(yp);
                      B.isub(xp);
                    }
                    A.iushrn(1);
                    B.iushrn(1);
                  }
                }
                for (
                  var j = 0, jm = 1;
                  (y.words[0] & jm) === 0 && j < 26;
                  ++j, jm <<= 1
                );
                if (j > 0) {
                  y.iushrn(j);
                  while (j-- > 0) {
                    if (C.isOdd() || D.isOdd()) {
                      C.iadd(yp);
                      D.isub(xp);
                    }
                    C.iushrn(1);
                    D.iushrn(1);
                  }
                }
                if (x.cmp(y) >= 0) {
                  x.isub(y);
                  A.isub(C);
                  B.isub(D);
                } else {
                  y.isub(x);
                  C.isub(A);
                  D.isub(B);
                }
              }
              return { a: C, b: D, gcd: y.iushln(g) };
            };
            BN.prototype._invmp = function _invmp(p) {
              assert(p.negative === 0);
              assert(!p.isZero());
              var a = this;
              var b = p.clone();
              if (a.negative !== 0) {
                a = a.umod(p);
              } else {
                a = a.clone();
              }
              var x1 = new BN(1);
              var x2 = new BN(0);
              var delta = b.clone();
              while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
                for (
                  var i = 0, im = 1;
                  (a.words[0] & im) === 0 && i < 26;
                  ++i, im <<= 1
                );
                if (i > 0) {
                  a.iushrn(i);
                  while (i-- > 0) {
                    if (x1.isOdd()) {
                      x1.iadd(delta);
                    }
                    x1.iushrn(1);
                  }
                }
                for (
                  var j = 0, jm = 1;
                  (b.words[0] & jm) === 0 && j < 26;
                  ++j, jm <<= 1
                );
                if (j > 0) {
                  b.iushrn(j);
                  while (j-- > 0) {
                    if (x2.isOdd()) {
                      x2.iadd(delta);
                    }
                    x2.iushrn(1);
                  }
                }
                if (a.cmp(b) >= 0) {
                  a.isub(b);
                  x1.isub(x2);
                } else {
                  b.isub(a);
                  x2.isub(x1);
                }
              }
              var res;
              if (a.cmpn(1) === 0) {
                res = x1;
              } else {
                res = x2;
              }
              if (res.cmpn(0) < 0) {
                res.iadd(p);
              }
              return res;
            };
            BN.prototype.gcd = function gcd(num) {
              if (this.isZero()) return num.abs();
              if (num.isZero()) return this.abs();
              var a = this.clone();
              var b = num.clone();
              a.negative = 0;
              b.negative = 0;
              for (var shift = 0; a.isEven() && b.isEven(); shift++) {
                a.iushrn(1);
                b.iushrn(1);
              }
              do {
                while (a.isEven()) {
                  a.iushrn(1);
                }
                while (b.isEven()) {
                  b.iushrn(1);
                }
                var r = a.cmp(b);
                if (r < 0) {
                  var t = a;
                  a = b;
                  b = t;
                } else if (r === 0 || b.cmpn(1) === 0) {
                  break;
                }
                a.isub(b);
              } while (true);
              return b.iushln(shift);
            };
            BN.prototype.invm = function invm(num) {
              return this.egcd(num).a.umod(num);
            };
            BN.prototype.isEven = function isEven() {
              return (this.words[0] & 1) === 0;
            };
            BN.prototype.isOdd = function isOdd() {
              return (this.words[0] & 1) === 1;
            };
            BN.prototype.andln = function andln(num) {
              return this.words[0] & num;
            };
            BN.prototype.bincn = function bincn(bit) {
              assert(typeof bit === 'number');
              var r = bit % 26;
              var s = (bit - r) / 26;
              var q = 1 << r;
              if (this.length <= s) {
                this._expand(s + 1);
                this.words[s] |= q;
                return this;
              }
              var carry = q;
              for (var i = s; carry !== 0 && i < this.length; i++) {
                var w = this.words[i] | 0;
                w += carry;
                carry = w >>> 26;
                w &= 67108863;
                this.words[i] = w;
              }
              if (carry !== 0) {
                this.words[i] = carry;
                this.length++;
              }
              return this;
            };
            BN.prototype.isZero = function isZero() {
              return this.length === 1 && this.words[0] === 0;
            };
            BN.prototype.cmpn = function cmpn(num) {
              var negative = num < 0;
              if (this.negative !== 0 && !negative) return -1;
              if (this.negative === 0 && negative) return 1;
              this.strip();
              var res;
              if (this.length > 1) {
                res = 1;
              } else {
                if (negative) {
                  num = -num;
                }
                assert(num <= 67108863, 'Number is too big');
                var w = this.words[0] | 0;
                res = w === num ? 0 : w < num ? -1 : 1;
              }
              if (this.negative !== 0) return -res | 0;
              return res;
            };
            BN.prototype.cmp = function cmp(num) {
              if (this.negative !== 0 && num.negative === 0) return -1;
              if (this.negative === 0 && num.negative !== 0) return 1;
              var res = this.ucmp(num);
              if (this.negative !== 0) return -res | 0;
              return res;
            };
            BN.prototype.ucmp = function ucmp(num) {
              if (this.length > num.length) return 1;
              if (this.length < num.length) return -1;
              var res = 0;
              for (var i = this.length - 1; i >= 0; i--) {
                var a = this.words[i] | 0;
                var b = num.words[i] | 0;
                if (a === b) continue;
                if (a < b) {
                  res = -1;
                } else if (a > b) {
                  res = 1;
                }
                break;
              }
              return res;
            };
            BN.prototype.gtn = function gtn(num) {
              return this.cmpn(num) === 1;
            };
            BN.prototype.gt = function gt(num) {
              return this.cmp(num) === 1;
            };
            BN.prototype.gten = function gten(num) {
              return this.cmpn(num) >= 0;
            };
            BN.prototype.gte = function gte(num) {
              return this.cmp(num) >= 0;
            };
            BN.prototype.ltn = function ltn(num) {
              return this.cmpn(num) === -1;
            };
            BN.prototype.lt = function lt(num) {
              return this.cmp(num) === -1;
            };
            BN.prototype.lten = function lten(num) {
              return this.cmpn(num) <= 0;
            };
            BN.prototype.lte = function lte(num) {
              return this.cmp(num) <= 0;
            };
            BN.prototype.eqn = function eqn(num) {
              return this.cmpn(num) === 0;
            };
            BN.prototype.eq = function eq(num) {
              return this.cmp(num) === 0;
            };
            BN.red = function red(num) {
              return new Red(num);
            };
            BN.prototype.toRed = function toRed(ctx) {
              assert(!this.red, 'Already a number in reduction context');
              assert(this.negative === 0, 'red works only with positives');
              return ctx.convertTo(this)._forceRed(ctx);
            };
            BN.prototype.fromRed = function fromRed() {
              assert(
                this.red,
                'fromRed works only with numbers in reduction context'
              );
              return this.red.convertFrom(this);
            };
            BN.prototype._forceRed = function _forceRed(ctx) {
              this.red = ctx;
              return this;
            };
            BN.prototype.forceRed = function forceRed(ctx) {
              assert(!this.red, 'Already a number in reduction context');
              return this._forceRed(ctx);
            };
            BN.prototype.redAdd = function redAdd(num) {
              assert(this.red, 'redAdd works only with red numbers');
              return this.red.add(this, num);
            };
            BN.prototype.redIAdd = function redIAdd(num) {
              assert(this.red, 'redIAdd works only with red numbers');
              return this.red.iadd(this, num);
            };
            BN.prototype.redSub = function redSub(num) {
              assert(this.red, 'redSub works only with red numbers');
              return this.red.sub(this, num);
            };
            BN.prototype.redISub = function redISub(num) {
              assert(this.red, 'redISub works only with red numbers');
              return this.red.isub(this, num);
            };
            BN.prototype.redShl = function redShl(num) {
              assert(this.red, 'redShl works only with red numbers');
              return this.red.shl(this, num);
            };
            BN.prototype.redMul = function redMul(num) {
              assert(this.red, 'redMul works only with red numbers');
              this.red._verify2(this, num);
              return this.red.mul(this, num);
            };
            BN.prototype.redIMul = function redIMul(num) {
              assert(this.red, 'redMul works only with red numbers');
              this.red._verify2(this, num);
              return this.red.imul(this, num);
            };
            BN.prototype.redSqr = function redSqr() {
              assert(this.red, 'redSqr works only with red numbers');
              this.red._verify1(this);
              return this.red.sqr(this);
            };
            BN.prototype.redISqr = function redISqr() {
              assert(this.red, 'redISqr works only with red numbers');
              this.red._verify1(this);
              return this.red.isqr(this);
            };
            BN.prototype.redSqrt = function redSqrt() {
              assert(this.red, 'redSqrt works only with red numbers');
              this.red._verify1(this);
              return this.red.sqrt(this);
            };
            BN.prototype.redInvm = function redInvm() {
              assert(this.red, 'redInvm works only with red numbers');
              this.red._verify1(this);
              return this.red.invm(this);
            };
            BN.prototype.redNeg = function redNeg() {
              assert(this.red, 'redNeg works only with red numbers');
              this.red._verify1(this);
              return this.red.neg(this);
            };
            BN.prototype.redPow = function redPow(num) {
              assert(this.red && !num.red, 'redPow(normalNum)');
              this.red._verify1(this);
              return this.red.pow(this, num);
            };
            var primes = { k256: null, p224: null, p192: null, p25519: null };
            function MPrime(name, p) {
              this.name = name;
              this.p = new BN(p, 16);
              this.n = this.p.bitLength();
              this.k = new BN(1).iushln(this.n).isub(this.p);
              this.tmp = this._tmp();
            }
            MPrime.prototype._tmp = function _tmp() {
              var tmp = new BN(null);
              tmp.words = new Array(Math.ceil(this.n / 13));
              return tmp;
            };
            MPrime.prototype.ireduce = function ireduce(num) {
              var r = num;
              var rlen;
              do {
                this.split(r, this.tmp);
                r = this.imulK(r);
                r = r.iadd(this.tmp);
                rlen = r.bitLength();
              } while (rlen > this.n);
              var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
              if (cmp === 0) {
                r.words[0] = 0;
                r.length = 1;
              } else if (cmp > 0) {
                r.isub(this.p);
              } else {
                r.strip();
              }
              return r;
            };
            MPrime.prototype.split = function split(input, out) {
              input.iushrn(this.n, 0, out);
            };
            MPrime.prototype.imulK = function imulK(num) {
              return num.imul(this.k);
            };
            function K256() {
              MPrime.call(
                this,
                'k256',
                'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f'
              );
            }
            inherits(K256, MPrime);
            K256.prototype.split = function split(input, output) {
              var mask = 4194303;
              var outLen = Math.min(input.length, 9);
              for (var i = 0; i < outLen; i++) {
                output.words[i] = input.words[i];
              }
              output.length = outLen;
              if (input.length <= 9) {
                input.words[0] = 0;
                input.length = 1;
                return;
              }
              var prev = input.words[9];
              output.words[output.length++] = prev & mask;
              for (i = 10; i < input.length; i++) {
                var next = input.words[i] | 0;
                input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
                prev = next;
              }
              prev >>>= 22;
              input.words[i - 10] = prev;
              if (prev === 0 && input.length > 10) {
                input.length -= 10;
              } else {
                input.length -= 9;
              }
            };
            K256.prototype.imulK = function imulK(num) {
              num.words[num.length] = 0;
              num.words[num.length + 1] = 0;
              num.length += 2;
              var lo = 0;
              for (var i = 0; i < num.length; i++) {
                var w = num.words[i] | 0;
                lo += w * 977;
                num.words[i] = lo & 67108863;
                lo = w * 64 + ((lo / 67108864) | 0);
              }
              if (num.words[num.length - 1] === 0) {
                num.length--;
                if (num.words[num.length - 1] === 0) {
                  num.length--;
                }
              }
              return num;
            };
            function P224() {
              MPrime.call(
                this,
                'p224',
                'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001'
              );
            }
            inherits(P224, MPrime);
            function P192() {
              MPrime.call(
                this,
                'p192',
                'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff'
              );
            }
            inherits(P192, MPrime);
            function P25519() {
              MPrime.call(
                this,
                '25519',
                '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed'
              );
            }
            inherits(P25519, MPrime);
            P25519.prototype.imulK = function imulK(num) {
              var carry = 0;
              for (var i = 0; i < num.length; i++) {
                var hi = (num.words[i] | 0) * 19 + carry;
                var lo = hi & 67108863;
                hi >>>= 26;
                num.words[i] = lo;
                carry = hi;
              }
              if (carry !== 0) {
                num.words[num.length++] = carry;
              }
              return num;
            };
            BN._prime = function prime(name) {
              if (primes[name]) return primes[name];
              var prime;
              if (name === 'k256') {
                prime = new K256();
              } else if (name === 'p224') {
                prime = new P224();
              } else if (name === 'p192') {
                prime = new P192();
              } else if (name === 'p25519') {
                prime = new P25519();
              } else {
                throw new Error('Unknown prime ' + name);
              }
              primes[name] = prime;
              return prime;
            };
            function Red(m) {
              if (typeof m === 'string') {
                var prime = BN._prime(m);
                this.m = prime.p;
                this.prime = prime;
              } else {
                assert(m.gtn(1), 'modulus must be greater than 1');
                this.m = m;
                this.prime = null;
              }
            }
            Red.prototype._verify1 = function _verify1(a) {
              assert(a.negative === 0, 'red works only with positives');
              assert(a.red, 'red works only with red numbers');
            };
            Red.prototype._verify2 = function _verify2(a, b) {
              assert(
                (a.negative | b.negative) === 0,
                'red works only with positives'
              );
              assert(
                a.red && a.red === b.red,
                'red works only with red numbers'
              );
            };
            Red.prototype.imod = function imod(a) {
              if (this.prime) return this.prime.ireduce(a)._forceRed(this);
              return a.umod(this.m)._forceRed(this);
            };
            Red.prototype.neg = function neg(a) {
              if (a.isZero()) {
                return a.clone();
              }
              return this.m.sub(a)._forceRed(this);
            };
            Red.prototype.add = function add(a, b) {
              this._verify2(a, b);
              var res = a.add(b);
              if (res.cmp(this.m) >= 0) {
                res.isub(this.m);
              }
              return res._forceRed(this);
            };
            Red.prototype.iadd = function iadd(a, b) {
              this._verify2(a, b);
              var res = a.iadd(b);
              if (res.cmp(this.m) >= 0) {
                res.isub(this.m);
              }
              return res;
            };
            Red.prototype.sub = function sub(a, b) {
              this._verify2(a, b);
              var res = a.sub(b);
              if (res.cmpn(0) < 0) {
                res.iadd(this.m);
              }
              return res._forceRed(this);
            };
            Red.prototype.isub = function isub(a, b) {
              this._verify2(a, b);
              var res = a.isub(b);
              if (res.cmpn(0) < 0) {
                res.iadd(this.m);
              }
              return res;
            };
            Red.prototype.shl = function shl(a, num) {
              this._verify1(a);
              return this.imod(a.ushln(num));
            };
            Red.prototype.imul = function imul(a, b) {
              this._verify2(a, b);
              return this.imod(a.imul(b));
            };
            Red.prototype.mul = function mul(a, b) {
              this._verify2(a, b);
              return this.imod(a.mul(b));
            };
            Red.prototype.isqr = function isqr(a) {
              return this.imul(a, a.clone());
            };
            Red.prototype.sqr = function sqr(a) {
              return this.mul(a, a);
            };
            Red.prototype.sqrt = function sqrt(a) {
              if (a.isZero()) return a.clone();
              var mod3 = this.m.andln(3);
              assert(mod3 % 2 === 1);
              if (mod3 === 3) {
                var pow = this.m.add(new BN(1)).iushrn(2);
                return this.pow(a, pow);
              }
              var q = this.m.subn(1);
              var s = 0;
              while (!q.isZero() && q.andln(1) === 0) {
                s++;
                q.iushrn(1);
              }
              assert(!q.isZero());
              var one = new BN(1).toRed(this);
              var nOne = one.redNeg();
              var lpow = this.m.subn(1).iushrn(1);
              var z = this.m.bitLength();
              z = new BN(2 * z * z).toRed(this);
              while (this.pow(z, lpow).cmp(nOne) !== 0) {
                z.redIAdd(nOne);
              }
              var c = this.pow(z, q);
              var r = this.pow(a, q.addn(1).iushrn(1));
              var t = this.pow(a, q);
              var m = s;
              while (t.cmp(one) !== 0) {
                var tmp = t;
                for (var i = 0; tmp.cmp(one) !== 0; i++) {
                  tmp = tmp.redSqr();
                }
                assert(i < m);
                var b = this.pow(c, new BN(1).iushln(m - i - 1));
                r = r.redMul(b);
                c = b.redSqr();
                t = t.redMul(c);
                m = i;
              }
              return r;
            };
            Red.prototype.invm = function invm(a) {
              var inv = a._invmp(this.m);
              if (inv.negative !== 0) {
                inv.negative = 0;
                return this.imod(inv).redNeg();
              } else {
                return this.imod(inv);
              }
            };
            Red.prototype.pow = function pow(a, num) {
              if (num.isZero()) return new BN(1).toRed(this);
              if (num.cmpn(1) === 0) return a.clone();
              var windowSize = 4;
              var wnd = new Array(1 << windowSize);
              wnd[0] = new BN(1).toRed(this);
              wnd[1] = a;
              for (var i = 2; i < wnd.length; i++) {
                wnd[i] = this.mul(wnd[i - 1], a);
              }
              var res = wnd[0];
              var current = 0;
              var currentLen = 0;
              var start = num.bitLength() % 26;
              if (start === 0) {
                start = 26;
              }
              for (i = num.length - 1; i >= 0; i--) {
                var word = num.words[i];
                for (var j = start - 1; j >= 0; j--) {
                  var bit = (word >> j) & 1;
                  if (res !== wnd[0]) {
                    res = this.sqr(res);
                  }
                  if (bit === 0 && current === 0) {
                    currentLen = 0;
                    continue;
                  }
                  current <<= 1;
                  current |= bit;
                  currentLen++;
                  if (currentLen !== windowSize && (i !== 0 || j !== 0))
                    continue;
                  res = this.mul(res, wnd[current]);
                  currentLen = 0;
                  current = 0;
                }
                start = 26;
              }
              return res;
            };
            Red.prototype.convertTo = function convertTo(num) {
              var r = num.umod(this.m);
              return r === num ? r.clone() : r;
            };
            Red.prototype.convertFrom = function convertFrom(num) {
              var res = num.clone();
              res.red = null;
              return res;
            };
            BN.mont = function mont(num) {
              return new Mont(num);
            };
            function Mont(m) {
              Red.call(this, m);
              this.shift = this.m.bitLength();
              if (this.shift % 26 !== 0) {
                this.shift += 26 - (this.shift % 26);
              }
              this.r = new BN(1).iushln(this.shift);
              this.r2 = this.imod(this.r.sqr());
              this.rinv = this.r._invmp(this.m);
              this.minv = this.rinv
                .mul(this.r)
                .isubn(1)
                .div(this.m);
              this.minv = this.minv.umod(this.r);
              this.minv = this.r.sub(this.minv);
            }
            inherits(Mont, Red);
            Mont.prototype.convertTo = function convertTo(num) {
              return this.imod(num.ushln(this.shift));
            };
            Mont.prototype.convertFrom = function convertFrom(num) {
              var r = this.imod(num.mul(this.rinv));
              r.red = null;
              return r;
            };
            Mont.prototype.imul = function imul(a, b) {
              if (a.isZero() || b.isZero()) {
                a.words[0] = 0;
                a.length = 1;
                return a;
              }
              var t = a.imul(b);
              var c = t
                .maskn(this.shift)
                .mul(this.minv)
                .imaskn(this.shift)
                .mul(this.m);
              var u = t.isub(c).iushrn(this.shift);
              var res = u;
              if (u.cmp(this.m) >= 0) {
                res = u.isub(this.m);
              } else if (u.cmpn(0) < 0) {
                res = u.iadd(this.m);
              }
              return res._forceRed(this);
            };
            Mont.prototype.mul = function mul(a, b) {
              if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
              var t = a.mul(b);
              var c = t
                .maskn(this.shift)
                .mul(this.minv)
                .imaskn(this.shift)
                .mul(this.m);
              var u = t.isub(c).iushrn(this.shift);
              var res = u;
              if (u.cmp(this.m) >= 0) {
                res = u.isub(this.m);
              } else if (u.cmpn(0) < 0) {
                res = u.iadd(this.m);
              }
              return res._forceRed(this);
            };
            Mont.prototype.invm = function invm(a) {
              var res = this.imod(a._invmp(this.m).mul(this.r2));
              return res._forceRed(this);
            };
          })(typeof module === 'undefined' || module, this);
        },
        { buffer: 155 }
      ],
      135: [
        function(require, module, exports) {
          module.exports = {
            trueFunc: function trueFunc() {
              return true;
            },
            falseFunc: function falseFunc() {
              return false;
            }
          };
        },
        {}
      ],
      136: [
        function(require, module, exports) {
          var r;
          module.exports = function rand(len) {
            if (!r) r = new Rand(null);
            return r.generate(len);
          };
          function Rand(rand) {
            this.rand = rand;
          }
          module.exports.Rand = Rand;
          Rand.prototype.generate = function generate(len) {
            return this._rand(len);
          };
          Rand.prototype._rand = function _rand(n) {
            if (this.rand.getBytes) return this.rand.getBytes(n);
            var res = new Uint8Array(n);
            for (var i = 0; i < res.length; i++) res[i] = this.rand.getByte();
            return res;
          };
          if (typeof self === 'object') {
            if (self.crypto && self.crypto.getRandomValues) {
              Rand.prototype._rand = function _rand(n) {
                var arr = new Uint8Array(n);
                self.crypto.getRandomValues(arr);
                return arr;
              };
            } else if (self.msCrypto && self.msCrypto.getRandomValues) {
              Rand.prototype._rand = function _rand(n) {
                var arr = new Uint8Array(n);
                self.msCrypto.getRandomValues(arr);
                return arr;
              };
            } else if (typeof window === 'object') {
              Rand.prototype._rand = function() {
                throw new Error('Not implemented yet');
              };
            }
          } else {
            try {
              var crypto = require('crypto');
              if (typeof crypto.randomBytes !== 'function')
                throw new Error('Not supported');
              Rand.prototype._rand = function _rand(n) {
                return crypto.randomBytes(n);
              };
            } catch (e) {}
          }
        },
        { crypto: 155 }
      ],
      137: [
        function(require, module, exports) {
          arguments[4][52][0].apply(exports, arguments);
        },
        {
          './asn1/api': 138,
          './asn1/base': 140,
          './asn1/constants': 144,
          './asn1/decoders': 146,
          './asn1/encoders': 149,
          'bn.js': 153,
          dup: 52
        }
      ],
      138: [
        function(require, module, exports) {
          arguments[4][53][0].apply(exports, arguments);
        },
        { '../asn1': 137, dup: 53, inherits: 207, vm: 266 }
      ],
      139: [
        function(require, module, exports) {
          arguments[4][54][0].apply(exports, arguments);
        },
        { '../base': 140, buffer: 183, dup: 54, inherits: 207 }
      ],
      140: [
        function(require, module, exports) {
          arguments[4][55][0].apply(exports, arguments);
        },
        { './buffer': 139, './node': 141, './reporter': 142, dup: 55 }
      ],
      141: [
        function(require, module, exports) {
          var Reporter = require('../base').Reporter;
          var EncoderBuffer = require('../base').EncoderBuffer;
          var DecoderBuffer = require('../base').DecoderBuffer;
          var assert = require('minimalistic-assert');
          var tags = [
            'seq',
            'seqof',
            'set',
            'setof',
            'objid',
            'bool',
            'gentime',
            'utctime',
            'null_',
            'enum',
            'int',
            'objDesc',
            'bitstr',
            'bmpstr',
            'charstr',
            'genstr',
            'graphstr',
            'ia5str',
            'iso646str',
            'numstr',
            'octstr',
            'printstr',
            't61str',
            'unistr',
            'utf8str',
            'videostr'
          ];
          var methods = [
            'key',
            'obj',
            'use',
            'optional',
            'explicit',
            'implicit',
            'def',
            'choice',
            'any',
            'contains'
          ].concat(tags);
          var overrided = [
            '_peekTag',
            '_decodeTag',
            '_use',
            '_decodeStr',
            '_decodeObjid',
            '_decodeTime',
            '_decodeNull',
            '_decodeInt',
            '_decodeBool',
            '_decodeList',
            '_encodeComposite',
            '_encodeStr',
            '_encodeObjid',
            '_encodeTime',
            '_encodeNull',
            '_encodeInt',
            '_encodeBool'
          ];
          function Node(enc, parent) {
            var state = {};
            this._baseState = state;
            state.enc = enc;
            state.parent = parent || null;
            state.children = null;
            state.tag = null;
            state.args = null;
            state.reverseArgs = null;
            state.choice = null;
            state.optional = false;
            state.any = false;
            state.obj = false;
            state.use = null;
            state.useDecoder = null;
            state.key = null;
            state['default'] = null;
            state.explicit = null;
            state.implicit = null;
            state.contains = null;
            if (!state.parent) {
              state.children = [];
              this._wrap();
            }
          }
          module.exports = Node;
          var stateProps = [
            'enc',
            'parent',
            'children',
            'tag',
            'args',
            'reverseArgs',
            'choice',
            'optional',
            'any',
            'obj',
            'use',
            'alteredUse',
            'key',
            'default',
            'explicit',
            'implicit',
            'contains'
          ];
          Node.prototype.clone = function clone() {
            var state = this._baseState;
            var cstate = {};
            stateProps.forEach(function(prop) {
              cstate[prop] = state[prop];
            });
            var res = new this.constructor(cstate.parent);
            res._baseState = cstate;
            return res;
          };
          Node.prototype._wrap = function wrap() {
            var state = this._baseState;
            methods.forEach(function(method) {
              this[method] = function _wrappedMethod() {
                var clone = new this.constructor(this);
                state.children.push(clone);
                return clone[method].apply(clone, arguments);
              };
            }, this);
          };
          Node.prototype._init = function init(body) {
            var state = this._baseState;
            assert(state.parent === null);
            body.call(this);
            state.children = state.children.filter(function(child) {
              return child._baseState.parent === this;
            }, this);
            assert.equal(
              state.children.length,
              1,
              'Root node can have only one child'
            );
          };
          Node.prototype._useArgs = function useArgs(args) {
            var state = this._baseState;
            var children = args.filter(function(arg) {
              return arg instanceof this.constructor;
            }, this);
            args = args.filter(function(arg) {
              return !(arg instanceof this.constructor);
            }, this);
            if (children.length !== 0) {
              assert(state.children === null);
              state.children = children;
              children.forEach(function(child) {
                child._baseState.parent = this;
              }, this);
            }
            if (args.length !== 0) {
              assert(state.args === null);
              state.args = args;
              state.reverseArgs = args.map(function(arg) {
                if (typeof arg !== 'object' || arg.constructor !== Object)
                  return arg;
                var res = {};
                Object.keys(arg).forEach(function(key) {
                  if (key == (key | 0)) key |= 0;
                  var value = arg[key];
                  res[value] = key;
                });
                return res;
              });
            }
          };
          overrided.forEach(function(method) {
            Node.prototype[method] = function _overrided() {
              var state = this._baseState;
              throw new Error(
                method + ' not implemented for encoding: ' + state.enc
              );
            };
          });
          tags.forEach(function(tag) {
            Node.prototype[tag] = function _tagMethod() {
              var state = this._baseState;
              var args = Array.prototype.slice.call(arguments);
              assert(state.tag === null);
              state.tag = tag;
              this._useArgs(args);
              return this;
            };
          });
          Node.prototype.use = function use(item) {
            assert(item);
            var state = this._baseState;
            assert(state.use === null);
            state.use = item;
            return this;
          };
          Node.prototype.optional = function optional() {
            var state = this._baseState;
            state.optional = true;
            return this;
          };
          Node.prototype.def = function def(val) {
            var state = this._baseState;
            assert(state['default'] === null);
            state['default'] = val;
            state.optional = true;
            return this;
          };
          Node.prototype.explicit = function explicit(num) {
            var state = this._baseState;
            assert(state.explicit === null && state.implicit === null);
            state.explicit = num;
            return this;
          };
          Node.prototype.implicit = function implicit(num) {
            var state = this._baseState;
            assert(state.explicit === null && state.implicit === null);
            state.implicit = num;
            return this;
          };
          Node.prototype.obj = function obj() {
            var state = this._baseState;
            var args = Array.prototype.slice.call(arguments);
            state.obj = true;
            if (args.length !== 0) this._useArgs(args);
            return this;
          };
          Node.prototype.key = function key(newKey) {
            var state = this._baseState;
            assert(state.key === null);
            state.key = newKey;
            return this;
          };
          Node.prototype.any = function any() {
            var state = this._baseState;
            state.any = true;
            return this;
          };
          Node.prototype.choice = function choice(obj) {
            var state = this._baseState;
            assert(state.choice === null);
            state.choice = obj;
            this._useArgs(
              Object.keys(obj).map(function(key) {
                return obj[key];
              })
            );
            return this;
          };
          Node.prototype.contains = function contains(item) {
            var state = this._baseState;
            assert(state.use === null);
            state.contains = item;
            return this;
          };
          Node.prototype._decode = function decode(input, options) {
            var state = this._baseState;
            if (state.parent === null)
              return input.wrapResult(
                state.children[0]._decode(input, options)
              );
            var result = state['default'];
            var present = true;
            var prevKey = null;
            if (state.key !== null) prevKey = input.enterKey(state.key);
            if (state.optional) {
              var tag = null;
              if (state.explicit !== null) tag = state.explicit;
              else if (state.implicit !== null) tag = state.implicit;
              else if (state.tag !== null) tag = state.tag;
              if (tag === null && !state.any) {
                var save = input.save();
                try {
                  if (state.choice === null)
                    this._decodeGeneric(state.tag, input, options);
                  else this._decodeChoice(input, options);
                  present = true;
                } catch (e) {
                  present = false;
                }
                input.restore(save);
              } else {
                present = this._peekTag(input, tag, state.any);
                if (input.isError(present)) return present;
              }
            }
            var prevObj;
            if (state.obj && present) prevObj = input.enterObject();
            if (present) {
              if (state.explicit !== null) {
                var explicit = this._decodeTag(input, state.explicit);
                if (input.isError(explicit)) return explicit;
                input = explicit;
              }
              var start = input.offset;
              if (state.use === null && state.choice === null) {
                if (state.any) var save = input.save();
                var body = this._decodeTag(
                  input,
                  state.implicit !== null ? state.implicit : state.tag,
                  state.any
                );
                if (input.isError(body)) return body;
                if (state.any) result = input.raw(save);
                else input = body;
              }
              if (options && options.track && state.tag !== null)
                options.track(input.path(), start, input.length, 'tagged');
              if (options && options.track && state.tag !== null)
                options.track(
                  input.path(),
                  input.offset,
                  input.length,
                  'content'
                );
              if (state.any) result = result;
              else if (state.choice === null)
                result = this._decodeGeneric(state.tag, input, options);
              else result = this._decodeChoice(input, options);
              if (input.isError(result)) return result;
              if (
                !state.any &&
                state.choice === null &&
                state.children !== null
              ) {
                state.children.forEach(function decodeChildren(child) {
                  child._decode(input, options);
                });
              }
              if (
                state.contains &&
                (state.tag === 'octstr' || state.tag === 'bitstr')
              ) {
                var data = new DecoderBuffer(result);
                result = this._getUse(
                  state.contains,
                  input._reporterState.obj
                )._decode(data, options);
              }
            }
            if (state.obj && present) result = input.leaveObject(prevObj);
            if (state.key !== null && (result !== null || present === true))
              input.leaveKey(prevKey, state.key, result);
            else if (prevKey !== null) input.exitKey(prevKey);
            return result;
          };
          Node.prototype._decodeGeneric = function decodeGeneric(
            tag,
            input,
            options
          ) {
            var state = this._baseState;
            if (tag === 'seq' || tag === 'set') return null;
            if (tag === 'seqof' || tag === 'setof')
              return this._decodeList(input, tag, state.args[0], options);
            else if (/str$/.test(tag))
              return this._decodeStr(input, tag, options);
            else if (tag === 'objid' && state.args)
              return this._decodeObjid(
                input,
                state.args[0],
                state.args[1],
                options
              );
            else if (tag === 'objid')
              return this._decodeObjid(input, null, null, options);
            else if (tag === 'gentime' || tag === 'utctime')
              return this._decodeTime(input, tag, options);
            else if (tag === 'null_') return this._decodeNull(input, options);
            else if (tag === 'bool') return this._decodeBool(input, options);
            else if (tag === 'objDesc')
              return this._decodeStr(input, tag, options);
            else if (tag === 'int' || tag === 'enum')
              return this._decodeInt(
                input,
                state.args && state.args[0],
                options
              );
            if (state.use !== null) {
              return this._getUse(state.use, input._reporterState.obj)._decode(
                input,
                options
              );
            } else {
              return input.error('unknown tag: ' + tag);
            }
          };
          Node.prototype._getUse = function _getUse(entity, obj) {
            var state = this._baseState;
            state.useDecoder = this._use(entity, obj);
            assert(state.useDecoder._baseState.parent === null);
            state.useDecoder = state.useDecoder._baseState.children[0];
            if (state.implicit !== state.useDecoder._baseState.implicit) {
              state.useDecoder = state.useDecoder.clone();
              state.useDecoder._baseState.implicit = state.implicit;
            }
            return state.useDecoder;
          };
          Node.prototype._decodeChoice = function decodeChoice(input, options) {
            var state = this._baseState;
            var result = null;
            var match = false;
            Object.keys(state.choice).some(function(key) {
              var save = input.save();
              var node = state.choice[key];
              try {
                var value = node._decode(input, options);
                if (input.isError(value)) return false;
                result = { type: key, value: value };
                match = true;
              } catch (e) {
                input.restore(save);
                return false;
              }
              return true;
            }, this);
            if (!match) return input.error('Choice not matched');
            return result;
          };
          Node.prototype._createEncoderBuffer = function createEncoderBuffer(
            data
          ) {
            return new EncoderBuffer(data, this.reporter);
          };
          Node.prototype._encode = function encode(data, reporter, parent) {
            var state = this._baseState;
            if (state['default'] !== null && state['default'] === data) return;
            var result = this._encodeValue(data, reporter, parent);
            if (result === undefined) return;
            if (this._skipDefault(result, reporter, parent)) return;
            return result;
          };
          Node.prototype._encodeValue = function encode(
            data,
            reporter,
            parent
          ) {
            var state = this._baseState;
            if (state.parent === null)
              return state.children[0]._encode(
                data,
                reporter || new Reporter()
              );
            var result = null;
            this.reporter = reporter;
            if (state.optional && data === undefined) {
              if (state['default'] !== null) data = state['default'];
              else return;
            }
            var content = null;
            var primitive = false;
            if (state.any) {
              result = this._createEncoderBuffer(data);
            } else if (state.choice) {
              result = this._encodeChoice(data, reporter);
            } else if (state.contains) {
              content = this._getUse(state.contains, parent)._encode(
                data,
                reporter
              );
              primitive = true;
            } else if (state.children) {
              content = state.children
                .map(function(child) {
                  if (child._baseState.tag === 'null_')
                    return child._encode(null, reporter, data);
                  if (child._baseState.key === null)
                    return reporter.error('Child should have a key');
                  var prevKey = reporter.enterKey(child._baseState.key);
                  if (typeof data !== 'object')
                    return reporter.error(
                      'Child expected, but input is not object'
                    );
                  var res = child._encode(
                    data[child._baseState.key],
                    reporter,
                    data
                  );
                  reporter.leaveKey(prevKey);
                  return res;
                }, this)
                .filter(function(child) {
                  return child;
                });
              content = this._createEncoderBuffer(content);
            } else {
              if (state.tag === 'seqof' || state.tag === 'setof') {
                if (!(state.args && state.args.length === 1))
                  return reporter.error('Too many args for : ' + state.tag);
                if (!Array.isArray(data))
                  return reporter.error('seqof/setof, but data is not Array');
                var child = this.clone();
                child._baseState.implicit = null;
                content = this._createEncoderBuffer(
                  data.map(function(item) {
                    var state = this._baseState;
                    return this._getUse(state.args[0], data)._encode(
                      item,
                      reporter
                    );
                  }, child)
                );
              } else if (state.use !== null) {
                result = this._getUse(state.use, parent)._encode(
                  data,
                  reporter
                );
              } else {
                content = this._encodePrimitive(state.tag, data);
                primitive = true;
              }
            }
            var result;
            if (!state.any && state.choice === null) {
              var tag = state.implicit !== null ? state.implicit : state.tag;
              var cls = state.implicit === null ? 'universal' : 'context';
              if (tag === null) {
                if (state.use === null)
                  reporter.error('Tag could be ommited only for .use()');
              } else {
                if (state.use === null)
                  result = this._encodeComposite(tag, primitive, cls, content);
              }
            }
            if (state.explicit !== null)
              result = this._encodeComposite(
                state.explicit,
                false,
                'context',
                result
              );
            return result;
          };
          Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
            var state = this._baseState;
            var node = state.choice[data.type];
            if (!node) {
              assert(
                false,
                data.type +
                  ' not found in ' +
                  JSON.stringify(Object.keys(state.choice))
              );
            }
            return node._encode(data.value, reporter);
          };
          Node.prototype._encodePrimitive = function encodePrimitive(
            tag,
            data
          ) {
            var state = this._baseState;
            if (/str$/.test(tag)) return this._encodeStr(data, tag);
            else if (tag === 'objid' && state.args)
              return this._encodeObjid(
                data,
                state.reverseArgs[0],
                state.args[1]
              );
            else if (tag === 'objid')
              return this._encodeObjid(data, null, null);
            else if (tag === 'gentime' || tag === 'utctime')
              return this._encodeTime(data, tag);
            else if (tag === 'null_') return this._encodeNull();
            else if (tag === 'int' || tag === 'enum')
              return this._encodeInt(data, state.args && state.reverseArgs[0]);
            else if (tag === 'bool') return this._encodeBool(data);
            else if (tag === 'objDesc') return this._encodeStr(data, tag);
            else throw new Error('Unsupported tag: ' + tag);
          };
          Node.prototype._isNumstr = function isNumstr(str) {
            return /^[0-9 ]*$/.test(str);
          };
          Node.prototype._isPrintstr = function isPrintstr(str) {
            return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(str);
          };
        },
        { '../base': 140, 'minimalistic-assert': 211 }
      ],
      142: [
        function(require, module, exports) {
          arguments[4][57][0].apply(exports, arguments);
        },
        { dup: 57, inherits: 207 }
      ],
      143: [
        function(require, module, exports) {
          arguments[4][58][0].apply(exports, arguments);
        },
        { '../constants': 144, dup: 58 }
      ],
      144: [
        function(require, module, exports) {
          arguments[4][59][0].apply(exports, arguments);
        },
        { './der': 143, dup: 59 }
      ],
      145: [
        function(require, module, exports) {
          arguments[4][60][0].apply(exports, arguments);
        },
        { '../../asn1': 137, dup: 60, inherits: 207 }
      ],
      146: [
        function(require, module, exports) {
          arguments[4][61][0].apply(exports, arguments);
        },
        { './der': 145, './pem': 147, dup: 61 }
      ],
      147: [
        function(require, module, exports) {
          arguments[4][62][0].apply(exports, arguments);
        },
        { './der': 145, buffer: 183, dup: 62, inherits: 207 }
      ],
      148: [
        function(require, module, exports) {
          arguments[4][63][0].apply(exports, arguments);
        },
        { '../../asn1': 137, buffer: 183, dup: 63, inherits: 207 }
      ],
      149: [
        function(require, module, exports) {
          arguments[4][64][0].apply(exports, arguments);
        },
        { './der': 148, './pem': 150, dup: 64 }
      ],
      150: [
        function(require, module, exports) {
          arguments[4][65][0].apply(exports, arguments);
        },
        { './der': 148, dup: 65, inherits: 207 }
      ],
      151: [
        function(require, module, exports) {
          (function(global) {
            'use strict';
            function compare(a, b) {
              if (a === b) {
                return 0;
              }
              var x = a.length;
              var y = b.length;
              for (var i = 0, len = Math.min(x, y); i < len; ++i) {
                if (a[i] !== b[i]) {
                  x = a[i];
                  y = b[i];
                  break;
                }
              }
              if (x < y) {
                return -1;
              }
              if (y < x) {
                return 1;
              }
              return 0;
            }
            function isBuffer(b) {
              if (
                global.Buffer &&
                typeof global.Buffer.isBuffer === 'function'
              ) {
                return global.Buffer.isBuffer(b);
              }
              return !!(b != null && b._isBuffer);
            }
            var util = require('util/');
            var hasOwn = Object.prototype.hasOwnProperty;
            var pSlice = Array.prototype.slice;
            var functionsHaveNames = (function() {
              return function foo() {}.name === 'foo';
            })();
            function pToString(obj) {
              return Object.prototype.toString.call(obj);
            }
            function isView(arrbuf) {
              if (isBuffer(arrbuf)) {
                return false;
              }
              if (typeof global.ArrayBuffer !== 'function') {
                return false;
              }
              if (typeof ArrayBuffer.isView === 'function') {
                return ArrayBuffer.isView(arrbuf);
              }
              if (!arrbuf) {
                return false;
              }
              if (arrbuf instanceof DataView) {
                return true;
              }
              if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
                return true;
              }
              return false;
            }
            var assert = (module.exports = ok);
            var regex = /\s*function\s+([^\(\s]*)\s*/;
            function getName(func) {
              if (!util.isFunction(func)) {
                return;
              }
              if (functionsHaveNames) {
                return func.name;
              }
              var str = func.toString();
              var match = str.match(regex);
              return match && match[1];
            }
            assert.AssertionError = function AssertionError(options) {
              this.name = 'AssertionError';
              this.actual = options.actual;
              this.expected = options.expected;
              this.operator = options.operator;
              if (options.message) {
                this.message = options.message;
                this.generatedMessage = false;
              } else {
                this.message = getMessage(this);
                this.generatedMessage = true;
              }
              var stackStartFunction = options.stackStartFunction || fail;
              if (Error.captureStackTrace) {
                Error.captureStackTrace(this, stackStartFunction);
              } else {
                var err = new Error();
                if (err.stack) {
                  var out = err.stack;
                  var fn_name = getName(stackStartFunction);
                  var idx = out.indexOf('\n' + fn_name);
                  if (idx >= 0) {
                    var next_line = out.indexOf('\n', idx + 1);
                    out = out.substring(next_line + 1);
                  }
                  this.stack = out;
                }
              }
            };
            util.inherits(assert.AssertionError, Error);
            function truncate(s, n) {
              if (typeof s === 'string') {
                return s.length < n ? s : s.slice(0, n);
              } else {
                return s;
              }
            }
            function inspect(something) {
              if (functionsHaveNames || !util.isFunction(something)) {
                return util.inspect(something);
              }
              var rawname = getName(something);
              var name = rawname ? ': ' + rawname : '';
              return '[Function' + name + ']';
            }
            function getMessage(self) {
              return (
                truncate(inspect(self.actual), 128) +
                ' ' +
                self.operator +
                ' ' +
                truncate(inspect(self.expected), 128)
              );
            }
            function fail(
              actual,
              expected,
              message,
              operator,
              stackStartFunction
            ) {
              throw new assert.AssertionError({
                message: message,
                actual: actual,
                expected: expected,
                operator: operator,
                stackStartFunction: stackStartFunction
              });
            }
            assert.fail = fail;
            function ok(value, message) {
              if (!value) fail(value, true, message, '==', assert.ok);
            }
            assert.ok = ok;
            assert.equal = function equal(actual, expected, message) {
              if (actual != expected)
                fail(actual, expected, message, '==', assert.equal);
            };
            assert.notEqual = function notEqual(actual, expected, message) {
              if (actual == expected) {
                fail(actual, expected, message, '!=', assert.notEqual);
              }
            };
            assert.deepEqual = function deepEqual(actual, expected, message) {
              if (!_deepEqual(actual, expected, false)) {
                fail(actual, expected, message, 'deepEqual', assert.deepEqual);
              }
            };
            assert.deepStrictEqual = function deepStrictEqual(
              actual,
              expected,
              message
            ) {
              if (!_deepEqual(actual, expected, true)) {
                fail(
                  actual,
                  expected,
                  message,
                  'deepStrictEqual',
                  assert.deepStrictEqual
                );
              }
            };
            function _deepEqual(actual, expected, strict, memos) {
              if (actual === expected) {
                return true;
              } else if (isBuffer(actual) && isBuffer(expected)) {
                return compare(actual, expected) === 0;
              } else if (util.isDate(actual) && util.isDate(expected)) {
                return actual.getTime() === expected.getTime();
              } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
                return (
                  actual.source === expected.source &&
                  actual.global === expected.global &&
                  actual.multiline === expected.multiline &&
                  actual.lastIndex === expected.lastIndex &&
                  actual.ignoreCase === expected.ignoreCase
                );
              } else if (
                (actual === null || typeof actual !== 'object') &&
                (expected === null || typeof expected !== 'object')
              ) {
                return strict ? actual === expected : actual == expected;
              } else if (
                isView(actual) &&
                isView(expected) &&
                pToString(actual) === pToString(expected) &&
                !(
                  actual instanceof Float32Array ||
                  actual instanceof Float64Array
                )
              ) {
                return (
                  compare(
                    new Uint8Array(actual.buffer),
                    new Uint8Array(expected.buffer)
                  ) === 0
                );
              } else if (isBuffer(actual) !== isBuffer(expected)) {
                return false;
              } else {
                memos = memos || { actual: [], expected: [] };
                var actualIndex = memos.actual.indexOf(actual);
                if (actualIndex !== -1) {
                  if (actualIndex === memos.expected.indexOf(expected)) {
                    return true;
                  }
                }
                memos.actual.push(actual);
                memos.expected.push(expected);
                return objEquiv(actual, expected, strict, memos);
              }
            }
            function isArguments(object) {
              return (
                Object.prototype.toString.call(object) == '[object Arguments]'
              );
            }
            function objEquiv(a, b, strict, actualVisitedObjects) {
              if (
                a === null ||
                a === undefined ||
                b === null ||
                b === undefined
              )
                return false;
              if (util.isPrimitive(a) || util.isPrimitive(b)) return a === b;
              if (
                strict &&
                Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)
              )
                return false;
              var aIsArgs = isArguments(a);
              var bIsArgs = isArguments(b);
              if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs)) return false;
              if (aIsArgs) {
                a = pSlice.call(a);
                b = pSlice.call(b);
                return _deepEqual(a, b, strict);
              }
              var ka = objectKeys(a);
              var kb = objectKeys(b);
              var key, i;
              if (ka.length !== kb.length) return false;
              ka.sort();
              kb.sort();
              for (i = ka.length - 1; i >= 0; i--) {
                if (ka[i] !== kb[i]) return false;
              }
              for (i = ka.length - 1; i >= 0; i--) {
                key = ka[i];
                if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
                  return false;
              }
              return true;
            }
            assert.notDeepEqual = function notDeepEqual(
              actual,
              expected,
              message
            ) {
              if (_deepEqual(actual, expected, false)) {
                fail(
                  actual,
                  expected,
                  message,
                  'notDeepEqual',
                  assert.notDeepEqual
                );
              }
            };
            assert.notDeepStrictEqual = notDeepStrictEqual;
            function notDeepStrictEqual(actual, expected, message) {
              if (_deepEqual(actual, expected, true)) {
                fail(
                  actual,
                  expected,
                  message,
                  'notDeepStrictEqual',
                  notDeepStrictEqual
                );
              }
            }
            assert.strictEqual = function strictEqual(
              actual,
              expected,
              message
            ) {
              if (actual !== expected) {
                fail(actual, expected, message, '===', assert.strictEqual);
              }
            };
            assert.notStrictEqual = function notStrictEqual(
              actual,
              expected,
              message
            ) {
              if (actual === expected) {
                fail(actual, expected, message, '!==', assert.notStrictEqual);
              }
            };
            function expectedException(actual, expected) {
              if (!actual || !expected) {
                return false;
              }
              if (
                Object.prototype.toString.call(expected) == '[object RegExp]'
              ) {
                return expected.test(actual);
              }
              try {
                if (actual instanceof expected) {
                  return true;
                }
              } catch (e) {}
              if (Error.isPrototypeOf(expected)) {
                return false;
              }
              return expected.call({}, actual) === true;
            }
            function _tryBlock(block) {
              var error;
              try {
                block();
              } catch (e) {
                error = e;
              }
              return error;
            }
            function _throws(shouldThrow, block, expected, message) {
              var actual;
              if (typeof block !== 'function') {
                throw new TypeError('"block" argument must be a function');
              }
              if (typeof expected === 'string') {
                message = expected;
                expected = null;
              }
              actual = _tryBlock(block);
              message =
                (expected && expected.name
                  ? ' (' + expected.name + ').'
                  : '.') + (message ? ' ' + message : '.');
              if (shouldThrow && !actual) {
                fail(actual, expected, 'Missing expected exception' + message);
              }
              var userProvidedMessage = typeof message === 'string';
              var isUnwantedException = !shouldThrow && util.isError(actual);
              var isUnexpectedException = !shouldThrow && actual && !expected;
              if (
                (isUnwantedException &&
                  userProvidedMessage &&
                  expectedException(actual, expected)) ||
                isUnexpectedException
              ) {
                fail(actual, expected, 'Got unwanted exception' + message);
              }
              if (
                (shouldThrow &&
                  actual &&
                  expected &&
                  !expectedException(actual, expected)) ||
                (!shouldThrow && actual)
              ) {
                throw actual;
              }
            }
            assert.throws = function(block, error, message) {
              _throws(true, block, error, message);
            };
            assert.doesNotThrow = function(block, error, message) {
              _throws(false, block, error, message);
            };
            assert.ifError = function(err) {
              if (err) throw err;
            };
            var objectKeys =
              Object.keys ||
              function(obj) {
                var keys = [];
                for (var key in obj) {
                  if (hasOwn.call(obj, key)) keys.push(key);
                }
                return keys;
              };
          }.call(
            this,
            typeof global !== 'undefined'
              ? global
              : typeof self !== 'undefined'
              ? self
              : typeof window !== 'undefined'
              ? window
              : {}
          ));
        },
        { 'util/': 265 }
      ],
      152: [
        function(require, module, exports) {
          'use strict';
          exports.byteLength = byteLength;
          exports.toByteArray = toByteArray;
          exports.fromByteArray = fromByteArray;
          var lookup = [];
          var revLookup = [];
          var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
          var code =
            'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
          for (var i = 0, len = code.length; i < len; ++i) {
            lookup[i] = code[i];
            revLookup[code.charCodeAt(i)] = i;
          }
          revLookup['-'.charCodeAt(0)] = 62;
          revLookup['_'.charCodeAt(0)] = 63;
          function placeHoldersCount(b64) {
            var len = b64.length;
            if (len % 4 > 0) {
              throw new Error('Invalid string. Length must be a multiple of 4');
            }
            return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;
          }
          function byteLength(b64) {
            return (b64.length * 3) / 4 - placeHoldersCount(b64);
          }
          function toByteArray(b64) {
            var i, l, tmp, placeHolders, arr;
            var len = b64.length;
            placeHolders = placeHoldersCount(b64);
            arr = new Arr((len * 3) / 4 - placeHolders);
            l = placeHolders > 0 ? len - 4 : len;
            var L = 0;
            for (i = 0; i < l; i += 4) {
              tmp =
                (revLookup[b64.charCodeAt(i)] << 18) |
                (revLookup[b64.charCodeAt(i + 1)] << 12) |
                (revLookup[b64.charCodeAt(i + 2)] << 6) |
                revLookup[b64.charCodeAt(i + 3)];
              arr[L++] = (tmp >> 16) & 255;
              arr[L++] = (tmp >> 8) & 255;
              arr[L++] = tmp & 255;
            }
            if (placeHolders === 2) {
              tmp =
                (revLookup[b64.charCodeAt(i)] << 2) |
                (revLookup[b64.charCodeAt(i + 1)] >> 4);
              arr[L++] = tmp & 255;
            } else if (placeHolders === 1) {
              tmp =
                (revLookup[b64.charCodeAt(i)] << 10) |
                (revLookup[b64.charCodeAt(i + 1)] << 4) |
                (revLookup[b64.charCodeAt(i + 2)] >> 2);
              arr[L++] = (tmp >> 8) & 255;
              arr[L++] = tmp & 255;
            }
            return arr;
          }
          function tripletToBase64(num) {
            return (
              lookup[(num >> 18) & 63] +
              lookup[(num >> 12) & 63] +
              lookup[(num >> 6) & 63] +
              lookup[num & 63]
            );
          }
          function encodeChunk(uint8, start, end) {
            var tmp;
            var output = [];
            for (var i = start; i < end; i += 3) {
              tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
              output.push(tripletToBase64(tmp));
            }
            return output.join('');
          }
          function fromByteArray(uint8) {
            var tmp;
            var len = uint8.length;
            var extraBytes = len % 3;
            var output = '';
            var parts = [];
            var maxChunkLength = 16383;
            for (
              var i = 0, len2 = len - extraBytes;
              i < len2;
              i += maxChunkLength
            ) {
              parts.push(
                encodeChunk(
                  uint8,
                  i,
                  i + maxChunkLength > len2 ? len2 : i + maxChunkLength
                )
              );
            }
            if (extraBytes === 1) {
              tmp = uint8[len - 1];
              output += lookup[tmp >> 2];
              output += lookup[(tmp << 4) & 63];
              output += '==';
            } else if (extraBytes === 2) {
              tmp = (uint8[len - 2] << 8) + uint8[len - 1];
              output += lookup[tmp >> 10];
              output += lookup[(tmp >> 4) & 63];
              output += lookup[(tmp << 2) & 63];
              output += '=';
            }
            parts.push(output);
            return parts.join('');
          }
        },
        {}
      ],
      153: [
        function(require, module, exports) {
          arguments[4][134][0].apply(exports, arguments);
        },
        { buffer: 155, dup: 134 }
      ],
      154: [
        function(require, module, exports) {
          arguments[4][136][0].apply(exports, arguments);
        },
        { crypto: 155, dup: 136 }
      ],
      155: [function(require, module, exports) {}, {}],
      156: [
        function(require, module, exports) {
          var Buffer = require('safe-buffer').Buffer;
          function asUInt32Array(buf) {
            if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
            var len = (buf.length / 4) | 0;
            var out = new Array(len);
            for (var i = 0; i < len; i++) {
              out[i] = buf.readUInt32BE(i * 4);
            }
            return out;
          }
          function scrubVec(v) {
            for (var i = 0; i < v.length; v++) {
              v[i] = 0;
            }
          }
          function cryptBlock(M, keySchedule, SUB_MIX, SBOX, nRounds) {
            var SUB_MIX0 = SUB_MIX[0];
            var SUB_MIX1 = SUB_MIX[1];
            var SUB_MIX2 = SUB_MIX[2];
            var SUB_MIX3 = SUB_MIX[3];
            var s0 = M[0] ^ keySchedule[0];
            var s1 = M[1] ^ keySchedule[1];
            var s2 = M[2] ^ keySchedule[2];
            var s3 = M[3] ^ keySchedule[3];
            var t0, t1, t2, t3;
            var ksRow = 4;
            for (var round = 1; round < nRounds; round++) {
              t0 =
                SUB_MIX0[s0 >>> 24] ^
                SUB_MIX1[(s1 >>> 16) & 255] ^
                SUB_MIX2[(s2 >>> 8) & 255] ^
                SUB_MIX3[s3 & 255] ^
                keySchedule[ksRow++];
              t1 =
                SUB_MIX0[s1 >>> 24] ^
                SUB_MIX1[(s2 >>> 16) & 255] ^
                SUB_MIX2[(s3 >>> 8) & 255] ^
                SUB_MIX3[s0 & 255] ^
                keySchedule[ksRow++];
              t2 =
                SUB_MIX0[s2 >>> 24] ^
                SUB_MIX1[(s3 >>> 16) & 255] ^
                SUB_MIX2[(s0 >>> 8) & 255] ^
                SUB_MIX3[s1 & 255] ^
                keySchedule[ksRow++];
              t3 =
                SUB_MIX0[s3 >>> 24] ^
                SUB_MIX1[(s0 >>> 16) & 255] ^
                SUB_MIX2[(s1 >>> 8) & 255] ^
                SUB_MIX3[s2 & 255] ^
                keySchedule[ksRow++];
              s0 = t0;
              s1 = t1;
              s2 = t2;
              s3 = t3;
            }
            t0 =
              ((SBOX[s0 >>> 24] << 24) |
                (SBOX[(s1 >>> 16) & 255] << 16) |
                (SBOX[(s2 >>> 8) & 255] << 8) |
                SBOX[s3 & 255]) ^
              keySchedule[ksRow++];
            t1 =
              ((SBOX[s1 >>> 24] << 24) |
                (SBOX[(s2 >>> 16) & 255] << 16) |
                (SBOX[(s3 >>> 8) & 255] << 8) |
                SBOX[s0 & 255]) ^
              keySchedule[ksRow++];
            t2 =
              ((SBOX[s2 >>> 24] << 24) |
                (SBOX[(s3 >>> 16) & 255] << 16) |
                (SBOX[(s0 >>> 8) & 255] << 8) |
                SBOX[s1 & 255]) ^
              keySchedule[ksRow++];
            t3 =
              ((SBOX[s3 >>> 24] << 24) |
                (SBOX[(s0 >>> 16) & 255] << 16) |
                (SBOX[(s1 >>> 8) & 255] << 8) |
                SBOX[s2 & 255]) ^
              keySchedule[ksRow++];
            t0 = t0 >>> 0;
            t1 = t1 >>> 0;
            t2 = t2 >>> 0;
            t3 = t3 >>> 0;
            return [t0, t1, t2, t3];
          }
          var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
          var G = (function() {
            var d = new Array(256);
            for (var j = 0; j < 256; j++) {
              if (j < 128) {
                d[j] = j << 1;
              } else {
                d[j] = (j << 1) ^ 283;
              }
            }
            var SBOX = [];
            var INV_SBOX = [];
            var SUB_MIX = [[], [], [], []];
            var INV_SUB_MIX = [[], [], [], []];
            var x = 0;
            var xi = 0;
            for (var i = 0; i < 256; ++i) {
              var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
              sx = (sx >>> 8) ^ (sx & 255) ^ 99;
              SBOX[x] = sx;
              INV_SBOX[sx] = x;
              var x2 = d[x];
              var x4 = d[x2];
              var x8 = d[x4];
              var t = (d[sx] * 257) ^ (sx * 16843008);
              SUB_MIX[0][x] = (t << 24) | (t >>> 8);
              SUB_MIX[1][x] = (t << 16) | (t >>> 16);
              SUB_MIX[2][x] = (t << 8) | (t >>> 24);
              SUB_MIX[3][x] = t;
              t = (x8 * 16843009) ^ (x4 * 65537) ^ (x2 * 257) ^ (x * 16843008);
              INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8);
              INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16);
              INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24);
              INV_SUB_MIX[3][sx] = t;
              if (x === 0) {
                x = xi = 1;
              } else {
                x = x2 ^ d[d[d[x8 ^ x2]]];
                xi ^= d[d[xi]];
              }
            }
            return {
              SBOX: SBOX,
              INV_SBOX: INV_SBOX,
              SUB_MIX: SUB_MIX,
              INV_SUB_MIX: INV_SUB_MIX
            };
          })();
          function AES(key) {
            this._key = asUInt32Array(key);
            this._reset();
          }
          AES.blockSize = 4 * 4;
          AES.keySize = 256 / 8;
          AES.prototype.blockSize = AES.blockSize;
          AES.prototype.keySize = AES.keySize;
          AES.prototype._reset = function() {
            var keyWords = this._key;
            var keySize = keyWords.length;
            var nRounds = keySize + 6;
            var ksRows = (nRounds + 1) * 4;
            var keySchedule = [];
            for (var k = 0; k < keySize; k++) {
              keySchedule[k] = keyWords[k];
            }
            for (k = keySize; k < ksRows; k++) {
              var t = keySchedule[k - 1];
              if (k % keySize === 0) {
                t = (t << 8) | (t >>> 24);
                t =
                  (G.SBOX[t >>> 24] << 24) |
                  (G.SBOX[(t >>> 16) & 255] << 16) |
                  (G.SBOX[(t >>> 8) & 255] << 8) |
                  G.SBOX[t & 255];
                t ^= RCON[(k / keySize) | 0] << 24;
              } else if (keySize > 6 && k % keySize === 4) {
                t =
                  (G.SBOX[t >>> 24] << 24) |
                  (G.SBOX[(t >>> 16) & 255] << 16) |
                  (G.SBOX[(t >>> 8) & 255] << 8) |
                  G.SBOX[t & 255];
              }
              keySchedule[k] = keySchedule[k - keySize] ^ t;
            }
            var invKeySchedule = [];
            for (var ik = 0; ik < ksRows; ik++) {
              var ksR = ksRows - ik;
              var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)];
              if (ik < 4 || ksR <= 4) {
                invKeySchedule[ik] = tt;
              } else {
                invKeySchedule[ik] =
                  G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^
                  G.INV_SUB_MIX[1][G.SBOX[(tt >>> 16) & 255]] ^
                  G.INV_SUB_MIX[2][G.SBOX[(tt >>> 8) & 255]] ^
                  G.INV_SUB_MIX[3][G.SBOX[tt & 255]];
              }
            }
            this._nRounds = nRounds;
            this._keySchedule = keySchedule;
            this._invKeySchedule = invKeySchedule;
          };
          AES.prototype.encryptBlockRaw = function(M) {
            M = asUInt32Array(M);
            return cryptBlock(
              M,
              this._keySchedule,
              G.SUB_MIX,
              G.SBOX,
              this._nRounds
            );
          };
          AES.prototype.encryptBlock = function(M) {
            var out = this.encryptBlockRaw(M);
            var buf = Buffer.allocUnsafe(16);
            buf.writeUInt32BE(out[0], 0);
            buf.writeUInt32BE(out[1], 4);
            buf.writeUInt32BE(out[2], 8);
            buf.writeUInt32BE(out[3], 12);
            return buf;
          };
          AES.prototype.decryptBlock = function(M) {
            M = asUInt32Array(M);
            var m1 = M[1];
            M[1] = M[3];
            M[3] = m1;
            var out = cryptBlock(
              M,
              this._invKeySchedule,
              G.INV_SUB_MIX,
              G.INV_SBOX,
              this._nRounds
            );
            var buf = Buffer.allocUnsafe(16);
            buf.writeUInt32BE(out[0], 0);
            buf.writeUInt32BE(out[3], 4);
            buf.writeUInt32BE(out[2], 8);
            buf.writeUInt32BE(out[1], 12);
            return buf;
          };
          AES.prototype.scrub = function() {
            scrubVec(this._keySchedule);
            scrubVec(this._invKeySchedule);
            scrubVec(this._key);
          };
          module.exports.AES = AES;
        },
        { 'safe-buffer': 460 }
      ],
      157: [
        function(require, module, exports) {
          var aes = require('./aes');
          var Buffer = require('safe-buffer').Buffer;
          var Transform = require('cipher-base');
          var inherits = require('inherits');
          var GHASH = require('./ghash');
          var xor = require('buffer-xor');
          function xorTest(a, b) {
            var out = 0;
            if (a.length !== b.length) out++;
            var len = Math.min(a.length, b.length);
            for (var i = 0; i < len; ++i) {
              out += a[i] ^ b[i];
            }
            return out;
          }
          function StreamCipher(mode, key, iv, decrypt) {
            Transform.call(this);
            this._finID = Buffer.concat([iv, Buffer.from([0, 0, 0, 1])]);
            iv = Buffer.concat([iv, Buffer.from([0, 0, 0, 2])]);
            this._cipher = new aes.AES(key);
            this._prev = Buffer.from(iv);
            this._cache = Buffer.allocUnsafe(0);
            this._secCache = Buffer.allocUnsafe(0);
            this._decrypt = decrypt;
            this._alen = 0;
            this._len = 0;
            this._mode = mode;
            var h = Buffer.alloc(4, 0);
            this._ghash = new GHASH(this._cipher.encryptBlock(h));
            this._authTag = null;
            this._called = false;
          }
          inherits(StreamCipher, Transform);
          StreamCipher.prototype._update = function(chunk) {
            if (!this._called && this._alen) {
              var rump = 16 - (this._alen % 16);
              if (rump < 16) {
                rump = Buffer.alloc(rump, 0);
                this._ghash.update(rump);
              }
            }
            this._called = true;
            var out = this._mode.encrypt(this, chunk);
            if (this._decrypt) {
              this._ghash.update(chunk);
            } else {
              this._ghash.update(out);
            }
            this._len += chunk.length;
            return out;
          };
          StreamCipher.prototype._final = function() {
            if (this._decrypt && !this._authTag)
              throw new Error(
                'Unsupported state or unable to authenticate data'
              );
            var tag = xor(
              this._ghash.final(this._alen * 8, this._len * 8),
              this._cipher.encryptBlock(this._finID)
            );
            if (this._decrypt && xorTest(tag, this._authTag))
              throw new Error(
                'Unsupported state or unable to authenticate data'
              );
            this._authTag = tag;
            this._cipher.scrub();
          };
          StreamCipher.prototype.getAuthTag = function getAuthTag() {
            if (this._decrypt || !Buffer.isBuffer(this._authTag))
              throw new Error(
                'Attempting to get auth tag in unsupported state'
              );
            return this._authTag;
          };
          StreamCipher.prototype.setAuthTag = function setAuthTag(tag) {
            if (!this._decrypt)
              throw new Error(
                'Attempting to set auth tag in unsupported state'
              );
            this._authTag = tag;
          };
          StreamCipher.prototype.setAAD = function setAAD(buf) {
            if (this._called)
              throw new Error('Attempting to set AAD in unsupported state');
            this._ghash.update(buf);
            this._alen += buf.length;
          };
          module.exports = StreamCipher;
        },
        {
          './aes': 156,
          './ghash': 161,
          'buffer-xor': 182,
          'cipher-base': 184,
          inherits: 207,
          'safe-buffer': 460
        }
      ],
      158: [
        function(require, module, exports) {
          var ciphers = require('./encrypter');
          var deciphers = require('./decrypter');
          var modes = require('./modes/list.json');
          function getCiphers() {
            return Object.keys(modes);
          }
          exports.createCipher = exports.Cipher = ciphers.createCipher;
          exports.createCipheriv = exports.Cipheriv = ciphers.createCipheriv;
          exports.createDecipher = exports.Decipher = deciphers.createDecipher;
          exports.createDecipheriv = exports.Decipheriv =
            deciphers.createDecipheriv;
          exports.listCiphers = exports.getCiphers = getCiphers;
        },
        { './decrypter': 159, './encrypter': 160, './modes/list.json': 169 }
      ],
      159: [
        function(require, module, exports) {
          var AuthCipher = require('./authCipher');
          var Buffer = require('safe-buffer').Buffer;
          var MODES = require('./modes');
          var StreamCipher = require('./streamCipher');
          var Transform = require('cipher-base');
          var aes = require('./aes');
          var ebtk = require('evp_bytestokey');
          var inherits = require('inherits');
          function Decipher(mode, key, iv) {
            Transform.call(this);
            this._cache = new Splitter();
            this._last = void 0;
            this._cipher = new aes.AES(key);
            this._prev = Buffer.from(iv);
            this._mode = mode;
            this._autopadding = true;
          }
          inherits(Decipher, Transform);
          Decipher.prototype._update = function(data) {
            this._cache.add(data);
            var chunk;
            var thing;
            var out = [];
            while ((chunk = this._cache.get(this._autopadding))) {
              thing = this._mode.decrypt(this, chunk);
              out.push(thing);
            }
            return Buffer.concat(out);
          };
          Decipher.prototype._final = function() {
            var chunk = this._cache.flush();
            if (this._autopadding) {
              return unpad(this._mode.decrypt(this, chunk));
            } else if (chunk) {
              throw new Error('data not multiple of block length');
            }
          };
          Decipher.prototype.setAutoPadding = function(setTo) {
            this._autopadding = !!setTo;
            return this;
          };
          function Splitter() {
            this.cache = Buffer.allocUnsafe(0);
          }
          Splitter.prototype.add = function(data) {
            this.cache = Buffer.concat([this.cache, data]);
          };
          Splitter.prototype.get = function(autoPadding) {
            var out;
            if (autoPadding) {
              if (this.cache.length > 16) {
                out = this.cache.slice(0, 16);
                this.cache = this.cache.slice(16);
                return out;
              }
            } else {
              if (this.cache.length >= 16) {
                out = this.cache.slice(0, 16);
                this.cache = this.cache.slice(16);
                return out;
              }
            }
            return null;
          };
          Splitter.prototype.flush = function() {
            if (this.cache.length) return this.cache;
          };
          function unpad(last) {
            var padded = last[15];
            var i = -1;
            while (++i < padded) {
              if (last[i + (16 - padded)] !== padded) {
                throw new Error('unable to decrypt data');
              }
            }
            if (padded === 16) return;
            return last.slice(0, 16 - padded);
          }
          function createDecipheriv(suite, password, iv) {
            var config = MODES[suite.toLowerCase()];
            if (!config) throw new TypeError('invalid suite type');
            if (typeof iv === 'string') iv = Buffer.from(iv);
            if (iv.length !== config.iv)
              throw new TypeError('invalid iv length ' + iv.length);
            if (typeof password === 'string') password = Buffer.from(password);
            if (password.length !== config.key / 8)
              throw new TypeError('invalid key length ' + password.length);
            if (config.type === 'stream') {
              return new StreamCipher(config.module, password, iv, true);
            } else if (config.type === 'auth') {
              return new AuthCipher(config.module, password, iv, true);
            }
            return new Decipher(config.module, password, iv);
          }
          function createDecipher(suite, password) {
            var config = MODES[suite.toLowerCase()];
            if (!config) throw new TypeError('invalid suite type');
            var keys = ebtk(password, false, config.key, config.iv);
            return createDecipheriv(suite, keys.key, keys.iv);
          }
          exports.createDecipher = createDecipher;
          exports.createDecipheriv = createDecipheriv;
        },
        {
          './aes': 156,
          './authCipher': 157,
          './modes': 168,
          './streamCipher': 171,
          'cipher-base': 184,
          evp_bytestokey: 204,
          inherits: 207,
          'safe-buffer': 460
        }
      ],
      160: [
        function(require, module, exports) {
          var MODES = require('./modes');
          var AuthCipher = require('./authCipher');
          var Buffer = require('safe-buffer').Buffer;
          var StreamCipher = require('./streamCipher');
          var Transform = require('cipher-base');
          var aes = require('./aes');
          var ebtk = require('evp_bytestokey');
          var inherits = require('inherits');
          function Cipher(mode, key, iv) {
            Transform.call(this);
            this._cache = new Splitter();
            this._cipher = new aes.AES(key);
            this._prev = Buffer.from(iv);
            this._mode = mode;
            this._autopadding = true;
          }
          inherits(Cipher, Transform);
          Cipher.prototype._update = function(data) {
            this._cache.add(data);
            var chunk;
            var thing;
            var out = [];
            while ((chunk = this._cache.get())) {
              thing = this._mode.encrypt(this, chunk);
              out.push(thing);
            }
            return Buffer.concat(out);
          };
          var PADDING = Buffer.alloc(16, 16);
          Cipher.prototype._final = function() {
            var chunk = this._cache.flush();
            if (this._autopadding) {
              chunk = this._mode.encrypt(this, chunk);
              this._cipher.scrub();
              return chunk;
            }
            if (!chunk.equals(PADDING)) {
              this._cipher.scrub();
              throw new Error('data not multiple of block length');
            }
          };
          Cipher.prototype.setAutoPadding = function(setTo) {
            this._autopadding = !!setTo;
            return this;
          };
          function Splitter() {
            this.cache = Buffer.allocUnsafe(0);
          }
          Splitter.prototype.add = function(data) {
            this.cache = Buffer.concat([this.cache, data]);
          };
          Splitter.prototype.get = function() {
            if (this.cache.length > 15) {
              var out = this.cache.slice(0, 16);
              this.cache = this.cache.slice(16);
              return out;
            }
            return null;
          };
          Splitter.prototype.flush = function() {
            var len = 16 - this.cache.length;
            var padBuff = Buffer.allocUnsafe(len);
            var i = -1;
            while (++i < len) {
              padBuff.writeUInt8(len, i);
            }
            return Buffer.concat([this.cache, padBuff]);
          };
          function createCipheriv(suite, password, iv) {
            var config = MODES[suite.toLowerCase()];
            if (!config) throw new TypeError('invalid suite type');
            if (typeof password === 'string') password = Buffer.from(password);
            if (password.length !== config.key / 8)
              throw new TypeError('invalid key length ' + password.length);
            if (typeof iv === 'string') iv = Buffer.from(iv);
            if (iv.length !== config.iv)
              throw new TypeError('invalid iv length ' + iv.length);
            if (config.type === 'stream') {
              return new StreamCipher(config.module, password, iv);
            } else if (config.type === 'auth') {
              return new AuthCipher(config.module, password, iv);
            }
            return new Cipher(config.module, password, iv);
          }
          function createCipher(suite, password) {
            var config = MODES[suite.toLowerCase()];
            if (!config) throw new TypeError('invalid suite type');
            var keys = ebtk(password, false, config.key, config.iv);
            return createCipheriv(suite, keys.key, keys.iv);
          }
          exports.createCipheriv = createCipheriv;
          exports.createCipher = createCipher;
        },
        {
          './aes': 156,
          './authCipher': 157,
          './modes': 168,
          './streamCipher': 171,
          'cipher-base': 184,
          evp_bytestokey: 204,
          inherits: 207,
          'safe-buffer': 460
        }
      ],
      161: [
        function(require, module, exports) {
          var Buffer = require('safe-buffer').Buffer;
          var ZEROES = Buffer.alloc(16, 0);
          function toArray(buf) {
            return [
              buf.readUInt32BE(0),
              buf.readUInt32BE(4),
              buf.readUInt32BE(8),
              buf.readUInt32BE(12)
            ];
          }
          function fromArray(out) {
            var buf = Buffer.allocUnsafe(16);
            buf.writeUInt32BE(out[0] >>> 0, 0);
            buf.writeUInt32BE(out[1] >>> 0, 4);
            buf.writeUInt32BE(out[2] >>> 0, 8);
            buf.writeUInt32BE(out[3] >>> 0, 12);
            return buf;
          }
          function GHASH(key) {
            this.h = key;
            this.state = Buffer.alloc(16, 0);
            this.cache = Buffer.allocUnsafe(0);
          }
          GHASH.prototype.ghash = function(block) {
            var i = -1;
            while (++i < block.length) {
              this.state[i] ^= block[i];
            }
            this._multiply();
          };
          GHASH.prototype._multiply = function() {
            var Vi = toArray(this.h);
            var Zi = [0, 0, 0, 0];
            var j, xi, lsbVi;
            var i = -1;
            while (++i < 128) {
              xi = (this.state[~~(i / 8)] & (1 << (7 - (i % 8)))) !== 0;
              if (xi) {
                Zi[0] ^= Vi[0];
                Zi[1] ^= Vi[1];
                Zi[2] ^= Vi[2];
                Zi[3] ^= Vi[3];
              }
              lsbVi = (Vi[3] & 1) !== 0;
              for (j = 3; j > 0; j--) {
                Vi[j] = (Vi[j] >>> 1) | ((Vi[j - 1] & 1) << 31);
              }
              Vi[0] = Vi[0] >>> 1;
              if (lsbVi) {
                Vi[0] = Vi[0] ^ (225 << 24);
              }
            }
            this.state = fromArray(Zi);
          };
          GHASH.prototype.update = function(buf) {
            this.cache = Buffer.concat([this.cache, buf]);
            var chunk;
            while (this.cache.length >= 16) {
              chunk = this.cache.slice(0, 16);
              this.cache = this.cache.slice(16);
              this.ghash(chunk);
            }
          };
          GHASH.prototype.final = function(abl, bl) {
            if (this.cache.length) {
              this.ghash(Buffer.concat([this.cache, ZEROES], 16));
            }
            this.ghash(fromArray([0, abl, 0, bl]));
            return this.state;
          };
          module.exports = GHASH;
        },
        { 'safe-buffer': 460 }
      ],
      162: [
        function(require, module, exports) {
          var xor = require('buffer-xor');
          exports.encrypt = function(self, block) {
            var data = xor(block, self._prev);
            self._prev = self._cipher.encryptBlock(data);
            return self._prev;
          };
          exports.decrypt = function(self, block) {
            var pad = self._prev;
            self._prev = block;
            var out = self._cipher.decryptBlock(block);
            return xor(out, pad);
          };
        },
        { 'buffer-xor': 182 }
      ],
      163: [
        function(require, module, exports) {
          var Buffer = require('safe-buffer').Buffer;
          var xor = require('buffer-xor');
          function encryptStart(self, data, decrypt) {
            var len = data.length;
            var out = xor(data, self._cache);
            self._cache = self._cache.slice(len);
            self._prev = Buffer.concat([self._prev, decrypt ? data : out]);
            return out;
          }
          exports.encrypt = function(self, data, decrypt) {
            var out = Buffer.allocUnsafe(0);
            var len;
            while (data.length) {
              if (self._cache.length === 0) {
                self._cache = self._cipher.encryptBlock(self._prev);
                self._prev = Buffer.allocUnsafe(0);
              }
              if (self._cache.length <= data.length) {
                len = self._cache.length;
                out = Buffer.concat([
                  out,
                  encryptStart(self, data.slice(0, len), decrypt)
                ]);
                data = data.slice(len);
              } else {
                out = Buffer.concat([out, encryptStart(self, data, decrypt)]);
                break;
              }
            }
            return out;
          };
        },
        { 'buffer-xor': 182, 'safe-buffer': 460 }
      ],
      164: [
        function(require, module, exports) {
          var Buffer = require('safe-buffer').Buffer;
          function encryptByte(self, byteParam, decrypt) {
            var pad;
            var i = -1;
            var len = 8;
            var out = 0;
            var bit, value;
            while (++i < len) {
              pad = self._cipher.encryptBlock(self._prev);
              bit = byteParam & (1 << (7 - i)) ? 128 : 0;
              value = pad[0] ^ bit;
              out += (value & 128) >> i % 8;
              self._prev = shiftIn(self._prev, decrypt ? bit : value);
            }
            return out;
          }
          function shiftIn(buffer, value) {
            var len = buffer.length;
            var i = -1;
            var out = Buffer.allocUnsafe(buffer.length);
            buffer = Buffer.concat([buffer, Buffer.from([value])]);
            while (++i < len) {
              out[i] = (buffer[i] << 1) | (buffer[i + 1] >> 7);
            }
            return out;
          }
          exports.encrypt = function(self, chunk, decrypt) {
            var len = chunk.length;
            var out = Buffer.allocUnsafe(len);
            var i = -1;
            while (++i < len) {
              out[i] = encryptByte(self, chunk[i], decrypt);
            }
            return out;
          };
        },
        { 'safe-buffer': 460 }
      ],
      165: [
        function(require, module, exports) {
          (function(Buffer) {
            function encryptByte(self, byteParam, decrypt) {
              var pad = self._cipher.encryptBlock(self._prev);
              var out = pad[0] ^ byteParam;
              self._prev = Buffer.concat([
                self._prev.slice(1),
                Buffer.from([decrypt ? byteParam : out])
              ]);
              return out;
            }
            exports.encrypt = function(self, chunk, decrypt) {
              var len = chunk.length;
              var out = Buffer.allocUnsafe(len);
              var i = -1;
              while (++i < len) {
                out[i] = encryptByte(self, chunk[i], decrypt);
              }
              return out;
            };
          }.call(this, require('buffer').Buffer));
        },
        { buffer: 183 }
      ],
      166: [
        function(require, module, exports) {
          (function(Buffer) {
            var xor = require('buffer-xor');
            function incr32(iv) {
              var len = iv.length;
              var item;
              while (len--) {
                item = iv.readUInt8(len);
                if (item === 255) {
                  iv.writeUInt8(0, len);
                } else {
                  item++;
                  iv.writeUInt8(item, len);
                  break;
                }
              }
            }
            function getBlock(self) {
              var out = self._cipher.encryptBlockRaw(self._prev);
              incr32(self._prev);
              return out;
            }
            var blockSize = 16;
            exports.encrypt = function(self, chunk) {
              var chunkNum = Math.ceil(chunk.length / blockSize);
              var start = self._cache.length;
              self._cache = Buffer.concat([
                self._cache,
                Buffer.allocUnsafe(chunkNum * blockSize)
              ]);
              for (var i = 0; i < chunkNum; i++) {
                var out = getBlock(self);
                var offset = start + i * blockSize;
                self._cache.writeUInt32BE(out[0], offset + 0);
                self._cache.writeUInt32BE(out[1], offset + 4);
                self._cache.writeUInt32BE(out[2], offset + 8);
                self._cache.writeUInt32BE(out[3], offset + 12);
              }
              var pad = self._cache.slice(0, chunk.length);
              self._cache = self._cache.slice(chunk.length);
              return xor(chunk, pad);
            };
          }.call(this, require('buffer').Buffer));
        },
        { buffer: 183, 'buffer-xor': 182 }
      ],
      167: [
        function(require, module, exports) {
          exports.encrypt = function(self, block) {
            return self._cipher.encryptBlock(block);
          };
          exports.decrypt = function(self, block) {
            return self._cipher.decryptBlock(block);
          };
        },
        {}
      ],
      168: [
        function(require, module, exports) {
          var modeModules = {
            ECB: require('./ecb'),
            CBC: require('./cbc'),
            CFB: require('./cfb'),
            CFB8: require('./cfb8'),
            CFB1: require('./cfb1'),
            OFB: require('./ofb'),
            CTR: require('./ctr'),
            GCM: require('./ctr')
          };
          var modes = require('./list.json');
          for (var key in modes) {
            modes[key].module = modeModules[modes[key].mode];
          }
          module.exports = modes;
        },
        {
          './cbc': 162,
          './cfb': 163,
          './cfb1': 164,
          './cfb8': 165,
          './ctr': 166,
          './ecb': 167,
          './list.json': 169,
          './ofb': 170
        }
      ],
      169: [
        function(require, module, exports) {
          module.exports = {
            'aes-128-ecb': {
              cipher: 'AES',
              key: 128,
              iv: 0,
              mode: 'ECB',
              type: 'block'
            },
            'aes-192-ecb': {
              cipher: 'AES',
              key: 192,
              iv: 0,
              mode: 'ECB',
              type: 'block'
            },
            'aes-256-ecb': {
              cipher: 'AES',
              key: 256,
              iv: 0,
              mode: 'ECB',
              type: 'block'
            },
            'aes-128-cbc': {
              cipher: 'AES',
              key: 128,
              iv: 16,
              mode: 'CBC',
              type: 'block'
            },
            'aes-192-cbc': {
              cipher: 'AES',
              key: 192,
              iv: 16,
              mode: 'CBC',
              type: 'block'
            },
            'aes-256-cbc': {
              cipher: 'AES',
              key: 256,
              iv: 16,
              mode: 'CBC',
              type: 'block'
            },
            aes128: {
              cipher: 'AES',
              key: 128,
              iv: 16,
              mode: 'CBC',
              type: 'block'
            },
            aes192: {
              cipher: 'AES',
              key: 192,
              iv: 16,
              mode: 'CBC',
              type: 'block'
            },
            aes256: {
              cipher: 'AES',
              key: 256,
              iv: 16,
              mode: 'CBC',
              type: 'block'
            },
            'aes-128-cfb': {
              cipher: 'AES',
              key: 128,
              iv: 16,
              mode: 'CFB',
              type: 'stream'
            },
            'aes-192-cfb': {
              cipher: 'AES',
              key: 192,
              iv: 16,
              mode: 'CFB',
              type: 'stream'
            },
            'aes-256-cfb': {
              cipher: 'AES',
              key: 256,
              iv: 16,
              mode: 'CFB',
              type: 'stream'
            },
            'aes-128-cfb8': {
              cipher: 'AES',
              key: 128,
              iv: 16,
              mode: 'CFB8',
              type: 'stream'
            },
            'aes-192-cfb8': {
              cipher: 'AES',
              key: 192,
              iv: 16,
              mode: 'CFB8',
              type: 'stream'
            },
            'aes-256-cfb8': {
              cipher: 'AES',
              key: 256,
              iv: 16,
              mode: 'CFB8',
              type: 'stream'
            },
            'aes-128-cfb1': {
              cipher: 'AES',
              key: 128,
              iv: 16,
              mode: 'CFB1',
              type: 'stream'
            },
            'aes-192-cfb1': {
              cipher: 'AES',
              key: 192,
              iv: 16,
              mode: 'CFB1',
              type: 'stream'
            },
            'aes-256-cfb1': {
              cipher: 'AES',
              key: 256,
              iv: 16,
              mode: 'CFB1',
              type: 'stream'
            },
            'aes-128-ofb': {
              cipher: 'AES',
              key: 128,
              iv: 16,
              mode: 'OFB',
              type: 'stream'
            },
            'aes-192-ofb': {
              cipher: 'AES',
              key: 192,
              iv: 16,
              mode: 'OFB',
              type: 'stream'
            },
            'aes-256-ofb': {
              cipher: 'AES',
              key: 256,
              iv: 16,
              mode: 'OFB',
              type: 'stream'
            },
            'aes-128-ctr': {
              cipher: 'AES',
              key: 128,
              iv: 16,
              mode: 'CTR',
              type: 'stream'
            },
            'aes-192-ctr': {
              cipher: 'AES',
              key: 192,
              iv: 16,
              mode: 'CTR',
              type: 'stream'
            },
            'aes-256-ctr': {
              cipher: 'AES',
              key: 256,
              iv: 16,
              mode: 'CTR',
              type: 'stream'
            },
            'aes-128-gcm': {
              cipher: 'AES',
              key: 128,
              iv: 12,
              mode: 'GCM',
              type: 'auth'
            },
            'aes-192-gcm': {
              cipher: 'AES',
              key: 192,
              iv: 12,
              mode: 'GCM',
              type: 'auth'
            },
            'aes-256-gcm': {
              cipher: 'AES',
              key: 256,
              iv: 12,
              mode: 'GCM',
              type: 'auth'
            }
          };
        },
        {}
      ],
      170: [
        function(require, module, exports) {
          (function(Buffer) {
            var xor = require('buffer-xor');
            function getBlock(self) {
              self._prev = self._cipher.encryptBlock(self._prev);
              return self._prev;
            }
            exports.encrypt = function(self, chunk) {
              while (self._cache.length < chunk.length) {
                self._cache = Buffer.concat([self._cache, getBlock(self)]);
              }
              var pad = self._cache.slice(0, chunk.length);
              self._cache = self._cache.slice(chunk.length);
              return xor(chunk, pad);
            };
          }.call(this, require('buffer').Buffer));
        },
        { buffer: 183, 'buffer-xor': 182 }
      ],
      171: [
        function(require, module, exports) {
          var aes = require('./aes');
          var Buffer = require('safe-buffer').Buffer;
          var Transform = require('cipher-base');
          var inherits = require('inherits');
          function StreamCipher(mode, key, iv, decrypt) {
            Transform.call(this);
            this._cipher = new aes.AES(key);
            this._prev = Buffer.from(iv);
            this._cache = Buffer.allocUnsafe(0);
            this._secCache = Buffer.allocUnsafe(0);
            this._decrypt = decrypt;
            this._mode = mode;
          }
          inherits(StreamCipher, Transform);
          StreamCipher.prototype._update = function(chunk) {
            return this._mode.encrypt(this, chunk, this._decrypt);
          };
          StreamCipher.prototype._final = function() {
            this._cipher.scrub();
          };
          module.exports = StreamCipher;
        },
        { './aes': 156, 'cipher-base': 184, inherits: 207, 'safe-buffer': 460 }
      ],
      172: [
        function(require, module, exports) {
          var ebtk = require('evp_bytestokey');
          var aes = require('browserify-aes/browser');
          var DES = require('browserify-des');
          var desModes = require('browserify-des/modes');
          var aesModes = require('browserify-aes/modes');
          function createCipher(suite, password) {
            var keyLen, ivLen;
            suite = suite.toLowerCase();
            if (aesModes[suite]) {
              keyLen = aesModes[suite].key;
              ivLen = aesModes[suite].iv;
            } else if (desModes[suite]) {
              keyLen = desModes[suite].key * 8;
              ivLen = desModes[suite].iv;
            } else {
              throw new TypeError('invalid suite type');
            }
            var keys = ebtk(password, false, keyLen, ivLen);
            return createCipheriv(suite, keys.key, keys.iv);
          }
          function createDecipher(suite, password) {
            var keyLen, ivLen;
            suite = suite.toLowerCase();
            if (aesModes[suite]) {
              keyLen = aesModes[suite].key;
              ivLen = aesModes[suite].iv;
            } else if (desModes[suite]) {
              keyLen = desModes[suite].key * 8;
              ivLen = desModes[suite].iv;
            } else {
              throw new TypeError('invalid suite type');
            }
            var keys = ebtk(password, false, keyLen, ivLen);
            return createDecipheriv(suite, keys.key, keys.iv);
          }
          function createCipheriv(suite, key, iv) {
            suite = suite.toLowerCase();
            if (aesModes[suite]) {
              return aes.createCipheriv(suite, key, iv);
            } else if (desModes[suite]) {
              return new DES({ key: key, iv: iv, mode: suite });
            } else {
              throw new TypeError('invalid suite type');
            }
          }
          function createDecipheriv(suite, key, iv) {
            suite = suite.toLowerCase();
            if (aesModes[suite]) {
              return aes.createDecipheriv(suite, key, iv);
            } else if (desModes[suite]) {
              return new DES({ key: key, iv: iv, mode: suite, decrypt: true });
            } else {
              throw new TypeError('invalid suite type');
            }
          }
          exports.createCipher = exports.Cipher = createCipher;
          exports.createCipheriv = exports.Cipheriv = createCipheriv;
          exports.createDecipher = exports.Decipher = createDecipher;
          exports.createDecipheriv = exports.Decipheriv = createDecipheriv;
          function getCiphers() {
            return Object.keys(desModes).concat(aes.getCiphers());
          }
          exports.listCiphers = exports.getCiphers = getCiphers;
        },
        {
          'browserify-aes/browser': 158,
          'browserify-aes/modes': 168,
          'browserify-des': 173,
          'browserify-des/modes': 174,
          evp_bytestokey: 204
        }
      ],
      173: [
        function(require, module, exports) {
          (function(Buffer) {
            var CipherBase = require('cipher-base');
            var des = require('des.js');
            var inherits = require('inherits');
            var modes = {
              'des-ede3-cbc': des.CBC.instantiate(des.EDE),
              'des-ede3': des.EDE,
              'des-ede-cbc': des.CBC.instantiate(des.EDE),
              'des-ede': des.EDE,
              'des-cbc': des.CBC.instantiate(des.DES),
              'des-ecb': des.DES
            };
            modes.des = modes['des-cbc'];
            modes.des3 = modes['des-ede3-cbc'];
            module.exports = DES;
            inherits(DES, CipherBase);
            function DES(opts) {
              CipherBase.call(this);
              var modeName = opts.mode.toLowerCase();
              var mode = modes[modeName];
              var type;
              if (opts.decrypt) {
                type = 'decrypt';
              } else {
                type = 'encrypt';
              }
              var key = opts.key;
              if (modeName === 'des-ede' || modeName === 'des-ede-cbc') {
                key = Buffer.concat([key, key.slice(0, 8)]);
              }
              var iv = opts.iv;
              this._des = mode.create({ key: key, iv: iv, type: type });
            }
            DES.prototype._update = function(data) {
              return new Buffer(this._des.update(data));
            };
            DES.prototype._final = function() {
              return new Buffer(this._des.final());
            };
          }.call(this, require('buffer').Buffer));
        },
        { buffer: 183, 'cipher-base': 184, 'des.js': 193, inherits: 207 }
      ],
      174: [
        function(require, module, exports) {
          exports['des-ecb'] = { key: 8, iv: 0 };
          exports['des-cbc'] = exports.des = { key: 8, iv: 8 };
          exports['des-ede3-cbc'] = exports.des3 = { key: 24, iv: 8 };
          exports['des-ede3'] = { key: 24, iv: 0 };
          exports['des-ede-cbc'] = { key: 16, iv: 8 };
          exports['des-ede'] = { key: 16, iv: 0 };
        },
        {}
      ],
      175: [
        function(require, module, exports) {
          (function(Buffer) {
            var bn = require('bn.js');
            var randomBytes = require('randombytes');
            module.exports = crt;
            function blind(priv) {
              var r = getr(priv);
              var blinder = r
                .toRed(bn.mont(priv.modulus))
                .redPow(new bn(priv.publicExponent))
                .fromRed();
              return { blinder: blinder, unblinder: r.invm(priv.modulus) };
            }
            function crt(msg, priv) {
              var blinds = blind(priv);
              var len = priv.modulus.byteLength();
              var mod = bn.mont(priv.modulus);
              var blinded = new bn(msg).mul(blinds.blinder).umod(priv.modulus);
              var c1 = blinded.toRed(bn.mont(priv.prime1));
              var c2 = blinded.toRed(bn.mont(priv.prime2));
              var qinv = priv.coefficient;
              var p = priv.prime1;
              var q = priv.prime2;
              var m1 = c1.redPow(priv.exponent1);
              var m2 = c2.redPow(priv.exponent2);
              m1 = m1.fromRed();
              m2 = m2.fromRed();
              var h = m1
                .isub(m2)
                .imul(qinv)
                .umod(p);
              h.imul(q);
              m2.iadd(h);
              return new Buffer(
                m2
                  .imul(blinds.unblinder)
                  .umod(priv.modulus)
                  .toArray(false, len)
              );
            }
            crt.getr = getr;
            function getr(priv) {
              var len = priv.modulus.byteLength();
              var r = new bn(randomBytes(len));
              while (
                r.cmp(priv.modulus) >= 0 ||
                !r.umod(priv.prime1) ||
                !r.umod(priv.prime2)
              ) {
                r = new bn(randomBytes(len));
              }
              return r;
            }
          }.call(this, require('buffer').Buffer));
        },
        { 'bn.js': 153, buffer: 183, randombytes: 234 }
      ],
      176: [
        function(require, module, exports) {
          module.exports = require('./browser/algorithms.json');
        },
        { './browser/algorithms.json': 177 }
      ],
      177: [
        function(require, module, exports) {
          module.exports = {
            sha224WithRSAEncryption: {
              sign: 'rsa',
              hash: 'sha224',
              id: '302d300d06096086480165030402040500041c'
            },
            'RSA-SHA224': {
              sign: 'ecdsa/rsa',
              hash: 'sha224',
              id: '302d300d06096086480165030402040500041c'
            },
            sha256WithRSAEncryption: {
              sign: 'rsa',
              hash: 'sha256',
              id: '3031300d060960864801650304020105000420'
            },
            'RSA-SHA256': {
              sign: 'ecdsa/rsa',
              hash: 'sha256',
              id: '3031300d060960864801650304020105000420'
            },
            sha384WithRSAEncryption: {
              sign: 'rsa',
              hash: 'sha384',
              id: '3041300d060960864801650304020205000430'
            },
            'RSA-SHA384': {
              sign: 'ecdsa/rsa',
              hash: 'sha384',
              id: '3041300d060960864801650304020205000430'
            },
            sha512WithRSAEncryption: {
              sign: 'rsa',
              hash: 'sha512',
              id: '3051300d060960864801650304020305000440'
            },
            'RSA-SHA512': {
              sign: 'ecdsa/rsa',
              hash: 'sha512',
              id: '3051300d060960864801650304020305000440'
            },
            'RSA-SHA1': {
              sign: 'rsa',
              hash: 'sha1',
              id: '3021300906052b0e03021a05000414'
            },
            'ecdsa-with-SHA1': { sign: 'ecdsa', hash: 'sha1', id: '' },
            sha256: { sign: 'ecdsa', hash: 'sha256', id: '' },
            sha224: { sign: 'ecdsa', hash: 'sha224', id: '' },
            sha384: { sign: 'ecdsa', hash: 'sha384', id: '' },
            sha512: { sign: 'ecdsa', hash: 'sha512', id: '' },
            'DSA-SHA': { sign: 'dsa', hash: 'sha1', id: '' },
            'DSA-SHA1': { sign: 'dsa', hash: 'sha1', id: '' },
            DSA: { sign: 'dsa', hash: 'sha1', id: '' },
            'DSA-WITH-SHA224': { sign: 'dsa', hash: 'sha224', id: '' },
            'DSA-SHA224': { sign: 'dsa', hash: 'sha224', id: '' },
            'DSA-WITH-SHA256': { sign: 'dsa', hash: 'sha256', id: '' },
            'DSA-SHA256': { sign: 'dsa', hash: 'sha256', id: '' },
            'DSA-WITH-SHA384': { sign: 'dsa', hash: 'sha384', id: '' },
            'DSA-SHA384': { sign: 'dsa', hash: 'sha384', id: '' },
            'DSA-WITH-SHA512': { sign: 'dsa', hash: 'sha512', id: '' },
            'DSA-SHA512': { sign: 'dsa', hash: 'sha512', id: '' },
            'DSA-RIPEMD160': { sign: 'dsa', hash: 'rmd160', id: '' },
            ripemd160WithRSA: {
              sign: 'rsa',
              hash: 'rmd160',
              id: '3021300906052b2403020105000414'
            },
            'RSA-RIPEMD160': {
              sign: 'rsa',
              hash: 'rmd160',
              id: '3021300906052b2403020105000414'
            },
            md5WithRSAEncryption: {
              sign: 'rsa',
              hash: 'md5',
              id: '3020300c06082a864886f70d020505000410'
            },
            'RSA-MD5': {
              sign: 'rsa',
              hash: 'md5',
              id: '3020300c06082a864886f70d020505000410'
            }
          };
        },
        {}
      ],
      178: [
        function(require, module, exports) {
          module.exports = {
            '1.3.132.0.10': 'secp256k1',
            '1.3.132.0.33': 'p224',
            '1.2.840.10045.3.1.1': 'p192',
            '1.2.840.10045.3.1.7': 'p256',
            '1.3.132.0.34': 'p384',
            '1.3.132.0.35': 'p521'
          };
        },
        {}
      ],
      179: [
        function(require, module, exports) {
          (function(Buffer) {
            var createHash = require('create-hash');
            var stream = require('stream');
            var inherits = require('inherits');
            var sign = require('./sign');
            var verify = require('./verify');
            var algorithms = require('./algorithms.json');
            Object.keys(algorithms).forEach(function(key) {
              algorithms[key].id = new Buffer(algorithms[key].id, 'hex');
              algorithms[key.toLowerCase()] = algorithms[key];
            });
            function Sign(algorithm) {
              stream.Writable.call(this);
              var data = algorithms[algorithm];
              if (!data) throw new Error('Unknown message digest');
              this._hashType = data.hash;
              this._hash = createHash(data.hash);
              this._tag = data.id;
              this._signType = data.sign;
            }
            inherits(Sign, stream.Writable);
            Sign.prototype._write = function _write(data, _, done) {
              this._hash.update(data);
              done();
            };
            Sign.prototype.update = function update(data, enc) {
              if (typeof data === 'string') data = new Buffer(data, enc);
              this._hash.update(data);
              return this;
            };
            Sign.prototype.sign = function signMethod(key, enc) {
              this.end();
              var hash = this._hash.digest();
              var sig = sign(
                hash,
                key,
                this._hashType,
                this._signType,
                this._tag
              );
              return enc ? sig.toString(enc) : sig;
            };
            function Verify(algorithm) {
              stream.Writable.call(this);
              var data = algorithms[algorithm];
              if (!data) throw new Error('Unknown message digest');
              this._hash = createHash(data.hash);
              this._tag = data.id;
              this._signType = data.sign;
            }
            inherits(Verify, stream.Writable);
            Verify.prototype._write = function _write(data, _, done) {
              this._hash.update(data);
              done();
            };
            Verify.prototype.update = function update(data, enc) {
              if (typeof data === 'string') data = new Buffer(data, enc);
              this._hash.update(data);
              return this;
            };
            Verify.prototype.verify = function verifyMethod(key, sig, enc) {
              if (typeof sig === 'string') sig = new Buffer(sig, enc);
              this.end();
              var hash = this._hash.digest();
              return verify(sig, hash, key, this._signType, this._tag);
            };
            function createSign(algorithm) {
              return new Sign(algorithm);
            }
            function createVerify(algorithm) {
              return new Verify(algorithm);
            }
            module.exports = {
              Sign: createSign,
              Verify: createVerify,
              createSign: createSign,
              createVerify: createVerify
            };
          }.call(this, require('buffer').Buffer));
        },
        {
          './algorithms.json': 177,
          './sign': 180,
          './verify': 181,
          buffer: 183,
          'create-hash': 187,
          inherits: 207,
          stream: 258
        }
      ],
      180: [
        function(require, module, exports) {
          (function(Buffer) {
            var createHmac = require('create-hmac');
            var crt = require('browserify-rsa');
            var EC = require('elliptic').ec;
            var BN = require('bn.js');
            var parseKeys = require('parse-asn1');
            var curves = require('./curves.json');
            function sign(hash, key, hashType, signType, tag) {
              var priv = parseKeys(key);
              if (priv.curve) {
                if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa')
                  throw new Error('wrong private key type');
                return ecSign(hash, priv);
              } else if (priv.type === 'dsa') {
                if (signType !== 'dsa')
                  throw new Error('wrong private key type');
                return dsaSign(hash, priv, hashType);
              } else {
                if (signType !== 'rsa' && signType !== 'ecdsa/rsa')
                  throw new Error('wrong private key type');
              }
              hash = Buffer.concat([tag, hash]);
              var len = priv.modulus.byteLength();
              var pad = [0, 1];
              while (hash.length + pad.length + 1 < len) pad.push(255);
              pad.push(0);
              var i = -1;
              while (++i < hash.length) pad.push(hash[i]);
              var out = crt(pad, priv);
              return out;
            }
            function ecSign(hash, priv) {
              var curveId = curves[priv.curve.join('.')];
              if (!curveId)
                throw new Error('unknown curve ' + priv.curve.join('.'));
              var curve = new EC(curveId);
              var key = curve.keyFromPrivate(priv.privateKey);
              var out = key.sign(hash);
              return new Buffer(out.toDER());
            }
            function dsaSign(hash, priv, algo) {
              var x = priv.params.priv_key;
              var p = priv.params.p;
              var q = priv.params.q;
              var g = priv.params.g;
              var r = new BN(0);
              var k;
              var H = bits2int(hash, q).mod(q);
              var s = false;
              var kv = getKey(x, q, hash, algo);
              while (s === false) {
                k = makeKey(q, kv, algo);
                r = makeR(g, k, p, q);
                s = k
                  .invm(q)
                  .imul(H.add(x.mul(r)))
                  .mod(q);
                if (s.cmpn(0) === 0) {
                  s = false;
                  r = new BN(0);
                }
              }
              return toDER(r, s);
            }
            function toDER(r, s) {
              r = r.toArray();
              s = s.toArray();
              if (r[0] & 128) r = [0].concat(r);
              if (s[0] & 128) s = [0].concat(s);
              var total = r.length + s.length + 4;
              var res = [48, total, 2, r.length];
              res = res.concat(r, [2, s.length], s);
              return new Buffer(res);
            }
            function getKey(x, q, hash, algo) {
              x = new Buffer(x.toArray());
              if (x.length < q.byteLength()) {
                var zeros = new Buffer(q.byteLength() - x.length);
                zeros.fill(0);
                x = Buffer.concat([zeros, x]);
              }
              var hlen = hash.length;
              var hbits = bits2octets(hash, q);
              var v = new Buffer(hlen);
              v.fill(1);
              var k = new Buffer(hlen);
              k.fill(0);
              k = createHmac(algo, k)
                .update(v)
                .update(new Buffer([0]))
                .update(x)
                .update(hbits)
                .digest();
              v = createHmac(algo, k)
                .update(v)
                .digest();
              k = createHmac(algo, k)
                .update(v)
                .update(new Buffer([1]))
                .update(x)
                .update(hbits)
                .digest();
              v = createHmac(algo, k)
                .update(v)
                .digest();
              return { k: k, v: v };
            }
            function bits2int(obits, q) {
              var bits = new BN(obits);
              var shift = (obits.length << 3) - q.bitLength();
              if (shift > 0) bits.ishrn(shift);
              return bits;
            }
            function bits2octets(bits, q) {
              bits = bits2int(bits, q);
              bits = bits.mod(q);
              var out = new Buffer(bits.toArray());
              if (out.length < q.byteLength()) {
                var zeros = new Buffer(q.byteLength() - out.length);
                zeros.fill(0);
                out = Buffer.concat([zeros, out]);
              }
              return out;
            }
            function makeKey(q, kv, algo) {
              var t;
              var k;
              do {
                t = new Buffer(0);
                while (t.length * 8 < q.bitLength()) {
                  kv.v = createHmac(algo, kv.k)
                    .update(kv.v)
                    .digest();
                  t = Buffer.concat([t, kv.v]);
                }
                k = bits2int(t, q);
                kv.k = createHmac(algo, kv.k)
                  .update(kv.v)
                  .update(new Buffer([0]))
                  .digest();
                kv.v = createHmac(algo, kv.k)
                  .update(kv.v)
                  .digest();
              } while (k.cmp(q) !== -1);
              return k;
            }
            function makeR(g, k, p, q) {
              return g
                .toRed(BN.mont(p))
                .redPow(k)
                .fromRed()
                .mod(q);
            }
            module.exports = sign;
            module.exports.getKey = getKey;
            module.exports.makeKey = makeKey;
          }.call(this, require('buffer').Buffer));
        },
        {
          './curves.json': 178,
          'bn.js': 153,
          'browserify-rsa': 175,
          buffer: 183,
          'create-hmac': 190,
          elliptic: 309,
          'parse-asn1': 216
        }
      ],
      181: [
        function(require, module, exports) {
          (function(Buffer) {
            var BN = require('bn.js');
            var EC = require('elliptic').ec;
            var parseKeys = require('parse-asn1');
            var curves = require('./curves.json');
            function verify(sig, hash, key, signType, tag) {
              var pub = parseKeys(key);
              if (pub.type === 'ec') {
                if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa')
                  throw new Error('wrong public key type');
                return ecVerify(sig, hash, pub);
              } else if (pub.type === 'dsa') {
                if (signType !== 'dsa')
                  throw new Error('wrong public key type');
                return dsaVerify(sig, hash, pub);
              } else {
                if (signType !== 'rsa' && signType !== 'ecdsa/rsa')
                  throw new Error('wrong public key type');
              }
              hash = Buffer.concat([tag, hash]);
              var len = pub.modulus.byteLength();
              var pad = [1];
              var padNum = 0;
              while (hash.length + pad.length + 2 < len) {
                pad.push(255);
                padNum++;
              }
              pad.push(0);
              var i = -1;
              while (++i < hash.length) {
                pad.push(hash[i]);
              }
              pad = new Buffer(pad);
              var red = BN.mont(pub.modulus);
              sig = new BN(sig).toRed(red);
              sig = sig.redPow(new BN(pub.publicExponent));
              sig = new Buffer(sig.fromRed().toArray());
              var out = padNum < 8 ? 1 : 0;
              len = Math.min(sig.length, pad.length);
              if (sig.length !== pad.length) out = 1;
              i = -1;
              while (++i < len) out |= sig[i] ^ pad[i];
              return out === 0;
            }
            function ecVerify(sig, hash, pub) {
              var curveId = curves[pub.data.algorithm.curve.join('.')];
              if (!curveId)
                throw new Error(
                  'unknown curve ' + pub.data.algorithm.curve.join('.')
                );
              var curve = new EC(curveId);
              var pubkey = pub.data.subjectPrivateKey.data;
              return curve.verify(hash, sig, pubkey);
            }
            function dsaVerify(sig, hash, pub) {
              var p = pub.data.p;
              var q = pub.data.q;
              var g = pub.data.g;
              var y = pub.data.pub_key;
              var unpacked = parseKeys.signature.decode(sig, 'der');
              var s = unpacked.s;
              var r = unpacked.r;
              checkValue(s, q);
              checkValue(r, q);
              var montp = BN.mont(p);
              var w = s.invm(q);
              var v = g
                .toRed(montp)
                .redPow(new BN(hash).mul(w).mod(q))
                .fromRed()
                .mul(
                  y
                    .toRed(montp)
                    .redPow(r.mul(w).mod(q))
                    .fromRed()
                )
                .mod(p)
                .mod(q);
              return v.cmp(r) === 0;
            }
            function checkValue(b, q) {
              if (b.cmpn(0) <= 0) throw new Error('invalid sig');
              if (b.cmp(q) >= q) throw new Error('invalid sig');
            }
            module.exports = verify;
          }.call(this, require('buffer').Buffer));
        },
        {
          './curves.json': 178,
          'bn.js': 153,
          buffer: 183,
          elliptic: 309,
          'parse-asn1': 216
        }
      ],
      182: [
        function(require, module, exports) {
          (function(Buffer) {
            module.exports = function xor(a, b) {
              var length = Math.min(a.length, b.length);
              var buffer = new Buffer(length);
              for (var i = 0; i < length; ++i) {
                buffer[i] = a[i] ^ b[i];
              }
              return buffer;
            };
          }.call(this, require('buffer').Buffer));
        },
        { buffer: 183 }
      ],
      183: [
        function(require, module, exports) {
          (function(global) {
            'use strict';
            var base64 = require('base64-js');
            var ieee754 = require('ieee754');
            var isArray = require('isarray');
            exports.Buffer = Buffer;
            exports.SlowBuffer = SlowBuffer;
            exports.INSPECT_MAX_BYTES = 50;
            Buffer.TYPED_ARRAY_SUPPORT =
              global.TYPED_ARRAY_SUPPORT !== undefined
                ? global.TYPED_ARRAY_SUPPORT
                : typedArraySupport();
            exports.kMaxLength = kMaxLength();
            function typedArraySupport() {
              try {
                var arr = new Uint8Array(1);
                arr.__proto__ = {
                  __proto__: Uint8Array.prototype,
                  foo: function() {
                    return 42;
                  }
                };
                return (
                  arr.foo() === 42 &&
                  typeof arr.subarray === 'function' &&
                  arr.subarray(1, 1).byteLength === 0
                );
              } catch (e) {
                return false;
              }
            }
            function kMaxLength() {
              return Buffer.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
            }
            function createBuffer(that, length) {
              if (kMaxLength() < length) {
                throw new RangeError('Invalid typed array length');
              }
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                that = new Uint8Array(length);
                that.__proto__ = Buffer.prototype;
              } else {
                if (that === null) {
                  that = new Buffer(length);
                }
                that.length = length;
              }
              return that;
            }
            function Buffer(arg, encodingOrOffset, length) {
              if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
                return new Buffer(arg, encodingOrOffset, length);
              }
              if (typeof arg === 'number') {
                if (typeof encodingOrOffset === 'string') {
                  throw new Error(
                    'If encoding is specified then the first argument must be a string'
                  );
                }
                return allocUnsafe(this, arg);
              }
              return from(this, arg, encodingOrOffset, length);
            }
            Buffer.poolSize = 8192;
            Buffer._augment = function(arr) {
              arr.__proto__ = Buffer.prototype;
              return arr;
            };
            function from(that, value, encodingOrOffset, length) {
              if (typeof value === 'number') {
                throw new TypeError('"value" argument must not be a number');
              }
              if (
                typeof ArrayBuffer !== 'undefined' &&
                value instanceof ArrayBuffer
              ) {
                return fromArrayBuffer(that, value, encodingOrOffset, length);
              }
              if (typeof value === 'string') {
                return fromString(that, value, encodingOrOffset);
              }
              return fromObject(that, value);
            }
            Buffer.from = function(value, encodingOrOffset, length) {
              return from(null, value, encodingOrOffset, length);
            };
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              Buffer.prototype.__proto__ = Uint8Array.prototype;
              Buffer.__proto__ = Uint8Array;
              if (
                typeof Symbol !== 'undefined' &&
                Symbol.species &&
                Buffer[Symbol.species] === Buffer
              ) {
                Object.defineProperty(Buffer, Symbol.species, {
                  value: null,
                  configurable: true
                });
              }
            }
            function assertSize(size) {
              if (typeof size !== 'number') {
                throw new TypeError('"size" argument must be a number');
              } else if (size < 0) {
                throw new RangeError('"size" argument must not be negative');
              }
            }
            function alloc(that, size, fill, encoding) {
              assertSize(size);
              if (size <= 0) {
                return createBuffer(that, size);
              }
              if (fill !== undefined) {
                return typeof encoding === 'string'
                  ? createBuffer(that, size).fill(fill, encoding)
                  : createBuffer(that, size).fill(fill);
              }
              return createBuffer(that, size);
            }
            Buffer.alloc = function(size, fill, encoding) {
              return alloc(null, size, fill, encoding);
            };
            function allocUnsafe(that, size) {
              assertSize(size);
              that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
              if (!Buffer.TYPED_ARRAY_SUPPORT) {
                for (var i = 0; i < size; ++i) {
                  that[i] = 0;
                }
              }
              return that;
            }
            Buffer.allocUnsafe = function(size) {
              return allocUnsafe(null, size);
            };
            Buffer.allocUnsafeSlow = function(size) {
              return allocUnsafe(null, size);
            };
            function fromString(that, string, encoding) {
              if (typeof encoding !== 'string' || encoding === '') {
                encoding = 'utf8';
              }
              if (!Buffer.isEncoding(encoding)) {
                throw new TypeError(
                  '"encoding" must be a valid string encoding'
                );
              }
              var length = byteLength(string, encoding) | 0;
              that = createBuffer(that, length);
              var actual = that.write(string, encoding);
              if (actual !== length) {
                that = that.slice(0, actual);
              }
              return that;
            }
            function fromArrayLike(that, array) {
              var length = array.length < 0 ? 0 : checked(array.length) | 0;
              that = createBuffer(that, length);
              for (var i = 0; i < length; i += 1) {
                that[i] = array[i] & 255;
              }
              return that;
            }
            function fromArrayBuffer(that, array, byteOffset, length) {
              array.byteLength;
              if (byteOffset < 0 || array.byteLength < byteOffset) {
                throw new RangeError("'offset' is out of bounds");
              }
              if (array.byteLength < byteOffset + (length || 0)) {
                throw new RangeError("'length' is out of bounds");
              }
              if (byteOffset === undefined && length === undefined) {
                array = new Uint8Array(array);
              } else if (length === undefined) {
                array = new Uint8Array(array, byteOffset);
              } else {
                array = new Uint8Array(array, byteOffset, length);
              }
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                that = array;
                that.__proto__ = Buffer.prototype;
              } else {
                that = fromArrayLike(that, array);
              }
              return that;
            }
            function fromObject(that, obj) {
              if (Buffer.isBuffer(obj)) {
                var len = checked(obj.length) | 0;
                that = createBuffer(that, len);
                if (that.length === 0) {
                  return that;
                }
                obj.copy(that, 0, 0, len);
                return that;
              }
              if (obj) {
                if (
                  (typeof ArrayBuffer !== 'undefined' &&
                    obj.buffer instanceof ArrayBuffer) ||
                  'length' in obj
                ) {
                  if (typeof obj.length !== 'number' || isnan(obj.length)) {
                    return createBuffer(that, 0);
                  }
                  return fromArrayLike(that, obj);
                }
                if (obj.type === 'Buffer' && isArray(obj.data)) {
                  return fromArrayLike(that, obj.data);
                }
              }
              throw new TypeError(
                'First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.'
              );
            }
            function checked(length) {
              if (length >= kMaxLength()) {
                throw new RangeError(
                  'Attempt to allocate Buffer larger than maximum ' +
                    'size: 0x' +
                    kMaxLength().toString(16) +
                    ' bytes'
                );
              }
              return length | 0;
            }
            function SlowBuffer(length) {
              if (+length != length) {
                length = 0;
              }
              return Buffer.alloc(+length);
            }
            Buffer.isBuffer = function isBuffer(b) {
              return !!(b != null && b._isBuffer);
            };
            Buffer.compare = function compare(a, b) {
              if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
                throw new TypeError('Arguments must be Buffers');
              }
              if (a === b) return 0;
              var x = a.length;
              var y = b.length;
              for (var i = 0, len = Math.min(x, y); i < len; ++i) {
                if (a[i] !== b[i]) {
                  x = a[i];
                  y = b[i];
                  break;
                }
              }
              if (x < y) return -1;
              if (y < x) return 1;
              return 0;
            };
            Buffer.isEncoding = function isEncoding(encoding) {
              switch (String(encoding).toLowerCase()) {
                case 'hex':
                case 'utf8':
                case 'utf-8':
                case 'ascii':
                case 'latin1':
                case 'binary':
                case 'base64':
                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                  return true;
                default:
                  return false;
              }
            };
            Buffer.concat = function concat(list, length) {
              if (!isArray(list)) {
                throw new TypeError(
                  '"list" argument must be an Array of Buffers'
                );
              }
              if (list.length === 0) {
                return Buffer.alloc(0);
              }
              var i;
              if (length === undefined) {
                length = 0;
                for (i = 0; i < list.length; ++i) {
                  length += list[i].length;
                }
              }
              var buffer = Buffer.allocUnsafe(length);
              var pos = 0;
              for (i = 0; i < list.length; ++i) {
                var buf = list[i];
                if (!Buffer.isBuffer(buf)) {
                  throw new TypeError(
                    '"list" argument must be an Array of Buffers'
                  );
                }
                buf.copy(buffer, pos);
                pos += buf.length;
              }
              return buffer;
            };
            function byteLength(string, encoding) {
              if (Buffer.isBuffer(string)) {
                return string.length;
              }
              if (
                typeof ArrayBuffer !== 'undefined' &&
                typeof ArrayBuffer.isView === 'function' &&
                (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)
              ) {
                return string.byteLength;
              }
              if (typeof string !== 'string') {
                string = '' + string;
              }
              var len = string.length;
              if (len === 0) return 0;
              var loweredCase = false;
              for (;;) {
                switch (encoding) {
                  case 'ascii':
                  case 'latin1':
                  case 'binary':
                    return len;
                  case 'utf8':
                  case 'utf-8':
                  case undefined:
                    return utf8ToBytes(string).length;
                  case 'ucs2':
                  case 'ucs-2':
                  case 'utf16le':
                  case 'utf-16le':
                    return len * 2;
                  case 'hex':
                    return len >>> 1;
                  case 'base64':
                    return base64ToBytes(string).length;
                  default:
                    if (loweredCase) return utf8ToBytes(string).length;
                    encoding = ('' + encoding).toLowerCase();
                    loweredCase = true;
                }
              }
            }
            Buffer.byteLength = byteLength;
            function slowToString(encoding, start, end) {
              var loweredCase = false;
              if (start === undefined || start < 0) {
                start = 0;
              }
              if (start > this.length) {
                return '';
              }
              if (end === undefined || end > this.length) {
                end = this.length;
              }
              if (end <= 0) {
                return '';
              }
              end >>>= 0;
              start >>>= 0;
              if (end <= start) {
                return '';
              }
              if (!encoding) encoding = 'utf8';
              while (true) {
                switch (encoding) {
                  case 'hex':
                    return hexSlice(this, start, end);
                  case 'utf8':
                  case 'utf-8':
                    return utf8Slice(this, start, end);
                  case 'ascii':
                    return asciiSlice(this, start, end);
                  case 'latin1':
                  case 'binary':
                    return latin1Slice(this, start, end);
                  case 'base64':
                    return base64Slice(this, start, end);
                  case 'ucs2':
                  case 'ucs-2':
                  case 'utf16le':
                  case 'utf-16le':
                    return utf16leSlice(this, start, end);
                  default:
                    if (loweredCase)
                      throw new TypeError('Unknown encoding: ' + encoding);
                    encoding = (encoding + '').toLowerCase();
                    loweredCase = true;
                }
              }
            }
            Buffer.prototype._isBuffer = true;
            function swap(b, n, m) {
              var i = b[n];
              b[n] = b[m];
              b[m] = i;
            }
            Buffer.prototype.swap16 = function swap16() {
              var len = this.length;
              if (len % 2 !== 0) {
                throw new RangeError(
                  'Buffer size must be a multiple of 16-bits'
                );
              }
              for (var i = 0; i < len; i += 2) {
                swap(this, i, i + 1);
              }
              return this;
            };
            Buffer.prototype.swap32 = function swap32() {
              var len = this.length;
              if (len % 4 !== 0) {
                throw new RangeError(
                  'Buffer size must be a multiple of 32-bits'
                );
              }
              for (var i = 0; i < len; i += 4) {
                swap(this, i, i + 3);
                swap(this, i + 1, i + 2);
              }
              return this;
            };
            Buffer.prototype.swap64 = function swap64() {
              var len = this.length;
              if (len % 8 !== 0) {
                throw new RangeError(
                  'Buffer size must be a multiple of 64-bits'
                );
              }
              for (var i = 0; i < len; i += 8) {
                swap(this, i, i + 7);
                swap(this, i + 1, i + 6);
                swap(this, i + 2, i + 5);
                swap(this, i + 3, i + 4);
              }
              return this;
            };
            Buffer.prototype.toString = function toString() {
              var length = this.length | 0;
              if (length === 0) return '';
              if (arguments.length === 0) return utf8Slice(this, 0, length);
              return slowToString.apply(this, arguments);
            };
            Buffer.prototype.equals = function equals(b) {
              if (!Buffer.isBuffer(b))
                throw new TypeError('Argument must be a Buffer');
              if (this === b) return true;
              return Buffer.compare(this, b) === 0;
            };
            Buffer.prototype.inspect = function inspect() {
              var str = '';
              var max = exports.INSPECT_MAX_BYTES;
              if (this.length > 0) {
                str = this.toString('hex', 0, max)
                  .match(/.{2}/g)
                  .join(' ');
                if (this.length > max) str += ' ... ';
              }
              return '<Buffer ' + str + '>';
            };
            Buffer.prototype.compare = function compare(
              target,
              start,
              end,
              thisStart,
              thisEnd
            ) {
              if (!Buffer.isBuffer(target)) {
                throw new TypeError('Argument must be a Buffer');
              }
              if (start === undefined) {
                start = 0;
              }
              if (end === undefined) {
                end = target ? target.length : 0;
              }
              if (thisStart === undefined) {
                thisStart = 0;
              }
              if (thisEnd === undefined) {
                thisEnd = this.length;
              }
              if (
                start < 0 ||
                end > target.length ||
                thisStart < 0 ||
                thisEnd > this.length
              ) {
                throw new RangeError('out of range index');
              }
              if (thisStart >= thisEnd && start >= end) {
                return 0;
              }
              if (thisStart >= thisEnd) {
                return -1;
              }
              if (start >= end) {
                return 1;
              }
              start >>>= 0;
              end >>>= 0;
              thisStart >>>= 0;
              thisEnd >>>= 0;
              if (this === target) return 0;
              var x = thisEnd - thisStart;
              var y = end - start;
              var len = Math.min(x, y);
              var thisCopy = this.slice(thisStart, thisEnd);
              var targetCopy = target.slice(start, end);
              for (var i = 0; i < len; ++i) {
                if (thisCopy[i] !== targetCopy[i]) {
                  x = thisCopy[i];
                  y = targetCopy[i];
                  break;
                }
              }
              if (x < y) return -1;
              if (y < x) return 1;
              return 0;
            };
            function bidirectionalIndexOf(
              buffer,
              val,
              byteOffset,
              encoding,
              dir
            ) {
              if (buffer.length === 0) return -1;
              if (typeof byteOffset === 'string') {
                encoding = byteOffset;
                byteOffset = 0;
              } else if (byteOffset > 2147483647) {
                byteOffset = 2147483647;
              } else if (byteOffset < -2147483648) {
                byteOffset = -2147483648;
              }
              byteOffset = +byteOffset;
              if (isNaN(byteOffset)) {
                byteOffset = dir ? 0 : buffer.length - 1;
              }
              if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
              if (byteOffset >= buffer.length) {
                if (dir) return -1;
                else byteOffset = buffer.length - 1;
              } else if (byteOffset < 0) {
                if (dir) byteOffset = 0;
                else return -1;
              }
              if (typeof val === 'string') {
                val = Buffer.from(val, encoding);
              }
              if (Buffer.isBuffer(val)) {
                if (val.length === 0) {
                  return -1;
                }
                return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
              } else if (typeof val === 'number') {
                val = val & 255;
                if (
                  Buffer.TYPED_ARRAY_SUPPORT &&
                  typeof Uint8Array.prototype.indexOf === 'function'
                ) {
                  if (dir) {
                    return Uint8Array.prototype.indexOf.call(
                      buffer,
                      val,
                      byteOffset
                    );
                  } else {
                    return Uint8Array.prototype.lastIndexOf.call(
                      buffer,
                      val,
                      byteOffset
                    );
                  }
                }
                return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
              }
              throw new TypeError('val must be string, number or Buffer');
            }
            function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
              var indexSize = 1;
              var arrLength = arr.length;
              var valLength = val.length;
              if (encoding !== undefined) {
                encoding = String(encoding).toLowerCase();
                if (
                  encoding === 'ucs2' ||
                  encoding === 'ucs-2' ||
                  encoding === 'utf16le' ||
                  encoding === 'utf-16le'
                ) {
                  if (arr.length < 2 || val.length < 2) {
                    return -1;
                  }
                  indexSize = 2;
                  arrLength /= 2;
                  valLength /= 2;
                  byteOffset /= 2;
                }
              }
              function read(buf, i) {
                if (indexSize === 1) {
                  return buf[i];
                } else {
                  return buf.readUInt16BE(i * indexSize);
                }
              }
              var i;
              if (dir) {
                var foundIndex = -1;
                for (i = byteOffset; i < arrLength; i++) {
                  if (
                    read(arr, i) ===
                    read(val, foundIndex === -1 ? 0 : i - foundIndex)
                  ) {
                    if (foundIndex === -1) foundIndex = i;
                    if (i - foundIndex + 1 === valLength)
                      return foundIndex * indexSize;
                  } else {
                    if (foundIndex !== -1) i -= i - foundIndex;
                    foundIndex = -1;
                  }
                }
              } else {
                if (byteOffset + valLength > arrLength)
                  byteOffset = arrLength - valLength;
                for (i = byteOffset; i >= 0; i--) {
                  var found = true;
                  for (var j = 0; j < valLength; j++) {
                    if (read(arr, i + j) !== read(val, j)) {
                      found = false;
                      break;
                    }
                  }
                  if (found) return i;
                }
              }
              return -1;
            }
            Buffer.prototype.includes = function includes(
              val,
              byteOffset,
              encoding
            ) {
              return this.indexOf(val, byteOffset, encoding) !== -1;
            };
            Buffer.prototype.indexOf = function indexOf(
              val,
              byteOffset,
              encoding
            ) {
              return bidirectionalIndexOf(
                this,
                val,
                byteOffset,
                encoding,
                true
              );
            };
            Buffer.prototype.lastIndexOf = function lastIndexOf(
              val,
              byteOffset,
              encoding
            ) {
              return bidirectionalIndexOf(
                this,
                val,
                byteOffset,
                encoding,
                false
              );
            };
            function hexWrite(buf, string, offset, length) {
              offset = Number(offset) || 0;
              var remaining = buf.length - offset;
              if (!length) {
                length = remaining;
              } else {
                length = Number(length);
                if (length > remaining) {
                  length = remaining;
                }
              }
              var strLen = string.length;
              if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');
              if (length > strLen / 2) {
                length = strLen / 2;
              }
              for (var i = 0; i < length; ++i) {
                var parsed = parseInt(string.substr(i * 2, 2), 16);
                if (isNaN(parsed)) return i;
                buf[offset + i] = parsed;
              }
              return i;
            }
            function utf8Write(buf, string, offset, length) {
              return blitBuffer(
                utf8ToBytes(string, buf.length - offset),
                buf,
                offset,
                length
              );
            }
            function asciiWrite(buf, string, offset, length) {
              return blitBuffer(asciiToBytes(string), buf, offset, length);
            }
            function latin1Write(buf, string, offset, length) {
              return asciiWrite(buf, string, offset, length);
            }
            function base64Write(buf, string, offset, length) {
              return blitBuffer(base64ToBytes(string), buf, offset, length);
            }
            function ucs2Write(buf, string, offset, length) {
              return blitBuffer(
                utf16leToBytes(string, buf.length - offset),
                buf,
                offset,
                length
              );
            }
            Buffer.prototype.write = function write(
              string,
              offset,
              length,
              encoding
            ) {
              if (offset === undefined) {
                encoding = 'utf8';
                length = this.length;
                offset = 0;
              } else if (length === undefined && typeof offset === 'string') {
                encoding = offset;
                length = this.length;
                offset = 0;
              } else if (isFinite(offset)) {
                offset = offset | 0;
                if (isFinite(length)) {
                  length = length | 0;
                  if (encoding === undefined) encoding = 'utf8';
                } else {
                  encoding = length;
                  length = undefined;
                }
              } else {
                throw new Error(
                  'Buffer.write(string, encoding, offset[, length]) is no longer supported'
                );
              }
              var remaining = this.length - offset;
              if (length === undefined || length > remaining)
                length = remaining;
              if (
                (string.length > 0 && (length < 0 || offset < 0)) ||
                offset > this.length
              ) {
                throw new RangeError('Attempt to write outside buffer bounds');
              }
              if (!encoding) encoding = 'utf8';
              var loweredCase = false;
              for (;;) {
                switch (encoding) {
                  case 'hex':
                    return hexWrite(this, string, offset, length);
                  case 'utf8':
                  case 'utf-8':
                    return utf8Write(this, string, offset, length);
                  case 'ascii':
                    return asciiWrite(this, string, offset, length);
                  case 'latin1':
                  case 'binary':
                    return latin1Write(this, string, offset, length);
                  case 'base64':
                    return base64Write(this, string, offset, length);
                  case 'ucs2':
                  case 'ucs-2':
                  case 'utf16le':
                  case 'utf-16le':
                    return ucs2Write(this, string, offset, length);
                  default:
                    if (loweredCase)
                      throw new TypeError('Unknown encoding: ' + encoding);
                    encoding = ('' + encoding).toLowerCase();
                    loweredCase = true;
                }
              }
            };
            Buffer.prototype.toJSON = function toJSON() {
              return {
                type: 'Buffer',
                data: Array.prototype.slice.call(this._arr || this, 0)
              };
            };
            function base64Slice(buf, start, end) {
              if (start === 0 && end === buf.length) {
                return base64.fromByteArray(buf);
              } else {
                return base64.fromByteArray(buf.slice(start, end));
              }
            }
            function utf8Slice(buf, start, end) {
              end = Math.min(buf.length, end);
              var res = [];
              var i = start;
              while (i < end) {
                var firstByte = buf[i];
                var codePoint = null;
                var bytesPerSequence =
                  firstByte > 239
                    ? 4
                    : firstByte > 223
                    ? 3
                    : firstByte > 191
                    ? 2
                    : 1;
                if (i + bytesPerSequence <= end) {
                  var secondByte, thirdByte, fourthByte, tempCodePoint;
                  switch (bytesPerSequence) {
                    case 1:
                      if (firstByte < 128) {
                        codePoint = firstByte;
                      }
                      break;
                    case 2:
                      secondByte = buf[i + 1];
                      if ((secondByte & 192) === 128) {
                        tempCodePoint =
                          ((firstByte & 31) << 6) | (secondByte & 63);
                        if (tempCodePoint > 127) {
                          codePoint = tempCodePoint;
                        }
                      }
                      break;
                    case 3:
                      secondByte = buf[i + 1];
                      thirdByte = buf[i + 2];
                      if (
                        (secondByte & 192) === 128 &&
                        (thirdByte & 192) === 128
                      ) {
                        tempCodePoint =
                          ((firstByte & 15) << 12) |
                          ((secondByte & 63) << 6) |
                          (thirdByte & 63);
                        if (
                          tempCodePoint > 2047 &&
                          (tempCodePoint < 55296 || tempCodePoint > 57343)
                        ) {
                          codePoint = tempCodePoint;
                        }
                      }
                      break;
                    case 4:
                      secondByte = buf[i + 1];
                      thirdByte = buf[i + 2];
                      fourthByte = buf[i + 3];
                      if (
                        (secondByte & 192) === 128 &&
                        (thirdByte & 192) === 128 &&
                        (fourthByte & 192) === 128
                      ) {
                        tempCodePoint =
                          ((firstByte & 15) << 18) |
                          ((secondByte & 63) << 12) |
                          ((thirdByte & 63) << 6) |
                          (fourthByte & 63);
                        if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                          codePoint = tempCodePoint;
                        }
                      }
                  }
                }
                if (codePoint === null) {
                  codePoint = 65533;
                  bytesPerSequence = 1;
                } else if (codePoint > 65535) {
                  codePoint -= 65536;
                  res.push(((codePoint >>> 10) & 1023) | 55296);
                  codePoint = 56320 | (codePoint & 1023);
                }
                res.push(codePoint);
                i += bytesPerSequence;
              }
              return decodeCodePointsArray(res);
            }
            var MAX_ARGUMENTS_LENGTH = 4096;
            function decodeCodePointsArray(codePoints) {
              var len = codePoints.length;
              if (len <= MAX_ARGUMENTS_LENGTH) {
                return String.fromCharCode.apply(String, codePoints);
              }
              var res = '';
              var i = 0;
              while (i < len) {
                res += String.fromCharCode.apply(
                  String,
                  codePoints.slice(i, (i += MAX_ARGUMENTS_LENGTH))
                );
              }
              return res;
            }
            function asciiSlice(buf, start, end) {
              var ret = '';
              end = Math.min(buf.length, end);
              for (var i = start; i < end; ++i) {
                ret += String.fromCharCode(buf[i] & 127);
              }
              return ret;
            }
            function latin1Slice(buf, start, end) {
              var ret = '';
              end = Math.min(buf.length, end);
              for (var i = start; i < end; ++i) {
                ret += String.fromCharCode(buf[i]);
              }
              return ret;
            }
            function hexSlice(buf, start, end) {
              var len = buf.length;
              if (!start || start < 0) start = 0;
              if (!end || end < 0 || end > len) end = len;
              var out = '';
              for (var i = start; i < end; ++i) {
                out += toHex(buf[i]);
              }
              return out;
            }
            function utf16leSlice(buf, start, end) {
              var bytes = buf.slice(start, end);
              var res = '';
              for (var i = 0; i < bytes.length; i += 2) {
                res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
              }
              return res;
            }
            Buffer.prototype.slice = function slice(start, end) {
              var len = this.length;
              start = ~~start;
              end = end === undefined ? len : ~~end;
              if (start < 0) {
                start += len;
                if (start < 0) start = 0;
              } else if (start > len) {
                start = len;
              }
              if (end < 0) {
                end += len;
                if (end < 0) end = 0;
              } else if (end > len) {
                end = len;
              }
              if (end < start) end = start;
              var newBuf;
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                newBuf = this.subarray(start, end);
                newBuf.__proto__ = Buffer.prototype;
              } else {
                var sliceLen = end - start;
                newBuf = new Buffer(sliceLen, undefined);
                for (var i = 0; i < sliceLen; ++i) {
                  newBuf[i] = this[i + start];
                }
              }
              return newBuf;
            };
            function checkOffset(offset, ext, length) {
              if (offset % 1 !== 0 || offset < 0)
                throw new RangeError('offset is not uint');
              if (offset + ext > length)
                throw new RangeError('Trying to access beyond buffer length');
            }
            Buffer.prototype.readUIntLE = function readUIntLE(
              offset,
              byteLength,
              noAssert
            ) {
              offset = offset | 0;
              byteLength = byteLength | 0;
              if (!noAssert) checkOffset(offset, byteLength, this.length);
              var val = this[offset];
              var mul = 1;
              var i = 0;
              while (++i < byteLength && (mul *= 256)) {
                val += this[offset + i] * mul;
              }
              return val;
            };
            Buffer.prototype.readUIntBE = function readUIntBE(
              offset,
              byteLength,
              noAssert
            ) {
              offset = offset | 0;
              byteLength = byteLength | 0;
              if (!noAssert) {
                checkOffset(offset, byteLength, this.length);
              }
              var val = this[offset + --byteLength];
              var mul = 1;
              while (byteLength > 0 && (mul *= 256)) {
                val += this[offset + --byteLength] * mul;
              }
              return val;
            };
            Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
              if (!noAssert) checkOffset(offset, 1, this.length);
              return this[offset];
            };
            Buffer.prototype.readUInt16LE = function readUInt16LE(
              offset,
              noAssert
            ) {
              if (!noAssert) checkOffset(offset, 2, this.length);
              return this[offset] | (this[offset + 1] << 8);
            };
            Buffer.prototype.readUInt16BE = function readUInt16BE(
              offset,
              noAssert
            ) {
              if (!noAssert) checkOffset(offset, 2, this.length);
              return (this[offset] << 8) | this[offset + 1];
            };
            Buffer.prototype.readUInt32LE = function readUInt32LE(
              offset,
              noAssert
            ) {
              if (!noAssert) checkOffset(offset, 4, this.length);
              return (
                (this[offset] |
                  (this[offset + 1] << 8) |
                  (this[offset + 2] << 16)) +
                this[offset + 3] * 16777216
              );
            };
            Buffer.prototype.readUInt32BE = function readUInt32BE(
              offset,
              noAssert
            ) {
              if (!noAssert) checkOffset(offset, 4, this.length);
              return (
                this[offset] * 16777216 +
                ((this[offset + 1] << 16) |
                  (this[offset + 2] << 8) |
                  this[offset + 3])
              );
            };
            Buffer.prototype.readIntLE = function readIntLE(
              offset,
              byteLength,
              noAssert
            ) {
              offset = offset | 0;
              byteLength = byteLength | 0;
              if (!noAssert) checkOffset(offset, byteLength, this.length);
              var val = this[offset];
              var mul = 1;
              var i = 0;
              while (++i < byteLength && (mul *= 256)) {
                val += this[offset + i] * mul;
              }
              mul *= 128;
              if (val >= mul) val -= Math.pow(2, 8 * byteLength);
              return val;
            };
            Buffer.prototype.readIntBE = function readIntBE(
              offset,
              byteLength,
              noAssert
            ) {
              offset = offset | 0;
              byteLength = byteLength | 0;
              if (!noAssert) checkOffset(offset, byteLength, this.length);
              var i = byteLength;
              var mul = 1;
              var val = this[offset + --i];
              while (i > 0 && (mul *= 256)) {
                val += this[offset + --i] * mul;
              }
              mul *= 128;
              if (val >= mul) val -= Math.pow(2, 8 * byteLength);
              return val;
            };
            Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
              if (!noAssert) checkOffset(offset, 1, this.length);
              if (!(this[offset] & 128)) return this[offset];
              return (255 - this[offset] + 1) * -1;
            };
            Buffer.prototype.readInt16LE = function readInt16LE(
              offset,
              noAssert
            ) {
              if (!noAssert) checkOffset(offset, 2, this.length);
              var val = this[offset] | (this[offset + 1] << 8);
              return val & 32768 ? val | 4294901760 : val;
            };
            Buffer.prototype.readInt16BE = function readInt16BE(
              offset,
              noAssert
            ) {
              if (!noAssert) checkOffset(offset, 2, this.length);
              var val = this[offset + 1] | (this[offset] << 8);
              return val & 32768 ? val | 4294901760 : val;
            };
            Buffer.prototype.readInt32LE = function readInt32LE(
              offset,
              noAssert
            ) {
              if (!noAssert) checkOffset(offset, 4, this.length);
              return (
                this[offset] |
                (this[offset + 1] << 8) |
                (this[offset + 2] << 16) |
                (this[offset + 3] << 24)
              );
            };
            Buffer.prototype.readInt32BE = function readInt32BE(
              offset,
              noAssert
            ) {
              if (!noAssert) checkOffset(offset, 4, this.length);
              return (
                (this[offset] << 24) |
                (this[offset + 1] << 16) |
                (this[offset + 2] << 8) |
                this[offset + 3]
              );
            };
            Buffer.prototype.readFloatLE = function readFloatLE(
              offset,
              noAssert
            ) {
              if (!noAssert) checkOffset(offset, 4, this.length);
              return ieee754.read(this, offset, true, 23, 4);
            };
            Buffer.prototype.readFloatBE = function readFloatBE(
              offset,
              noAssert
            ) {
              if (!noAssert) checkOffset(offset, 4, this.length);
              return ieee754.read(this, offset, false, 23, 4);
            };
            Buffer.prototype.readDoubleLE = function readDoubleLE(
              offset,
              noAssert
            ) {
              if (!noAssert) checkOffset(offset, 8, this.length);
              return ieee754.read(this, offset, true, 52, 8);
            };
            Buffer.prototype.readDoubleBE = function readDoubleBE(
              offset,
              noAssert
            ) {
              if (!noAssert) checkOffset(offset, 8, this.length);
              return ieee754.read(this, offset, false, 52, 8);
            };
            function checkInt(buf, value, offset, ext, max, min) {
              if (!Buffer.isBuffer(buf))
                throw new TypeError(
                  '"buffer" argument must be a Buffer instance'
                );
              if (value > max || value < min)
                throw new RangeError('"value" argument is out of bounds');
              if (offset + ext > buf.length)
                throw new RangeError('Index out of range');
            }
            Buffer.prototype.writeUIntLE = function writeUIntLE(
              value,
              offset,
              byteLength,
              noAssert
            ) {
              value = +value;
              offset = offset | 0;
              byteLength = byteLength | 0;
              if (!noAssert) {
                var maxBytes = Math.pow(2, 8 * byteLength) - 1;
                checkInt(this, value, offset, byteLength, maxBytes, 0);
              }
              var mul = 1;
              var i = 0;
              this[offset] = value & 255;
              while (++i < byteLength && (mul *= 256)) {
                this[offset + i] = (value / mul) & 255;
              }
              return offset + byteLength;
            };
            Buffer.prototype.writeUIntBE = function writeUIntBE(
              value,
              offset,
              byteLength,
              noAssert
            ) {
              value = +value;
              offset = offset | 0;
              byteLength = byteLength | 0;
              if (!noAssert) {
                var maxBytes = Math.pow(2, 8 * byteLength) - 1;
                checkInt(this, value, offset, byteLength, maxBytes, 0);
              }
              var i = byteLength - 1;
              var mul = 1;
              this[offset + i] = value & 255;
              while (--i >= 0 && (mul *= 256)) {
                this[offset + i] = (value / mul) & 255;
              }
              return offset + byteLength;
            };
            Buffer.prototype.writeUInt8 = function writeUInt8(
              value,
              offset,
              noAssert
            ) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
              if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
              this[offset] = value & 255;
              return offset + 1;
            };
            function objectWriteUInt16(buf, value, offset, littleEndian) {
              if (value < 0) value = 65535 + value + 1;
              for (
                var i = 0, j = Math.min(buf.length - offset, 2);
                i < j;
                ++i
              ) {
                buf[offset + i] =
                  (value & (255 << (8 * (littleEndian ? i : 1 - i)))) >>>
                  ((littleEndian ? i : 1 - i) * 8);
              }
            }
            Buffer.prototype.writeUInt16LE = function writeUInt16LE(
              value,
              offset,
              noAssert
            ) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = value & 255;
                this[offset + 1] = value >>> 8;
              } else {
                objectWriteUInt16(this, value, offset, true);
              }
              return offset + 2;
            };
            Buffer.prototype.writeUInt16BE = function writeUInt16BE(
              value,
              offset,
              noAssert
            ) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = value >>> 8;
                this[offset + 1] = value & 255;
              } else {
                objectWriteUInt16(this, value, offset, false);
              }
              return offset + 2;
            };
            function objectWriteUInt32(buf, value, offset, littleEndian) {
              if (value < 0) value = 4294967295 + value + 1;
              for (
                var i = 0, j = Math.min(buf.length - offset, 4);
                i < j;
                ++i
              ) {
                buf[offset + i] =
                  (value >>> ((littleEndian ? i : 3 - i) * 8)) & 255;
              }
            }
            Buffer.prototype.writeUInt32LE = function writeUInt32LE(
              value,
              offset,
              noAssert
            ) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset + 3] = value >>> 24;
                this[offset + 2] = value >>> 16;
                this[offset + 1] = value >>> 8;
                this[offset] = value & 255;
              } else {
                objectWriteUInt32(this, value, offset, true);
              }
              return offset + 4;
            };
            Buffer.prototype.writeUInt32BE = function writeUInt32BE(
              value,
              offset,
              noAssert
            ) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = value >>> 24;
                this[offset + 1] = value >>> 16;
                this[offset + 2] = value >>> 8;
                this[offset + 3] = value & 255;
              } else {
                objectWriteUInt32(this, value, offset, false);
              }
              return offset + 4;
            };
            Buffer.prototype.writeIntLE = function writeIntLE(
              value,
              offset,
              byteLength,
              noAssert
            ) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) {
                var limit = Math.pow(2, 8 * byteLength - 1);
                checkInt(this, value, offset, byteLength, limit - 1, -limit);
              }
              var i = 0;
              var mul = 1;
              var sub = 0;
              this[offset] = value & 255;
              while (++i < byteLength && (mul *= 256)) {
                if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                  sub = 1;
                }
                this[offset + i] = (((value / mul) >> 0) - sub) & 255;
              }
              return offset + byteLength;
            };
            Buffer.prototype.writeIntBE = function writeIntBE(
              value,
              offset,
              byteLength,
              noAssert
            ) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) {
                var limit = Math.pow(2, 8 * byteLength - 1);
                checkInt(this, value, offset, byteLength, limit - 1, -limit);
              }
              var i = byteLength - 1;
              var mul = 1;
              var sub = 0;
              this[offset + i] = value & 255;
              while (--i >= 0 && (mul *= 256)) {
                if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                  sub = 1;
                }
                this[offset + i] = (((value / mul) >> 0) - sub) & 255;
              }
              return offset + byteLength;
            };
            Buffer.prototype.writeInt8 = function writeInt8(
              value,
              offset,
              noAssert
            ) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
              if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
              if (value < 0) value = 255 + value + 1;
              this[offset] = value & 255;
              return offset + 1;
            };
            Buffer.prototype.writeInt16LE = function writeInt16LE(
              value,
              offset,
              noAssert
            ) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = value & 255;
                this[offset + 1] = value >>> 8;
              } else {
                objectWriteUInt16(this, value, offset, true);
              }
              return offset + 2;
            };
            Buffer.prototype.writeInt16BE = function writeInt16BE(
              value,
              offset,
              noAssert
            ) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = value >>> 8;
                this[offset + 1] = value & 255;
              } else {
                objectWriteUInt16(this, value, offset, false);
              }
              return offset + 2;
            };
            Buffer.prototype.writeInt32LE = function writeInt32LE(
              value,
              offset,
              noAssert
            ) {
              value = +value;
              offset = offset | 0;
              if (!noAssert)
                checkInt(this, value, offset, 4, 2147483647, -2147483648);
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = value & 255;
                this[offset + 1] = value >>> 8;
                this[offset + 2] = value >>> 16;
                this[offset + 3] = value >>> 24;
              } else {
                objectWriteUInt32(this, value, offset, true);
              }
              return offset + 4;
            };
            Buffer.prototype.writeInt32BE = function writeInt32BE(
              value,
              offset,
              noAssert
            ) {
              value = +value;
              offset = offset | 0;
              if (!noAssert)
                checkInt(this, value, offset, 4, 2147483647, -2147483648);
              if (value < 0) value = 4294967295 + value + 1;
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = value >>> 24;
                this[offset + 1] = value >>> 16;
                this[offset + 2] = value >>> 8;
                this[offset + 3] = value & 255;
              } else {
                objectWriteUInt32(this, value, offset, false);
              }
              return offset + 4;
            };
            function checkIEEE754(buf, value, offset, ext, max, min) {
              if (offset + ext > buf.length)
                throw new RangeError('Index out of range');
              if (offset < 0) throw new RangeError('Index out of range');
            }
            function writeFloat(buf, value, offset, littleEndian, noAssert) {
              if (!noAssert) {
                checkIEEE754(
                  buf,
                  value,
                  offset,
                  4,
                  3.4028234663852886e38,
                  -3.4028234663852886e38
                );
              }
              ieee754.write(buf, value, offset, littleEndian, 23, 4);
              return offset + 4;
            }
            Buffer.prototype.writeFloatLE = function writeFloatLE(
              value,
              offset,
              noAssert
            ) {
              return writeFloat(this, value, offset, true, noAssert);
            };
            Buffer.prototype.writeFloatBE = function writeFloatBE(
              value,
              offset,
              noAssert
            ) {
              return writeFloat(this, value, offset, false, noAssert);
            };
            function writeDouble(buf, value, offset, littleEndian, noAssert) {
              if (!noAssert) {
                checkIEEE754(
                  buf,
                  value,
                  offset,
                  8,
                  1.7976931348623157e308,
                  -1.7976931348623157e308
                );
              }
              ieee754.write(buf, value, offset, littleEndian, 52, 8);
              return offset + 8;
            }
            Buffer.prototype.writeDoubleLE = function writeDoubleLE(
              value,
              offset,
              noAssert
            ) {
              return writeDouble(this, value, offset, true, noAssert);
            };
            Buffer.prototype.writeDoubleBE = function writeDoubleBE(
              value,
              offset,
              noAssert
            ) {
              return writeDouble(this, value, offset, false, noAssert);
            };
            Buffer.prototype.copy = function copy(
              target,
              targetStart,
              start,
              end
            ) {
              if (!start) start = 0;
              if (!end && end !== 0) end = this.length;
              if (targetStart >= target.length) targetStart = target.length;
              if (!targetStart) targetStart = 0;
              if (end > 0 && end < start) end = start;
              if (end === start) return 0;
              if (target.length === 0 || this.length === 0) return 0;
              if (targetStart < 0) {
                throw new RangeError('targetStart out of bounds');
              }
              if (start < 0 || start >= this.length)
                throw new RangeError('sourceStart out of bounds');
              if (end < 0) throw new RangeError('sourceEnd out of bounds');
              if (end > this.length) end = this.length;
              if (target.length - targetStart < end - start) {
                end = target.length - targetStart + start;
              }
              var len = end - start;
              var i;
              if (this === target && start < targetStart && targetStart < end) {
                for (i = len - 1; i >= 0; --i) {
                  target[i + targetStart] = this[i + start];
                }
              } else if (len < 1e3 || !Buffer.TYPED_ARRAY_SUPPORT) {
                for (i = 0; i < len; ++i) {
                  target[i + targetStart] = this[i + start];
                }
              } else {
                Uint8Array.prototype.set.call(
                  target,
                  this.subarray(start, start + len),
                  targetStart
                );
              }
              return len;
            };
            Buffer.prototype.fill = function fill(val, start, end, encoding) {
              if (typeof val === 'string') {
                if (typeof start === 'string') {
                  encoding = start;
                  start = 0;
                  end = this.length;
                } else if (typeof end === 'string') {
                  encoding = end;
                  end = this.length;
                }
                if (val.length === 1) {
                  var code = val.charCodeAt(0);
                  if (code < 256) {
                    val = code;
                  }
                }
                if (encoding !== undefined && typeof encoding !== 'string') {
                  throw new TypeError('encoding must be a string');
                }
                if (
                  typeof encoding === 'string' &&
                  !Buffer.isEncoding(encoding)
                ) {
                  throw new TypeError('Unknown encoding: ' + encoding);
                }
              } else if (typeof val === 'number') {
                val = val & 255;
              }
              if (start < 0 || this.length < start || this.length < end) {
                throw new RangeError('Out of range index');
              }
              if (end <= start) {
                return this;
              }
              start = start >>> 0;
              end = end === undefined ? this.length : end >>> 0;
              if (!val) val = 0;
              var i;
              if (typeof val === 'number') {
                for (i = start; i < end; ++i) {
                  this[i] = val;
                }
              } else {
                var bytes = Buffer.isBuffer(val)
                  ? val
                  : utf8ToBytes(new Buffer(val, encoding).toString());
                var len = bytes.length;
                for (i = 0; i < end - start; ++i) {
                  this[i + start] = bytes[i % len];
                }
              }
              return this;
            };
            var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
            function base64clean(str) {
              str = stringtrim(str).replace(INVALID_BASE64_RE, '');
              if (str.length < 2) return '';
              while (str.length % 4 !== 0) {
                str = str + '=';
              }
              return str;
            }
            function stringtrim(str) {
              if (str.trim) return str.trim();
              return str.replace(/^\s+|\s+$/g, '');
            }
            function toHex(n) {
              if (n < 16) return '0' + n.toString(16);
              return n.toString(16);
            }
            function utf8ToBytes(string, units) {
              units = units || Infinity;
              var codePoint;
              var length = string.length;
              var leadSurrogate = null;
              var bytes = [];
              for (var i = 0; i < length; ++i) {
                codePoint = string.charCodeAt(i);
                if (codePoint > 55295 && codePoint < 57344) {
                  if (!leadSurrogate) {
                    if (codePoint > 56319) {
                      if ((units -= 3) > -1) bytes.push(239, 191, 189);
                      continue;
                    } else if (i + 1 === length) {
                      if ((units -= 3) > -1) bytes.push(239, 191, 189);
                      continue;
                    }
                    leadSurrogate = codePoint;
                    continue;
                  }
                  if (codePoint < 56320) {
                    if ((units -= 3) > -1) bytes.push(239, 191, 189);
                    leadSurrogate = codePoint;
                    continue;
                  }
                  codePoint =
                    (((leadSurrogate - 55296) << 10) | (codePoint - 56320)) +
                    65536;
                } else if (leadSurrogate) {
                  if ((units -= 3) > -1) bytes.push(239, 191, 189);
                }
                leadSurrogate = null;
                if (codePoint < 128) {
                  if ((units -= 1) < 0) break;
                  bytes.push(codePoint);
                } else if (codePoint < 2048) {
                  if ((units -= 2) < 0) break;
                  bytes.push((codePoint >> 6) | 192, (codePoint & 63) | 128);
                } else if (codePoint < 65536) {
                  if ((units -= 3) < 0) break;
                  bytes.push(
                    (codePoint >> 12) | 224,
                    ((codePoint >> 6) & 63) | 128,
                    (codePoint & 63) | 128
                  );
                } else if (codePoint < 1114112) {
                  if ((units -= 4) < 0) break;
                  bytes.push(
                    (codePoint >> 18) | 240,
                    ((codePoint >> 12) & 63) | 128,
                    ((codePoint >> 6) & 63) | 128,
                    (codePoint & 63) | 128
                  );
                } else {
                  throw new Error('Invalid code point');
                }
              }
              return bytes;
            }
            function asciiToBytes(str) {
              var byteArray = [];
              for (var i = 0; i < str.length; ++i) {
                byteArray.push(str.charCodeAt(i) & 255);
              }
              return byteArray;
            }
            function utf16leToBytes(str, units) {
              var c, hi, lo;
              var byteArray = [];
              for (var i = 0; i < str.length; ++i) {
                if ((units -= 2) < 0) break;
                c = str.charCodeAt(i);
                hi = c >> 8;
                lo = c % 256;
                byteArray.push(lo);
                byteArray.push(hi);
              }
              return byteArray;
            }
            function base64ToBytes(str) {
              return base64.toByteArray(base64clean(str));
            }
            function blitBuffer(src, dst, offset, length) {
              for (var i = 0; i < length; ++i) {
                if (i + offset >= dst.length || i >= src.length) break;
                dst[i + offset] = src[i];
              }
              return i;
            }
            function isnan(val) {
              return val !== val;
            }
          }.call(
            this,
            typeof global !== 'undefined'
              ? global
              : typeof self !== 'undefined'
              ? self
              : typeof window !== 'undefined'
              ? window
              : {}
          ));
        },
        { 'base64-js': 152, ieee754: 205, isarray: 209 }
      ],
      184: [
        function(require, module, exports) {
          var Buffer = require('safe-buffer').Buffer;
          var Transform = require('stream').Transform;
          var StringDecoder = require('string_decoder').StringDecoder;
          var inherits = require('inherits');
          function CipherBase(hashMode) {
            Transform.call(this);
            this.hashMode = typeof hashMode === 'string';
            if (this.hashMode) {
              this[hashMode] = this._finalOrDigest;
            } else {
              this.final = this._finalOrDigest;
            }
            if (this._final) {
              this.__final = this._final;
              this._final = null;
            }
            this._decoder = null;
            this._encoding = null;
          }
          inherits(CipherBase, Transform);
          CipherBase.prototype.update = function(data, inputEnc, outputEnc) {
            if (typeof data === 'string') {
              data = Buffer.from(data, inputEnc);
            }
            var outData = this._update(data);
            if (this.hashMode) return this;
            if (outputEnc) {
              outData = this._toString(outData, outputEnc);
            }
            return outData;
          };
          CipherBase.prototype.setAutoPadding = function() {};
          CipherBase.prototype.getAuthTag = function() {
            throw new Error('trying to get auth tag in unsupported state');
          };
          CipherBase.prototype.setAuthTag = function() {
            throw new Error('trying to set auth tag in unsupported state');
          };
          CipherBase.prototype.setAAD = function() {
            throw new Error('trying to set aad in unsupported state');
          };
          CipherBase.prototype._transform = function(data, _, next) {
            var err;
            try {
              if (this.hashMode) {
                this._update(data);
              } else {
                this.push(this._update(data));
              }
            } catch (e) {
              err = e;
            } finally {
              next(err);
            }
          };
          CipherBase.prototype._flush = function(done) {
            var err;
            try {
              this.push(this.__final());
            } catch (e) {
              err = e;
            }
            done(err);
          };
          CipherBase.prototype._finalOrDigest = function(outputEnc) {
            var outData = this.__final() || Buffer.alloc(0);
            if (outputEnc) {
              outData = this._toString(outData, outputEnc, true);
            }
            return outData;
          };
          CipherBase.prototype._toString = function(value, enc, fin) {
            if (!this._decoder) {
              this._decoder = new StringDecoder(enc);
              this._encoding = enc;
            }
            if (this._encoding !== enc)
              throw new Error("can't switch encodings");
            var out = this._decoder.write(value);
            if (fin) {
              out += this._decoder.end();
            }
            return out;
          };
          module.exports = CipherBase;
        },
        { inherits: 207, 'safe-buffer': 460, stream: 258, string_decoder: 259 }
      ],
      185: [
        function(require, module, exports) {
          (function(Buffer) {
            function isArray(arg) {
              if (Array.isArray) {
                return Array.isArray(arg);
              }
              return objectToString(arg) === '[object Array]';
            }
            exports.isArray = isArray;
            function isBoolean(arg) {
              return typeof arg === 'boolean';
            }
            exports.isBoolean = isBoolean;
            function isNull(arg) {
              return arg === null;
            }
            exports.isNull = isNull;
            function isNullOrUndefined(arg) {
              return arg == null;
            }
            exports.isNullOrUndefined = isNullOrUndefined;
            function isNumber(arg) {
              return typeof arg === 'number';
            }
            exports.isNumber = isNumber;
            function isString(arg) {
              return typeof arg === 'string';
            }
            exports.isString = isString;
            function isSymbol(arg) {
              return typeof arg === 'symbol';
            }
            exports.isSymbol = isSymbol;
            function isUndefined(arg) {
              return arg === void 0;
            }
            exports.isUndefined = isUndefined;
            function isRegExp(re) {
              return objectToString(re) === '[object RegExp]';
            }
            exports.isRegExp = isRegExp;
            function isObject(arg) {
              return typeof arg === 'object' && arg !== null;
            }
            exports.isObject = isObject;
            function isDate(d) {
              return objectToString(d) === '[object Date]';
            }
            exports.isDate = isDate;
            function isError(e) {
              return (
                objectToString(e) === '[object Error]' || e instanceof Error
              );
            }
            exports.isError = isError;
            function isFunction(arg) {
              return typeof arg === 'function';
            }
            exports.isFunction = isFunction;
            function isPrimitive(arg) {
              return (
                arg === null ||
                typeof arg === 'boolean' ||
                typeof arg === 'number' ||
                typeof arg === 'string' ||
                typeof arg === 'symbol' ||
                typeof arg === 'undefined'
              );
            }
            exports.isPrimitive = isPrimitive;
            exports.isBuffer = Buffer.isBuffer;
            function objectToString(o) {
              return Object.prototype.toString.call(o);
            }
          }.call(this, { isBuffer: require('../../is-buffer/index.js') }));
        },
        { '../../is-buffer/index.js': 208 }
      ],
      186: [
        function(require, module, exports) {
          (function(Buffer) {
            var elliptic = require('elliptic');
            var BN = require('bn.js');
            module.exports = function createECDH(curve) {
              return new ECDH(curve);
            };
            var aliases = {
              secp256k1: { name: 'secp256k1', byteLength: 32 },
              secp224r1: { name: 'p224', byteLength: 28 },
              prime256v1: { name: 'p256', byteLength: 32 },
              prime192v1: { name: 'p192', byteLength: 24 },
              ed25519: { name: 'ed25519', byteLength: 32 },
              secp384r1: { name: 'p384', byteLength: 48 },
              secp521r1: { name: 'p521', byteLength: 66 }
            };
            aliases.p224 = aliases.secp224r1;
            aliases.p256 = aliases.secp256r1 = aliases.prime256v1;
            aliases.p192 = aliases.secp192r1 = aliases.prime192v1;
            aliases.p384 = aliases.secp384r1;
            aliases.p521 = aliases.secp521r1;
            function ECDH(curve) {
              this.curveType = aliases[curve];
              if (!this.curveType) {
                this.curveType = { name: curve };
              }
              this.curve = new elliptic.ec(this.curveType.name);
              this.keys = void 0;
            }
            ECDH.prototype.generateKeys = function(enc, format) {
              this.keys = this.curve.genKeyPair();
              return this.getPublicKey(enc, format);
            };
            ECDH.prototype.computeSecret = function(other, inenc, enc) {
              inenc = inenc || 'utf8';
              if (!Buffer.isBuffer(other)) {
                other = new Buffer(other, inenc);
              }
              var otherPub = this.curve.keyFromPublic(other).getPublic();
              var out = otherPub.mul(this.keys.getPrivate()).getX();
              return formatReturnValue(out, enc, this.curveType.byteLength);
            };
            ECDH.prototype.getPublicKey = function(enc, format) {
              var key = this.keys.getPublic(format === 'compressed', true);
              if (format === 'hybrid') {
                if (key[key.length - 1] % 2) {
                  key[0] = 7;
                } else {
                  key[0] = 6;
                }
              }
              return formatReturnValue(key, enc);
            };
            ECDH.prototype.getPrivateKey = function(enc) {
              return formatReturnValue(this.keys.getPrivate(), enc);
            };
            ECDH.prototype.setPublicKey = function(pub, enc) {
              enc = enc || 'utf8';
              if (!Buffer.isBuffer(pub)) {
                pub = new Buffer(pub, enc);
              }
              this.keys._importPublic(pub);
              return this;
            };
            ECDH.prototype.setPrivateKey = function(priv, enc) {
              enc = enc || 'utf8';
              if (!Buffer.isBuffer(priv)) {
                priv = new Buffer(priv, enc);
              }
              var _priv = new BN(priv);
              _priv = _priv.toString(16);
              this.keys._importPrivate(_priv);
              return this;
            };
            function formatReturnValue(bn, enc, len) {
              if (!Array.isArray(bn)) {
                bn = bn.toArray();
              }
              var buf = new Buffer(bn);
              if (len && buf.length < len) {
                var zeros = new Buffer(len - buf.length);
                zeros.fill(0);
                buf = Buffer.concat([zeros, buf]);
              }
              if (!enc) {
                return buf;
              } else {
                return buf.toString(enc);
              }
            }
          }.call(this, require('buffer').Buffer));
        },
        { 'bn.js': 153, buffer: 183, elliptic: 309 }
      ],
      187: [
        function(require, module, exports) {
          (function(Buffer) {
            'use strict';
            var inherits = require('inherits');
            var md5 = require('./md5');
            var RIPEMD160 = require('ripemd160');
            var sha = require('sha.js');
            var Base = require('cipher-base');
            function HashNoConstructor(hash) {
              Base.call(this, 'digest');
              this._hash = hash;
              this.buffers = [];
            }
            inherits(HashNoConstructor, Base);
            HashNoConstructor.prototype._update = function(data) {
              this.buffers.push(data);
            };
            HashNoConstructor.prototype._final = function() {
              var buf = Buffer.concat(this.buffers);
              var r = this._hash(buf);
              this.buffers = null;
              return r;
            };
            function Hash(hash) {
              Base.call(this, 'digest');
              this._hash = hash;
            }
            inherits(Hash, Base);
            Hash.prototype._update = function(data) {
              this._hash.update(data);
            };
            Hash.prototype._final = function() {
              return this._hash.digest();
            };
            module.exports = function createHash(alg) {
              alg = alg.toLowerCase();
              if (alg === 'md5') return new HashNoConstructor(md5);
              if (alg === 'rmd160' || alg === 'ripemd160')
                return new Hash(new RIPEMD160());
              return new Hash(sha(alg));
            };
          }.call(this, require('buffer').Buffer));
        },
        {
          './md5': 189,
          buffer: 183,
          'cipher-base': 184,
          inherits: 207,
          ripemd160: 249,
          'sha.js': 251
        }
      ],
      188: [
        function(require, module, exports) {
          (function(Buffer) {
            'use strict';
            var intSize = 4;
            var zeroBuffer = new Buffer(intSize);
            zeroBuffer.fill(0);
            var charSize = 8;
            var hashSize = 16;
            function toArray(buf) {
              if (buf.length % intSize !== 0) {
                var len = buf.length + (intSize - (buf.length % intSize));
                buf = Buffer.concat([buf, zeroBuffer], len);
              }
              var arr = new Array(buf.length >>> 2);
              for (var i = 0, j = 0; i < buf.length; i += intSize, j++) {
                arr[j] = buf.readInt32LE(i);
              }
              return arr;
            }
            module.exports = function hash(buf, fn) {
              var arr = fn(toArray(buf), buf.length * charSize);
              buf = new Buffer(hashSize);
              for (var i = 0; i < arr.length; i++) {
                buf.writeInt32LE(arr[i], i << 2, true);
              }
              return buf;
            };
          }.call(this, require('buffer').Buffer));
        },
        { buffer: 183 }
      ],
      189: [
        function(require, module, exports) {
          'use strict';
          var makeHash = require('./make-hash');
          function core_md5(x, len) {
            x[len >> 5] |= 128 << len % 32;
            x[(((len + 64) >>> 9) << 4) + 14] = len;
            var a = 1732584193;
            var b = -271733879;
            var c = -1732584194;
            var d = 271733878;
            for (var i = 0; i < x.length; i += 16) {
              var olda = a;
              var oldb = b;
              var oldc = c;
              var oldd = d;
              a = md5_ff(a, b, c, d, x[i + 0], 7, -680876936);
              d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586);
              c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819);
              b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330);
              a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897);
              d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426);
              c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341);
              b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983);
              a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416);
              d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417);
              c = md5_ff(c, d, a, b, x[i + 10], 17, -42063);
              b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);
              a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682);
              d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101);
              c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);
              b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329);
              a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510);
              d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632);
              c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713);
              b = md5_gg(b, c, d, a, x[i + 0], 20, -373897302);
              a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691);
              d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083);
              c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335);
              b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848);
              a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438);
              d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690);
              c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961);
              b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501);
              a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467);
              d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784);
              c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473);
              b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);
              a = md5_hh(a, b, c, d, x[i + 5], 4, -378558);
              d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463);
              c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562);
              b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556);
              a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060);
              d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353);
              c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632);
              b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);
              a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174);
              d = md5_hh(d, a, b, c, x[i + 0], 11, -358537222);
              c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979);
              b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189);
              a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487);
              d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835);
              c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520);
              b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651);
              a = md5_ii(a, b, c, d, x[i + 0], 6, -198630844);
              d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415);
              c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);
              b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055);
              a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571);
              d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606);
              c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523);
              b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799);
              a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359);
              d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744);
              c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380);
              b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649);
              a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070);
              d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);
              c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259);
              b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551);
              a = safe_add(a, olda);
              b = safe_add(b, oldb);
              c = safe_add(c, oldc);
              d = safe_add(d, oldd);
            }
            return [a, b, c, d];
          }
          function md5_cmn(q, a, b, x, s, t) {
            return safe_add(
              bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),
              b
            );
          }
          function md5_ff(a, b, c, d, x, s, t) {
            return md5_cmn((b & c) | (~b & d), a, b, x, s, t);
          }
          function md5_gg(a, b, c, d, x, s, t) {
            return md5_cmn((b & d) | (c & ~d), a, b, x, s, t);
          }
          function md5_hh(a, b, c, d, x, s, t) {
            return md5_cmn(b ^ c ^ d, a, b, x, s, t);
          }
          function md5_ii(a, b, c, d, x, s, t) {
            return md5_cmn(c ^ (b | ~d), a, b, x, s, t);
          }
          function safe_add(x, y) {
            var lsw = (x & 65535) + (y & 65535);
            var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
            return (msw << 16) | (lsw & 65535);
          }
          function bit_rol(num, cnt) {
            return (num << cnt) | (num >>> (32 - cnt));
          }
          module.exports = function md5(buf) {
            return makeHash(buf, core_md5);
          };
        },
        { './make-hash': 188 }
      ],
      190: [
        function(require, module, exports) {
          'use strict';
          var inherits = require('inherits');
          var Legacy = require('./legacy');
          var Base = require('cipher-base');
          var Buffer = require('safe-buffer').Buffer;
          var md5 = require('create-hash/md5');
          var RIPEMD160 = require('ripemd160');
          var sha = require('sha.js');
          var ZEROS = Buffer.alloc(128);
          function Hmac(alg, key) {
            Base.call(this, 'digest');
            if (typeof key === 'string') {
              key = Buffer.from(key);
            }
            var blocksize = alg === 'sha512' || alg === 'sha384' ? 128 : 64;
            this._alg = alg;
            this._key = key;
            if (key.length > blocksize) {
              var hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg);
              key = hash.update(key).digest();
            } else if (key.length < blocksize) {
              key = Buffer.concat([key, ZEROS], blocksize);
            }
            var ipad = (this._ipad = Buffer.allocUnsafe(blocksize));
            var opad = (this._opad = Buffer.allocUnsafe(blocksize));
            for (var i = 0; i < blocksize; i++) {
              ipad[i] = key[i] ^ 54;
              opad[i] = key[i] ^ 92;
            }
            this._hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg);
            this._hash.update(ipad);
          }
          inherits(Hmac, Base);
          Hmac.prototype._update = function(data) {
            this._hash.update(data);
          };
          Hmac.prototype._final = function() {
            var h = this._hash.digest();
            var hash =
              this._alg === 'rmd160' ? new RIPEMD160() : sha(this._alg);
            return hash
              .update(this._opad)
              .update(h)
              .digest();
          };
          module.exports = function createHmac(alg, key) {
            alg = alg.toLowerCase();
            if (alg === 'rmd160' || alg === 'ripemd160') {
              return new Hmac('rmd160', key);
            }
            if (alg === 'md5') {
              return new Legacy(md5, key);
            }
            return new Hmac(alg, key);
          };
        },
        {
          './legacy': 191,
          'cipher-base': 184,
          'create-hash/md5': 189,
          inherits: 207,
          ripemd160: 249,
          'safe-buffer': 460,
          'sha.js': 251
        }
      ],
      191: [
        function(require, module, exports) {
          'use strict';
          var inherits = require('inherits');
          var Buffer = require('safe-buffer').Buffer;
          var Base = require('cipher-base');
          var ZEROS = Buffer.alloc(128);
          var blocksize = 64;
          function Hmac(alg, key) {
            Base.call(this, 'digest');
            if (typeof key === 'string') {
              key = Buffer.from(key);
            }
            this._alg = alg;
            this._key = key;
            if (key.length > blocksize) {
              key = alg(key);
            } else if (key.length < blocksize) {
              key = Buffer.concat([key, ZEROS], blocksize);
            }
            var ipad = (this._ipad = Buffer.allocUnsafe(blocksize));
            var opad = (this._opad = Buffer.allocUnsafe(blocksize));
            for (var i = 0; i < blocksize; i++) {
              ipad[i] = key[i] ^ 54;
              opad[i] = key[i] ^ 92;
            }
            this._hash = [ipad];
          }
          inherits(Hmac, Base);
          Hmac.prototype._update = function(data) {
            this._hash.push(data);
          };
          Hmac.prototype._final = function() {
            var h = this._alg(Buffer.concat(this._hash));
            return this._alg(Buffer.concat([this._opad, h]));
          };
          module.exports = Hmac;
        },
        { 'cipher-base': 184, inherits: 207, 'safe-buffer': 460 }
      ],
      192: [
        function(require, module, exports) {
          'use strict';
          exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = require('randombytes');
          exports.createHash = exports.Hash = require('create-hash');
          exports.createHmac = exports.Hmac = require('create-hmac');
          var algos = require('browserify-sign/algos');
          var algoKeys = Object.keys(algos);
          var hashes = [
            'sha1',
            'sha224',
            'sha256',
            'sha384',
            'sha512',
            'md5',
            'rmd160'
          ].concat(algoKeys);
          exports.getHashes = function() {
            return hashes;
          };
          var p = require('pbkdf2');
          exports.pbkdf2 = p.pbkdf2;
          exports.pbkdf2Sync = p.pbkdf2Sync;
          var aes = require('browserify-cipher');
          exports.Cipher = aes.Cipher;
          exports.createCipher = aes.createCipher;
          exports.Cipheriv = aes.Cipheriv;
          exports.createCipheriv = aes.createCipheriv;
          exports.Decipher = aes.Decipher;
          exports.createDecipher = aes.createDecipher;
          exports.Decipheriv = aes.Decipheriv;
          exports.createDecipheriv = aes.createDecipheriv;
          exports.getCiphers = aes.getCiphers;
          exports.listCiphers = aes.listCiphers;
          var dh = require('diffie-hellman');
          exports.DiffieHellmanGroup = dh.DiffieHellmanGroup;
          exports.createDiffieHellmanGroup = dh.createDiffieHellmanGroup;
          exports.getDiffieHellman = dh.getDiffieHellman;
          exports.createDiffieHellman = dh.createDiffieHellman;
          exports.DiffieHellman = dh.DiffieHellman;
          var sign = require('browserify-sign');
          exports.createSign = sign.createSign;
          exports.Sign = sign.Sign;
          exports.createVerify = sign.createVerify;
          exports.Verify = sign.Verify;
          exports.createECDH = require('create-ecdh');
          var publicEncrypt = require('public-encrypt');
          exports.publicEncrypt = publicEncrypt.publicEncrypt;
          exports.privateEncrypt = publicEncrypt.privateEncrypt;
          exports.publicDecrypt = publicEncrypt.publicDecrypt;
          exports.privateDecrypt = publicEncrypt.privateDecrypt;
          exports.createCredentials = function() {
            throw new Error(
              [
                'sorry, createCredentials is not implemented yet',
                'we accept pull requests',
                'https://github.com/crypto-browserify/crypto-browserify'
              ].join('\n')
            );
          };
          exports.constants = {
            DH_CHECK_P_NOT_SAFE_PRIME: 2,
            DH_CHECK_P_NOT_PRIME: 1,
            DH_UNABLE_TO_CHECK_GENERATOR: 4,
            DH_NOT_SUITABLE_GENERATOR: 8,
            NPN_ENABLED: 1,
            ALPN_ENABLED: 1,
            RSA_PKCS1_PADDING: 1,
            RSA_SSLV23_PADDING: 2,
            RSA_NO_PADDING: 3,
            RSA_PKCS1_OAEP_PADDING: 4,
            RSA_X931_PADDING: 5,
            RSA_PKCS1_PSS_PADDING: 6,
            POINT_CONVERSION_COMPRESSED: 2,
            POINT_CONVERSION_UNCOMPRESSED: 4,
            POINT_CONVERSION_HYBRID: 6
          };
        },
        {
          'browserify-cipher': 172,
          'browserify-sign': 179,
          'browserify-sign/algos': 176,
          'create-ecdh': 186,
          'create-hash': 187,
          'create-hmac': 190,
          'diffie-hellman': 199,
          pbkdf2: 217,
          'public-encrypt': 224,
          randombytes: 234
        }
      ],
      193: [
        function(require, module, exports) {
          'use strict';
          exports.utils = require('./des/utils');
          exports.Cipher = require('./des/cipher');
          exports.DES = require('./des/des');
          exports.CBC = require('./des/cbc');
          exports.EDE = require('./des/ede');
        },
        {
          './des/cbc': 194,
          './des/cipher': 195,
          './des/des': 196,
          './des/ede': 197,
          './des/utils': 198
        }
      ],
      194: [
        function(require, module, exports) {
          'use strict';
          var assert = require('minimalistic-assert');
          var inherits = require('inherits');
          var proto = {};
          function CBCState(iv) {
            assert.equal(iv.length, 8, 'Invalid IV length');
            this.iv = new Array(8);
            for (var i = 0; i < this.iv.length; i++) this.iv[i] = iv[i];
          }
          function instantiate(Base) {
            function CBC(options) {
              Base.call(this, options);
              this._cbcInit();
            }
            inherits(CBC, Base);
            var keys = Object.keys(proto);
            for (var i = 0; i < keys.length; i++) {
              var key = keys[i];
              CBC.prototype[key] = proto[key];
            }
            CBC.create = function create(options) {
              return new CBC(options);
            };
            return CBC;
          }
          exports.instantiate = instantiate;
          proto._cbcInit = function _cbcInit() {
            var state = new CBCState(this.options.iv);
            this._cbcState = state;
          };
          proto._update = function _update(inp, inOff, out, outOff) {
            var state = this._cbcState;
            var superProto = this.constructor.super_.prototype;
            var iv = state.iv;
            if (this.type === 'encrypt') {
              for (var i = 0; i < this.blockSize; i++) iv[i] ^= inp[inOff + i];
              superProto._update.call(this, iv, 0, out, outOff);
              for (var i = 0; i < this.blockSize; i++) iv[i] = out[outOff + i];
            } else {
              superProto._update.call(this, inp, inOff, out, outOff);
              for (var i = 0; i < this.blockSize; i++) out[outOff + i] ^= iv[i];
              for (var i = 0; i < this.blockSize; i++) iv[i] = inp[inOff + i];
            }
          };
        },
        { inherits: 207, 'minimalistic-assert': 211 }
      ],
      195: [
        function(require, module, exports) {
          'use strict';
          var assert = require('minimalistic-assert');
          function Cipher(options) {
            this.options = options;
            this.type = this.options.type;
            this.blockSize = 8;
            this._init();
            this.buffer = new Array(this.blockSize);
            this.bufferOff = 0;
          }
          module.exports = Cipher;
          Cipher.prototype._init = function _init() {};
          Cipher.prototype.update = function update(data) {
            if (data.length === 0) return [];
            if (this.type === 'decrypt') return this._updateDecrypt(data);
            else return this._updateEncrypt(data);
          };
          Cipher.prototype._buffer = function _buffer(data, off) {
            var min = Math.min(
              this.buffer.length - this.bufferOff,
              data.length - off
            );
            for (var i = 0; i < min; i++)
              this.buffer[this.bufferOff + i] = data[off + i];
            this.bufferOff += min;
            return min;
          };
          Cipher.prototype._flushBuffer = function _flushBuffer(out, off) {
            this._update(this.buffer, 0, out, off);
            this.bufferOff = 0;
            return this.blockSize;
          };
          Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {
            var inputOff = 0;
            var outputOff = 0;
            var count = ((this.bufferOff + data.length) / this.blockSize) | 0;
            var out = new Array(count * this.blockSize);
            if (this.bufferOff !== 0) {
              inputOff += this._buffer(data, inputOff);
              if (this.bufferOff === this.buffer.length)
                outputOff += this._flushBuffer(out, outputOff);
            }
            var max = data.length - ((data.length - inputOff) % this.blockSize);
            for (; inputOff < max; inputOff += this.blockSize) {
              this._update(data, inputOff, out, outputOff);
              outputOff += this.blockSize;
            }
            for (; inputOff < data.length; inputOff++, this.bufferOff++)
              this.buffer[this.bufferOff] = data[inputOff];
            return out;
          };
          Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {
            var inputOff = 0;
            var outputOff = 0;
            var count =
              Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
            var out = new Array(count * this.blockSize);
            for (; count > 0; count--) {
              inputOff += this._buffer(data, inputOff);
              outputOff += this._flushBuffer(out, outputOff);
            }
            inputOff += this._buffer(data, inputOff);
            return out;
          };
          Cipher.prototype.final = function final(buffer) {
            var first;
            if (buffer) first = this.update(buffer);
            var last;
            if (this.type === 'encrypt') last = this._finalEncrypt();
            else last = this._finalDecrypt();
            if (first) return first.concat(last);
            else return last;
          };
          Cipher.prototype._pad = function _pad(buffer, off) {
            if (off === 0) return false;
            while (off < buffer.length) buffer[off++] = 0;
            return true;
          };
          Cipher.prototype._finalEncrypt = function _finalEncrypt() {
            if (!this._pad(this.buffer, this.bufferOff)) return [];
            var out = new Array(this.blockSize);
            this._update(this.buffer, 0, out, 0);
            return out;
          };
          Cipher.prototype._unpad = function _unpad(buffer) {
            return buffer;
          };
          Cipher.prototype._finalDecrypt = function _finalDecrypt() {
            assert.equal(
              this.bufferOff,
              this.blockSize,
              'Not enough data to decrypt'
            );
            var out = new Array(this.blockSize);
            this._flushBuffer(out, 0);
            return this._unpad(out);
          };
        },
        { 'minimalistic-assert': 211 }
      ],
      196: [
        function(require, module, exports) {
          'use strict';
          var assert = require('minimalistic-assert');
          var inherits = require('inherits');
          var des = require('../des');
          var utils = des.utils;
          var Cipher = des.Cipher;
          function DESState() {
            this.tmp = new Array(2);
            this.keys = null;
          }
          function DES(options) {
            Cipher.call(this, options);
            var state = new DESState();
            this._desState = state;
            this.deriveKeys(state, options.key);
          }
          inherits(DES, Cipher);
          module.exports = DES;
          DES.create = function create(options) {
            return new DES(options);
          };
          var shiftTable = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];
          DES.prototype.deriveKeys = function deriveKeys(state, key) {
            state.keys = new Array(16 * 2);
            assert.equal(key.length, this.blockSize, 'Invalid key length');
            var kL = utils.readUInt32BE(key, 0);
            var kR = utils.readUInt32BE(key, 4);
            utils.pc1(kL, kR, state.tmp, 0);
            kL = state.tmp[0];
            kR = state.tmp[1];
            for (var i = 0; i < state.keys.length; i += 2) {
              var shift = shiftTable[i >>> 1];
              kL = utils.r28shl(kL, shift);
              kR = utils.r28shl(kR, shift);
              utils.pc2(kL, kR, state.keys, i);
            }
          };
          DES.prototype._update = function _update(inp, inOff, out, outOff) {
            var state = this._desState;
            var l = utils.readUInt32BE(inp, inOff);
            var r = utils.readUInt32BE(inp, inOff + 4);
            utils.ip(l, r, state.tmp, 0);
            l = state.tmp[0];
            r = state.tmp[1];
            if (this.type === 'encrypt')
              this._encrypt(state, l, r, state.tmp, 0);
            else this._decrypt(state, l, r, state.tmp, 0);
            l = state.tmp[0];
            r = state.tmp[1];
            utils.writeUInt32BE(out, l, outOff);
            utils.writeUInt32BE(out, r, outOff + 4);
          };
          DES.prototype._pad = function _pad(buffer, off) {
            var value = buffer.length - off;
            for (var i = off; i < buffer.length; i++) buffer[i] = value;
            return true;
          };
          DES.prototype._unpad = function _unpad(buffer) {
            var pad = buffer[buffer.length - 1];
            for (var i = buffer.length - pad; i < buffer.length; i++)
              assert.equal(buffer[i], pad);
            return buffer.slice(0, buffer.length - pad);
          };
          DES.prototype._encrypt = function _encrypt(
            state,
            lStart,
            rStart,
            out,
            off
          ) {
            var l = lStart;
            var r = rStart;
            for (var i = 0; i < state.keys.length; i += 2) {
              var keyL = state.keys[i];
              var keyR = state.keys[i + 1];
              utils.expand(r, state.tmp, 0);
              keyL ^= state.tmp[0];
              keyR ^= state.tmp[1];
              var s = utils.substitute(keyL, keyR);
              var f = utils.permute(s);
              var t = r;
              r = (l ^ f) >>> 0;
              l = t;
            }
            utils.rip(r, l, out, off);
          };
          DES.prototype._decrypt = function _decrypt(
            state,
            lStart,
            rStart,
            out,
            off
          ) {
            var l = rStart;
            var r = lStart;
            for (var i = state.keys.length - 2; i >= 0; i -= 2) {
              var keyL = state.keys[i];
              var keyR = state.keys[i + 1];
              utils.expand(l, state.tmp, 0);
              keyL ^= state.tmp[0];
              keyR ^= state.tmp[1];
              var s = utils.substitute(keyL, keyR);
              var f = utils.permute(s);
              var t = l;
              l = (r ^ f) >>> 0;
              r = t;
            }
            utils.rip(l, r, out, off);
          };
        },
        { '../des': 193, inherits: 207, 'minimalistic-assert': 211 }
      ],
      197: [
        function(require, module, exports) {
          'use strict';
          var assert = require('minimalistic-assert');
          var inherits = require('inherits');
          var des = require('../des');
          var Cipher = des.Cipher;
          var DES = des.DES;
          function EDEState(type, key) {
            assert.equal(key.length, 24, 'Invalid key length');
            var k1 = key.slice(0, 8);
            var k2 = key.slice(8, 16);
            var k3 = key.slice(16, 24);
            if (type === 'encrypt') {
              this.ciphers = [
                DES.create({ type: 'encrypt', key: k1 }),
                DES.create({ type: 'decrypt', key: k2 }),
                DES.create({ type: 'encrypt', key: k3 })
              ];
            } else {
              this.ciphers = [
                DES.create({ type: 'decrypt', key: k3 }),
                DES.create({ type: 'encrypt', key: k2 }),
                DES.create({ type: 'decrypt', key: k1 })
              ];
            }
          }
          function EDE(options) {
            Cipher.call(this, options);
            var state = new EDEState(this.type, this.options.key);
            this._edeState = state;
          }
          inherits(EDE, Cipher);
          module.exports = EDE;
          EDE.create = function create(options) {
            return new EDE(options);
          };
          EDE.prototype._update = function _update(inp, inOff, out, outOff) {
            var state = this._edeState;
            state.ciphers[0]._update(inp, inOff, out, outOff);
            state.ciphers[1]._update(out, outOff, out, outOff);
            state.ciphers[2]._update(out, outOff, out, outOff);
          };
          EDE.prototype._pad = DES.prototype._pad;
          EDE.prototype._unpad = DES.prototype._unpad;
        },
        { '../des': 193, inherits: 207, 'minimalistic-assert': 211 }
      ],
      198: [
        function(require, module, exports) {
          'use strict';
          exports.readUInt32BE = function readUInt32BE(bytes, off) {
            var res =
              (bytes[0 + off] << 24) |
              (bytes[1 + off] << 16) |
              (bytes[2 + off] << 8) |
              bytes[3 + off];
            return res >>> 0;
          };
          exports.writeUInt32BE = function writeUInt32BE(bytes, value, off) {
            bytes[0 + off] = value >>> 24;
            bytes[1 + off] = (value >>> 16) & 255;
            bytes[2 + off] = (value >>> 8) & 255;
            bytes[3 + off] = value & 255;
          };
          exports.ip = function ip(inL, inR, out, off) {
            var outL = 0;
            var outR = 0;
            for (var i = 6; i >= 0; i -= 2) {
              for (var j = 0; j <= 24; j += 8) {
                outL <<= 1;
                outL |= (inR >>> (j + i)) & 1;
              }
              for (var j = 0; j <= 24; j += 8) {
                outL <<= 1;
                outL |= (inL >>> (j + i)) & 1;
              }
            }
            for (var i = 6; i >= 0; i -= 2) {
              for (var j = 1; j <= 25; j += 8) {
                outR <<= 1;
                outR |= (inR >>> (j + i)) & 1;
              }
              for (var j = 1; j <= 25; j += 8) {
                outR <<= 1;
                outR |= (inL >>> (j + i)) & 1;
              }
            }
            out[off + 0] = outL >>> 0;
            out[off + 1] = outR >>> 0;
          };
          exports.rip = function rip(inL, inR, out, off) {
            var outL = 0;
            var outR = 0;
            for (var i = 0; i < 4; i++) {
              for (var j = 24; j >= 0; j -= 8) {
                outL <<= 1;
                outL |= (inR >>> (j + i)) & 1;
                outL <<= 1;
                outL |= (inL >>> (j + i)) & 1;
              }
            }
            for (var i = 4; i < 8; i++) {
              for (var j = 24; j >= 0; j -= 8) {
                outR <<= 1;
                outR |= (inR >>> (j + i)) & 1;
                outR <<= 1;
                outR |= (inL >>> (j + i)) & 1;
              }
            }
            out[off + 0] = outL >>> 0;
            out[off + 1] = outR >>> 0;
          };
          exports.pc1 = function pc1(inL, inR, out, off) {
            var outL = 0;
            var outR = 0;
            for (var i = 7; i >= 5; i--) {
              for (var j = 0; j <= 24; j += 8) {
                outL <<= 1;
                outL |= (inR >> (j + i)) & 1;
              }
              for (var j = 0; j <= 24; j += 8) {
                outL <<= 1;
                outL |= (inL >> (j + i)) & 1;
              }
            }
            for (var j = 0; j <= 24; j += 8) {
              outL <<= 1;
              outL |= (inR >> (j + i)) & 1;
            }
            for (var i = 1; i <= 3; i++) {
              for (var j = 0; j <= 24; j += 8) {
                outR <<= 1;
                outR |= (inR >> (j + i)) & 1;
              }
              for (var j = 0; j <= 24; j += 8) {
                outR <<= 1;
                outR |= (inL >> (j + i)) & 1;
              }
            }
            for (var j = 0; j <= 24; j += 8) {
              outR <<= 1;
              outR |= (inL >> (j + i)) & 1;
            }
            out[off + 0] = outL >>> 0;
            out[off + 1] = outR >>> 0;
          };
          exports.r28shl = function r28shl(num, shift) {
            return ((num << shift) & 268435455) | (num >>> (28 - shift));
          };
          var pc2table = [
            14,
            11,
            17,
            4,
            27,
            23,
            25,
            0,
            13,
            22,
            7,
            18,
            5,
            9,
            16,
            24,
            2,
            20,
            12,
            21,
            1,
            8,
            15,
            26,
            15,
            4,
            25,
            19,
            9,
            1,
            26,
            16,
            5,
            11,
            23,
            8,
            12,
            7,
            17,
            0,
            22,
            3,
            10,
            14,
            6,
            20,
            27,
            24
          ];
          exports.pc2 = function pc2(inL, inR, out, off) {
            var outL = 0;
            var outR = 0;
            var len = pc2table.length >>> 1;
            for (var i = 0; i < len; i++) {
              outL <<= 1;
              outL |= (inL >>> pc2table[i]) & 1;
            }
            for (var i = len; i < pc2table.length; i++) {
              outR <<= 1;
              outR |= (inR >>> pc2table[i]) & 1;
            }
            out[off + 0] = outL >>> 0;
            out[off + 1] = outR >>> 0;
          };
          exports.expand = function expand(r, out, off) {
            var outL = 0;
            var outR = 0;
            outL = ((r & 1) << 5) | (r >>> 27);
            for (var i = 23; i >= 15; i -= 4) {
              outL <<= 6;
              outL |= (r >>> i) & 63;
            }
            for (var i = 11; i >= 3; i -= 4) {
              outR |= (r >>> i) & 63;
              outR <<= 6;
            }
            outR |= ((r & 31) << 1) | (r >>> 31);
            out[off + 0] = outL >>> 0;
            out[off + 1] = outR >>> 0;
          };
          var sTable = [
            14,
            0,
            4,
            15,
            13,
            7,
            1,
            4,
            2,
            14,
            15,
            2,
            11,
            13,
            8,
            1,
            3,
            10,
            10,
            6,
            6,
            12,
            12,
            11,
            5,
            9,
            9,
            5,
            0,
            3,
            7,
            8,
            4,
            15,
            1,
            12,
            14,
            8,
            8,
            2,
            13,
            4,
            6,
            9,
            2,
            1,
            11,
            7,
            15,
            5,
            12,
            11,
            9,
            3,
            7,
            14,
            3,
            10,
            10,
            0,
            5,
            6,
            0,
            13,
            15,
            3,
            1,
            13,
            8,
            4,
            14,
            7,
            6,
            15,
            11,
            2,
            3,
            8,
            4,
            14,
            9,
            12,
            7,
            0,
            2,
            1,
            13,
            10,
            12,
            6,
            0,
            9,
            5,
            11,
            10,
            5,
            0,
            13,
            14,
            8,
            7,
            10,
            11,
            1,
            10,
            3,
            4,
            15,
            13,
            4,
            1,
            2,
            5,
            11,
            8,
            6,
            12,
            7,
            6,
            12,
            9,
            0,
            3,
            5,
            2,
            14,
            15,
            9,
            10,
            13,
            0,
            7,
            9,
            0,
            14,
            9,
            6,
            3,
            3,
            4,
            15,
            6,
            5,
            10,
            1,
            2,
            13,
            8,
            12,
            5,
            7,
            14,
            11,
            12,
            4,
            11,
            2,
            15,
            8,
            1,
            13,
            1,
            6,
            10,
            4,
            13,
            9,
            0,
            8,
            6,
            15,
            9,
            3,
            8,
            0,
            7,
            11,
            4,
            1,
            15,
            2,
            14,
            12,
            3,
            5,
            11,
            10,
            5,
            14,
            2,
            7,
            12,
            7,
            13,
            13,
            8,
            14,
            11,
            3,
            5,
            0,
            6,
            6,
            15,
            9,
            0,
            10,
            3,
            1,
            4,
            2,
            7,
            8,
            2,
            5,
            12,
            11,
            1,
            12,
            10,
            4,
            14,
            15,
            9,
            10,
            3,
            6,
            15,
            9,
            0,
            0,
            6,
            12,
            10,
            11,
            1,
            7,
            13,
            13,
            8,
            15,
            9,
            1,
            4,
            3,
            5,
            14,
            11,
            5,
            12,
            2,
            7,
            8,
            2,
            4,
            14,
            2,
            14,
            12,
            11,
            4,
            2,
            1,
            12,
            7,
            4,
            10,
            7,
            11,
            13,
            6,
            1,
            8,
            5,
            5,
            0,
            3,
            15,
            15,
            10,
            13,
            3,
            0,
            9,
            14,
            8,
            9,
            6,
            4,
            11,
            2,
            8,
            1,
            12,
            11,
            7,
            10,
            1,
            13,
            14,
            7,
            2,
            8,
            13,
            15,
            6,
            9,
            15,
            12,
            0,
            5,
            9,
            6,
            10,
            3,
            4,
            0,
            5,
            14,
            3,
            12,
            10,
            1,
            15,
            10,
            4,
            15,
            2,
            9,
            7,
            2,
            12,
            6,
            9,
            8,
            5,
            0,
            6,
            13,
            1,
            3,
            13,
            4,
            14,
            14,
            0,
            7,
            11,
            5,
            3,
            11,
            8,
            9,
            4,
            14,
            3,
            15,
            2,
            5,
            12,
            2,
            9,
            8,
            5,
            12,
            15,
            3,
            10,
            7,
            11,
            0,
            14,
            4,
            1,
            10,
            7,
            1,
            6,
            13,
            0,
            11,
            8,
            6,
            13,
            4,
            13,
            11,
            0,
            2,
            11,
            14,
            7,
            15,
            4,
            0,
            9,
            8,
            1,
            13,
            10,
            3,
            14,
            12,
            3,
            9,
            5,
            7,
            12,
            5,
            2,
            10,
            15,
            6,
            8,
            1,
            6,
            1,
            6,
            4,
            11,
            11,
            13,
            13,
            8,
            12,
            1,
            3,
            4,
            7,
            10,
            14,
            7,
            10,
            9,
            15,
            5,
            6,
            0,
            8,
            15,
            0,
            14,
            5,
            2,
            9,
            3,
            2,
            12,
            13,
            1,
            2,
            15,
            8,
            13,
            4,
            8,
            6,
            10,
            15,
            3,
            11,
            7,
            1,
            4,
            10,
            12,
            9,
            5,
            3,
            6,
            14,
            11,
            5,
            0,
            0,
            14,
            12,
            9,
            7,
            2,
            7,
            2,
            11,
            1,
            4,
            14,
            1,
            7,
            9,
            4,
            12,
            10,
            14,
            8,
            2,
            13,
            0,
            15,
            6,
            12,
            10,
            9,
            13,
            0,
            15,
            3,
            3,
            5,
            5,
            6,
            8,
            11
          ];
          exports.substitute = function substitute(inL, inR) {
            var out = 0;
            for (var i = 0; i < 4; i++) {
              var b = (inL >>> (18 - i * 6)) & 63;
              var sb = sTable[i * 64 + b];
              out <<= 4;
              out |= sb;
            }
            for (var i = 0; i < 4; i++) {
              var b = (inR >>> (18 - i * 6)) & 63;
              var sb = sTable[4 * 64 + i * 64 + b];
              out <<= 4;
              out |= sb;
            }
            return out >>> 0;
          };
          var permuteTable = [
            16,
            25,
            12,
            11,
            3,
            20,
            4,
            15,
            31,
            17,
            9,
            6,
            27,
            14,
            1,
            22,
            30,
            24,
            8,
            18,
            0,
            5,
            29,
            23,
            13,
            19,
            2,
            26,
            10,
            21,
            28,
            7
          ];
          exports.permute = function permute(num) {
            var out = 0;
            for (var i = 0; i < permuteTable.length; i++) {
              out <<= 1;
              out |= (num >>> permuteTable[i]) & 1;
            }
            return out >>> 0;
          };
          exports.padSplit = function padSplit(num, size, group) {
            var str = num.toString(2);
            while (str.length < size) str = '0' + str;
            var out = [];
            for (var i = 0; i < size; i += group)
              out.push(str.slice(i, i + group));
            return out.join(' ');
          };
        },
        {}
      ],
      199: [
        function(require, module, exports) {
          (function(Buffer) {
            var generatePrime = require('./lib/generatePrime');
            var primes = require('./lib/primes.json');
            var DH = require('./lib/dh');
            function getDiffieHellman(mod) {
              var prime = new Buffer(primes[mod].prime, 'hex');
              var gen = new Buffer(primes[mod].gen, 'hex');
              return new DH(prime, gen);
            }
            var ENCODINGS = { binary: true, hex: true, base64: true };
            function createDiffieHellman(prime, enc, generator, genc) {
              if (Buffer.isBuffer(enc) || ENCODINGS[enc] === undefined) {
                return createDiffieHellman(prime, 'binary', enc, generator);
              }
              enc = enc || 'binary';
              genc = genc || 'binary';
              generator = generator || new Buffer([2]);
              if (!Buffer.isBuffer(generator)) {
                generator = new Buffer(generator, genc);
              }
              if (typeof prime === 'number') {
                return new DH(generatePrime(prime, generator), generator, true);
              }
              if (!Buffer.isBuffer(prime)) {
                prime = new Buffer(prime, enc);
              }
              return new DH(prime, generator, true);
            }
            exports.DiffieHellmanGroup = exports.createDiffieHellmanGroup = exports.getDiffieHellman = getDiffieHellman;
            exports.createDiffieHellman = exports.DiffieHellman = createDiffieHellman;
          }.call(this, require('buffer').Buffer));
        },
        {
          './lib/dh': 200,
          './lib/generatePrime': 201,
          './lib/primes.json': 202,
          buffer: 183
        }
      ],
      200: [
        function(require, module, exports) {
          (function(Buffer) {
            var BN = require('bn.js');
            var MillerRabin = require('miller-rabin');
            var millerRabin = new MillerRabin();
            var TWENTYFOUR = new BN(24);
            var ELEVEN = new BN(11);
            var TEN = new BN(10);
            var THREE = new BN(3);
            var SEVEN = new BN(7);
            var primes = require('./generatePrime');
            var randomBytes = require('randombytes');
            module.exports = DH;
            function setPublicKey(pub, enc) {
              enc = enc || 'utf8';
              if (!Buffer.isBuffer(pub)) {
                pub = new Buffer(pub, enc);
              }
              this._pub = new BN(pub);
              return this;
            }
            function setPrivateKey(priv, enc) {
              enc = enc || 'utf8';
              if (!Buffer.isBuffer(priv)) {
                priv = new Buffer(priv, enc);
              }
              this._priv = new BN(priv);
              return this;
            }
            var primeCache = {};
            function checkPrime(prime, generator) {
              var gen = generator.toString('hex');
              var hex = [gen, prime.toString(16)].join('_');
              if (hex in primeCache) {
                return primeCache[hex];
              }
              var error = 0;
              if (
                prime.isEven() ||
                !primes.simpleSieve ||
                !primes.fermatTest(prime) ||
                !millerRabin.test(prime)
              ) {
                error += 1;
                if (gen === '02' || gen === '05') {
                  error += 8;
                } else {
                  error += 4;
                }
                primeCache[hex] = error;
                return error;
              }
              if (!millerRabin.test(prime.shrn(1))) {
                error += 2;
              }
              var rem;
              switch (gen) {
                case '02':
                  if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {
                    error += 8;
                  }
                  break;
                case '05':
                  rem = prime.mod(TEN);
                  if (rem.cmp(THREE) && rem.cmp(SEVEN)) {
                    error += 8;
                  }
                  break;
                default:
                  error += 4;
              }
              primeCache[hex] = error;
              return error;
            }
            function DH(prime, generator, malleable) {
              this.setGenerator(generator);
              this.__prime = new BN(prime);
              this._prime = BN.mont(this.__prime);
              this._primeLen = prime.length;
              this._pub = undefined;
              this._priv = undefined;
              this._primeCode = undefined;
              if (malleable) {
                this.setPublicKey = setPublicKey;
                this.setPrivateKey = setPrivateKey;
              } else {
                this._primeCode = 8;
              }
            }
            Object.defineProperty(DH.prototype, 'verifyError', {
              enumerable: true,
              get: function() {
                if (typeof this._primeCode !== 'number') {
                  this._primeCode = checkPrime(this.__prime, this.__gen);
                }
                return this._primeCode;
              }
            });
            DH.prototype.generateKeys = function() {
              if (!this._priv) {
                this._priv = new BN(randomBytes(this._primeLen));
              }
              this._pub = this._gen
                .toRed(this._prime)
                .redPow(this._priv)
                .fromRed();
              return this.getPublicKey();
            };
            DH.prototype.computeSecret = function(other) {
              other = new BN(other);
              other = other.toRed(this._prime);
              var secret = other.redPow(this._priv).fromRed();
              var out = new Buffer(secret.toArray());
              var prime = this.getPrime();
              if (out.length < prime.length) {
                var front = new Buffer(prime.length - out.length);
                front.fill(0);
                out = Buffer.concat([front, out]);
              }
              return out;
            };
            DH.prototype.getPublicKey = function getPublicKey(enc) {
              return formatReturnValue(this._pub, enc);
            };
            DH.prototype.getPrivateKey = function getPrivateKey(enc) {
              return formatReturnValue(this._priv, enc);
            };
            DH.prototype.getPrime = function(enc) {
              return formatReturnValue(this.__prime, enc);
            };
            DH.prototype.getGenerator = function(enc) {
              return formatReturnValue(this._gen, enc);
            };
            DH.prototype.setGenerator = function(gen, enc) {
              enc = enc || 'utf8';
              if (!Buffer.isBuffer(gen)) {
                gen = new Buffer(gen, enc);
              }
              this.__gen = gen;
              this._gen = new BN(gen);
              return this;
            };
            function formatReturnValue(bn, enc) {
              var buf = new Buffer(bn.toArray());
              if (!enc) {
                return buf;
              } else {
                return buf.toString(enc);
              }
            }
          }.call(this, require('buffer').Buffer));
        },
        {
          './generatePrime': 201,
          'bn.js': 153,
          buffer: 183,
          'miller-rabin': 210,
          randombytes: 234
        }
      ],
      201: [
        function(require, module, exports) {
          var randomBytes = require('randombytes');
          module.exports = findPrime;
          findPrime.simpleSieve = simpleSieve;
          findPrime.fermatTest = fermatTest;
          var BN = require('bn.js');
          var TWENTYFOUR = new BN(24);
          var MillerRabin = require('miller-rabin');
          var millerRabin = new MillerRabin();
          var ONE = new BN(1);
          var TWO = new BN(2);
          var FIVE = new BN(5);
          var SIXTEEN = new BN(16);
          var EIGHT = new BN(8);
          var TEN = new BN(10);
          var THREE = new BN(3);
          var SEVEN = new BN(7);
          var ELEVEN = new BN(11);
          var FOUR = new BN(4);
          var TWELVE = new BN(12);
          var primes = null;
          function _getPrimes() {
            if (primes !== null) return primes;
            var limit = 1048576;
            var res = [];
            res[0] = 2;
            for (var i = 1, k = 3; k < limit; k += 2) {
              var sqrt = Math.ceil(Math.sqrt(k));
              for (var j = 0; j < i && res[j] <= sqrt; j++)
                if (k % res[j] === 0) break;
              if (i !== j && res[j] <= sqrt) continue;
              res[i++] = k;
            }
            primes = res;
            return res;
          }
          function simpleSieve(p) {
            var primes = _getPrimes();
            for (var i = 0; i < primes.length; i++)
              if (p.modn(primes[i]) === 0) {
                if (p.cmpn(primes[i]) === 0) {
                  return true;
                } else {
                  return false;
                }
              }
            return true;
          }
          function fermatTest(p) {
            var red = BN.mont(p);
            return (
              TWO.toRed(red)
                .redPow(p.subn(1))
                .fromRed()
                .cmpn(1) === 0
            );
          }
          function findPrime(bits, gen) {
            if (bits < 16) {
              if (gen === 2 || gen === 5) {
                return new BN([140, 123]);
              } else {
                return new BN([140, 39]);
              }
            }
            gen = new BN(gen);
            var num, n2;
            while (true) {
              num = new BN(randomBytes(Math.ceil(bits / 8)));
              while (num.bitLength() > bits) {
                num.ishrn(1);
              }
              if (num.isEven()) {
                num.iadd(ONE);
              }
              if (!num.testn(1)) {
                num.iadd(TWO);
              }
              if (!gen.cmp(TWO)) {
                while (num.mod(TWENTYFOUR).cmp(ELEVEN)) {
                  num.iadd(FOUR);
                }
              } else if (!gen.cmp(FIVE)) {
                while (num.mod(TEN).cmp(THREE)) {
                  num.iadd(FOUR);
                }
              }
              n2 = num.shrn(1);
              if (
                simpleSieve(n2) &&
                simpleSieve(num) &&
                fermatTest(n2) &&
                fermatTest(num) &&
                millerRabin.test(n2) &&
                millerRabin.test(num)
              ) {
                return num;
              }
            }
          }
        },
        { 'bn.js': 153, 'miller-rabin': 210, randombytes: 234 }
      ],
      202: [
        function(require, module, exports) {
          module.exports = {
            modp1: {
              gen: '02',
              prime:
                'ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff'
            },
            modp2: {
              gen: '02',
              prime:
                'ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff'
            },
            modp5: {
              gen: '02',
              prime:
                'ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff'
            },
            modp14: {
              gen: '02',
              prime:
                'ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff'
            },
            modp15: {
              gen: '02',
              prime:
                'ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff'
            },
            modp16: {
              gen: '02',
              prime:
                'ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff'
            },
            modp17: {
              gen: '02',
              prime:
                'ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff'
            },
            modp18: {
              gen: '02',
              prime:
                'ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff'
            }
          };
        },
        {}
      ],
      203: [
        function(require, module, exports) {
          function EventEmitter() {
            this._events = this._events || {};
            this._maxListeners = this._maxListeners || undefined;
          }
          module.exports = EventEmitter;
          EventEmitter.EventEmitter = EventEmitter;
          EventEmitter.prototype._events = undefined;
          EventEmitter.prototype._maxListeners = undefined;
          EventEmitter.defaultMaxListeners = 10;
          EventEmitter.prototype.setMaxListeners = function(n) {
            if (!isNumber(n) || n < 0 || isNaN(n))
              throw TypeError('n must be a positive number');
            this._maxListeners = n;
            return this;
          };
          EventEmitter.prototype.emit = function(type) {
            var er, handler, len, args, i, listeners;
            if (!this._events) this._events = {};
            if (type === 'error') {
              if (
                !this._events.error ||
                (isObject(this._events.error) && !this._events.error.length)
              ) {
                er = arguments[1];
                if (er instanceof Error) {
                  throw er;
                } else {
                  var err = new Error(
                    'Uncaught, unspecified "error" event. (' + er + ')'
                  );
                  err.context = er;
                  throw err;
                }
              }
            }
            handler = this._events[type];
            if (isUndefined(handler)) return false;
            if (isFunction(handler)) {
              switch (arguments.length) {
                case 1:
                  handler.call(this);
                  break;
                case 2:
                  handler.call(this, arguments[1]);
                  break;
                case 3:
                  handler.call(this, arguments[1], arguments[2]);
                  break;
                default:
                  args = Array.prototype.slice.call(arguments, 1);
                  handler.apply(this, args);
              }
            } else if (isObject(handler)) {
              args = Array.prototype.slice.call(arguments, 1);
              listeners = handler.slice();
              len = listeners.length;
              for (i = 0; i < len; i++) listeners[i].apply(this, args);
            }
            return true;
          };
          EventEmitter.prototype.addListener = function(type, listener) {
            var m;
            if (!isFunction(listener))
              throw TypeError('listener must be a function');
            if (!this._events) this._events = {};
            if (this._events.newListener)
              this.emit(
                'newListener',
                type,
                isFunction(listener.listener) ? listener.listener : listener
              );
            if (!this._events[type]) this._events[type] = listener;
            else if (isObject(this._events[type]))
              this._events[type].push(listener);
            else this._events[type] = [this._events[type], listener];
            if (isObject(this._events[type]) && !this._events[type].warned) {
              if (!isUndefined(this._maxListeners)) {
                m = this._maxListeners;
              } else {
                m = EventEmitter.defaultMaxListeners;
              }
              if (m && m > 0 && this._events[type].length > m) {
                this._events[type].warned = true;
                console.error(
                  '(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                  this._events[type].length
                );
                if (typeof console.trace === 'function') {
                  console.trace();
                }
              }
            }
            return this;
          };
          EventEmitter.prototype.on = EventEmitter.prototype.addListener;
          EventEmitter.prototype.once = function(type, listener) {
            if (!isFunction(listener))
              throw TypeError('listener must be a function');
            var fired = false;
            function g() {
              this.removeListener(type, g);
              if (!fired) {
                fired = true;
                listener.apply(this, arguments);
              }
            }
            g.listener = listener;
            this.on(type, g);
            return this;
          };
          EventEmitter.prototype.removeListener = function(type, listener) {
            var list, position, length, i;
            if (!isFunction(listener))
              throw TypeError('listener must be a function');
            if (!this._events || !this._events[type]) return this;
            list = this._events[type];
            length = list.length;
            position = -1;
            if (
              list === listener ||
              (isFunction(list.listener) && list.listener === listener)
            ) {
              delete this._events[type];
              if (this._events.removeListener)
                this.emit('removeListener', type, listener);
            } else if (isObject(list)) {
              for (i = length; i-- > 0; ) {
                if (
                  list[i] === listener ||
                  (list[i].listener && list[i].listener === listener)
                ) {
                  position = i;
                  break;
                }
              }
              if (position < 0) return this;
              if (list.length === 1) {
                list.length = 0;
                delete this._events[type];
              } else {
                list.splice(position, 1);
              }
              if (this._events.removeListener)
                this.emit('removeListener', type, listener);
            }
            return this;
          };
          EventEmitter.prototype.removeAllListeners = function(type) {
            var key, listeners;
            if (!this._events) return this;
            if (!this._events.removeListener) {
              if (arguments.length === 0) this._events = {};
              else if (this._events[type]) delete this._events[type];
              return this;
            }
            if (arguments.length === 0) {
              for (key in this._events) {
                if (key === 'removeListener') continue;
                this.removeAllListeners(key);
              }
              this.removeAllListeners('removeListener');
              this._events = {};
              return this;
            }
            listeners = this._events[type];
            if (isFunction(listeners)) {
              this.removeListener(type, listeners);
            } else if (listeners) {
              while (listeners.length)
                this.removeListener(type, listeners[listeners.length - 1]);
            }
            delete this._events[type];
            return this;
          };
          EventEmitter.prototype.listeners = function(type) {
            var ret;
            if (!this._events || !this._events[type]) ret = [];
            else if (isFunction(this._events[type])) ret = [this._events[type]];
            else ret = this._events[type].slice();
            return ret;
          };
          EventEmitter.prototype.listenerCount = function(type) {
            if (this._events) {
              var evlistener = this._events[type];
              if (isFunction(evlistener)) return 1;
              else if (evlistener) return evlistener.length;
            }
            return 0;
          };
          EventEmitter.listenerCount = function(emitter, type) {
            return emitter.listenerCount(type);
          };
          function isFunction(arg) {
            return typeof arg === 'function';
          }
          function isNumber(arg) {
            return typeof arg === 'number';
          }
          function isObject(arg) {
            return typeof arg === 'object' && arg !== null;
          }
          function isUndefined(arg) {
            return arg === void 0;
          }
        },
        {}
      ],
      204: [
        function(require, module, exports) {
          var Buffer = require('safe-buffer').Buffer;
          var MD5 = require('md5.js');
          function EVP_BytesToKey(password, salt, keyBits, ivLen) {
            if (!Buffer.isBuffer(password))
              password = Buffer.from(password, 'binary');
            if (salt) {
              if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, 'binary');
              if (salt.length !== 8)
                throw new RangeError(
                  'salt should be Buffer with 8 byte length'
                );
            }
            var keyLen = keyBits / 8;
            var key = Buffer.alloc(keyLen);
            var iv = Buffer.alloc(ivLen || 0);
            var tmp = Buffer.alloc(0);
            while (keyLen > 0 || ivLen > 0) {
              var hash = new MD5();
              hash.update(tmp);
              hash.update(password);
              if (salt) hash.update(salt);
              tmp = hash.digest();
              var used = 0;
              if (keyLen > 0) {
                var keyStart = key.length - keyLen;
                used = Math.min(keyLen, tmp.length);
                tmp.copy(key, keyStart, 0, used);
                keyLen -= used;
              }
              if (used < tmp.length && ivLen > 0) {
                var ivStart = iv.length - ivLen;
                var length = Math.min(ivLen, tmp.length - used);
                tmp.copy(iv, ivStart, used, used + length);
                ivLen -= length;
              }
            }
            tmp.fill(0);
            return { key: key, iv: iv };
          }
          module.exports = EVP_BytesToKey;
        },
        { 'md5.js': 437, 'safe-buffer': 460 }
      ],
      205: [
        function(require, module, exports) {
          exports.read = function(buffer, offset, isLE, mLen, nBytes) {
            var e, m;
            var eLen = nBytes * 8 - mLen - 1;
            var eMax = (1 << eLen) - 1;
            var eBias = eMax >> 1;
            var nBits = -7;
            var i = isLE ? nBytes - 1 : 0;
            var d = isLE ? -1 : 1;
            var s = buffer[offset + i];
            i += d;
            e = s & ((1 << -nBits) - 1);
            s >>= -nBits;
            nBits += eLen;
            for (
              ;
              nBits > 0;
              e = e * 256 + buffer[offset + i], i += d, nBits -= 8
            ) {}
            m = e & ((1 << -nBits) - 1);
            e >>= -nBits;
            nBits += mLen;
            for (
              ;
              nBits > 0;
              m = m * 256 + buffer[offset + i], i += d, nBits -= 8
            ) {}
            if (e === 0) {
              e = 1 - eBias;
            } else if (e === eMax) {
              return m ? NaN : (s ? -1 : 1) * Infinity;
            } else {
              m = m + Math.pow(2, mLen);
              e = e - eBias;
            }
            return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
          };
          exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
            var e, m, c;
            var eLen = nBytes * 8 - mLen - 1;
            var eMax = (1 << eLen) - 1;
            var eBias = eMax >> 1;
            var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
            var i = isLE ? 0 : nBytes - 1;
            var d = isLE ? 1 : -1;
            var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;
            value = Math.abs(value);
            if (isNaN(value) || value === Infinity) {
              m = isNaN(value) ? 1 : 0;
              e = eMax;
            } else {
              e = Math.floor(Math.log(value) / Math.LN2);
              if (value * (c = Math.pow(2, -e)) < 1) {
                e--;
                c *= 2;
              }
              if (e + eBias >= 1) {
                value += rt / c;
              } else {
                value += rt * Math.pow(2, 1 - eBias);
              }
              if (value * c >= 2) {
                e++;
                c /= 2;
              }
              if (e + eBias >= eMax) {
                m = 0;
                e = eMax;
              } else if (e + eBias >= 1) {
                m = (value * c - 1) * Math.pow(2, mLen);
                e = e + eBias;
              } else {
                m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                e = 0;
              }
            }
            for (
              ;
              mLen >= 8;
              buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8
            ) {}
            e = (e << mLen) | m;
            eLen += mLen;
            for (
              ;
              eLen > 0;
              buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8
            ) {}
            buffer[offset + i - d] |= s * 128;
          };
        },
        {}
      ],
      206: [
        function(require, module, exports) {
          var indexOf = [].indexOf;
          module.exports = function(arr, obj) {
            if (indexOf) return arr.indexOf(obj);
            for (var i = 0; i < arr.length; ++i) {
              if (arr[i] === obj) return i;
            }
            return -1;
          };
        },
        {}
      ],
      207: [
        function(require, module, exports) {
          if (typeof Object.create === 'function') {
            module.exports = function inherits(ctor, superCtor) {
              ctor.super_ = superCtor;
              ctor.prototype = Object.create(superCtor.prototype, {
                constructor: {
                  value: ctor,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
            };
          } else {
            module.exports = function inherits(ctor, superCtor) {
              ctor.super_ = superCtor;
              var TempCtor = function() {};
              TempCtor.prototype = superCtor.prototype;
              ctor.prototype = new TempCtor();
              ctor.prototype.constructor = ctor;
            };
          }
        },
        {}
      ],
      208: [
        function(require, module, exports) {
          module.exports = function(obj) {
            return (
              obj != null &&
              (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
            );
          };
          function isBuffer(obj) {
            return (
              !!obj.constructor &&
              typeof obj.constructor.isBuffer === 'function' &&
              obj.constructor.isBuffer(obj)
            );
          }
          function isSlowBuffer(obj) {
            return (
              typeof obj.readFloatLE === 'function' &&
              typeof obj.slice === 'function' &&
              isBuffer(obj.slice(0, 0))
            );
          }
        },
        {}
      ],
      209: [
        function(require, module, exports) {
          var toString = {}.toString;
          module.exports =
            Array.isArray ||
            function(arr) {
              return toString.call(arr) == '[object Array]';
            };
        },
        {}
      ],
      210: [
        function(require, module, exports) {
          var bn = require('bn.js');
          var brorand = require('brorand');
          function MillerRabin(rand) {
            this.rand = rand || new brorand.Rand();
          }
          module.exports = MillerRabin;
          MillerRabin.create = function create(rand) {
            return new MillerRabin(rand);
          };
          MillerRabin.prototype._randbelow = function _randbelow(n) {
            var len = n.bitLength();
            var min_bytes = Math.ceil(len / 8);
            do {
              var a = new bn(this.rand.generate(min_bytes));
            } while (a.cmp(n) >= 0);
            return a;
          };
          MillerRabin.prototype._randrange = function _randrange(start, stop) {
            var size = stop.sub(start);
            return start.add(this._randbelow(size));
          };
          MillerRabin.prototype.test = function test(n, k, cb) {
            var len = n.bitLength();
            var red = bn.mont(n);
            var rone = new bn(1).toRed(red);
            if (!k) k = Math.max(1, (len / 48) | 0);
            var n1 = n.subn(1);
            for (var s = 0; !n1.testn(s); s++) {}
            var d = n.shrn(s);
            var rn1 = n1.toRed(red);
            var prime = true;
            for (; k > 0; k--) {
              var a = this._randrange(new bn(2), n1);
              if (cb) cb(a);
              var x = a.toRed(red).redPow(d);
              if (x.cmp(rone) === 0 || x.cmp(rn1) === 0) continue;
              for (var i = 1; i < s; i++) {
                x = x.redSqr();
                if (x.cmp(rone) === 0) return false;
                if (x.cmp(rn1) === 0) break;
              }
              if (i === s) return false;
            }
            return prime;
          };
          MillerRabin.prototype.getDivisor = function getDivisor(n, k) {
            var len = n.bitLength();
            var red = bn.mont(n);
            var rone = new bn(1).toRed(red);
            if (!k) k = Math.max(1, (len / 48) | 0);
            var n1 = n.subn(1);
            for (var s = 0; !n1.testn(s); s++) {}
            var d = n.shrn(s);
            var rn1 = n1.toRed(red);
            for (; k > 0; k--) {
              var a = this._randrange(new bn(2), n1);
              var g = n.gcd(a);
              if (g.cmpn(1) !== 0) return g;
              var x = a.toRed(red).redPow(d);
              if (x.cmp(rone) === 0 || x.cmp(rn1) === 0) continue;
              for (var i = 1; i < s; i++) {
                x = x.redSqr();
                if (x.cmp(rone) === 0)
                  return x
                    .fromRed()
                    .subn(1)
                    .gcd(n);
                if (x.cmp(rn1) === 0) break;
              }
              if (i === s) {
                x = x.redSqr();
                return x
                  .fromRed()
                  .subn(1)
                  .gcd(n);
              }
            }
            return false;
          };
        },
        { 'bn.js': 153, brorand: 154 }
      ],
      211: [
        function(require, module, exports) {
          module.exports = assert;
          function assert(val, msg) {
            if (!val) throw new Error(msg || 'Assertion failed');
          }
          assert.equal = function assertEqual(l, r, msg) {
            if (l != r)
              throw new Error(msg || 'Assertion failed: ' + l + ' != ' + r);
          };
        },
        {}
      ],
      212: [
        function(require, module, exports) {
          module.exports = {
            '2.16.840.1.101.3.4.1.1': 'aes-128-ecb',
            '2.16.840.1.101.3.4.1.2': 'aes-128-cbc',
            '2.16.840.1.101.3.4.1.3': 'aes-128-ofb',
            '2.16.840.1.101.3.4.1.4': 'aes-128-cfb',
            '2.16.840.1.101.3.4.1.21': 'aes-192-ecb',
            '2.16.840.1.101.3.4.1.22': 'aes-192-cbc',
            '2.16.840.1.101.3.4.1.23': 'aes-192-ofb',
            '2.16.840.1.101.3.4.1.24': 'aes-192-cfb',
            '2.16.840.1.101.3.4.1.41': 'aes-256-ecb',
            '2.16.840.1.101.3.4.1.42': 'aes-256-cbc',
            '2.16.840.1.101.3.4.1.43': 'aes-256-ofb',
            '2.16.840.1.101.3.4.1.44': 'aes-256-cfb'
          };
        },
        {}
      ],
      213: [
        function(require, module, exports) {
          'use strict';
          var asn1 = require('asn1.js');
          exports.certificate = require('./certificate');
          var RSAPrivateKey = asn1.define('RSAPrivateKey', function() {
            this.seq().obj(
              this.key('version').int(),
              this.key('modulus').int(),
              this.key('publicExponent').int(),
              this.key('privateExponent').int(),
              this.key('prime1').int(),
              this.key('prime2').int(),
              this.key('exponent1').int(),
              this.key('exponent2').int(),
              this.key('coefficient').int()
            );
          });
          exports.RSAPrivateKey = RSAPrivateKey;
          var RSAPublicKey = asn1.define('RSAPublicKey', function() {
            this.seq().obj(
              this.key('modulus').int(),
              this.key('publicExponent').int()
            );
          });
          exports.RSAPublicKey = RSAPublicKey;
          var PublicKey = asn1.define('SubjectPublicKeyInfo', function() {
            this.seq().obj(
              this.key('algorithm').use(AlgorithmIdentifier),
              this.key('subjectPublicKey').bitstr()
            );
          });
          exports.PublicKey = PublicKey;
          var AlgorithmIdentifier = asn1.define(
            'AlgorithmIdentifier',
            function() {
              this.seq().obj(
                this.key('algorithm').objid(),
                this.key('none')
                  .null_()
                  .optional(),
                this.key('curve')
                  .objid()
                  .optional(),
                this.key('params')
                  .seq()
                  .obj(
                    this.key('p').int(),
                    this.key('q').int(),
                    this.key('g').int()
                  )
                  .optional()
              );
            }
          );
          var PrivateKeyInfo = asn1.define('PrivateKeyInfo', function() {
            this.seq().obj(
              this.key('version').int(),
              this.key('algorithm').use(AlgorithmIdentifier),
              this.key('subjectPrivateKey').octstr()
            );
          });
          exports.PrivateKey = PrivateKeyInfo;
          var EncryptedPrivateKeyInfo = asn1.define(
            'EncryptedPrivateKeyInfo',
            function() {
              this.seq().obj(
                this.key('algorithm')
                  .seq()
                  .obj(
                    this.key('id').objid(),
                    this.key('decrypt')
                      .seq()
                      .obj(
                        this.key('kde')
                          .seq()
                          .obj(
                            this.key('id').objid(),
                            this.key('kdeparams')
                              .seq()
                              .obj(
                                this.key('salt').octstr(),
                                this.key('iters').int()
                              )
                          ),
                        this.key('cipher')
                          .seq()
                          .obj(
                            this.key('algo').objid(),
                            this.key('iv').octstr()
                          )
                      )
                  ),
                this.key('subjectPrivateKey').octstr()
              );
            }
          );
          exports.EncryptedPrivateKey = EncryptedPrivateKeyInfo;
          var DSAPrivateKey = asn1.define('DSAPrivateKey', function() {
            this.seq().obj(
              this.key('version').int(),
              this.key('p').int(),
              this.key('q').int(),
              this.key('g').int(),
              this.key('pub_key').int(),
              this.key('priv_key').int()
            );
          });
          exports.DSAPrivateKey = DSAPrivateKey;
          exports.DSAparam = asn1.define('DSAparam', function() {
            this.int();
          });
          var ECPrivateKey = asn1.define('ECPrivateKey', function() {
            this.seq().obj(
              this.key('version').int(),
              this.key('privateKey').octstr(),
              this.key('parameters')
                .optional()
                .explicit(0)
                .use(ECParameters),
              this.key('publicKey')
                .optional()
                .explicit(1)
                .bitstr()
            );
          });
          exports.ECPrivateKey = ECPrivateKey;
          var ECParameters = asn1.define('ECParameters', function() {
            this.choice({ namedCurve: this.objid() });
          });
          exports.signature = asn1.define('signature', function() {
            this.seq().obj(this.key('r').int(), this.key('s').int());
          });
        },
        { './certificate': 214, 'asn1.js': 137 }
      ],
      214: [
        function(require, module, exports) {
          'use strict';
          var asn = require('asn1.js');
          var Time = asn.define('Time', function() {
            this.choice({
              utcTime: this.utctime(),
              generalTime: this.gentime()
            });
          });
          var AttributeTypeValue = asn.define('AttributeTypeValue', function() {
            this.seq().obj(this.key('type').objid(), this.key('value').any());
          });
          var AlgorithmIdentifier = asn.define(
            'AlgorithmIdentifier',
            function() {
              this.seq().obj(
                this.key('algorithm').objid(),
                this.key('parameters').optional()
              );
            }
          );
          var SubjectPublicKeyInfo = asn.define(
            'SubjectPublicKeyInfo',
            function() {
              this.seq().obj(
                this.key('algorithm').use(AlgorithmIdentifier),
                this.key('subjectPublicKey').bitstr()
              );
            }
          );
          var RelativeDistinguishedName = asn.define(
            'RelativeDistinguishedName',
            function() {
              this.setof(AttributeTypeValue);
            }
          );
          var RDNSequence = asn.define('RDNSequence', function() {
            this.seqof(RelativeDistinguishedName);
          });
          var Name = asn.define('Name', function() {
            this.choice({ rdnSequence: this.use(RDNSequence) });
          });
          var Validity = asn.define('Validity', function() {
            this.seq().obj(
              this.key('notBefore').use(Time),
              this.key('notAfter').use(Time)
            );
          });
          var Extension = asn.define('Extension', function() {
            this.seq().obj(
              this.key('extnID').objid(),
              this.key('critical')
                .bool()
                .def(false),
              this.key('extnValue').octstr()
            );
          });
          var TBSCertificate = asn.define('TBSCertificate', function() {
            this.seq().obj(
              this.key('version')
                .explicit(0)
                .int(),
              this.key('serialNumber').int(),
              this.key('signature').use(AlgorithmIdentifier),
              this.key('issuer').use(Name),
              this.key('validity').use(Validity),
              this.key('subject').use(Name),
              this.key('subjectPublicKeyInfo').use(SubjectPublicKeyInfo),
              this.key('issuerUniqueID')
                .implicit(1)
                .bitstr()
                .optional(),
              this.key('subjectUniqueID')
                .implicit(2)
                .bitstr()
                .optional(),
              this.key('extensions')
                .explicit(3)
                .seqof(Extension)
                .optional()
            );
          });
          var X509Certificate = asn.define('X509Certificate', function() {
            this.seq().obj(
              this.key('tbsCertificate').use(TBSCertificate),
              this.key('signatureAlgorithm').use(AlgorithmIdentifier),
              this.key('signatureValue').bitstr()
            );
          });
          module.exports = X509Certificate;
        },
        { 'asn1.js': 137 }
      ],
      215: [
        function(require, module, exports) {
          (function(Buffer) {
            var findProc = /Proc-Type: 4,ENCRYPTED\n\r?DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)\n\r?\n\r?([0-9A-z\n\r\+\/\=]+)\n\r?/m;
            var startRegex = /^-----BEGIN ((?:.* KEY)|CERTIFICATE)-----\n/m;
            var fullRegex = /^-----BEGIN ((?:.* KEY)|CERTIFICATE)-----\n\r?([0-9A-z\n\r\+\/\=]+)\n\r?-----END \1-----$/m;
            var evp = require('evp_bytestokey');
            var ciphers = require('browserify-aes');
            module.exports = function(okey, password) {
              var key = okey.toString();
              var match = key.match(findProc);
              var decrypted;
              if (!match) {
                var match2 = key.match(fullRegex);
                decrypted = new Buffer(
                  match2[2].replace(/\r?\n/g, ''),
                  'base64'
                );
              } else {
                var suite = 'aes' + match[1];
                var iv = new Buffer(match[2], 'hex');
                var cipherText = new Buffer(
                  match[3].replace(/\r?\n/g, ''),
                  'base64'
                );
                var cipherKey = evp(
                  password,
                  iv.slice(0, 8),
                  parseInt(match[1], 10)
                ).key;
                var out = [];
                var cipher = ciphers.createDecipheriv(suite, cipherKey, iv);
                out.push(cipher.update(cipherText));
                out.push(cipher.final());
                decrypted = Buffer.concat(out);
              }
              var tag = key.match(startRegex)[1];
              return { tag: tag, data: decrypted };
            };
          }.call(this, require('buffer').Buffer));
        },
        { 'browserify-aes': 158, buffer: 183, evp_bytestokey: 204 }
      ],
      216: [
        function(require, module, exports) {
          (function(Buffer) {
            var asn1 = require('./asn1');
            var aesid = require('./aesid.json');
            var fixProc = require('./fixProc');
            var ciphers = require('browserify-aes');
            var compat = require('pbkdf2');
            module.exports = parseKeys;
            function parseKeys(buffer) {
              var password;
              if (typeof buffer === 'object' && !Buffer.isBuffer(buffer)) {
                password = buffer.passphrase;
                buffer = buffer.key;
              }
              if (typeof buffer === 'string') {
                buffer = new Buffer(buffer);
              }
              var stripped = fixProc(buffer, password);
              var type = stripped.tag;
              var data = stripped.data;
              var subtype, ndata;
              switch (type) {
                case 'CERTIFICATE':
                  ndata = asn1.certificate.decode(data, 'der').tbsCertificate
                    .subjectPublicKeyInfo;
                case 'PUBLIC KEY':
                  if (!ndata) {
                    ndata = asn1.PublicKey.decode(data, 'der');
                  }
                  subtype = ndata.algorithm.algorithm.join('.');
                  switch (subtype) {
                    case '1.2.840.113549.1.1.1':
                      return asn1.RSAPublicKey.decode(
                        ndata.subjectPublicKey.data,
                        'der'
                      );
                    case '1.2.840.10045.2.1':
                      ndata.subjectPrivateKey = ndata.subjectPublicKey;
                      return { type: 'ec', data: ndata };
                    case '1.2.840.10040.4.1':
                      ndata.algorithm.params.pub_key = asn1.DSAparam.decode(
                        ndata.subjectPublicKey.data,
                        'der'
                      );
                      return { type: 'dsa', data: ndata.algorithm.params };
                    default:
                      throw new Error('unknown key id ' + subtype);
                  }
                  throw new Error('unknown key type ' + type);
                case 'ENCRYPTED PRIVATE KEY':
                  data = asn1.EncryptedPrivateKey.decode(data, 'der');
                  data = decrypt(data, password);
                case 'PRIVATE KEY':
                  ndata = asn1.PrivateKey.decode(data, 'der');
                  subtype = ndata.algorithm.algorithm.join('.');
                  switch (subtype) {
                    case '1.2.840.113549.1.1.1':
                      return asn1.RSAPrivateKey.decode(
                        ndata.subjectPrivateKey,
                        'der'
                      );
                    case '1.2.840.10045.2.1':
                      return {
                        curve: ndata.algorithm.curve,
                        privateKey: asn1.ECPrivateKey.decode(
                          ndata.subjectPrivateKey,
                          'der'
                        ).privateKey
                      };
                    case '1.2.840.10040.4.1':
                      ndata.algorithm.params.priv_key = asn1.DSAparam.decode(
                        ndata.subjectPrivateKey,
                        'der'
                      );
                      return { type: 'dsa', params: ndata.algorithm.params };
                    default:
                      throw new Error('unknown key id ' + subtype);
                  }
                  throw new Error('unknown key type ' + type);
                case 'RSA PUBLIC KEY':
                  return asn1.RSAPublicKey.decode(data, 'der');
                case 'RSA PRIVATE KEY':
                  return asn1.RSAPrivateKey.decode(data, 'der');
                case 'DSA PRIVATE KEY':
                  return {
                    type: 'dsa',
                    params: asn1.DSAPrivateKey.decode(data, 'der')
                  };
                case 'EC PRIVATE KEY':
                  data = asn1.ECPrivateKey.decode(data, 'der');
                  return {
                    curve: data.parameters.value,
                    privateKey: data.privateKey
                  };
                default:
                  throw new Error('unknown key type ' + type);
              }
            }
            parseKeys.signature = asn1.signature;
            function decrypt(data, password) {
              var salt = data.algorithm.decrypt.kde.kdeparams.salt;
              var iters = parseInt(
                data.algorithm.decrypt.kde.kdeparams.iters.toString(),
                10
              );
              var algo = aesid[data.algorithm.decrypt.cipher.algo.join('.')];
              var iv = data.algorithm.decrypt.cipher.iv;
              var cipherText = data.subjectPrivateKey;
              var keylen = parseInt(algo.split('-')[1], 10) / 8;
              var key = compat.pbkdf2Sync(password, salt, iters, keylen);
              var cipher = ciphers.createDecipheriv(algo, key, iv);
              var out = [];
              out.push(cipher.update(cipherText));
              out.push(cipher.final());
              return Buffer.concat(out);
            }
          }.call(this, require('buffer').Buffer));
        },
        {
          './aesid.json': 212,
          './asn1': 213,
          './fixProc': 215,
          'browserify-aes': 158,
          buffer: 183,
          pbkdf2: 217
        }
      ],
      217: [
        function(require, module, exports) {
          exports.pbkdf2 = require('./lib/async');
          exports.pbkdf2Sync = require('./lib/sync');
        },
        { './lib/async': 218, './lib/sync': 221 }
      ],
      218: [
        function(require, module, exports) {
          (function(process, global) {
            var checkParameters = require('./precondition');
            var defaultEncoding = require('./default-encoding');
            var sync = require('./sync');
            var Buffer = require('safe-buffer').Buffer;
            var ZERO_BUF;
            var subtle = global.crypto && global.crypto.subtle;
            var toBrowser = {
              sha: 'SHA-1',
              'sha-1': 'SHA-1',
              sha1: 'SHA-1',
              sha256: 'SHA-256',
              'sha-256': 'SHA-256',
              sha384: 'SHA-384',
              'sha-384': 'SHA-384',
              'sha-512': 'SHA-512',
              sha512: 'SHA-512'
            };
            var checks = [];
            function checkNative(algo) {
              if (global.process && !global.process.browser) {
                return Promise.resolve(false);
              }
              if (!subtle || !subtle.importKey || !subtle.deriveBits) {
                return Promise.resolve(false);
              }
              if (checks[algo] !== undefined) {
                return checks[algo];
              }
              ZERO_BUF = ZERO_BUF || Buffer.alloc(8);
              var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo)
                .then(function() {
                  return true;
                })
                .catch(function() {
                  return false;
                });
              checks[algo] = prom;
              return prom;
            }
            function browserPbkdf2(password, salt, iterations, length, algo) {
              return subtle
                .importKey('raw', password, { name: 'PBKDF2' }, false, [
                  'deriveBits'
                ])
                .then(function(key) {
                  return subtle.deriveBits(
                    {
                      name: 'PBKDF2',
                      salt: salt,
                      iterations: iterations,
                      hash: { name: algo }
                    },
                    key,
                    length << 3
                  );
                })
                .then(function(res) {
                  return Buffer.from(res);
                });
            }
            function resolvePromise(promise, callback) {
              promise.then(
                function(out) {
                  process.nextTick(function() {
                    callback(null, out);
                  });
                },
                function(e) {
                  process.nextTick(function() {
                    callback(e);
                  });
                }
              );
            }
            module.exports = function(
              password,
              salt,
              iterations,
              keylen,
              digest,
              callback
            ) {
              if (!Buffer.isBuffer(password))
                password = Buffer.from(password, defaultEncoding);
              if (!Buffer.isBuffer(salt))
                salt = Buffer.from(salt, defaultEncoding);
              checkParameters(iterations, keylen);
              if (typeof digest === 'function') {
                callback = digest;
                digest = undefined;
              }
              if (typeof callback !== 'function')
                throw new Error('No callback provided to pbkdf2');
              digest = digest || 'sha1';
              var algo = toBrowser[digest.toLowerCase()];
              if (!algo || typeof global.Promise !== 'function') {
                return process.nextTick(function() {
                  var out;
                  try {
                    out = sync(password, salt, iterations, keylen, digest);
                  } catch (e) {
                    return callback(e);
                  }
                  callback(null, out);
                });
              }
              resolvePromise(
                checkNative(algo).then(function(resp) {
                  if (resp) {
                    return browserPbkdf2(
                      password,
                      salt,
                      iterations,
                      keylen,
                      algo
                    );
                  } else {
                    return sync(password, salt, iterations, keylen, digest);
                  }
                }),
                callback
              );
            };
          }.call(
            this,
            require('_process'),
            typeof global !== 'undefined'
              ? global
              : typeof self !== 'undefined'
              ? self
              : typeof window !== 'undefined'
              ? window
              : {}
          ));
        },
        {
          './default-encoding': 219,
          './precondition': 220,
          './sync': 221,
          _process: 223,
          'safe-buffer': 460
        }
      ],
      219: [
        function(require, module, exports) {
          (function(process) {
            var defaultEncoding;
            if (process.browser) {
              defaultEncoding = 'utf-8';
            } else {
              var pVersionMajor = parseInt(
                process.version.split('.')[0].slice(1),
                10
              );
              defaultEncoding = pVersionMajor >= 6 ? 'utf-8' : 'binary';
            }
            module.exports = defaultEncoding;
          }.call(this, require('_process')));
        },
        { _process: 223 }
      ],
      220: [
        function(require, module, exports) {
          var MAX_ALLOC = Math.pow(2, 30) - 1;
          module.exports = function(iterations, keylen) {
            if (typeof iterations !== 'number') {
              throw new TypeError('Iterations not a number');
            }
            if (iterations < 0) {
              throw new TypeError('Bad iterations');
            }
            if (typeof keylen !== 'number') {
              throw new TypeError('Key length not a number');
            }
            if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) {
              throw new TypeError('Bad key length');
            }
          };
        },
        {}
      ],
      221: [
        function(require, module, exports) {
          var md5 = require('create-hash/md5');
          var rmd160 = require('ripemd160');
          var sha = require('sha.js');
          var checkParameters = require('./precondition');
          var defaultEncoding = require('./default-encoding');
          var Buffer = require('safe-buffer').Buffer;
          var ZEROS = Buffer.alloc(128);
          var sizes = {
            md5: 16,
            sha1: 20,
            sha224: 28,
            sha256: 32,
            sha384: 48,
            sha512: 64,
            rmd160: 20,
            ripemd160: 20
          };
          function Hmac(alg, key, saltLen) {
            var hash = getDigest(alg);
            var blocksize = alg === 'sha512' || alg === 'sha384' ? 128 : 64;
            if (key.length > blocksize) {
              key = hash(key);
            } else if (key.length < blocksize) {
              key = Buffer.concat([key, ZEROS], blocksize);
            }
            var ipad = Buffer.allocUnsafe(blocksize + sizes[alg]);
            var opad = Buffer.allocUnsafe(blocksize + sizes[alg]);
            for (var i = 0; i < blocksize; i++) {
              ipad[i] = key[i] ^ 54;
              opad[i] = key[i] ^ 92;
            }
            var ipad1 = Buffer.allocUnsafe(blocksize + saltLen + 4);
            ipad.copy(ipad1, 0, 0, blocksize);
            this.ipad1 = ipad1;
            this.ipad2 = ipad;
            this.opad = opad;
            this.alg = alg;
            this.blocksize = blocksize;
            this.hash = hash;
            this.size = sizes[alg];
          }
          Hmac.prototype.run = function(data, ipad) {
            data.copy(ipad, this.blocksize);
            var h = this.hash(ipad);
            h.copy(this.opad, this.blocksize);
            return this.hash(this.opad);
          };
          function getDigest(alg) {
            function shaFunc(data) {
              return sha(alg)
                .update(data)
                .digest();
            }
            if (alg === 'rmd160' || alg === 'ripemd160') return rmd160;
            if (alg === 'md5') return md5;
            return shaFunc;
          }
          function pbkdf2(password, salt, iterations, keylen, digest) {
            if (!Buffer.isBuffer(password))
              password = Buffer.from(password, defaultEncoding);
            if (!Buffer.isBuffer(salt))
              salt = Buffer.from(salt, defaultEncoding);
            checkParameters(iterations, keylen);
            digest = digest || 'sha1';
            var hmac = new Hmac(digest, password, salt.length);
            var DK = Buffer.allocUnsafe(keylen);
            var block1 = Buffer.allocUnsafe(salt.length + 4);
            salt.copy(block1, 0, 0, salt.length);
            var destPos = 0;
            var hLen = sizes[digest];
            var l = Math.ceil(keylen / hLen);
            for (var i = 1; i <= l; i++) {
              block1.writeUInt32BE(i, salt.length);
              var T = hmac.run(block1, hmac.ipad1);
              var U = T;
              for (var j = 1; j < iterations; j++) {
                U = hmac.run(U, hmac.ipad2);
                for (var k = 0; k < hLen; k++) T[k] ^= U[k];
              }
              T.copy(DK, destPos);
              destPos += hLen;
            }
            return DK;
          }
          module.exports = pbkdf2;
        },
        {
          './default-encoding': 219,
          './precondition': 220,
          'create-hash/md5': 189,
          ripemd160: 249,
          'safe-buffer': 460,
          'sha.js': 251
        }
      ],
      222: [
        function(require, module, exports) {
          (function(process) {
            'use strict';
            if (
              !process.version ||
              process.version.indexOf('v0.') === 0 ||
              (process.version.indexOf('v1.') === 0 &&
                process.version.indexOf('v1.8.') !== 0)
            ) {
              module.exports = nextTick;
            } else {
              module.exports = process.nextTick;
            }
            function nextTick(fn, arg1, arg2, arg3) {
              if (typeof fn !== 'function') {
                throw new TypeError('"callback" argument must be a function');
              }
              var len = arguments.length;
              var args, i;
              switch (len) {
                case 0:
                case 1:
                  return process.nextTick(fn);
                case 2:
                  return process.nextTick(function afterTickOne() {
                    fn.call(null, arg1);
                  });
                case 3:
                  return process.nextTick(function afterTickTwo() {
                    fn.call(null, arg1, arg2);
                  });
                case 4:
                  return process.nextTick(function afterTickThree() {
                    fn.call(null, arg1, arg2, arg3);
                  });
                default:
                  args = new Array(len - 1);
                  i = 0;
                  while (i < args.length) {
                    args[i++] = arguments[i];
                  }
                  return process.nextTick(function afterTick() {
                    fn.apply(null, args);
                  });
              }
            }
          }.call(this, require('_process')));
        },
        { _process: 223 }
      ],
      223: [
        function(require, module, exports) {
          var process = (module.exports = {});
          var cachedSetTimeout;
          var cachedClearTimeout;
          function defaultSetTimout() {
            throw new Error('setTimeout has not been defined');
          }
          function defaultClearTimeout() {
            throw new Error('clearTimeout has not been defined');
          }
          (function() {
            try {
              if (typeof setTimeout === 'function') {
                cachedSetTimeout = setTimeout;
              } else {
                cachedSetTimeout = defaultSetTimout;
              }
            } catch (e) {
              cachedSetTimeout = defaultSetTimout;
            }
            try {
              if (typeof clearTimeout === 'function') {
                cachedClearTimeout = clearTimeout;
              } else {
                cachedClearTimeout = defaultClearTimeout;
              }
            } catch (e) {
              cachedClearTimeout = defaultClearTimeout;
            }
          })();
          function runTimeout(fun) {
            if (cachedSetTimeout === setTimeout) {
              return setTimeout(fun, 0);
            }
            if (
              (cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) &&
              setTimeout
            ) {
              cachedSetTimeout = setTimeout;
              return setTimeout(fun, 0);
            }
            try {
              return cachedSetTimeout(fun, 0);
            } catch (e) {
              try {
                return cachedSetTimeout.call(null, fun, 0);
              } catch (e) {
                return cachedSetTimeout.call(this, fun, 0);
              }
            }
          }
          function runClearTimeout(marker) {
            if (cachedClearTimeout === clearTimeout) {
              return clearTimeout(marker);
            }
            if (
              (cachedClearTimeout === defaultClearTimeout ||
                !cachedClearTimeout) &&
              clearTimeout
            ) {
              cachedClearTimeout = clearTimeout;
              return clearTimeout(marker);
            }
            try {
              return cachedClearTimeout(marker);
            } catch (e) {
              try {
                return cachedClearTimeout.call(null, marker);
              } catch (e) {
                return cachedClearTimeout.call(this, marker);
              }
            }
          }
          var queue = [];
          var draining = false;
          var currentQueue;
          var queueIndex = -1;
          function cleanUpNextTick() {
            if (!draining || !currentQueue) {
              return;
            }
            draining = false;
            if (currentQueue.length) {
              queue = currentQueue.concat(queue);
            } else {
              queueIndex = -1;
            }
            if (queue.length) {
              drainQueue();
            }
          }
          function drainQueue() {
            if (draining) {
              return;
            }
            var timeout = runTimeout(cleanUpNextTick);
            draining = true;
            var len = queue.length;
            while (len) {
              currentQueue = queue;
              queue = [];
              while (++queueIndex < len) {
                if (currentQueue) {
                  currentQueue[queueIndex].run();
                }
              }
              queueIndex = -1;
              len = queue.length;
            }
            currentQueue = null;
            draining = false;
            runClearTimeout(timeout);
          }
          process.nextTick = function(fun) {
            var args = new Array(arguments.length - 1);
            if (arguments.length > 1) {
              for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
              }
            }
            queue.push(new Item(fun, args));
            if (queue.length === 1 && !draining) {
              runTimeout(drainQueue);
            }
          };
          function Item(fun, array) {
            this.fun = fun;
            this.array = array;
          }
          Item.prototype.run = function() {
            this.fun.apply(null, this.array);
          };
          process.title = 'browser';
          process.browser = true;
          process.env = {};
          process.argv = [];
          process.version = '';
          process.versions = {};
          function noop() {}
          process.on = noop;
          process.addListener = noop;
          process.once = noop;
          process.off = noop;
          process.removeListener = noop;
          process.removeAllListeners = noop;
          process.emit = noop;
          process.prependListener = noop;
          process.prependOnceListener = noop;
          process.listeners = function(name) {
            return [];
          };
          process.binding = function(name) {
            throw new Error('process.binding is not supported');
          };
          process.cwd = function() {
            return '/';
          };
          process.chdir = function(dir) {
            throw new Error('process.chdir is not supported');
          };
          process.umask = function() {
            return 0;
          };
        },
        {}
      ],
      224: [
        function(require, module, exports) {
          exports.publicEncrypt = require('./publicEncrypt');
          exports.privateDecrypt = require('./privateDecrypt');
          exports.privateEncrypt = function privateEncrypt(key, buf) {
            return exports.publicEncrypt(key, buf, true);
          };
          exports.publicDecrypt = function publicDecrypt(key, buf) {
            return exports.privateDecrypt(key, buf, true);
          };
        },
        { './privateDecrypt': 226, './publicEncrypt': 227 }
      ],
      225: [
        function(require, module, exports) {
          (function(Buffer) {
            var createHash = require('create-hash');
            module.exports = function(seed, len) {
              var t = new Buffer('');
              var i = 0,
                c;
              while (t.length < len) {
                c = i2ops(i++);
                t = Buffer.concat([
                  t,
                  createHash('sha1')
                    .update(seed)
                    .update(c)
                    .digest()
                ]);
              }
              return t.slice(0, len);
            };
            function i2ops(c) {
              var out = new Buffer(4);
              out.writeUInt32BE(c, 0);
              return out;
            }
          }.call(this, require('buffer').Buffer));
        },
        { buffer: 183, 'create-hash': 187 }
      ],
      226: [
        function(require, module, exports) {
          (function(Buffer) {
            var parseKeys = require('parse-asn1');
            var mgf = require('./mgf');
            var xor = require('./xor');
            var bn = require('bn.js');
            var crt = require('browserify-rsa');
            var createHash = require('create-hash');
            var withPublic = require('./withPublic');
            module.exports = function privateDecrypt(
              private_key,
              enc,
              reverse
            ) {
              var padding;
              if (private_key.padding) {
                padding = private_key.padding;
              } else if (reverse) {
                padding = 1;
              } else {
                padding = 4;
              }
              var key = parseKeys(private_key);
              var k = key.modulus.byteLength();
              if (enc.length > k || new bn(enc).cmp(key.modulus) >= 0) {
                throw new Error('decryption error');
              }
              var msg;
              if (reverse) {
                msg = withPublic(new bn(enc), key);
              } else {
                msg = crt(enc, key);
              }
              var zBuffer = new Buffer(k - msg.length);
              zBuffer.fill(0);
              msg = Buffer.concat([zBuffer, msg], k);
              if (padding === 4) {
                return oaep(key, msg);
              } else if (padding === 1) {
                return pkcs1(key, msg, reverse);
              } else if (padding === 3) {
                return msg;
              } else {
                throw new Error('unknown padding');
              }
            };
            function oaep(key, msg) {
              var n = key.modulus;
              var k = key.modulus.byteLength();
              var mLen = msg.length;
              var iHash = createHash('sha1')
                .update(new Buffer(''))
                .digest();
              var hLen = iHash.length;
              var hLen2 = 2 * hLen;
              if (msg[0] !== 0) {
                throw new Error('decryption error');
              }
              var maskedSeed = msg.slice(1, hLen + 1);
              var maskedDb = msg.slice(hLen + 1);
              var seed = xor(maskedSeed, mgf(maskedDb, hLen));
              var db = xor(maskedDb, mgf(seed, k - hLen - 1));
              if (compare(iHash, db.slice(0, hLen))) {
                throw new Error('decryption error');
              }
              var i = hLen;
              while (db[i] === 0) {
                i++;
              }
              if (db[i++] !== 1) {
                throw new Error('decryption error');
              }
              return db.slice(i);
            }
            function pkcs1(key, msg, reverse) {
              var p1 = msg.slice(0, 2);
              var i = 2;
              var status = 0;
              while (msg[i++] !== 0) {
                if (i >= msg.length) {
                  status++;
                  break;
                }
              }
              var ps = msg.slice(2, i - 1);
              var p2 = msg.slice(i - 1, i);
              if (
                (p1.toString('hex') !== '0002' && !reverse) ||
                (p1.toString('hex') !== '0001' && reverse)
              ) {
                status++;
              }
              if (ps.length < 8) {
                status++;
              }
              if (status) {
                throw new Error('decryption error');
              }
              return msg.slice(i);
            }
            function compare(a, b) {
              a = new Buffer(a);
              b = new Buffer(b);
              var dif = 0;
              var len = a.length;
              if (a.length !== b.length) {
                dif++;
                len = Math.min(a.length, b.length);
              }
              var i = -1;
              while (++i < len) {
                dif += a[i] ^ b[i];
              }
              return dif;
            }
          }.call(this, require('buffer').Buffer));
        },
        {
          './mgf': 225,
          './withPublic': 228,
          './xor': 229,
          'bn.js': 153,
          'browserify-rsa': 175,
          buffer: 183,
          'create-hash': 187,
          'parse-asn1': 216
        }
      ],
      227: [
        function(require, module, exports) {
          (function(Buffer) {
            var parseKeys = require('parse-asn1');
            var randomBytes = require('randombytes');
            var createHash = require('create-hash');
            var mgf = require('./mgf');
            var xor = require('./xor');
            var bn = require('bn.js');
            var withPublic = require('./withPublic');
            var crt = require('browserify-rsa');
            var constants = {
              RSA_PKCS1_OAEP_PADDING: 4,
              RSA_PKCS1_PADDIN: 1,
              RSA_NO_PADDING: 3
            };
            module.exports = function publicEncrypt(public_key, msg, reverse) {
              var padding;
              if (public_key.padding) {
                padding = public_key.padding;
              } else if (reverse) {
                padding = 1;
              } else {
                padding = 4;
              }
              var key = parseKeys(public_key);
              var paddedMsg;
              if (padding === 4) {
                paddedMsg = oaep(key, msg);
              } else if (padding === 1) {
                paddedMsg = pkcs1(key, msg, reverse);
              } else if (padding === 3) {
                paddedMsg = new bn(msg);
                if (paddedMsg.cmp(key.modulus) >= 0) {
                  throw new Error('data too long for modulus');
                }
              } else {
                throw new Error('unknown padding');
              }
              if (reverse) {
                return crt(paddedMsg, key);
              } else {
                return withPublic(paddedMsg, key);
              }
            };
            function oaep(key, msg) {
              var k = key.modulus.byteLength();
              var mLen = msg.length;
              var iHash = createHash('sha1')
                .update(new Buffer(''))
                .digest();
              var hLen = iHash.length;
              var hLen2 = 2 * hLen;
              if (mLen > k - hLen2 - 2) {
                throw new Error('message too long');
              }
              var ps = new Buffer(k - mLen - hLen2 - 2);
              ps.fill(0);
              var dblen = k - hLen - 1;
              var seed = randomBytes(hLen);
              var maskedDb = xor(
                Buffer.concat([iHash, ps, new Buffer([1]), msg], dblen),
                mgf(seed, dblen)
              );
              var maskedSeed = xor(seed, mgf(maskedDb, hLen));
              return new bn(
                Buffer.concat([new Buffer([0]), maskedSeed, maskedDb], k)
              );
            }
            function pkcs1(key, msg, reverse) {
              var mLen = msg.length;
              var k = key.modulus.byteLength();
              if (mLen > k - 11) {
                throw new Error('message too long');
              }
              var ps;
              if (reverse) {
                ps = new Buffer(k - mLen - 3);
                ps.fill(255);
              } else {
                ps = nonZero(k - mLen - 3);
              }
              return new bn(
                Buffer.concat(
                  [new Buffer([0, reverse ? 1 : 2]), ps, new Buffer([0]), msg],
                  k
                )
              );
            }
            function nonZero(len, crypto) {
              var out = new Buffer(len);
              var i = 0;
              var cache = randomBytes(len * 2);
              var cur = 0;
              var num;
              while (i < len) {
                if (cur === cache.length) {
                  cache = randomBytes(len * 2);
                  cur = 0;
                }
                num = cache[cur++];
                if (num) {
                  out[i++] = num;
                }
              }
              return out;
            }
          }.call(this, require('buffer').Buffer));
        },
        {
          './mgf': 225,
          './withPublic': 228,
          './xor': 229,
          'bn.js': 153,
          'browserify-rsa': 175,
          buffer: 183,
          'create-hash': 187,
          'parse-asn1': 216,
          randombytes: 234
        }
      ],
      228: [
        function(require, module, exports) {
          (function(Buffer) {
            var bn = require('bn.js');
            function withPublic(paddedMsg, key) {
              return new Buffer(
                paddedMsg
                  .toRed(bn.mont(key.modulus))
                  .redPow(new bn(key.publicExponent))
                  .fromRed()
                  .toArray()
              );
            }
            module.exports = withPublic;
          }.call(this, require('buffer').Buffer));
        },
        { 'bn.js': 153, buffer: 183 }
      ],
      229: [
        function(require, module, exports) {
          module.exports = function xor(a, b) {
            var len = a.length;
            var i = -1;
            while (++i < len) {
              a[i] ^= b[i];
            }
            return a;
          };
        },
        {}
      ],
      230: [
        function(require, module, exports) {
          (function(global) {
            (function(root) {
              var freeExports =
                typeof exports == 'object' &&
                exports &&
                !exports.nodeType &&
                exports;
              var freeModule =
                typeof module == 'object' &&
                module &&
                !module.nodeType &&
                module;
              var freeGlobal = typeof global == 'object' && global;
              if (
                freeGlobal.global === freeGlobal ||
                freeGlobal.window === freeGlobal ||
                freeGlobal.self === freeGlobal
              ) {
                root = freeGlobal;
              }
              var punycode,
                maxInt = 2147483647,
                base = 36,
                tMin = 1,
                tMax = 26,
                skew = 38,
                damp = 700,
                initialBias = 72,
                initialN = 128,
                delimiter = '-',
                regexPunycode = /^xn--/,
                regexNonASCII = /[^\x20-\x7E]/,
                regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
                errors = {
                  overflow: 'Overflow: input needs wider integers to process',
                  'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
                  'invalid-input': 'Invalid input'
                },
                baseMinusTMin = base - tMin,
                floor = Math.floor,
                stringFromCharCode = String.fromCharCode,
                key;
              function error(type) {
                throw new RangeError(errors[type]);
              }
              function map(array, fn) {
                var length = array.length;
                var result = [];
                while (length--) {
                  result[length] = fn(array[length]);
                }
                return result;
              }
              function mapDomain(string, fn) {
                var parts = string.split('@');
                var result = '';
                if (parts.length > 1) {
                  result = parts[0] + '@';
                  string = parts[1];
                }
                string = string.replace(regexSeparators, '.');
                var labels = string.split('.');
                var encoded = map(labels, fn).join('.');
                return result + encoded;
              }
              function ucs2decode(string) {
                var output = [],
                  counter = 0,
                  length = string.length,
                  value,
                  extra;
                while (counter < length) {
                  value = string.charCodeAt(counter++);
                  if (value >= 55296 && value <= 56319 && counter < length) {
                    extra = string.charCodeAt(counter++);
                    if ((extra & 64512) == 56320) {
                      output.push(
                        ((value & 1023) << 10) + (extra & 1023) + 65536
                      );
                    } else {
                      output.push(value);
                      counter--;
                    }
                  } else {
                    output.push(value);
                  }
                }
                return output;
              }
              function ucs2encode(array) {
                return map(array, function(value) {
                  var output = '';
                  if (value > 65535) {
                    value -= 65536;
                    output += stringFromCharCode(
                      ((value >>> 10) & 1023) | 55296
                    );
                    value = 56320 | (value & 1023);
                  }
                  output += stringFromCharCode(value);
                  return output;
                }).join('');
              }
              function basicToDigit(codePoint) {
                if (codePoint - 48 < 10) {
                  return codePoint - 22;
                }
                if (codePoint - 65 < 26) {
                  return codePoint - 65;
                }
                if (codePoint - 97 < 26) {
                  return codePoint - 97;
                }
                return base;
              }
              function digitToBasic(digit, flag) {
                return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
              }
              function adapt(delta, numPoints, firstTime) {
                var k = 0;
                delta = firstTime ? floor(delta / damp) : delta >> 1;
                delta += floor(delta / numPoints);
                for (; delta > (baseMinusTMin * tMax) >> 1; k += base) {
                  delta = floor(delta / baseMinusTMin);
                }
                return floor(
                  k + ((baseMinusTMin + 1) * delta) / (delta + skew)
                );
              }
              function decode(input) {
                var output = [],
                  inputLength = input.length,
                  out,
                  i = 0,
                  n = initialN,
                  bias = initialBias,
                  basic,
                  j,
                  index,
                  oldi,
                  w,
                  k,
                  digit,
                  t,
                  baseMinusT;
                basic = input.lastIndexOf(delimiter);
                if (basic < 0) {
                  basic = 0;
                }
                for (j = 0; j < basic; ++j) {
                  if (input.charCodeAt(j) >= 128) {
                    error('not-basic');
                  }
                  output.push(input.charCodeAt(j));
                }
                for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
                  for (oldi = i, w = 1, k = base; ; k += base) {
                    if (index >= inputLength) {
                      error('invalid-input');
                    }
                    digit = basicToDigit(input.charCodeAt(index++));
                    if (digit >= base || digit > floor((maxInt - i) / w)) {
                      error('overflow');
                    }
                    i += digit * w;
                    t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                    if (digit < t) {
                      break;
                    }
                    baseMinusT = base - t;
                    if (w > floor(maxInt / baseMinusT)) {
                      error('overflow');
                    }
                    w *= baseMinusT;
                  }
                  out = output.length + 1;
                  bias = adapt(i - oldi, out, oldi == 0);
                  if (floor(i / out) > maxInt - n) {
                    error('overflow');
                  }
                  n += floor(i / out);
                  i %= out;
                  output.splice(i++, 0, n);
                }
                return ucs2encode(output);
              }
              function encode(input) {
                var n,
                  delta,
                  handledCPCount,
                  basicLength,
                  bias,
                  j,
                  m,
                  q,
                  k,
                  t,
                  currentValue,
                  output = [],
                  inputLength,
                  handledCPCountPlusOne,
                  baseMinusT,
                  qMinusT;
                input = ucs2decode(input);
                inputLength = input.length;
                n = initialN;
                delta = 0;
                bias = initialBias;
                for (j = 0; j < inputLength; ++j) {
                  currentValue = input[j];
                  if (currentValue < 128) {
                    output.push(stringFromCharCode(currentValue));
                  }
                }
                handledCPCount = basicLength = output.length;
                if (basicLength) {
                  output.push(delimiter);
                }
                while (handledCPCount < inputLength) {
                  for (m = maxInt, j = 0; j < inputLength; ++j) {
                    currentValue = input[j];
                    if (currentValue >= n && currentValue < m) {
                      m = currentValue;
                    }
                  }
                  handledCPCountPlusOne = handledCPCount + 1;
                  if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                    error('overflow');
                  }
                  delta += (m - n) * handledCPCountPlusOne;
                  n = m;
                  for (j = 0; j < inputLength; ++j) {
                    currentValue = input[j];
                    if (currentValue < n && ++delta > maxInt) {
                      error('overflow');
                    }
                    if (currentValue == n) {
                      for (q = delta, k = base; ; k += base) {
                        t =
                          k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                        if (q < t) {
                          break;
                        }
                        qMinusT = q - t;
                        baseMinusT = base - t;
                        output.push(
                          stringFromCharCode(
                            digitToBasic(t + (qMinusT % baseMinusT), 0)
                          )
                        );
                        q = floor(qMinusT / baseMinusT);
                      }
                      output.push(stringFromCharCode(digitToBasic(q, 0)));
                      bias = adapt(
                        delta,
                        handledCPCountPlusOne,
                        handledCPCount == basicLength
                      );
                      delta = 0;
                      ++handledCPCount;
                    }
                  }
                  ++delta;
                  ++n;
                }
                return output.join('');
              }
              function toUnicode(input) {
                return mapDomain(input, function(string) {
                  return regexPunycode.test(string)
                    ? decode(string.slice(4).toLowerCase())
                    : string;
                });
              }
              function toASCII(input) {
                return mapDomain(input, function(string) {
                  return regexNonASCII.test(string)
                    ? 'xn--' + encode(string)
                    : string;
                });
              }
              punycode = {
                version: '1.4.1',
                ucs2: { decode: ucs2decode, encode: ucs2encode },
                decode: decode,
                encode: encode,
                toASCII: toASCII,
                toUnicode: toUnicode
              };
              if (
                typeof define == 'function' &&
                typeof define.amd == 'object' &&
                define.amd
              ) {
                define('punycode', function() {
                  return punycode;
                });
              } else if (freeExports && freeModule) {
                if (module.exports == freeExports) {
                  freeModule.exports = punycode;
                } else {
                  for (key in punycode) {
                    punycode.hasOwnProperty(key) &&
                      (freeExports[key] = punycode[key]);
                  }
                }
              } else {
                root.punycode = punycode;
              }
            })(this);
          }.call(
            this,
            typeof global !== 'undefined'
              ? global
              : typeof self !== 'undefined'
              ? self
              : typeof window !== 'undefined'
              ? window
              : {}
          ));
        },
        {}
      ],
      231: [
        function(require, module, exports) {
          'use strict';
          function hasOwnProperty(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
          }
          module.exports = function(qs, sep, eq, options) {
            sep = sep || '&';
            eq = eq || '=';
            var obj = {};
            if (typeof qs !== 'string' || qs.length === 0) {
              return obj;
            }
            var regexp = /\+/g;
            qs = qs.split(sep);
            var maxKeys = 1e3;
            if (options && typeof options.maxKeys === 'number') {
              maxKeys = options.maxKeys;
            }
            var len = qs.length;
            if (maxKeys > 0 && len > maxKeys) {
              len = maxKeys;
            }
            for (var i = 0; i < len; ++i) {
              var x = qs[i].replace(regexp, '%20'),
                idx = x.indexOf(eq),
                kstr,
                vstr,
                k,
                v;
              if (idx >= 0) {
                kstr = x.substr(0, idx);
                vstr = x.substr(idx + 1);
              } else {
                kstr = x;
                vstr = '';
              }
              k = decodeURIComponent(kstr);
              v = decodeURIComponent(vstr);
              if (!hasOwnProperty(obj, k)) {
                obj[k] = v;
              } else if (isArray(obj[k])) {
                obj[k].push(v);
              } else {
                obj[k] = [obj[k], v];
              }
            }
            return obj;
          };
          var isArray =
            Array.isArray ||
            function(xs) {
              return Object.prototype.toString.call(xs) === '[object Array]';
            };
        },
        {}
      ],
      232: [
        function(require, module, exports) {
          'use strict';
          var stringifyPrimitive = function(v) {
            switch (typeof v) {
              case 'string':
                return v;
              case 'boolean':
                return v ? 'true' : 'false';
              case 'number':
                return isFinite(v) ? v : '';
              default:
                return '';
            }
          };
          module.exports = function(obj, sep, eq, name) {
            sep = sep || '&';
            eq = eq || '=';
            if (obj === null) {
              obj = undefined;
            }
            if (typeof obj === 'object') {
              return map(objectKeys(obj), function(k) {
                var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
                if (isArray(obj[k])) {
                  return map(obj[k], function(v) {
                    return ks + encodeURIComponent(stringifyPrimitive(v));
                  }).join(sep);
                } else {
                  return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
                }
              }).join(sep);
            }
            if (!name) return '';
            return (
              encodeURIComponent(stringifyPrimitive(name)) +
              eq +
              encodeURIComponent(stringifyPrimitive(obj))
            );
          };
          var isArray =
            Array.isArray ||
            function(xs) {
              return Object.prototype.toString.call(xs) === '[object Array]';
            };
          function map(xs, f) {
            if (xs.map) return xs.map(f);
            var res = [];
            for (var i = 0; i < xs.length; i++) {
              res.push(f(xs[i], i));
            }
            return res;
          }
          var objectKeys =
            Object.keys ||
            function(obj) {
              var res = [];
              for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key))
                  res.push(key);
              }
              return res;
            };
        },
        {}
      ],
      233: [
        function(require, module, exports) {
          'use strict';
          exports.decode = exports.parse = require('./decode');
          exports.encode = exports.stringify = require('./encode');
        },
        { './decode': 231, './encode': 232 }
      ],
      234: [
        function(require, module, exports) {
          (function(process, global) {
            'use strict';
            function oldBrowser() {
              throw new Error(
                'secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11'
              );
            }
            var Buffer = require('safe-buffer').Buffer;
            var crypto = global.crypto || global.msCrypto;
            if (crypto && crypto.getRandomValues) {
              module.exports = randomBytes;
            } else {
              module.exports = oldBrowser;
            }
            function randomBytes(size, cb) {
              if (size > 65536)
                throw new Error('requested too many random bytes');
              var rawBytes = new global.Uint8Array(size);
              if (size > 0) {
                crypto.getRandomValues(rawBytes);
              }
              var bytes = Buffer.from(rawBytes.buffer);
              if (typeof cb === 'function') {
                return process.nextTick(function() {
                  cb(null, bytes);
                });
              }
              return bytes;
            }
          }.call(
            this,
            require('_process'),
            typeof global !== 'undefined'
              ? global
              : typeof self !== 'undefined'
              ? self
              : typeof window !== 'undefined'
              ? window
              : {}
          ));
        },
        { _process: 223, 'safe-buffer': 460 }
      ],
      235: [
        function(require, module, exports) {
          module.exports = require('./lib/_stream_duplex.js');
        },
        { './lib/_stream_duplex.js': 236 }
      ],
      236: [
        function(require, module, exports) {
          'use strict';
          var processNextTick = require('process-nextick-args');
          var objectKeys =
            Object.keys ||
            function(obj) {
              var keys = [];
              for (var key in obj) {
                keys.push(key);
              }
              return keys;
            };
          module.exports = Duplex;
          var util = require('core-util-is');
          util.inherits = require('inherits');
          var Readable = require('./_stream_readable');
          var Writable = require('./_stream_writable');
          util.inherits(Duplex, Readable);
          var keys = objectKeys(Writable.prototype);
          for (var v = 0; v < keys.length; v++) {
            var method = keys[v];
            if (!Duplex.prototype[method])
              Duplex.prototype[method] = Writable.prototype[method];
          }
          function Duplex(options) {
            if (!(this instanceof Duplex)) return new Duplex(options);
            Readable.call(this, options);
            Writable.call(this, options);
            if (options && options.readable === false) this.readable = false;
            if (options && options.writable === false) this.writable = false;
            this.allowHalfOpen = true;
            if (options && options.allowHalfOpen === false)
              this.allowHalfOpen = false;
            this.once('end', onend);
          }
          function onend() {
            if (this.allowHalfOpen || this._writableState.ended) return;
            processNextTick(onEndNT, this);
          }
          function onEndNT(self) {
            self.end();
          }
          Object.defineProperty(Duplex.prototype, 'destroyed', {
            get: function() {
              if (
                this._readableState === undefined ||
                this._writableState === undefined
              ) {
                return false;
              }
              return (
                this._readableState.destroyed && this._writableState.destroyed
              );
            },
            set: function(value) {
              if (
                this._readableState === undefined ||
                this._writableState === undefined
              ) {
                return;
              }
              this._readableState.destroyed = value;
              this._writableState.destroyed = value;
            }
          });
          Duplex.prototype._destroy = function(err, cb) {
            this.push(null);
            this.end();
            processNextTick(cb, err);
          };
          function forEach(xs, f) {
            for (var i = 0, l = xs.length; i < l; i++) {
              f(xs[i], i);
            }
          }
        },
        {
          './_stream_readable': 238,
          './_stream_writable': 240,
          'core-util-is': 185,
          inherits: 207,
          'process-nextick-args': 222
        }
      ],
      237: [
        function(require, module, exports) {
          'use strict';
          module.exports = PassThrough;
          var Transform = require('./_stream_transform');
          var util = require('core-util-is');
          util.inherits = require('inherits');
          util.inherits(PassThrough, Transform);
          function PassThrough(options) {
            if (!(this instanceof PassThrough)) return new PassThrough(options);
            Transform.call(this, options);
          }
          PassThrough.prototype._transform = function(chunk, encoding, cb) {
            cb(null, chunk);
          };
        },
        { './_stream_transform': 239, 'core-util-is': 185, inherits: 207 }
      ],
      238: [
        function(require, module, exports) {
          (function(process, global) {
            'use strict';
            var processNextTick = require('process-nextick-args');
            module.exports = Readable;
            var isArray = require('isarray');
            var Duplex;
            Readable.ReadableState = ReadableState;
            var EE = require('events').EventEmitter;
            var EElistenerCount = function(emitter, type) {
              return emitter.listeners(type).length;
            };
            var Stream = require('./internal/streams/stream');
            var Buffer = require('safe-buffer').Buffer;
            var OurUint8Array = global.Uint8Array || function() {};
            function _uint8ArrayToBuffer(chunk) {
              return Buffer.from(chunk);
            }
            function _isUint8Array(obj) {
              return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
            }
            var util = require('core-util-is');
            util.inherits = require('inherits');
            var debugUtil = require('util');
            var debug = void 0;
            if (debugUtil && debugUtil.debuglog) {
              debug = debugUtil.debuglog('stream');
            } else {
              debug = function() {};
            }
            var BufferList = require('./internal/streams/BufferList');
            var destroyImpl = require('./internal/streams/destroy');
            var StringDecoder;
            util.inherits(Readable, Stream);
            var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];
            function prependListener(emitter, event, fn) {
              if (typeof emitter.prependListener === 'function') {
                return emitter.prependListener(event, fn);
              } else {
                if (!emitter._events || !emitter._events[event])
                  emitter.on(event, fn);
                else if (isArray(emitter._events[event]))
                  emitter._events[event].unshift(fn);
                else emitter._events[event] = [fn, emitter._events[event]];
              }
            }
            function ReadableState(options, stream) {
              Duplex = Duplex || require('./_stream_duplex');
              options = options || {};
              this.objectMode = !!options.objectMode;
              if (stream instanceof Duplex)
                this.objectMode =
                  this.objectMode || !!options.readableObjectMode;
              var hwm = options.highWaterMark;
              var defaultHwm = this.objectMode ? 16 : 16 * 1024;
              this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
              this.highWaterMark = Math.floor(this.highWaterMark);
              this.buffer = new BufferList();
              this.length = 0;
              this.pipes = null;
              this.pipesCount = 0;
              this.flowing = null;
              this.ended = false;
              this.endEmitted = false;
              this.reading = false;
              this.sync = true;
              this.needReadable = false;
              this.emittedReadable = false;
              this.readableListening = false;
              this.resumeScheduled = false;
              this.destroyed = false;
              this.defaultEncoding = options.defaultEncoding || 'utf8';
              this.awaitDrain = 0;
              this.readingMore = false;
              this.decoder = null;
              this.encoding = null;
              if (options.encoding) {
                if (!StringDecoder)
                  StringDecoder = require('string_decoder/').StringDecoder;
                this.decoder = new StringDecoder(options.encoding);
                this.encoding = options.encoding;
              }
            }
            function Readable(options) {
              Duplex = Duplex || require('./_stream_duplex');
              if (!(this instanceof Readable)) return new Readable(options);
              this._readableState = new ReadableState(options, this);
              this.readable = true;
              if (options) {
                if (typeof options.read === 'function')
                  this._read = options.read;
                if (typeof options.destroy === 'function')
                  this._destroy = options.destroy;
              }
              Stream.call(this);
            }
            Object.defineProperty(Readable.prototype, 'destroyed', {
              get: function() {
                if (this._readableState === undefined) {
                  return false;
                }
                return this._readableState.destroyed;
              },
              set: function(value) {
                if (!this._readableState) {
                  return;
                }
                this._readableState.destroyed = value;
              }
            });
            Readable.prototype.destroy = destroyImpl.destroy;
            Readable.prototype._undestroy = destroyImpl.undestroy;
            Readable.prototype._destroy = function(err, cb) {
              this.push(null);
              cb(err);
            };
            Readable.prototype.push = function(chunk, encoding) {
              var state = this._readableState;
              var skipChunkCheck;
              if (!state.objectMode) {
                if (typeof chunk === 'string') {
                  encoding = encoding || state.defaultEncoding;
                  if (encoding !== state.encoding) {
                    chunk = Buffer.from(chunk, encoding);
                    encoding = '';
                  }
                  skipChunkCheck = true;
                }
              } else {
                skipChunkCheck = true;
              }
              return readableAddChunk(
                this,
                chunk,
                encoding,
                false,
                skipChunkCheck
              );
            };
            Readable.prototype.unshift = function(chunk) {
              return readableAddChunk(this, chunk, null, true, false);
            };
            function readableAddChunk(
              stream,
              chunk,
              encoding,
              addToFront,
              skipChunkCheck
            ) {
              var state = stream._readableState;
              if (chunk === null) {
                state.reading = false;
                onEofChunk(stream, state);
              } else {
                var er;
                if (!skipChunkCheck) er = chunkInvalid(state, chunk);
                if (er) {
                  stream.emit('error', er);
                } else if (state.objectMode || (chunk && chunk.length > 0)) {
                  if (
                    typeof chunk !== 'string' &&
                    !state.objectMode &&
                    Object.getPrototypeOf(chunk) !== Buffer.prototype
                  ) {
                    chunk = _uint8ArrayToBuffer(chunk);
                  }
                  if (addToFront) {
                    if (state.endEmitted)
                      stream.emit(
                        'error',
                        new Error('stream.unshift() after end event')
                      );
                    else addChunk(stream, state, chunk, true);
                  } else if (state.ended) {
                    stream.emit('error', new Error('stream.push() after EOF'));
                  } else {
                    state.reading = false;
                    if (state.decoder && !encoding) {
                      chunk = state.decoder.write(chunk);
                      if (state.objectMode || chunk.length !== 0)
                        addChunk(stream, state, chunk, false);
                      else maybeReadMore(stream, state);
                    } else {
                      addChunk(stream, state, chunk, false);
                    }
                  }
                } else if (!addToFront) {
                  state.reading = false;
                }
              }
              return needMoreData(state);
            }
            function addChunk(stream, state, chunk, addToFront) {
              if (state.flowing && state.length === 0 && !state.sync) {
                stream.emit('data', chunk);
                stream.read(0);
              } else {
                state.length += state.objectMode ? 1 : chunk.length;
                if (addToFront) state.buffer.unshift(chunk);
                else state.buffer.push(chunk);
                if (state.needReadable) emitReadable(stream);
              }
              maybeReadMore(stream, state);
            }
            function chunkInvalid(state, chunk) {
              var er;
              if (
                !_isUint8Array(chunk) &&
                typeof chunk !== 'string' &&
                chunk !== undefined &&
                !state.objectMode
              ) {
                er = new TypeError('Invalid non-string/buffer chunk');
              }
              return er;
            }
            function needMoreData(state) {
              return (
                !state.ended &&
                (state.needReadable ||
                  state.length < state.highWaterMark ||
                  state.length === 0)
              );
            }
            Readable.prototype.isPaused = function() {
              return this._readableState.flowing === false;
            };
            Readable.prototype.setEncoding = function(enc) {
              if (!StringDecoder)
                StringDecoder = require('string_decoder/').StringDecoder;
              this._readableState.decoder = new StringDecoder(enc);
              this._readableState.encoding = enc;
              return this;
            };
            var MAX_HWM = 8388608;
            function computeNewHighWaterMark(n) {
              if (n >= MAX_HWM) {
                n = MAX_HWM;
              } else {
                n--;
                n |= n >>> 1;
                n |= n >>> 2;
                n |= n >>> 4;
                n |= n >>> 8;
                n |= n >>> 16;
                n++;
              }
              return n;
            }
            function howMuchToRead(n, state) {
              if (n <= 0 || (state.length === 0 && state.ended)) return 0;
              if (state.objectMode) return 1;
              if (n !== n) {
                if (state.flowing && state.length)
                  return state.buffer.head.data.length;
                else return state.length;
              }
              if (n > state.highWaterMark)
                state.highWaterMark = computeNewHighWaterMark(n);
              if (n <= state.length) return n;
              if (!state.ended) {
                state.needReadable = true;
                return 0;
              }
              return state.length;
            }
            Readable.prototype.read = function(n) {
              debug('read', n);
              n = parseInt(n, 10);
              var state = this._readableState;
              var nOrig = n;
              if (n !== 0) state.emittedReadable = false;
              if (
                n === 0 &&
                state.needReadable &&
                (state.length >= state.highWaterMark || state.ended)
              ) {
                debug('read: emitReadable', state.length, state.ended);
                if (state.length === 0 && state.ended) endReadable(this);
                else emitReadable(this);
                return null;
              }
              n = howMuchToRead(n, state);
              if (n === 0 && state.ended) {
                if (state.length === 0) endReadable(this);
                return null;
              }
              var doRead = state.needReadable;
              debug('need readable', doRead);
              if (
                state.length === 0 ||
                state.length - n < state.highWaterMark
              ) {
                doRead = true;
                debug('length less than watermark', doRead);
              }
              if (state.ended || state.reading) {
                doRead = false;
                debug('reading or ended', doRead);
              } else if (doRead) {
                debug('do read');
                state.reading = true;
                state.sync = true;
                if (state.length === 0) state.needReadable = true;
                this._read(state.highWaterMark);
                state.sync = false;
                if (!state.reading) n = howMuchToRead(nOrig, state);
              }
              var ret;
              if (n > 0) ret = fromList(n, state);
              else ret = null;
              if (ret === null) {
                state.needReadable = true;
                n = 0;
              } else {
                state.length -= n;
              }
              if (state.length === 0) {
                if (!state.ended) state.needReadable = true;
                if (nOrig !== n && state.ended) endReadable(this);
              }
              if (ret !== null) this.emit('data', ret);
              return ret;
            };
            function onEofChunk(stream, state) {
              if (state.ended) return;
              if (state.decoder) {
                var chunk = state.decoder.end();
                if (chunk && chunk.length) {
                  state.buffer.push(chunk);
                  state.length += state.objectMode ? 1 : chunk.length;
                }
              }
              state.ended = true;
              emitReadable(stream);
            }
            function emitReadable(stream) {
              var state = stream._readableState;
              state.needReadable = false;
              if (!state.emittedReadable) {
                debug('emitReadable', state.flowing);
                state.emittedReadable = true;
                if (state.sync) processNextTick(emitReadable_, stream);
                else emitReadable_(stream);
              }
            }
            function emitReadable_(stream) {
              debug('emit readable');
              stream.emit('readable');
              flow(stream);
            }
            function maybeReadMore(stream, state) {
              if (!state.readingMore) {
                state.readingMore = true;
                processNextTick(maybeReadMore_, stream, state);
              }
            }
            function maybeReadMore_(stream, state) {
              var len = state.length;
              while (
                !state.reading &&
                !state.flowing &&
                !state.ended &&
                state.length < state.highWaterMark
              ) {
                debug('maybeReadMore read 0');
                stream.read(0);
                if (len === state.length) break;
                else len = state.length;
              }
              state.readingMore = false;
            }
            Readable.prototype._read = function(n) {
              this.emit('error', new Error('_read() is not implemented'));
            };
            Readable.prototype.pipe = function(dest, pipeOpts) {
              var src = this;
              var state = this._readableState;
              switch (state.pipesCount) {
                case 0:
                  state.pipes = dest;
                  break;
                case 1:
                  state.pipes = [state.pipes, dest];
                  break;
                default:
                  state.pipes.push(dest);
                  break;
              }
              state.pipesCount += 1;
              debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
              var doEnd =
                (!pipeOpts || pipeOpts.end !== false) &&
                dest !== process.stdout &&
                dest !== process.stderr;
              var endFn = doEnd ? onend : unpipe;
              if (state.endEmitted) processNextTick(endFn);
              else src.once('end', endFn);
              dest.on('unpipe', onunpipe);
              function onunpipe(readable, unpipeInfo) {
                debug('onunpipe');
                if (readable === src) {
                  if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                    unpipeInfo.hasUnpiped = true;
                    cleanup();
                  }
                }
              }
              function onend() {
                debug('onend');
                dest.end();
              }
              var ondrain = pipeOnDrain(src);
              dest.on('drain', ondrain);
              var cleanedUp = false;
              function cleanup() {
                debug('cleanup');
                dest.removeListener('close', onclose);
                dest.removeListener('finish', onfinish);
                dest.removeListener('drain', ondrain);
                dest.removeListener('error', onerror);
                dest.removeListener('unpipe', onunpipe);
                src.removeListener('end', onend);
                src.removeListener('end', unpipe);
                src.removeListener('data', ondata);
                cleanedUp = true;
                if (
                  state.awaitDrain &&
                  (!dest._writableState || dest._writableState.needDrain)
                )
                  ondrain();
              }
              var increasedAwaitDrain = false;
              src.on('data', ondata);
              function ondata(chunk) {
                debug('ondata');
                increasedAwaitDrain = false;
                var ret = dest.write(chunk);
                if (false === ret && !increasedAwaitDrain) {
                  if (
                    ((state.pipesCount === 1 && state.pipes === dest) ||
                      (state.pipesCount > 1 &&
                        indexOf(state.pipes, dest) !== -1)) &&
                    !cleanedUp
                  ) {
                    debug(
                      'false write response, pause',
                      src._readableState.awaitDrain
                    );
                    src._readableState.awaitDrain++;
                    increasedAwaitDrain = true;
                  }
                  src.pause();
                }
              }
              function onerror(er) {
                debug('onerror', er);
                unpipe();
                dest.removeListener('error', onerror);
                if (EElistenerCount(dest, 'error') === 0)
                  dest.emit('error', er);
              }
              prependListener(dest, 'error', onerror);
              function onclose() {
                dest.removeListener('finish', onfinish);
                unpipe();
              }
              dest.once('close', onclose);
              function onfinish() {
                debug('onfinish');
                dest.removeListener('close', onclose);
                unpipe();
              }
              dest.once('finish', onfinish);
              function unpipe() {
                debug('unpipe');
                src.unpipe(dest);
              }
              dest.emit('pipe', src);
              if (!state.flowing) {
                debug('pipe resume');
                src.resume();
              }
              return dest;
            };
            function pipeOnDrain(src) {
              return function() {
                var state = src._readableState;
                debug('pipeOnDrain', state.awaitDrain);
                if (state.awaitDrain) state.awaitDrain--;
                if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
                  state.flowing = true;
                  flow(src);
                }
              };
            }
            Readable.prototype.unpipe = function(dest) {
              var state = this._readableState;
              var unpipeInfo = { hasUnpiped: false };
              if (state.pipesCount === 0) return this;
              if (state.pipesCount === 1) {
                if (dest && dest !== state.pipes) return this;
                if (!dest) dest = state.pipes;
                state.pipes = null;
                state.pipesCount = 0;
                state.flowing = false;
                if (dest) dest.emit('unpipe', this, unpipeInfo);
                return this;
              }
              if (!dest) {
                var dests = state.pipes;
                var len = state.pipesCount;
                state.pipes = null;
                state.pipesCount = 0;
                state.flowing = false;
                for (var i = 0; i < len; i++) {
                  dests[i].emit('unpipe', this, unpipeInfo);
                }
                return this;
              }
              var index = indexOf(state.pipes, dest);
              if (index === -1) return this;
              state.pipes.splice(index, 1);
              state.pipesCount -= 1;
              if (state.pipesCount === 1) state.pipes = state.pipes[0];
              dest.emit('unpipe', this, unpipeInfo);
              return this;
            };
            Readable.prototype.on = function(ev, fn) {
              var res = Stream.prototype.on.call(this, ev, fn);
              if (ev === 'data') {
                if (this._readableState.flowing !== false) this.resume();
              } else if (ev === 'readable') {
                var state = this._readableState;
                if (!state.endEmitted && !state.readableListening) {
                  state.readableListening = state.needReadable = true;
                  state.emittedReadable = false;
                  if (!state.reading) {
                    processNextTick(nReadingNextTick, this);
                  } else if (state.length) {
                    emitReadable(this);
                  }
                }
              }
              return res;
            };
            Readable.prototype.addListener = Readable.prototype.on;
            function nReadingNextTick(self) {
              debug('readable nexttick read 0');
              self.read(0);
            }
            Readable.prototype.resume = function() {
              var state = this._readableState;
              if (!state.flowing) {
                debug('resume');
                state.flowing = true;
                resume(this, state);
              }
              return this;
            };
            function resume(stream, state) {
              if (!state.resumeScheduled) {
                state.resumeScheduled = true;
                processNextTick(resume_, stream, state);
              }
            }
            function resume_(stream, state) {
              if (!state.reading) {
                debug('resume read 0');
                stream.read(0);
              }
              state.resumeScheduled = false;
              state.awaitDrain = 0;
              stream.emit('resume');
              flow(stream);
              if (state.flowing && !state.reading) stream.read(0);
            }
            Readable.prototype.pause = function() {
              debug('call pause flowing=%j', this._readableState.flowing);
              if (false !== this._readableState.flowing) {
                debug('pause');
                this._readableState.flowing = false;
                this.emit('pause');
              }
              return this;
            };
            function flow(stream) {
              var state = stream._readableState;
              debug('flow', state.flowing);
              while (state.flowing && stream.read() !== null) {}
            }
            Readable.prototype.wrap = function(stream) {
              var state = this._readableState;
              var paused = false;
              var self = this;
              stream.on('end', function() {
                debug('wrapped end');
                if (state.decoder && !state.ended) {
                  var chunk = state.decoder.end();
                  if (chunk && chunk.length) self.push(chunk);
                }
                self.push(null);
              });
              stream.on('data', function(chunk) {
                debug('wrapped data');
                if (state.decoder) chunk = state.decoder.write(chunk);
                if (state.objectMode && (chunk === null || chunk === undefined))
                  return;
                else if (!state.objectMode && (!chunk || !chunk.length)) return;
                var ret = self.push(chunk);
                if (!ret) {
                  paused = true;
                  stream.pause();
                }
              });
              for (var i in stream) {
                if (this[i] === undefined && typeof stream[i] === 'function') {
                  this[i] = (function(method) {
                    return function() {
                      return stream[method].apply(stream, arguments);
                    };
                  })(i);
                }
              }
              for (var n = 0; n < kProxyEvents.length; n++) {
                stream.on(
                  kProxyEvents[n],
                  self.emit.bind(self, kProxyEvents[n])
                );
              }
              self._read = function(n) {
                debug('wrapped _read', n);
                if (paused) {
                  paused = false;
                  stream.resume();
                }
              };
              return self;
            };
            Readable._fromList = fromList;
            function fromList(n, state) {
              if (state.length === 0) return null;
              var ret;
              if (state.objectMode) ret = state.buffer.shift();
              else if (!n || n >= state.length) {
                if (state.decoder) ret = state.buffer.join('');
                else if (state.buffer.length === 1)
                  ret = state.buffer.head.data;
                else ret = state.buffer.concat(state.length);
                state.buffer.clear();
              } else {
                ret = fromListPartial(n, state.buffer, state.decoder);
              }
              return ret;
            }
            function fromListPartial(n, list, hasStrings) {
              var ret;
              if (n < list.head.data.length) {
                ret = list.head.data.slice(0, n);
                list.head.data = list.head.data.slice(n);
              } else if (n === list.head.data.length) {
                ret = list.shift();
              } else {
                ret = hasStrings
                  ? copyFromBufferString(n, list)
                  : copyFromBuffer(n, list);
              }
              return ret;
            }
            function copyFromBufferString(n, list) {
              var p = list.head;
              var c = 1;
              var ret = p.data;
              n -= ret.length;
              while ((p = p.next)) {
                var str = p.data;
                var nb = n > str.length ? str.length : n;
                if (nb === str.length) ret += str;
                else ret += str.slice(0, n);
                n -= nb;
                if (n === 0) {
                  if (nb === str.length) {
                    ++c;
                    if (p.next) list.head = p.next;
                    else list.head = list.tail = null;
                  } else {
                    list.head = p;
                    p.data = str.slice(nb);
                  }
                  break;
                }
                ++c;
              }
              list.length -= c;
              return ret;
            }
            function copyFromBuffer(n, list) {
              var ret = Buffer.allocUnsafe(n);
              var p = list.head;
              var c = 1;
              p.data.copy(ret);
              n -= p.data.length;
              while ((p = p.next)) {
                var buf = p.data;
                var nb = n > buf.length ? buf.length : n;
                buf.copy(ret, ret.length - n, 0, nb);
                n -= nb;
                if (n === 0) {
                  if (nb === buf.length) {
                    ++c;
                    if (p.next) list.head = p.next;
                    else list.head = list.tail = null;
                  } else {
                    list.head = p;
                    p.data = buf.slice(nb);
                  }
                  break;
                }
                ++c;
              }
              list.length -= c;
              return ret;
            }
            function endReadable(stream) {
              var state = stream._readableState;
              if (state.length > 0)
                throw new Error('"endReadable()" called on non-empty stream');
              if (!state.endEmitted) {
                state.ended = true;
                processNextTick(endReadableNT, state, stream);
              }
            }
            function endReadableNT(state, stream) {
              if (!state.endEmitted && state.length === 0) {
                state.endEmitted = true;
                stream.readable = false;
                stream.emit('end');
              }
            }
            function forEach(xs, f) {
              for (var i = 0, l = xs.length; i < l; i++) {
                f(xs[i], i);
              }
            }
            function indexOf(xs, x) {
              for (var i = 0, l = xs.length; i < l; i++) {
                if (xs[i] === x) return i;
              }
              return -1;
            }
          }.call(
            this,
            require('_process'),
            typeof global !== 'undefined'
              ? global
              : typeof self !== 'undefined'
              ? self
              : typeof window !== 'undefined'
              ? window
              : {}
          ));
        },
        {
          './_stream_duplex': 236,
          './internal/streams/BufferList': 241,
          './internal/streams/destroy': 242,
          './internal/streams/stream': 243,
          _process: 223,
          'core-util-is': 185,
          events: 203,
          inherits: 207,
          isarray: 209,
          'process-nextick-args': 222,
          'safe-buffer': 460,
          'string_decoder/': 244,
          util: 155
        }
      ],
      239: [
        function(require, module, exports) {
          'use strict';
          module.exports = Transform;
          var Duplex = require('./_stream_duplex');
          var util = require('core-util-is');
          util.inherits = require('inherits');
          util.inherits(Transform, Duplex);
          function TransformState(stream) {
            this.afterTransform = function(er, data) {
              return afterTransform(stream, er, data);
            };
            this.needTransform = false;
            this.transforming = false;
            this.writecb = null;
            this.writechunk = null;
            this.writeencoding = null;
          }
          function afterTransform(stream, er, data) {
            var ts = stream._transformState;
            ts.transforming = false;
            var cb = ts.writecb;
            if (!cb) {
              return stream.emit(
                'error',
                new Error('write callback called multiple times')
              );
            }
            ts.writechunk = null;
            ts.writecb = null;
            if (data !== null && data !== undefined) stream.push(data);
            cb(er);
            var rs = stream._readableState;
            rs.reading = false;
            if (rs.needReadable || rs.length < rs.highWaterMark) {
              stream._read(rs.highWaterMark);
            }
          }
          function Transform(options) {
            if (!(this instanceof Transform)) return new Transform(options);
            Duplex.call(this, options);
            this._transformState = new TransformState(this);
            var stream = this;
            this._readableState.needReadable = true;
            this._readableState.sync = false;
            if (options) {
              if (typeof options.transform === 'function')
                this._transform = options.transform;
              if (typeof options.flush === 'function')
                this._flush = options.flush;
            }
            this.once('prefinish', function() {
              if (typeof this._flush === 'function')
                this._flush(function(er, data) {
                  done(stream, er, data);
                });
              else done(stream);
            });
          }
          Transform.prototype.push = function(chunk, encoding) {
            this._transformState.needTransform = false;
            return Duplex.prototype.push.call(this, chunk, encoding);
          };
          Transform.prototype._transform = function(chunk, encoding, cb) {
            throw new Error('_transform() is not implemented');
          };
          Transform.prototype._write = function(chunk, encoding, cb) {
            var ts = this._transformState;
            ts.writecb = cb;
            ts.writechunk = chunk;
            ts.writeencoding = encoding;
            if (!ts.transforming) {
              var rs = this._readableState;
              if (
                ts.needTransform ||
                rs.needReadable ||
                rs.length < rs.highWaterMark
              )
                this._read(rs.highWaterMark);
            }
          };
          Transform.prototype._read = function(n) {
            var ts = this._transformState;
            if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
              ts.transforming = true;
              this._transform(
                ts.writechunk,
                ts.writeencoding,
                ts.afterTransform
              );
            } else {
              ts.needTransform = true;
            }
          };
          Transform.prototype._destroy = function(err, cb) {
            var _this = this;
            Duplex.prototype._destroy.call(this, err, function(err2) {
              cb(err2);
              _this.emit('close');
            });
          };
          function done(stream, er, data) {
            if (er) return stream.emit('error', er);
            if (data !== null && data !== undefined) stream.push(data);
            var ws = stream._writableState;
            var ts = stream._transformState;
            if (ws.length)
              throw new Error('Calling transform done when ws.length != 0');
            if (ts.transforming)
              throw new Error('Calling transform done when still transforming');
            return stream.push(null);
          }
        },
        { './_stream_duplex': 236, 'core-util-is': 185, inherits: 207 }
      ],
      240: [
        function(require, module, exports) {
          (function(process, global) {
            'use strict';
            var processNextTick = require('process-nextick-args');
            module.exports = Writable;
            function WriteReq(chunk, encoding, cb) {
              this.chunk = chunk;
              this.encoding = encoding;
              this.callback = cb;
              this.next = null;
            }
            function CorkedRequest(state) {
              var _this = this;
              this.next = null;
              this.entry = null;
              this.finish = function() {
                onCorkedFinish(_this, state);
              };
            }
            var asyncWrite =
              !process.browser &&
              ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1
                ? setImmediate
                : processNextTick;
            var Duplex;
            Writable.WritableState = WritableState;
            var util = require('core-util-is');
            util.inherits = require('inherits');
            var internalUtil = { deprecate: require('util-deprecate') };
            var Stream = require('./internal/streams/stream');
            var Buffer = require('safe-buffer').Buffer;
            var OurUint8Array = global.Uint8Array || function() {};
            function _uint8ArrayToBuffer(chunk) {
              return Buffer.from(chunk);
            }
            function _isUint8Array(obj) {
              return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
            }
            var destroyImpl = require('./internal/streams/destroy');
            util.inherits(Writable, Stream);
            function nop() {}
            function WritableState(options, stream) {
              Duplex = Duplex || require('./_stream_duplex');
              options = options || {};
              this.objectMode = !!options.objectMode;
              if (stream instanceof Duplex)
                this.objectMode =
                  this.objectMode || !!options.writableObjectMode;
              var hwm = options.highWaterMark;
              var defaultHwm = this.objectMode ? 16 : 16 * 1024;
              this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
              this.highWaterMark = Math.floor(this.highWaterMark);
              this.finalCalled = false;
              this.needDrain = false;
              this.ending = false;
              this.ended = false;
              this.finished = false;
              this.destroyed = false;
              var noDecode = options.decodeStrings === false;
              this.decodeStrings = !noDecode;
              this.defaultEncoding = options.defaultEncoding || 'utf8';
              this.length = 0;
              this.writing = false;
              this.corked = 0;
              this.sync = true;
              this.bufferProcessing = false;
              this.onwrite = function(er) {
                onwrite(stream, er);
              };
              this.writecb = null;
              this.writelen = 0;
              this.bufferedRequest = null;
              this.lastBufferedRequest = null;
              this.pendingcb = 0;
              this.prefinished = false;
              this.errorEmitted = false;
              this.bufferedRequestCount = 0;
              this.corkedRequestsFree = new CorkedRequest(this);
            }
            WritableState.prototype.getBuffer = function getBuffer() {
              var current = this.bufferedRequest;
              var out = [];
              while (current) {
                out.push(current);
                current = current.next;
              }
              return out;
            };
            (function() {
              try {
                Object.defineProperty(WritableState.prototype, 'buffer', {
                  get: internalUtil.deprecate(
                    function() {
                      return this.getBuffer();
                    },
                    '_writableState.buffer is deprecated. Use _writableState.getBuffer ' +
                      'instead.',
                    'DEP0003'
                  )
                });
              } catch (_) {}
            })();
            var realHasInstance;
            if (
              typeof Symbol === 'function' &&
              Symbol.hasInstance &&
              typeof Function.prototype[Symbol.hasInstance] === 'function'
            ) {
              realHasInstance = Function.prototype[Symbol.hasInstance];
              Object.defineProperty(Writable, Symbol.hasInstance, {
                value: function(object) {
                  if (realHasInstance.call(this, object)) return true;
                  return (
                    object && object._writableState instanceof WritableState
                  );
                }
              });
            } else {
              realHasInstance = function(object) {
                return object instanceof this;
              };
            }
            function Writable(options) {
              Duplex = Duplex || require('./_stream_duplex');
              if (
                !realHasInstance.call(Writable, this) &&
                !(this instanceof Duplex)
              ) {
                return new Writable(options);
              }
              this._writableState = new WritableState(options, this);
              this.writable = true;
              if (options) {
                if (typeof options.write === 'function')
                  this._write = options.write;
                if (typeof options.writev === 'function')
                  this._writev = options.writev;
                if (typeof options.destroy === 'function')
                  this._destroy = options.destroy;
                if (typeof options.final === 'function')
                  this._final = options.final;
              }
              Stream.call(this);
            }
            Writable.prototype.pipe = function() {
              this.emit('error', new Error('Cannot pipe, not readable'));
            };
            function writeAfterEnd(stream, cb) {
              var er = new Error('write after end');
              stream.emit('error', er);
              processNextTick(cb, er);
            }
            function validChunk(stream, state, chunk, cb) {
              var valid = true;
              var er = false;
              if (chunk === null) {
                er = new TypeError('May not write null values to stream');
              } else if (
                typeof chunk !== 'string' &&
                chunk !== undefined &&
                !state.objectMode
              ) {
                er = new TypeError('Invalid non-string/buffer chunk');
              }
              if (er) {
                stream.emit('error', er);
                processNextTick(cb, er);
                valid = false;
              }
              return valid;
            }
            Writable.prototype.write = function(chunk, encoding, cb) {
              var state = this._writableState;
              var ret = false;
              var isBuf = _isUint8Array(chunk) && !state.objectMode;
              if (isBuf && !Buffer.isBuffer(chunk)) {
                chunk = _uint8ArrayToBuffer(chunk);
              }
              if (typeof encoding === 'function') {
                cb = encoding;
                encoding = null;
              }
              if (isBuf) encoding = 'buffer';
              else if (!encoding) encoding = state.defaultEncoding;
              if (typeof cb !== 'function') cb = nop;
              if (state.ended) writeAfterEnd(this, cb);
              else if (isBuf || validChunk(this, state, chunk, cb)) {
                state.pendingcb++;
                ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
              }
              return ret;
            };
            Writable.prototype.cork = function() {
              var state = this._writableState;
              state.corked++;
            };
            Writable.prototype.uncork = function() {
              var state = this._writableState;
              if (state.corked) {
                state.corked--;
                if (
                  !state.writing &&
                  !state.corked &&
                  !state.finished &&
                  !state.bufferProcessing &&
                  state.bufferedRequest
                )
                  clearBuffer(this, state);
              }
            };
            Writable.prototype.setDefaultEncoding = function setDefaultEncoding(
              encoding
            ) {
              if (typeof encoding === 'string')
                encoding = encoding.toLowerCase();
              if (
                !(
                  [
                    'hex',
                    'utf8',
                    'utf-8',
                    'ascii',
                    'binary',
                    'base64',
                    'ucs2',
                    'ucs-2',
                    'utf16le',
                    'utf-16le',
                    'raw'
                  ].indexOf((encoding + '').toLowerCase()) > -1
                )
              )
                throw new TypeError('Unknown encoding: ' + encoding);
              this._writableState.defaultEncoding = encoding;
              return this;
            };
            function decodeChunk(state, chunk, encoding) {
              if (
                !state.objectMode &&
                state.decodeStrings !== false &&
                typeof chunk === 'string'
              ) {
                chunk = Buffer.from(chunk, encoding);
              }
              return chunk;
            }
            function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
              if (!isBuf) {
                var newChunk = decodeChunk(state, chunk, encoding);
                if (chunk !== newChunk) {
                  isBuf = true;
                  encoding = 'buffer';
                  chunk = newChunk;
                }
              }
              var len = state.objectMode ? 1 : chunk.length;
              state.length += len;
              var ret = state.length < state.highWaterMark;
              if (!ret) state.needDrain = true;
              if (state.writing || state.corked) {
                var last = state.lastBufferedRequest;
                state.lastBufferedRequest = {
                  chunk: chunk,
                  encoding: encoding,
                  isBuf: isBuf,
                  callback: cb,
                  next: null
                };
                if (last) {
                  last.next = state.lastBufferedRequest;
                } else {
                  state.bufferedRequest = state.lastBufferedRequest;
                }
                state.bufferedRequestCount += 1;
              } else {
                doWrite(stream, state, false, len, chunk, encoding, cb);
              }
              return ret;
            }
            function doWrite(stream, state, writev, len, chunk, encoding, cb) {
              state.writelen = len;
              state.writecb = cb;
              state.writing = true;
              state.sync = true;
              if (writev) stream._writev(chunk, state.onwrite);
              else stream._write(chunk, encoding, state.onwrite);
              state.sync = false;
            }
            function onwriteError(stream, state, sync, er, cb) {
              --state.pendingcb;
              if (sync) {
                processNextTick(cb, er);
                processNextTick(finishMaybe, stream, state);
                stream._writableState.errorEmitted = true;
                stream.emit('error', er);
              } else {
                cb(er);
                stream._writableState.errorEmitted = true;
                stream.emit('error', er);
                finishMaybe(stream, state);
              }
            }
            function onwriteStateUpdate(state) {
              state.writing = false;
              state.writecb = null;
              state.length -= state.writelen;
              state.writelen = 0;
            }
            function onwrite(stream, er) {
              var state = stream._writableState;
              var sync = state.sync;
              var cb = state.writecb;
              onwriteStateUpdate(state);
              if (er) onwriteError(stream, state, sync, er, cb);
              else {
                var finished = needFinish(state);
                if (
                  !finished &&
                  !state.corked &&
                  !state.bufferProcessing &&
                  state.bufferedRequest
                ) {
                  clearBuffer(stream, state);
                }
                if (sync) {
                  asyncWrite(afterWrite, stream, state, finished, cb);
                } else {
                  afterWrite(stream, state, finished, cb);
                }
              }
            }
            function afterWrite(stream, state, finished, cb) {
              if (!finished) onwriteDrain(stream, state);
              state.pendingcb--;
              cb();
              finishMaybe(stream, state);
            }
            function onwriteDrain(stream, state) {
              if (state.length === 0 && state.needDrain) {
                state.needDrain = false;
                stream.emit('drain');
              }
            }
            function clearBuffer(stream, state) {
              state.bufferProcessing = true;
              var entry = state.bufferedRequest;
              if (stream._writev && entry && entry.next) {
                var l = state.bufferedRequestCount;
                var buffer = new Array(l);
                var holder = state.corkedRequestsFree;
                holder.entry = entry;
                var count = 0;
                var allBuffers = true;
                while (entry) {
                  buffer[count] = entry;
                  if (!entry.isBuf) allBuffers = false;
                  entry = entry.next;
                  count += 1;
                }
                buffer.allBuffers = allBuffers;
                doWrite(
                  stream,
                  state,
                  true,
                  state.length,
                  buffer,
                  '',
                  holder.finish
                );
                state.pendingcb++;
                state.lastBufferedRequest = null;
                if (holder.next) {
                  state.corkedRequestsFree = holder.next;
                  holder.next = null;
                } else {
                  state.corkedRequestsFree = new CorkedRequest(state);
                }
              } else {
                while (entry) {
                  var chunk = entry.chunk;
                  var encoding = entry.encoding;
                  var cb = entry.callback;
                  var len = state.objectMode ? 1 : chunk.length;
                  doWrite(stream, state, false, len, chunk, encoding, cb);
                  entry = entry.next;
                  if (state.writing) {
                    break;
                  }
                }
                if (entry === null) state.lastBufferedRequest = null;
              }
              state.bufferedRequestCount = 0;
              state.bufferedRequest = entry;
              state.bufferProcessing = false;
            }
            Writable.prototype._write = function(chunk, encoding, cb) {
              cb(new Error('_write() is not implemented'));
            };
            Writable.prototype._writev = null;
            Writable.prototype.end = function(chunk, encoding, cb) {
              var state = this._writableState;
              if (typeof chunk === 'function') {
                cb = chunk;
                chunk = null;
                encoding = null;
              } else if (typeof encoding === 'function') {
                cb = encoding;
                encoding = null;
              }
              if (chunk !== null && chunk !== undefined)
                this.write(chunk, encoding);
              if (state.corked) {
                state.corked = 1;
                this.uncork();
              }
              if (!state.ending && !state.finished)
                endWritable(this, state, cb);
            };
            function needFinish(state) {
              return (
                state.ending &&
                state.length === 0 &&
                state.bufferedRequest === null &&
                !state.finished &&
                !state.writing
              );
            }
            function callFinal(stream, state) {
              stream._final(function(err) {
                state.pendingcb--;
                if (err) {
                  stream.emit('error', err);
                }
                state.prefinished = true;
                stream.emit('prefinish');
                finishMaybe(stream, state);
              });
            }
            function prefinish(stream, state) {
              if (!state.prefinished && !state.finalCalled) {
                if (typeof stream._final === 'function') {
                  state.pendingcb++;
                  state.finalCalled = true;
                  processNextTick(callFinal, stream, state);
                } else {
                  state.prefinished = true;
                  stream.emit('prefinish');
                }
              }
            }
            function finishMaybe(stream, state) {
              var need = needFinish(state);
              if (need) {
                prefinish(stream, state);
                if (state.pendingcb === 0) {
                  state.finished = true;
                  stream.emit('finish');
                }
              }
              return need;
            }
            function endWritable(stream, state, cb) {
              state.ending = true;
              finishMaybe(stream, state);
              if (cb) {
                if (state.finished) processNextTick(cb);
                else stream.once('finish', cb);
              }
              state.ended = true;
              stream.writable = false;
            }
            function onCorkedFinish(corkReq, state, err) {
              var entry = corkReq.entry;
              corkReq.entry = null;
              while (entry) {
                var cb = entry.callback;
                state.pendingcb--;
                cb(err);
                entry = entry.next;
              }
              if (state.corkedRequestsFree) {
                state.corkedRequestsFree.next = corkReq;
              } else {
                state.corkedRequestsFree = corkReq;
              }
            }
            Object.defineProperty(Writable.prototype, 'destroyed', {
              get: function() {
                if (this._writableState === undefined) {
                  return false;
                }
                return this._writableState.destroyed;
              },
              set: function(value) {
                if (!this._writableState) {
                  return;
                }
                this._writableState.destroyed = value;
              }
            });
            Writable.prototype.destroy = destroyImpl.destroy;
            Writable.prototype._undestroy = destroyImpl.undestroy;
            Writable.prototype._destroy = function(err, cb) {
              this.end();
              cb(err);
            };
          }.call(
            this,
            require('_process'),
            typeof global !== 'undefined'
              ? global
              : typeof self !== 'undefined'
              ? self
              : typeof window !== 'undefined'
              ? window
              : {}
          ));
        },
        {
          './_stream_duplex': 236,
          './internal/streams/destroy': 242,
          './internal/streams/stream': 243,
          _process: 223,
          'core-util-is': 185,
          inherits: 207,
          'process-nextick-args': 222,
          'safe-buffer': 460,
          'util-deprecate': 262
        }
      ],
      241: [
        function(require, module, exports) {
          'use strict';
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          var Buffer = require('safe-buffer').Buffer;
          function copyBuffer(src, target, offset) {
            src.copy(target, offset);
          }
          module.exports = (function() {
            function BufferList() {
              _classCallCheck(this, BufferList);
              this.head = null;
              this.tail = null;
              this.length = 0;
            }
            BufferList.prototype.push = function push(v) {
              var entry = { data: v, next: null };
              if (this.length > 0) this.tail.next = entry;
              else this.head = entry;
              this.tail = entry;
              ++this.length;
            };
            BufferList.prototype.unshift = function unshift(v) {
              var entry = { data: v, next: this.head };
              if (this.length === 0) this.tail = entry;
              this.head = entry;
              ++this.length;
            };
            BufferList.prototype.shift = function shift() {
              if (this.length === 0) return;
              var ret = this.head.data;
              if (this.length === 1) this.head = this.tail = null;
              else this.head = this.head.next;
              --this.length;
              return ret;
            };
            BufferList.prototype.clear = function clear() {
              this.head = this.tail = null;
              this.length = 0;
            };
            BufferList.prototype.join = function join(s) {
              if (this.length === 0) return '';
              var p = this.head;
              var ret = '' + p.data;
              while ((p = p.next)) {
                ret += s + p.data;
              }
              return ret;
            };
            BufferList.prototype.concat = function concat(n) {
              if (this.length === 0) return Buffer.alloc(0);
              if (this.length === 1) return this.head.data;
              var ret = Buffer.allocUnsafe(n >>> 0);
              var p = this.head;
              var i = 0;
              while (p) {
                copyBuffer(p.data, ret, i);
                i += p.data.length;
                p = p.next;
              }
              return ret;
            };
            return BufferList;
          })();
        },
        { 'safe-buffer': 460 }
      ],
      242: [
        function(require, module, exports) {
          'use strict';
          var processNextTick = require('process-nextick-args');
          function destroy(err, cb) {
            var _this = this;
            var readableDestroyed =
              this._readableState && this._readableState.destroyed;
            var writableDestroyed =
              this._writableState && this._writableState.destroyed;
            if (readableDestroyed || writableDestroyed) {
              if (cb) {
                cb(err);
              } else if (
                err &&
                (!this._writableState || !this._writableState.errorEmitted)
              ) {
                processNextTick(emitErrorNT, this, err);
              }
              return;
            }
            if (this._readableState) {
              this._readableState.destroyed = true;
            }
            if (this._writableState) {
              this._writableState.destroyed = true;
            }
            this._destroy(err || null, function(err) {
              if (!cb && err) {
                processNextTick(emitErrorNT, _this, err);
                if (_this._writableState) {
                  _this._writableState.errorEmitted = true;
                }
              } else if (cb) {
                cb(err);
              }
            });
          }
          function undestroy() {
            if (this._readableState) {
              this._readableState.destroyed = false;
              this._readableState.reading = false;
              this._readableState.ended = false;
              this._readableState.endEmitted = false;
            }
            if (this._writableState) {
              this._writableState.destroyed = false;
              this._writableState.ended = false;
              this._writableState.ending = false;
              this._writableState.finished = false;
              this._writableState.errorEmitted = false;
            }
          }
          function emitErrorNT(self, err) {
            self.emit('error', err);
          }
          module.exports = { destroy: destroy, undestroy: undestroy };
        },
        { 'process-nextick-args': 222 }
      ],
      243: [
        function(require, module, exports) {
          module.exports = require('events').EventEmitter;
        },
        { events: 203 }
      ],
      244: [
        function(require, module, exports) {
          'use strict';
          var Buffer = require('safe-buffer').Buffer;
          var isEncoding =
            Buffer.isEncoding ||
            function(encoding) {
              encoding = '' + encoding;
              switch (encoding && encoding.toLowerCase()) {
                case 'hex':
                case 'utf8':
                case 'utf-8':
                case 'ascii':
                case 'binary':
                case 'base64':
                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                case 'raw':
                  return true;
                default:
                  return false;
              }
            };
          function _normalizeEncoding(enc) {
            if (!enc) return 'utf8';
            var retried;
            while (true) {
              switch (enc) {
                case 'utf8':
                case 'utf-8':
                  return 'utf8';
                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                  return 'utf16le';
                case 'latin1':
                case 'binary':
                  return 'latin1';
                case 'base64':
                case 'ascii':
                case 'hex':
                  return enc;
                default:
                  if (retried) return;
                  enc = ('' + enc).toLowerCase();
                  retried = true;
              }
            }
          }
          function normalizeEncoding(enc) {
            var nenc = _normalizeEncoding(enc);
            if (
              typeof nenc !== 'string' &&
              (Buffer.isEncoding === isEncoding || !isEncoding(enc))
            )
              throw new Error('Unknown encoding: ' + enc);
            return nenc || enc;
          }
          exports.StringDecoder = StringDecoder;
          function StringDecoder(encoding) {
            this.encoding = normalizeEncoding(encoding);
            var nb;
            switch (this.encoding) {
              case 'utf16le':
                this.text = utf16Text;
                this.end = utf16End;
                nb = 4;
                break;
              case 'utf8':
                this.fillLast = utf8FillLast;
                nb = 4;
                break;
              case 'base64':
                this.text = base64Text;
                this.end = base64End;
                nb = 3;
                break;
              default:
                this.write = simpleWrite;
                this.end = simpleEnd;
                return;
            }
            this.lastNeed = 0;
            this.lastTotal = 0;
            this.lastChar = Buffer.allocUnsafe(nb);
          }
          StringDecoder.prototype.write = function(buf) {
            if (buf.length === 0) return '';
            var r;
            var i;
            if (this.lastNeed) {
              r = this.fillLast(buf);
              if (r === undefined) return '';
              i = this.lastNeed;
              this.lastNeed = 0;
            } else {
              i = 0;
            }
            if (i < buf.length)
              return r ? r + this.text(buf, i) : this.text(buf, i);
            return r || '';
          };
          StringDecoder.prototype.end = utf8End;
          StringDecoder.prototype.text = utf8Text;
          StringDecoder.prototype.fillLast = function(buf) {
            if (this.lastNeed <= buf.length) {
              buf.copy(
                this.lastChar,
                this.lastTotal - this.lastNeed,
                0,
                this.lastNeed
              );
              return this.lastChar.toString(this.encoding, 0, this.lastTotal);
            }
            buf.copy(
              this.lastChar,
              this.lastTotal - this.lastNeed,
              0,
              buf.length
            );
            this.lastNeed -= buf.length;
          };
          function utf8CheckByte(byte) {
            if (byte <= 127) return 0;
            else if (byte >> 5 === 6) return 2;
            else if (byte >> 4 === 14) return 3;
            else if (byte >> 3 === 30) return 4;
            return -1;
          }
          function utf8CheckIncomplete(self, buf, i) {
            var j = buf.length - 1;
            if (j < i) return 0;
            var nb = utf8CheckByte(buf[j]);
            if (nb >= 0) {
              if (nb > 0) self.lastNeed = nb - 1;
              return nb;
            }
            if (--j < i) return 0;
            nb = utf8CheckByte(buf[j]);
            if (nb >= 0) {
              if (nb > 0) self.lastNeed = nb - 2;
              return nb;
            }
            if (--j < i) return 0;
            nb = utf8CheckByte(buf[j]);
            if (nb >= 0) {
              if (nb > 0) {
                if (nb === 2) nb = 0;
                else self.lastNeed = nb - 3;
              }
              return nb;
            }
            return 0;
          }
          function utf8CheckExtraBytes(self, buf, p) {
            if ((buf[0] & 192) !== 128) {
              self.lastNeed = 0;
              return '�'.repeat(p);
            }
            if (self.lastNeed > 1 && buf.length > 1) {
              if ((buf[1] & 192) !== 128) {
                self.lastNeed = 1;
                return '�'.repeat(p + 1);
              }
              if (self.lastNeed > 2 && buf.length > 2) {
                if ((buf[2] & 192) !== 128) {
                  self.lastNeed = 2;
                  return '�'.repeat(p + 2);
                }
              }
            }
          }
          function utf8FillLast(buf) {
            var p = this.lastTotal - this.lastNeed;
            var r = utf8CheckExtraBytes(this, buf, p);
            if (r !== undefined) return r;
            if (this.lastNeed <= buf.length) {
              buf.copy(this.lastChar, p, 0, this.lastNeed);
              return this.lastChar.toString(this.encoding, 0, this.lastTotal);
            }
            buf.copy(this.lastChar, p, 0, buf.length);
            this.lastNeed -= buf.length;
          }
          function utf8Text(buf, i) {
            var total = utf8CheckIncomplete(this, buf, i);
            if (!this.lastNeed) return buf.toString('utf8', i);
            this.lastTotal = total;
            var end = buf.length - (total - this.lastNeed);
            buf.copy(this.lastChar, 0, end);
            return buf.toString('utf8', i, end);
          }
          function utf8End(buf) {
            var r = buf && buf.length ? this.write(buf) : '';
            if (this.lastNeed)
              return r + '�'.repeat(this.lastTotal - this.lastNeed);
            return r;
          }
          function utf16Text(buf, i) {
            if ((buf.length - i) % 2 === 0) {
              var r = buf.toString('utf16le', i);
              if (r) {
                var c = r.charCodeAt(r.length - 1);
                if (c >= 55296 && c <= 56319) {
                  this.lastNeed = 2;
                  this.lastTotal = 4;
                  this.lastChar[0] = buf[buf.length - 2];
                  this.lastChar[1] = buf[buf.length - 1];
                  return r.slice(0, -1);
                }
              }
              return r;
            }
            this.lastNeed = 1;
            this.lastTotal = 2;
            this.lastChar[0] = buf[buf.length - 1];
            return buf.toString('utf16le', i, buf.length - 1);
          }
          function utf16End(buf) {
            var r = buf && buf.length ? this.write(buf) : '';
            if (this.lastNeed) {
              var end = this.lastTotal - this.lastNeed;
              return r + this.lastChar.toString('utf16le', 0, end);
            }
            return r;
          }
          function base64Text(buf, i) {
            var n = (buf.length - i) % 3;
            if (n === 0) return buf.toString('base64', i);
            this.lastNeed = 3 - n;
            this.lastTotal = 3;
            if (n === 1) {
              this.lastChar[0] = buf[buf.length - 1];
            } else {
              this.lastChar[0] = buf[buf.length - 2];
              this.lastChar[1] = buf[buf.length - 1];
            }
            return buf.toString('base64', i, buf.length - n);
          }
          function base64End(buf) {
            var r = buf && buf.length ? this.write(buf) : '';
            if (this.lastNeed)
              return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
            return r;
          }
          function simpleWrite(buf) {
            return buf.toString(this.encoding);
          }
          function simpleEnd(buf) {
            return buf && buf.length ? this.write(buf) : '';
          }
        },
        { 'safe-buffer': 460 }
      ],
      245: [
        function(require, module, exports) {
          module.exports = require('./readable').PassThrough;
        },
        { './readable': 246 }
      ],
      246: [
        function(require, module, exports) {
          exports = module.exports = require('./lib/_stream_readable.js');
          exports.Stream = exports;
          exports.Readable = exports;
          exports.Writable = require('./lib/_stream_writable.js');
          exports.Duplex = require('./lib/_stream_duplex.js');
          exports.Transform = require('./lib/_stream_transform.js');
          exports.PassThrough = require('./lib/_stream_passthrough.js');
        },
        {
          './lib/_stream_duplex.js': 236,
          './lib/_stream_passthrough.js': 237,
          './lib/_stream_readable.js': 238,
          './lib/_stream_transform.js': 239,
          './lib/_stream_writable.js': 240
        }
      ],
      247: [
        function(require, module, exports) {
          module.exports = require('./readable').Transform;
        },
        { './readable': 246 }
      ],
      248: [
        function(require, module, exports) {
          module.exports = require('./lib/_stream_writable.js');
        },
        { './lib/_stream_writable.js': 240 }
      ],
      249: [
        function(require, module, exports) {
          (function(Buffer) {
            'use strict';
            var inherits = require('inherits');
            var HashBase = require('hash-base');
            function RIPEMD160() {
              HashBase.call(this, 64);
              this._a = 1732584193;
              this._b = 4023233417;
              this._c = 2562383102;
              this._d = 271733878;
              this._e = 3285377520;
            }
            inherits(RIPEMD160, HashBase);
            RIPEMD160.prototype._update = function() {
              var m = new Array(16);
              for (var i = 0; i < 16; ++i)
                m[i] = this._block.readInt32LE(i * 4);
              var al = this._a;
              var bl = this._b;
              var cl = this._c;
              var dl = this._d;
              var el = this._e;
              al = fn1(al, bl, cl, dl, el, m[0], 0, 11);
              cl = rotl(cl, 10);
              el = fn1(el, al, bl, cl, dl, m[1], 0, 14);
              bl = rotl(bl, 10);
              dl = fn1(dl, el, al, bl, cl, m[2], 0, 15);
              al = rotl(al, 10);
              cl = fn1(cl, dl, el, al, bl, m[3], 0, 12);
              el = rotl(el, 10);
              bl = fn1(bl, cl, dl, el, al, m[4], 0, 5);
              dl = rotl(dl, 10);
              al = fn1(al, bl, cl, dl, el, m[5], 0, 8);
              cl = rotl(cl, 10);
              el = fn1(el, al, bl, cl, dl, m[6], 0, 7);
              bl = rotl(bl, 10);
              dl = fn1(dl, el, al, bl, cl, m[7], 0, 9);
              al = rotl(al, 10);
              cl = fn1(cl, dl, el, al, bl, m[8], 0, 11);
              el = rotl(el, 10);
              bl = fn1(bl, cl, dl, el, al, m[9], 0, 13);
              dl = rotl(dl, 10);
              al = fn1(al, bl, cl, dl, el, m[10], 0, 14);
              cl = rotl(cl, 10);
              el = fn1(el, al, bl, cl, dl, m[11], 0, 15);
              bl = rotl(bl, 10);
              dl = fn1(dl, el, al, bl, cl, m[12], 0, 6);
              al = rotl(al, 10);
              cl = fn1(cl, dl, el, al, bl, m[13], 0, 7);
              el = rotl(el, 10);
              bl = fn1(bl, cl, dl, el, al, m[14], 0, 9);
              dl = rotl(dl, 10);
              al = fn1(al, bl, cl, dl, el, m[15], 0, 8);
              cl = rotl(cl, 10);
              el = fn2(el, al, bl, cl, dl, m[7], 1518500249, 7);
              bl = rotl(bl, 10);
              dl = fn2(dl, el, al, bl, cl, m[4], 1518500249, 6);
              al = rotl(al, 10);
              cl = fn2(cl, dl, el, al, bl, m[13], 1518500249, 8);
              el = rotl(el, 10);
              bl = fn2(bl, cl, dl, el, al, m[1], 1518500249, 13);
              dl = rotl(dl, 10);
              al = fn2(al, bl, cl, dl, el, m[10], 1518500249, 11);
              cl = rotl(cl, 10);
              el = fn2(el, al, bl, cl, dl, m[6], 1518500249, 9);
              bl = rotl(bl, 10);
              dl = fn2(dl, el, al, bl, cl, m[15], 1518500249, 7);
              al = rotl(al, 10);
              cl = fn2(cl, dl, el, al, bl, m[3], 1518500249, 15);
              el = rotl(el, 10);
              bl = fn2(bl, cl, dl, el, al, m[12], 1518500249, 7);
              dl = rotl(dl, 10);
              al = fn2(al, bl, cl, dl, el, m[0], 1518500249, 12);
              cl = rotl(cl, 10);
              el = fn2(el, al, bl, cl, dl, m[9], 1518500249, 15);
              bl = rotl(bl, 10);
              dl = fn2(dl, el, al, bl, cl, m[5], 1518500249, 9);
              al = rotl(al, 10);
              cl = fn2(cl, dl, el, al, bl, m[2], 1518500249, 11);
              el = rotl(el, 10);
              bl = fn2(bl, cl, dl, el, al, m[14], 1518500249, 7);
              dl = rotl(dl, 10);
              al = fn2(al, bl, cl, dl, el, m[11], 1518500249, 13);
              cl = rotl(cl, 10);
              el = fn2(el, al, bl, cl, dl, m[8], 1518500249, 12);
              bl = rotl(bl, 10);
              dl = fn3(dl, el, al, bl, cl, m[3], 1859775393, 11);
              al = rotl(al, 10);
              cl = fn3(cl, dl, el, al, bl, m[10], 1859775393, 13);
              el = rotl(el, 10);
              bl = fn3(bl, cl, dl, el, al, m[14], 1859775393, 6);
              dl = rotl(dl, 10);
              al = fn3(al, bl, cl, dl, el, m[4], 1859775393, 7);
              cl = rotl(cl, 10);
              el = fn3(el, al, bl, cl, dl, m[9], 1859775393, 14);
              bl = rotl(bl, 10);
              dl = fn3(dl, el, al, bl, cl, m[15], 1859775393, 9);
              al = rotl(al, 10);
              cl = fn3(cl, dl, el, al, bl, m[8], 1859775393, 13);
              el = rotl(el, 10);
              bl = fn3(bl, cl, dl, el, al, m[1], 1859775393, 15);
              dl = rotl(dl, 10);
              al = fn3(al, bl, cl, dl, el, m[2], 1859775393, 14);
              cl = rotl(cl, 10);
              el = fn3(el, al, bl, cl, dl, m[7], 1859775393, 8);
              bl = rotl(bl, 10);
              dl = fn3(dl, el, al, bl, cl, m[0], 1859775393, 13);
              al = rotl(al, 10);
              cl = fn3(cl, dl, el, al, bl, m[6], 1859775393, 6);
              el = rotl(el, 10);
              bl = fn3(bl, cl, dl, el, al, m[13], 1859775393, 5);
              dl = rotl(dl, 10);
              al = fn3(al, bl, cl, dl, el, m[11], 1859775393, 12);
              cl = rotl(cl, 10);
              el = fn3(el, al, bl, cl, dl, m[5], 1859775393, 7);
              bl = rotl(bl, 10);
              dl = fn3(dl, el, al, bl, cl, m[12], 1859775393, 5);
              al = rotl(al, 10);
              cl = fn4(cl, dl, el, al, bl, m[1], 2400959708, 11);
              el = rotl(el, 10);
              bl = fn4(bl, cl, dl, el, al, m[9], 2400959708, 12);
              dl = rotl(dl, 10);
              al = fn4(al, bl, cl, dl, el, m[11], 2400959708, 14);
              cl = rotl(cl, 10);
              el = fn4(el, al, bl, cl, dl, m[10], 2400959708, 15);
              bl = rotl(bl, 10);
              dl = fn4(dl, el, al, bl, cl, m[0], 2400959708, 14);
              al = rotl(al, 10);
              cl = fn4(cl, dl, el, al, bl, m[8], 2400959708, 15);
              el = rotl(el, 10);
              bl = fn4(bl, cl, dl, el, al, m[12], 2400959708, 9);
              dl = rotl(dl, 10);
              al = fn4(al, bl, cl, dl, el, m[4], 2400959708, 8);
              cl = rotl(cl, 10);
              el = fn4(el, al, bl, cl, dl, m[13], 2400959708, 9);
              bl = rotl(bl, 10);
              dl = fn4(dl, el, al, bl, cl, m[3], 2400959708, 14);
              al = rotl(al, 10);
              cl = fn4(cl, dl, el, al, bl, m[7], 2400959708, 5);
              el = rotl(el, 10);
              bl = fn4(bl, cl, dl, el, al, m[15], 2400959708, 6);
              dl = rotl(dl, 10);
              al = fn4(al, bl, cl, dl, el, m[14], 2400959708, 8);
              cl = rotl(cl, 10);
              el = fn4(el, al, bl, cl, dl, m[5], 2400959708, 6);
              bl = rotl(bl, 10);
              dl = fn4(dl, el, al, bl, cl, m[6], 2400959708, 5);
              al = rotl(al, 10);
              cl = fn4(cl, dl, el, al, bl, m[2], 2400959708, 12);
              el = rotl(el, 10);
              bl = fn5(bl, cl, dl, el, al, m[4], 2840853838, 9);
              dl = rotl(dl, 10);
              al = fn5(al, bl, cl, dl, el, m[0], 2840853838, 15);
              cl = rotl(cl, 10);
              el = fn5(el, al, bl, cl, dl, m[5], 2840853838, 5);
              bl = rotl(bl, 10);
              dl = fn5(dl, el, al, bl, cl, m[9], 2840853838, 11);
              al = rotl(al, 10);
              cl = fn5(cl, dl, el, al, bl, m[7], 2840853838, 6);
              el = rotl(el, 10);
              bl = fn5(bl, cl, dl, el, al, m[12], 2840853838, 8);
              dl = rotl(dl, 10);
              al = fn5(al, bl, cl, dl, el, m[2], 2840853838, 13);
              cl = rotl(cl, 10);
              el = fn5(el, al, bl, cl, dl, m[10], 2840853838, 12);
              bl = rotl(bl, 10);
              dl = fn5(dl, el, al, bl, cl, m[14], 2840853838, 5);
              al = rotl(al, 10);
              cl = fn5(cl, dl, el, al, bl, m[1], 2840853838, 12);
              el = rotl(el, 10);
              bl = fn5(bl, cl, dl, el, al, m[3], 2840853838, 13);
              dl = rotl(dl, 10);
              al = fn5(al, bl, cl, dl, el, m[8], 2840853838, 14);
              cl = rotl(cl, 10);
              el = fn5(el, al, bl, cl, dl, m[11], 2840853838, 11);
              bl = rotl(bl, 10);
              dl = fn5(dl, el, al, bl, cl, m[6], 2840853838, 8);
              al = rotl(al, 10);
              cl = fn5(cl, dl, el, al, bl, m[15], 2840853838, 5);
              el = rotl(el, 10);
              bl = fn5(bl, cl, dl, el, al, m[13], 2840853838, 6);
              dl = rotl(dl, 10);
              var ar = this._a;
              var br = this._b;
              var cr = this._c;
              var dr = this._d;
              var er = this._e;
              ar = fn5(ar, br, cr, dr, er, m[5], 1352829926, 8);
              cr = rotl(cr, 10);
              er = fn5(er, ar, br, cr, dr, m[14], 1352829926, 9);
              br = rotl(br, 10);
              dr = fn5(dr, er, ar, br, cr, m[7], 1352829926, 9);
              ar = rotl(ar, 10);
              cr = fn5(cr, dr, er, ar, br, m[0], 1352829926, 11);
              er = rotl(er, 10);
              br = fn5(br, cr, dr, er, ar, m[9], 1352829926, 13);
              dr = rotl(dr, 10);
              ar = fn5(ar, br, cr, dr, er, m[2], 1352829926, 15);
              cr = rotl(cr, 10);
              er = fn5(er, ar, br, cr, dr, m[11], 1352829926, 15);
              br = rotl(br, 10);
              dr = fn5(dr, er, ar, br, cr, m[4], 1352829926, 5);
              ar = rotl(ar, 10);
              cr = fn5(cr, dr, er, ar, br, m[13], 1352829926, 7);
              er = rotl(er, 10);
              br = fn5(br, cr, dr, er, ar, m[6], 1352829926, 7);
              dr = rotl(dr, 10);
              ar = fn5(ar, br, cr, dr, er, m[15], 1352829926, 8);
              cr = rotl(cr, 10);
              er = fn5(er, ar, br, cr, dr, m[8], 1352829926, 11);
              br = rotl(br, 10);
              dr = fn5(dr, er, ar, br, cr, m[1], 1352829926, 14);
              ar = rotl(ar, 10);
              cr = fn5(cr, dr, er, ar, br, m[10], 1352829926, 14);
              er = rotl(er, 10);
              br = fn5(br, cr, dr, er, ar, m[3], 1352829926, 12);
              dr = rotl(dr, 10);
              ar = fn5(ar, br, cr, dr, er, m[12], 1352829926, 6);
              cr = rotl(cr, 10);
              er = fn4(er, ar, br, cr, dr, m[6], 1548603684, 9);
              br = rotl(br, 10);
              dr = fn4(dr, er, ar, br, cr, m[11], 1548603684, 13);
              ar = rotl(ar, 10);
              cr = fn4(cr, dr, er, ar, br, m[3], 1548603684, 15);
              er = rotl(er, 10);
              br = fn4(br, cr, dr, er, ar, m[7], 1548603684, 7);
              dr = rotl(dr, 10);
              ar = fn4(ar, br, cr, dr, er, m[0], 1548603684, 12);
              cr = rotl(cr, 10);
              er = fn4(er, ar, br, cr, dr, m[13], 1548603684, 8);
              br = rotl(br, 10);
              dr = fn4(dr, er, ar, br, cr, m[5], 1548603684, 9);
              ar = rotl(ar, 10);
              cr = fn4(cr, dr, er, ar, br, m[10], 1548603684, 11);
              er = rotl(er, 10);
              br = fn4(br, cr, dr, er, ar, m[14], 1548603684, 7);
              dr = rotl(dr, 10);
              ar = fn4(ar, br, cr, dr, er, m[15], 1548603684, 7);
              cr = rotl(cr, 10);
              er = fn4(er, ar, br, cr, dr, m[8], 1548603684, 12);
              br = rotl(br, 10);
              dr = fn4(dr, er, ar, br, cr, m[12], 1548603684, 7);
              ar = rotl(ar, 10);
              cr = fn4(cr, dr, er, ar, br, m[4], 1548603684, 6);
              er = rotl(er, 10);
              br = fn4(br, cr, dr, er, ar, m[9], 1548603684, 15);
              dr = rotl(dr, 10);
              ar = fn4(ar, br, cr, dr, er, m[1], 1548603684, 13);
              cr = rotl(cr, 10);
              er = fn4(er, ar, br, cr, dr, m[2], 1548603684, 11);
              br = rotl(br, 10);
              dr = fn3(dr, er, ar, br, cr, m[15], 1836072691, 9);
              ar = rotl(ar, 10);
              cr = fn3(cr, dr, er, ar, br, m[5], 1836072691, 7);
              er = rotl(er, 10);
              br = fn3(br, cr, dr, er, ar, m[1], 1836072691, 15);
              dr = rotl(dr, 10);
              ar = fn3(ar, br, cr, dr, er, m[3], 1836072691, 11);
              cr = rotl(cr, 10);
              er = fn3(er, ar, br, cr, dr, m[7], 1836072691, 8);
              br = rotl(br, 10);
              dr = fn3(dr, er, ar, br, cr, m[14], 1836072691, 6);
              ar = rotl(ar, 10);
              cr = fn3(cr, dr, er, ar, br, m[6], 1836072691, 6);
              er = rotl(er, 10);
              br = fn3(br, cr, dr, er, ar, m[9], 1836072691, 14);
              dr = rotl(dr, 10);
              ar = fn3(ar, br, cr, dr, er, m[11], 1836072691, 12);
              cr = rotl(cr, 10);
              er = fn3(er, ar, br, cr, dr, m[8], 1836072691, 13);
              br = rotl(br, 10);
              dr = fn3(dr, er, ar, br, cr, m[12], 1836072691, 5);
              ar = rotl(ar, 10);
              cr = fn3(cr, dr, er, ar, br, m[2], 1836072691, 14);
              er = rotl(er, 10);
              br = fn3(br, cr, dr, er, ar, m[10], 1836072691, 13);
              dr = rotl(dr, 10);
              ar = fn3(ar, br, cr, dr, er, m[0], 1836072691, 13);
              cr = rotl(cr, 10);
              er = fn3(er, ar, br, cr, dr, m[4], 1836072691, 7);
              br = rotl(br, 10);
              dr = fn3(dr, er, ar, br, cr, m[13], 1836072691, 5);
              ar = rotl(ar, 10);
              cr = fn2(cr, dr, er, ar, br, m[8], 2053994217, 15);
              er = rotl(er, 10);
              br = fn2(br, cr, dr, er, ar, m[6], 2053994217, 5);
              dr = rotl(dr, 10);
              ar = fn2(ar, br, cr, dr, er, m[4], 2053994217, 8);
              cr = rotl(cr, 10);
              er = fn2(er, ar, br, cr, dr, m[1], 2053994217, 11);
              br = rotl(br, 10);
              dr = fn2(dr, er, ar, br, cr, m[3], 2053994217, 14);
              ar = rotl(ar, 10);
              cr = fn2(cr, dr, er, ar, br, m[11], 2053994217, 14);
              er = rotl(er, 10);
              br = fn2(br, cr, dr, er, ar, m[15], 2053994217, 6);
              dr = rotl(dr, 10);
              ar = fn2(ar, br, cr, dr, er, m[0], 2053994217, 14);
              cr = rotl(cr, 10);
              er = fn2(er, ar, br, cr, dr, m[5], 2053994217, 6);
              br = rotl(br, 10);
              dr = fn2(dr, er, ar, br, cr, m[12], 2053994217, 9);
              ar = rotl(ar, 10);
              cr = fn2(cr, dr, er, ar, br, m[2], 2053994217, 12);
              er = rotl(er, 10);
              br = fn2(br, cr, dr, er, ar, m[13], 2053994217, 9);
              dr = rotl(dr, 10);
              ar = fn2(ar, br, cr, dr, er, m[9], 2053994217, 12);
              cr = rotl(cr, 10);
              er = fn2(er, ar, br, cr, dr, m[7], 2053994217, 5);
              br = rotl(br, 10);
              dr = fn2(dr, er, ar, br, cr, m[10], 2053994217, 15);
              ar = rotl(ar, 10);
              cr = fn2(cr, dr, er, ar, br, m[14], 2053994217, 8);
              er = rotl(er, 10);
              br = fn1(br, cr, dr, er, ar, m[12], 0, 8);
              dr = rotl(dr, 10);
              ar = fn1(ar, br, cr, dr, er, m[15], 0, 5);
              cr = rotl(cr, 10);
              er = fn1(er, ar, br, cr, dr, m[10], 0, 12);
              br = rotl(br, 10);
              dr = fn1(dr, er, ar, br, cr, m[4], 0, 9);
              ar = rotl(ar, 10);
              cr = fn1(cr, dr, er, ar, br, m[1], 0, 12);
              er = rotl(er, 10);
              br = fn1(br, cr, dr, er, ar, m[5], 0, 5);
              dr = rotl(dr, 10);
              ar = fn1(ar, br, cr, dr, er, m[8], 0, 14);
              cr = rotl(cr, 10);
              er = fn1(er, ar, br, cr, dr, m[7], 0, 6);
              br = rotl(br, 10);
              dr = fn1(dr, er, ar, br, cr, m[6], 0, 8);
              ar = rotl(ar, 10);
              cr = fn1(cr, dr, er, ar, br, m[2], 0, 13);
              er = rotl(er, 10);
              br = fn1(br, cr, dr, er, ar, m[13], 0, 6);
              dr = rotl(dr, 10);
              ar = fn1(ar, br, cr, dr, er, m[14], 0, 5);
              cr = rotl(cr, 10);
              er = fn1(er, ar, br, cr, dr, m[0], 0, 15);
              br = rotl(br, 10);
              dr = fn1(dr, er, ar, br, cr, m[3], 0, 13);
              ar = rotl(ar, 10);
              cr = fn1(cr, dr, er, ar, br, m[9], 0, 11);
              er = rotl(er, 10);
              br = fn1(br, cr, dr, er, ar, m[11], 0, 11);
              dr = rotl(dr, 10);
              var t = (this._b + cl + dr) | 0;
              this._b = (this._c + dl + er) | 0;
              this._c = (this._d + el + ar) | 0;
              this._d = (this._e + al + br) | 0;
              this._e = (this._a + bl + cr) | 0;
              this._a = t;
            };
            RIPEMD160.prototype._digest = function() {
              this._block[this._blockOffset++] = 128;
              if (this._blockOffset > 56) {
                this._block.fill(0, this._blockOffset, 64);
                this._update();
                this._blockOffset = 0;
              }
              this._block.fill(0, this._blockOffset, 56);
              this._block.writeUInt32LE(this._length[0], 56);
              this._block.writeUInt32LE(this._length[1], 60);
              this._update();
              var buffer = new Buffer(20);
              buffer.writeInt32LE(this._a, 0);
              buffer.writeInt32LE(this._b, 4);
              buffer.writeInt32LE(this._c, 8);
              buffer.writeInt32LE(this._d, 12);
              buffer.writeInt32LE(this._e, 16);
              return buffer;
            };
            function rotl(x, n) {
              return (x << n) | (x >>> (32 - n));
            }
            function fn1(a, b, c, d, e, m, k, s) {
              return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + e) | 0;
            }
            function fn2(a, b, c, d, e, m, k, s) {
              return (rotl((a + ((b & c) | (~b & d)) + m + k) | 0, s) + e) | 0;
            }
            function fn3(a, b, c, d, e, m, k, s) {
              return (rotl((a + ((b | ~c) ^ d) + m + k) | 0, s) + e) | 0;
            }
            function fn4(a, b, c, d, e, m, k, s) {
              return (rotl((a + ((b & d) | (c & ~d)) + m + k) | 0, s) + e) | 0;
            }
            function fn5(a, b, c, d, e, m, k, s) {
              return (rotl((a + (b ^ (c | ~d)) + m + k) | 0, s) + e) | 0;
            }
            module.exports = RIPEMD160;
          }.call(this, require('buffer').Buffer));
        },
        { buffer: 183, 'hash-base': 352, inherits: 207 }
      ],
      250: [
        function(require, module, exports) {
          var Buffer = require('safe-buffer').Buffer;
          function Hash(blockSize, finalSize) {
            this._block = Buffer.alloc(blockSize);
            this._finalSize = finalSize;
            this._blockSize = blockSize;
            this._len = 0;
          }
          Hash.prototype.update = function(data, enc) {
            if (typeof data === 'string') {
              enc = enc || 'utf8';
              data = Buffer.from(data, enc);
            }
            var block = this._block;
            var blockSize = this._blockSize;
            var length = data.length;
            var accum = this._len;
            for (var offset = 0; offset < length; ) {
              var assigned = accum % blockSize;
              var remainder = Math.min(length - offset, blockSize - assigned);
              for (var i = 0; i < remainder; i++) {
                block[assigned + i] = data[offset + i];
              }
              accum += remainder;
              offset += remainder;
              if (accum % blockSize === 0) {
                this._update(block);
              }
            }
            this._len += length;
            return this;
          };
          Hash.prototype.digest = function(enc) {
            var rem = this._len % this._blockSize;
            this._block[rem] = 128;
            this._block.fill(0, rem + 1);
            if (rem >= this._finalSize) {
              this._update(this._block);
              this._block.fill(0);
            }
            var bits = this._len * 8;
            if (bits <= 4294967295) {
              this._block.writeUInt32BE(bits, this._blockSize - 4);
            } else {
              var lowBits = bits & 4294967295;
              var highBits = (bits - lowBits) / 4294967296;
              this._block.writeUInt32BE(highBits, this._blockSize - 8);
              this._block.writeUInt32BE(lowBits, this._blockSize - 4);
            }
            this._update(this._block);
            var hash = this._hash();
            return enc ? hash.toString(enc) : hash;
          };
          Hash.prototype._update = function() {
            throw new Error('_update must be implemented by subclass');
          };
          module.exports = Hash;
        },
        { 'safe-buffer': 460 }
      ],
      251: [
        function(require, module, exports) {
          var exports = (module.exports = function SHA(algorithm) {
            algorithm = algorithm.toLowerCase();
            var Algorithm = exports[algorithm];
            if (!Algorithm)
              throw new Error(
                algorithm + ' is not supported (we accept pull requests)'
              );
            return new Algorithm();
          });
          exports.sha = require('./sha');
          exports.sha1 = require('./sha1');
          exports.sha224 = require('./sha224');
          exports.sha256 = require('./sha256');
          exports.sha384 = require('./sha384');
          exports.sha512 = require('./sha512');
        },
        {
          './sha': 252,
          './sha1': 253,
          './sha224': 254,
          './sha256': 255,
          './sha384': 256,
          './sha512': 257
        }
      ],
      252: [
        function(require, module, exports) {
          var inherits = require('inherits');
          var Hash = require('./hash');
          var Buffer = require('safe-buffer').Buffer;
          var K = [1518500249, 1859775393, 2400959708 | 0, 3395469782 | 0];
          var W = new Array(80);
          function Sha() {
            this.init();
            this._w = W;
            Hash.call(this, 64, 56);
          }
          inherits(Sha, Hash);
          Sha.prototype.init = function() {
            this._a = 1732584193;
            this._b = 4023233417;
            this._c = 2562383102;
            this._d = 271733878;
            this._e = 3285377520;
            return this;
          };
          function rotl5(num) {
            return (num << 5) | (num >>> 27);
          }
          function rotl30(num) {
            return (num << 30) | (num >>> 2);
          }
          function ft(s, b, c, d) {
            if (s === 0) return (b & c) | (~b & d);
            if (s === 2) return (b & c) | (b & d) | (c & d);
            return b ^ c ^ d;
          }
          Sha.prototype._update = function(M) {
            var W = this._w;
            var a = this._a | 0;
            var b = this._b | 0;
            var c = this._c | 0;
            var d = this._d | 0;
            var e = this._e | 0;
            for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);
            for (; i < 80; ++i)
              W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
            for (var j = 0; j < 80; ++j) {
              var s = ~~(j / 20);
              var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0;
              e = d;
              d = c;
              c = rotl30(b);
              b = a;
              a = t;
            }
            this._a = (a + this._a) | 0;
            this._b = (b + this._b) | 0;
            this._c = (c + this._c) | 0;
            this._d = (d + this._d) | 0;
            this._e = (e + this._e) | 0;
          };
          Sha.prototype._hash = function() {
            var H = Buffer.allocUnsafe(20);
            H.writeInt32BE(this._a | 0, 0);
            H.writeInt32BE(this._b | 0, 4);
            H.writeInt32BE(this._c | 0, 8);
            H.writeInt32BE(this._d | 0, 12);
            H.writeInt32BE(this._e | 0, 16);
            return H;
          };
          module.exports = Sha;
        },
        { './hash': 250, inherits: 207, 'safe-buffer': 460 }
      ],
      253: [
        function(require, module, exports) {
          var inherits = require('inherits');
          var Hash = require('./hash');
          var Buffer = require('safe-buffer').Buffer;
          var K = [1518500249, 1859775393, 2400959708 | 0, 3395469782 | 0];
          var W = new Array(80);
          function Sha1() {
            this.init();
            this._w = W;
            Hash.call(this, 64, 56);
          }
          inherits(Sha1, Hash);
          Sha1.prototype.init = function() {
            this._a = 1732584193;
            this._b = 4023233417;
            this._c = 2562383102;
            this._d = 271733878;
            this._e = 3285377520;
            return this;
          };
          function rotl1(num) {
            return (num << 1) | (num >>> 31);
          }
          function rotl5(num) {
            return (num << 5) | (num >>> 27);
          }
          function rotl30(num) {
            return (num << 30) | (num >>> 2);
          }
          function ft(s, b, c, d) {
            if (s === 0) return (b & c) | (~b & d);
            if (s === 2) return (b & c) | (b & d) | (c & d);
            return b ^ c ^ d;
          }
          Sha1.prototype._update = function(M) {
            var W = this._w;
            var a = this._a | 0;
            var b = this._b | 0;
            var c = this._c | 0;
            var d = this._d | 0;
            var e = this._e | 0;
            for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);
            for (; i < 80; ++i)
              W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]);
            for (var j = 0; j < 80; ++j) {
              var s = ~~(j / 20);
              var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0;
              e = d;
              d = c;
              c = rotl30(b);
              b = a;
              a = t;
            }
            this._a = (a + this._a) | 0;
            this._b = (b + this._b) | 0;
            this._c = (c + this._c) | 0;
            this._d = (d + this._d) | 0;
            this._e = (e + this._e) | 0;
          };
          Sha1.prototype._hash = function() {
            var H = Buffer.allocUnsafe(20);
            H.writeInt32BE(this._a | 0, 0);
            H.writeInt32BE(this._b | 0, 4);
            H.writeInt32BE(this._c | 0, 8);
            H.writeInt32BE(this._d | 0, 12);
            H.writeInt32BE(this._e | 0, 16);
            return H;
          };
          module.exports = Sha1;
        },
        { './hash': 250, inherits: 207, 'safe-buffer': 460 }
      ],
      254: [
        function(require, module, exports) {
          var inherits = require('inherits');
          var Sha256 = require('./sha256');
          var Hash = require('./hash');
          var Buffer = require('safe-buffer').Buffer;
          var W = new Array(64);
          function Sha224() {
            this.init();
            this._w = W;
            Hash.call(this, 64, 56);
          }
          inherits(Sha224, Sha256);
          Sha224.prototype.init = function() {
            this._a = 3238371032;
            this._b = 914150663;
            this._c = 812702999;
            this._d = 4144912697;
            this._e = 4290775857;
            this._f = 1750603025;
            this._g = 1694076839;
            this._h = 3204075428;
            return this;
          };
          Sha224.prototype._hash = function() {
            var H = Buffer.allocUnsafe(28);
            H.writeInt32BE(this._a, 0);
            H.writeInt32BE(this._b, 4);
            H.writeInt32BE(this._c, 8);
            H.writeInt32BE(this._d, 12);
            H.writeInt32BE(this._e, 16);
            H.writeInt32BE(this._f, 20);
            H.writeInt32BE(this._g, 24);
            return H;
          };
          module.exports = Sha224;
        },
        { './hash': 250, './sha256': 255, inherits: 207, 'safe-buffer': 460 }
      ],
      255: [
        function(require, module, exports) {
          var inherits = require('inherits');
          var Hash = require('./hash');
          var Buffer = require('safe-buffer').Buffer;
          var K = [
            1116352408,
            1899447441,
            3049323471,
            3921009573,
            961987163,
            1508970993,
            2453635748,
            2870763221,
            3624381080,
            310598401,
            607225278,
            1426881987,
            1925078388,
            2162078206,
            2614888103,
            3248222580,
            3835390401,
            4022224774,
            264347078,
            604807628,
            770255983,
            1249150122,
            1555081692,
            1996064986,
            2554220882,
            2821834349,
            2952996808,
            3210313671,
            3336571891,
            3584528711,
            113926993,
            338241895,
            666307205,
            773529912,
            1294757372,
            1396182291,
            1695183700,
            1986661051,
            2177026350,
            2456956037,
            2730485921,
            2820302411,
            3259730800,
            3345764771,
            3516065817,
            3600352804,
            4094571909,
            275423344,
            430227734,
            506948616,
            659060556,
            883997877,
            958139571,
            1322822218,
            1537002063,
            1747873779,
            1955562222,
            2024104815,
            2227730452,
            2361852424,
            2428436474,
            2756734187,
            3204031479,
            3329325298
          ];
          var W = new Array(64);
          function Sha256() {
            this.init();
            this._w = W;
            Hash.call(this, 64, 56);
          }
          inherits(Sha256, Hash);
          Sha256.prototype.init = function() {
            this._a = 1779033703;
            this._b = 3144134277;
            this._c = 1013904242;
            this._d = 2773480762;
            this._e = 1359893119;
            this._f = 2600822924;
            this._g = 528734635;
            this._h = 1541459225;
            return this;
          };
          function ch(x, y, z) {
            return z ^ (x & (y ^ z));
          }
          function maj(x, y, z) {
            return (x & y) | (z & (x | y));
          }
          function sigma0(x) {
            return (
              ((x >>> 2) | (x << 30)) ^
              ((x >>> 13) | (x << 19)) ^
              ((x >>> 22) | (x << 10))
            );
          }
          function sigma1(x) {
            return (
              ((x >>> 6) | (x << 26)) ^
              ((x >>> 11) | (x << 21)) ^
              ((x >>> 25) | (x << 7))
            );
          }
          function gamma0(x) {
            return (
              ((x >>> 7) | (x << 25)) ^ ((x >>> 18) | (x << 14)) ^ (x >>> 3)
            );
          }
          function gamma1(x) {
            return (
              ((x >>> 17) | (x << 15)) ^ ((x >>> 19) | (x << 13)) ^ (x >>> 10)
            );
          }
          Sha256.prototype._update = function(M) {
            var W = this._w;
            var a = this._a | 0;
            var b = this._b | 0;
            var c = this._c | 0;
            var d = this._d | 0;
            var e = this._e | 0;
            var f = this._f | 0;
            var g = this._g | 0;
            var h = this._h | 0;
            for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);
            for (; i < 64; ++i)
              W[i] =
                (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) |
                0;
            for (var j = 0; j < 64; ++j) {
              var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0;
              var T2 = (sigma0(a) + maj(a, b, c)) | 0;
              h = g;
              g = f;
              f = e;
              e = (d + T1) | 0;
              d = c;
              c = b;
              b = a;
              a = (T1 + T2) | 0;
            }
            this._a = (a + this._a) | 0;
            this._b = (b + this._b) | 0;
            this._c = (c + this._c) | 0;
            this._d = (d + this._d) | 0;
            this._e = (e + this._e) | 0;
            this._f = (f + this._f) | 0;
            this._g = (g + this._g) | 0;
            this._h = (h + this._h) | 0;
          };
          Sha256.prototype._hash = function() {
            var H = Buffer.allocUnsafe(32);
            H.writeInt32BE(this._a, 0);
            H.writeInt32BE(this._b, 4);
            H.writeInt32BE(this._c, 8);
            H.writeInt32BE(this._d, 12);
            H.writeInt32BE(this._e, 16);
            H.writeInt32BE(this._f, 20);
            H.writeInt32BE(this._g, 24);
            H.writeInt32BE(this._h, 28);
            return H;
          };
          module.exports = Sha256;
        },
        { './hash': 250, inherits: 207, 'safe-buffer': 460 }
      ],
      256: [
        function(require, module, exports) {
          var inherits = require('inherits');
          var SHA512 = require('./sha512');
          var Hash = require('./hash');
          var Buffer = require('safe-buffer').Buffer;
          var W = new Array(160);
          function Sha384() {
            this.init();
            this._w = W;
            Hash.call(this, 128, 112);
          }
          inherits(Sha384, SHA512);
          Sha384.prototype.init = function() {
            this._ah = 3418070365;
            this._bh = 1654270250;
            this._ch = 2438529370;
            this._dh = 355462360;
            this._eh = 1731405415;
            this._fh = 2394180231;
            this._gh = 3675008525;
            this._hh = 1203062813;
            this._al = 3238371032;
            this._bl = 914150663;
            this._cl = 812702999;
            this._dl = 4144912697;
            this._el = 4290775857;
            this._fl = 1750603025;
            this._gl = 1694076839;
            this._hl = 3204075428;
            return this;
          };
          Sha384.prototype._hash = function() {
            var H = Buffer.allocUnsafe(48);
            function writeInt64BE(h, l, offset) {
              H.writeInt32BE(h, offset);
              H.writeInt32BE(l, offset + 4);
            }
            writeInt64BE(this._ah, this._al, 0);
            writeInt64BE(this._bh, this._bl, 8);
            writeInt64BE(this._ch, this._cl, 16);
            writeInt64BE(this._dh, this._dl, 24);
            writeInt64BE(this._eh, this._el, 32);
            writeInt64BE(this._fh, this._fl, 40);
            return H;
          };
          module.exports = Sha384;
        },
        { './hash': 250, './sha512': 257, inherits: 207, 'safe-buffer': 460 }
      ],
      257: [
        function(require, module, exports) {
          var inherits = require('inherits');
          var Hash = require('./hash');
          var Buffer = require('safe-buffer').Buffer;
          var K = [
            1116352408,
            3609767458,
            1899447441,
            602891725,
            3049323471,
            3964484399,
            3921009573,
            2173295548,
            961987163,
            4081628472,
            1508970993,
            3053834265,
            2453635748,
            2937671579,
            2870763221,
            3664609560,
            3624381080,
            2734883394,
            310598401,
            1164996542,
            607225278,
            1323610764,
            1426881987,
            3590304994,
            1925078388,
            4068182383,
            2162078206,
            991336113,
            2614888103,
            633803317,
            3248222580,
            3479774868,
            3835390401,
            2666613458,
            4022224774,
            944711139,
            264347078,
            2341262773,
            604807628,
            2007800933,
            770255983,
            1495990901,
            1249150122,
            1856431235,
            1555081692,
            3175218132,
            1996064986,
            2198950837,
            2554220882,
            3999719339,
            2821834349,
            766784016,
            2952996808,
            2566594879,
            3210313671,
            3203337956,
            3336571891,
            1034457026,
            3584528711,
            2466948901,
            113926993,
            3758326383,
            338241895,
            168717936,
            666307205,
            1188179964,
            773529912,
            1546045734,
            1294757372,
            1522805485,
            1396182291,
            2643833823,
            1695183700,
            2343527390,
            1986661051,
            1014477480,
            2177026350,
            1206759142,
            2456956037,
            344077627,
            2730485921,
            1290863460,
            2820302411,
            3158454273,
            3259730800,
            3505952657,
            3345764771,
            106217008,
            3516065817,
            3606008344,
            3600352804,
            1432725776,
            4094571909,
            1467031594,
            275423344,
            851169720,
            430227734,
            3100823752,
            506948616,
            1363258195,
            659060556,
            3750685593,
            883997877,
            3785050280,
            958139571,
            3318307427,
            1322822218,
            3812723403,
            1537002063,
            2003034995,
            1747873779,
            3602036899,
            1955562222,
            1575990012,
            2024104815,
            1125592928,
            2227730452,
            2716904306,
            2361852424,
            442776044,
            2428436474,
            593698344,
            2756734187,
            3733110249,
            3204031479,
            2999351573,
            3329325298,
            3815920427,
            3391569614,
            3928383900,
            3515267271,
            566280711,
            3940187606,
            3454069534,
            4118630271,
            4000239992,
            116418474,
            1914138554,
            174292421,
            2731055270,
            289380356,
            3203993006,
            460393269,
            320620315,
            685471733,
            587496836,
            852142971,
            1086792851,
            1017036298,
            365543100,
            1126000580,
            2618297676,
            1288033470,
            3409855158,
            1501505948,
            4234509866,
            1607167915,
            987167468,
            1816402316,
            1246189591
          ];
          var W = new Array(160);
          function Sha512() {
            this.init();
            this._w = W;
            Hash.call(this, 128, 112);
          }
          inherits(Sha512, Hash);
          Sha512.prototype.init = function() {
            this._ah = 1779033703;
            this._bh = 3144134277;
            this._ch = 1013904242;
            this._dh = 2773480762;
            this._eh = 1359893119;
            this._fh = 2600822924;
            this._gh = 528734635;
            this._hh = 1541459225;
            this._al = 4089235720;
            this._bl = 2227873595;
            this._cl = 4271175723;
            this._dl = 1595750129;
            this._el = 2917565137;
            this._fl = 725511199;
            this._gl = 4215389547;
            this._hl = 327033209;
            return this;
          };
          function Ch(x, y, z) {
            return z ^ (x & (y ^ z));
          }
          function maj(x, y, z) {
            return (x & y) | (z & (x | y));
          }
          function sigma0(x, xl) {
            return (
              ((x >>> 28) | (xl << 4)) ^
              ((xl >>> 2) | (x << 30)) ^
              ((xl >>> 7) | (x << 25))
            );
          }
          function sigma1(x, xl) {
            return (
              ((x >>> 14) | (xl << 18)) ^
              ((x >>> 18) | (xl << 14)) ^
              ((xl >>> 9) | (x << 23))
            );
          }
          function Gamma0(x, xl) {
            return (
              ((x >>> 1) | (xl << 31)) ^ ((x >>> 8) | (xl << 24)) ^ (x >>> 7)
            );
          }
          function Gamma0l(x, xl) {
            return (
              ((x >>> 1) | (xl << 31)) ^
              ((x >>> 8) | (xl << 24)) ^
              ((x >>> 7) | (xl << 25))
            );
          }
          function Gamma1(x, xl) {
            return (
              ((x >>> 19) | (xl << 13)) ^ ((xl >>> 29) | (x << 3)) ^ (x >>> 6)
            );
          }
          function Gamma1l(x, xl) {
            return (
              ((x >>> 19) | (xl << 13)) ^
              ((xl >>> 29) | (x << 3)) ^
              ((x >>> 6) | (xl << 26))
            );
          }
          function getCarry(a, b) {
            return a >>> 0 < b >>> 0 ? 1 : 0;
          }
          Sha512.prototype._update = function(M) {
            var W = this._w;
            var ah = this._ah | 0;
            var bh = this._bh | 0;
            var ch = this._ch | 0;
            var dh = this._dh | 0;
            var eh = this._eh | 0;
            var fh = this._fh | 0;
            var gh = this._gh | 0;
            var hh = this._hh | 0;
            var al = this._al | 0;
            var bl = this._bl | 0;
            var cl = this._cl | 0;
            var dl = this._dl | 0;
            var el = this._el | 0;
            var fl = this._fl | 0;
            var gl = this._gl | 0;
            var hl = this._hl | 0;
            for (var i = 0; i < 32; i += 2) {
              W[i] = M.readInt32BE(i * 4);
              W[i + 1] = M.readInt32BE(i * 4 + 4);
            }
            for (; i < 160; i += 2) {
              var xh = W[i - 15 * 2];
              var xl = W[i - 15 * 2 + 1];
              var gamma0 = Gamma0(xh, xl);
              var gamma0l = Gamma0l(xl, xh);
              xh = W[i - 2 * 2];
              xl = W[i - 2 * 2 + 1];
              var gamma1 = Gamma1(xh, xl);
              var gamma1l = Gamma1l(xl, xh);
              var Wi7h = W[i - 7 * 2];
              var Wi7l = W[i - 7 * 2 + 1];
              var Wi16h = W[i - 16 * 2];
              var Wi16l = W[i - 16 * 2 + 1];
              var Wil = (gamma0l + Wi7l) | 0;
              var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0;
              Wil = (Wil + gamma1l) | 0;
              Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0;
              Wil = (Wil + Wi16l) | 0;
              Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0;
              W[i] = Wih;
              W[i + 1] = Wil;
            }
            for (var j = 0; j < 160; j += 2) {
              Wih = W[j];
              Wil = W[j + 1];
              var majh = maj(ah, bh, ch);
              var majl = maj(al, bl, cl);
              var sigma0h = sigma0(ah, al);
              var sigma0l = sigma0(al, ah);
              var sigma1h = sigma1(eh, el);
              var sigma1l = sigma1(el, eh);
              var Kih = K[j];
              var Kil = K[j + 1];
              var chh = Ch(eh, fh, gh);
              var chl = Ch(el, fl, gl);
              var t1l = (hl + sigma1l) | 0;
              var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0;
              t1l = (t1l + chl) | 0;
              t1h = (t1h + chh + getCarry(t1l, chl)) | 0;
              t1l = (t1l + Kil) | 0;
              t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0;
              t1l = (t1l + Wil) | 0;
              t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0;
              var t2l = (sigma0l + majl) | 0;
              var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0;
              hh = gh;
              hl = gl;
              gh = fh;
              gl = fl;
              fh = eh;
              fl = el;
              el = (dl + t1l) | 0;
              eh = (dh + t1h + getCarry(el, dl)) | 0;
              dh = ch;
              dl = cl;
              ch = bh;
              cl = bl;
              bh = ah;
              bl = al;
              al = (t1l + t2l) | 0;
              ah = (t1h + t2h + getCarry(al, t1l)) | 0;
            }
            this._al = (this._al + al) | 0;
            this._bl = (this._bl + bl) | 0;
            this._cl = (this._cl + cl) | 0;
            this._dl = (this._dl + dl) | 0;
            this._el = (this._el + el) | 0;
            this._fl = (this._fl + fl) | 0;
            this._gl = (this._gl + gl) | 0;
            this._hl = (this._hl + hl) | 0;
            this._ah = (this._ah + ah + getCarry(this._al, al)) | 0;
            this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0;
            this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0;
            this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0;
            this._eh = (this._eh + eh + getCarry(this._el, el)) | 0;
            this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0;
            this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0;
            this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0;
          };
          Sha512.prototype._hash = function() {
            var H = Buffer.allocUnsafe(64);
            function writeInt64BE(h, l, offset) {
              H.writeInt32BE(h, offset);
              H.writeInt32BE(l, offset + 4);
            }
            writeInt64BE(this._ah, this._al, 0);
            writeInt64BE(this._bh, this._bl, 8);
            writeInt64BE(this._ch, this._cl, 16);
            writeInt64BE(this._dh, this._dl, 24);
            writeInt64BE(this._eh, this._el, 32);
            writeInt64BE(this._fh, this._fl, 40);
            writeInt64BE(this._gh, this._gl, 48);
            writeInt64BE(this._hh, this._hl, 56);
            return H;
          };
          module.exports = Sha512;
        },
        { './hash': 250, inherits: 207, 'safe-buffer': 460 }
      ],
      258: [
        function(require, module, exports) {
          module.exports = Stream;
          var EE = require('events').EventEmitter;
          var inherits = require('inherits');
          inherits(Stream, EE);
          Stream.Readable = require('readable-stream/readable.js');
          Stream.Writable = require('readable-stream/writable.js');
          Stream.Duplex = require('readable-stream/duplex.js');
          Stream.Transform = require('readable-stream/transform.js');
          Stream.PassThrough = require('readable-stream/passthrough.js');
          Stream.Stream = Stream;
          function Stream() {
            EE.call(this);
          }
          Stream.prototype.pipe = function(dest, options) {
            var source = this;
            function ondata(chunk) {
              if (dest.writable) {
                if (false === dest.write(chunk) && source.pause) {
                  source.pause();
                }
              }
            }
            source.on('data', ondata);
            function ondrain() {
              if (source.readable && source.resume) {
                source.resume();
              }
            }
            dest.on('drain', ondrain);
            if (!dest._isStdio && (!options || options.end !== false)) {
              source.on('end', onend);
              source.on('close', onclose);
            }
            var didOnEnd = false;
            function onend() {
              if (didOnEnd) return;
              didOnEnd = true;
              dest.end();
            }
            function onclose() {
              if (didOnEnd) return;
              didOnEnd = true;
              if (typeof dest.destroy === 'function') dest.destroy();
            }
            function onerror(er) {
              cleanup();
              if (EE.listenerCount(this, 'error') === 0) {
                throw er;
              }
            }
            source.on('error', onerror);
            dest.on('error', onerror);
            function cleanup() {
              source.removeListener('data', ondata);
              dest.removeListener('drain', ondrain);
              source.removeListener('end', onend);
              source.removeListener('close', onclose);
              source.removeListener('error', onerror);
              dest.removeListener('error', onerror);
              source.removeListener('end', cleanup);
              source.removeListener('close', cleanup);
              dest.removeListener('close', cleanup);
            }
            source.on('end', cleanup);
            source.on('close', cleanup);
            dest.on('close', cleanup);
            dest.emit('pipe', source);
            return dest;
          };
        },
        {
          events: 203,
          inherits: 207,
          'readable-stream/duplex.js': 235,
          'readable-stream/passthrough.js': 245,
          'readable-stream/readable.js': 246,
          'readable-stream/transform.js': 247,
          'readable-stream/writable.js': 248
        }
      ],
      259: [
        function(require, module, exports) {
          var Buffer = require('buffer').Buffer;
          var isBufferEncoding =
            Buffer.isEncoding ||
            function(encoding) {
              switch (encoding && encoding.toLowerCase()) {
                case 'hex':
                case 'utf8':
                case 'utf-8':
                case 'ascii':
                case 'binary':
                case 'base64':
                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                case 'raw':
                  return true;
                default:
                  return false;
              }
            };
          function assertEncoding(encoding) {
            if (encoding && !isBufferEncoding(encoding)) {
              throw new Error('Unknown encoding: ' + encoding);
            }
          }
          var StringDecoder = (exports.StringDecoder = function(encoding) {
            this.encoding = (encoding || 'utf8')
              .toLowerCase()
              .replace(/[-_]/, '');
            assertEncoding(encoding);
            switch (this.encoding) {
              case 'utf8':
                this.surrogateSize = 3;
                break;
              case 'ucs2':
              case 'utf16le':
                this.surrogateSize = 2;
                this.detectIncompleteChar = utf16DetectIncompleteChar;
                break;
              case 'base64':
                this.surrogateSize = 3;
                this.detectIncompleteChar = base64DetectIncompleteChar;
                break;
              default:
                this.write = passThroughWrite;
                return;
            }
            this.charBuffer = new Buffer(6);
            this.charReceived = 0;
            this.charLength = 0;
          });
          StringDecoder.prototype.write = function(buffer) {
            var charStr = '';
            while (this.charLength) {
              var available =
                buffer.length >= this.charLength - this.charReceived
                  ? this.charLength - this.charReceived
                  : buffer.length;
              buffer.copy(this.charBuffer, this.charReceived, 0, available);
              this.charReceived += available;
              if (this.charReceived < this.charLength) {
                return '';
              }
              buffer = buffer.slice(available, buffer.length);
              charStr = this.charBuffer
                .slice(0, this.charLength)
                .toString(this.encoding);
              var charCode = charStr.charCodeAt(charStr.length - 1);
              if (charCode >= 55296 && charCode <= 56319) {
                this.charLength += this.surrogateSize;
                charStr = '';
                continue;
              }
              this.charReceived = this.charLength = 0;
              if (buffer.length === 0) {
                return charStr;
              }
              break;
            }
            this.detectIncompleteChar(buffer);
            var end = buffer.length;
            if (this.charLength) {
              buffer.copy(
                this.charBuffer,
                0,
                buffer.length - this.charReceived,
                end
              );
              end -= this.charReceived;
            }
            charStr += buffer.toString(this.encoding, 0, end);
            var end = charStr.length - 1;
            var charCode = charStr.charCodeAt(end);
            if (charCode >= 55296 && charCode <= 56319) {
              var size = this.surrogateSize;
              this.charLength += size;
              this.charReceived += size;
              this.charBuffer.copy(this.charBuffer, size, 0, size);
              buffer.copy(this.charBuffer, 0, 0, size);
              return charStr.substring(0, end);
            }
            return charStr;
          };
          StringDecoder.prototype.detectIncompleteChar = function(buffer) {
            var i = buffer.length >= 3 ? 3 : buffer.length;
            for (; i > 0; i--) {
              var c = buffer[buffer.length - i];
              if (i == 1 && c >> 5 == 6) {
                this.charLength = 2;
                break;
              }
              if (i <= 2 && c >> 4 == 14) {
                this.charLength = 3;
                break;
              }
              if (i <= 3 && c >> 3 == 30) {
                this.charLength = 4;
                break;
              }
            }
            this.charReceived = i;
          };
          StringDecoder.prototype.end = function(buffer) {
            var res = '';
            if (buffer && buffer.length) res = this.write(buffer);
            if (this.charReceived) {
              var cr = this.charReceived;
              var buf = this.charBuffer;
              var enc = this.encoding;
              res += buf.slice(0, cr).toString(enc);
            }
            return res;
          };
          function passThroughWrite(buffer) {
            return buffer.toString(this.encoding);
          }
          function utf16DetectIncompleteChar(buffer) {
            this.charReceived = buffer.length % 2;
            this.charLength = this.charReceived ? 2 : 0;
          }
          function base64DetectIncompleteChar(buffer) {
            this.charReceived = buffer.length % 3;
            this.charLength = this.charReceived ? 3 : 0;
          }
        },
        { buffer: 183 }
      ],
      260: [
        function(require, module, exports) {
          'use strict';
          var punycode = require('punycode');
          var util = require('./util');
          exports.parse = urlParse;
          exports.resolve = urlResolve;
          exports.resolveObject = urlResolveObject;
          exports.format = urlFormat;
          exports.Url = Url;
          function Url() {
            this.protocol = null;
            this.slashes = null;
            this.auth = null;
            this.host = null;
            this.port = null;
            this.hostname = null;
            this.hash = null;
            this.search = null;
            this.query = null;
            this.pathname = null;
            this.path = null;
            this.href = null;
          }
          var protocolPattern = /^([a-z0-9.+-]+:)/i,
            portPattern = /:[0-9]*$/,
            simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
            delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
            unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),
            autoEscape = ["'"].concat(unwise),
            nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
            hostEndingChars = ['/', '?', '#'],
            hostnameMaxLen = 255,
            hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
            hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
            unsafeProtocol = { javascript: true, 'javascript:': true },
            hostlessProtocol = { javascript: true, 'javascript:': true },
            slashedProtocol = {
              http: true,
              https: true,
              ftp: true,
              gopher: true,
              file: true,
              'http:': true,
              'https:': true,
              'ftp:': true,
              'gopher:': true,
              'file:': true
            },
            querystring = require('querystring');
          function urlParse(url, parseQueryString, slashesDenoteHost) {
            if (url && util.isObject(url) && url instanceof Url) return url;
            var u = new Url();
            u.parse(url, parseQueryString, slashesDenoteHost);
            return u;
          }
          Url.prototype.parse = function(
            url,
            parseQueryString,
            slashesDenoteHost
          ) {
            if (!util.isString(url)) {
              throw new TypeError(
                "Parameter 'url' must be a string, not " + typeof url
              );
            }
            var queryIndex = url.indexOf('?'),
              splitter =
                queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',
              uSplit = url.split(splitter),
              slashRegex = /\\/g;
            uSplit[0] = uSplit[0].replace(slashRegex, '/');
            url = uSplit.join(splitter);
            var rest = url;
            rest = rest.trim();
            if (!slashesDenoteHost && url.split('#').length === 1) {
              var simplePath = simplePathPattern.exec(rest);
              if (simplePath) {
                this.path = rest;
                this.href = rest;
                this.pathname = simplePath[1];
                if (simplePath[2]) {
                  this.search = simplePath[2];
                  if (parseQueryString) {
                    this.query = querystring.parse(this.search.substr(1));
                  } else {
                    this.query = this.search.substr(1);
                  }
                } else if (parseQueryString) {
                  this.search = '';
                  this.query = {};
                }
                return this;
              }
            }
            var proto = protocolPattern.exec(rest);
            if (proto) {
              proto = proto[0];
              var lowerProto = proto.toLowerCase();
              this.protocol = lowerProto;
              rest = rest.substr(proto.length);
            }
            if (
              slashesDenoteHost ||
              proto ||
              rest.match(/^\/\/[^@\/]+@[^@\/]+/)
            ) {
              var slashes = rest.substr(0, 2) === '//';
              if (slashes && !(proto && hostlessProtocol[proto])) {
                rest = rest.substr(2);
                this.slashes = true;
              }
            }
            if (
              !hostlessProtocol[proto] &&
              (slashes || (proto && !slashedProtocol[proto]))
            ) {
              var hostEnd = -1;
              for (var i = 0; i < hostEndingChars.length; i++) {
                var hec = rest.indexOf(hostEndingChars[i]);
                if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                  hostEnd = hec;
              }
              var auth, atSign;
              if (hostEnd === -1) {
                atSign = rest.lastIndexOf('@');
              } else {
                atSign = rest.lastIndexOf('@', hostEnd);
              }
              if (atSign !== -1) {
                auth = rest.slice(0, atSign);
                rest = rest.slice(atSign + 1);
                this.auth = decodeURIComponent(auth);
              }
              hostEnd = -1;
              for (var i = 0; i < nonHostChars.length; i++) {
                var hec = rest.indexOf(nonHostChars[i]);
                if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                  hostEnd = hec;
              }
              if (hostEnd === -1) hostEnd = rest.length;
              this.host = rest.slice(0, hostEnd);
              rest = rest.slice(hostEnd);
              this.parseHost();
              this.hostname = this.hostname || '';
              var ipv6Hostname =
                this.hostname[0] === '[' &&
                this.hostname[this.hostname.length - 1] === ']';
              if (!ipv6Hostname) {
                var hostparts = this.hostname.split(/\./);
                for (var i = 0, l = hostparts.length; i < l; i++) {
                  var part = hostparts[i];
                  if (!part) continue;
                  if (!part.match(hostnamePartPattern)) {
                    var newpart = '';
                    for (var j = 0, k = part.length; j < k; j++) {
                      if (part.charCodeAt(j) > 127) {
                        newpart += 'x';
                      } else {
                        newpart += part[j];
                      }
                    }
                    if (!newpart.match(hostnamePartPattern)) {
                      var validParts = hostparts.slice(0, i);
                      var notHost = hostparts.slice(i + 1);
                      var bit = part.match(hostnamePartStart);
                      if (bit) {
                        validParts.push(bit[1]);
                        notHost.unshift(bit[2]);
                      }
                      if (notHost.length) {
                        rest = '/' + notHost.join('.') + rest;
                      }
                      this.hostname = validParts.join('.');
                      break;
                    }
                  }
                }
              }
              if (this.hostname.length > hostnameMaxLen) {
                this.hostname = '';
              } else {
                this.hostname = this.hostname.toLowerCase();
              }
              if (!ipv6Hostname) {
                this.hostname = punycode.toASCII(this.hostname);
              }
              var p = this.port ? ':' + this.port : '';
              var h = this.hostname || '';
              this.host = h + p;
              this.href += this.host;
              if (ipv6Hostname) {
                this.hostname = this.hostname.substr(
                  1,
                  this.hostname.length - 2
                );
                if (rest[0] !== '/') {
                  rest = '/' + rest;
                }
              }
            }
            if (!unsafeProtocol[lowerProto]) {
              for (var i = 0, l = autoEscape.length; i < l; i++) {
                var ae = autoEscape[i];
                if (rest.indexOf(ae) === -1) continue;
                var esc = encodeURIComponent(ae);
                if (esc === ae) {
                  esc = escape(ae);
                }
                rest = rest.split(ae).join(esc);
              }
            }
            var hash = rest.indexOf('#');
            if (hash !== -1) {
              this.hash = rest.substr(hash);
              rest = rest.slice(0, hash);
            }
            var qm = rest.indexOf('?');
            if (qm !== -1) {
              this.search = rest.substr(qm);
              this.query = rest.substr(qm + 1);
              if (parseQueryString) {
                this.query = querystring.parse(this.query);
              }
              rest = rest.slice(0, qm);
            } else if (parseQueryString) {
              this.search = '';
              this.query = {};
            }
            if (rest) this.pathname = rest;
            if (
              slashedProtocol[lowerProto] &&
              this.hostname &&
              !this.pathname
            ) {
              this.pathname = '/';
            }
            if (this.pathname || this.search) {
              var p = this.pathname || '';
              var s = this.search || '';
              this.path = p + s;
            }
            this.href = this.format();
            return this;
          };
          function urlFormat(obj) {
            if (util.isString(obj)) obj = urlParse(obj);
            if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
            return obj.format();
          }
          Url.prototype.format = function() {
            var auth = this.auth || '';
            if (auth) {
              auth = encodeURIComponent(auth);
              auth = auth.replace(/%3A/i, ':');
              auth += '@';
            }
            var protocol = this.protocol || '',
              pathname = this.pathname || '',
              hash = this.hash || '',
              host = false,
              query = '';
            if (this.host) {
              host = auth + this.host;
            } else if (this.hostname) {
              host =
                auth +
                (this.hostname.indexOf(':') === -1
                  ? this.hostname
                  : '[' + this.hostname + ']');
              if (this.port) {
                host += ':' + this.port;
              }
            }
            if (
              this.query &&
              util.isObject(this.query) &&
              Object.keys(this.query).length
            ) {
              query = querystring.stringify(this.query);
            }
            var search = this.search || (query && '?' + query) || '';
            if (protocol && protocol.substr(-1) !== ':') protocol += ':';
            if (
              this.slashes ||
              ((!protocol || slashedProtocol[protocol]) && host !== false)
            ) {
              host = '//' + (host || '');
              if (pathname && pathname.charAt(0) !== '/')
                pathname = '/' + pathname;
            } else if (!host) {
              host = '';
            }
            if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
            if (search && search.charAt(0) !== '?') search = '?' + search;
            pathname = pathname.replace(/[?#]/g, function(match) {
              return encodeURIComponent(match);
            });
            search = search.replace('#', '%23');
            return protocol + host + pathname + search + hash;
          };
          function urlResolve(source, relative) {
            return urlParse(source, false, true).resolve(relative);
          }
          Url.prototype.resolve = function(relative) {
            return this.resolveObject(urlParse(relative, false, true)).format();
          };
          function urlResolveObject(source, relative) {
            if (!source) return relative;
            return urlParse(source, false, true).resolveObject(relative);
          }
          Url.prototype.resolveObject = function(relative) {
            if (util.isString(relative)) {
              var rel = new Url();
              rel.parse(relative, false, true);
              relative = rel;
            }
            var result = new Url();
            var tkeys = Object.keys(this);
            for (var tk = 0; tk < tkeys.length; tk++) {
              var tkey = tkeys[tk];
              result[tkey] = this[tkey];
            }
            result.hash = relative.hash;
            if (relative.href === '') {
              result.href = result.format();
              return result;
            }
            if (relative.slashes && !relative.protocol) {
              var rkeys = Object.keys(relative);
              for (var rk = 0; rk < rkeys.length; rk++) {
                var rkey = rkeys[rk];
                if (rkey !== 'protocol') result[rkey] = relative[rkey];
              }
              if (
                slashedProtocol[result.protocol] &&
                result.hostname &&
                !result.pathname
              ) {
                result.path = result.pathname = '/';
              }
              result.href = result.format();
              return result;
            }
            if (relative.protocol && relative.protocol !== result.protocol) {
              if (!slashedProtocol[relative.protocol]) {
                var keys = Object.keys(relative);
                for (var v = 0; v < keys.length; v++) {
                  var k = keys[v];
                  result[k] = relative[k];
                }
                result.href = result.format();
                return result;
              }
              result.protocol = relative.protocol;
              if (!relative.host && !hostlessProtocol[relative.protocol]) {
                var relPath = (relative.pathname || '').split('/');
                while (relPath.length && !(relative.host = relPath.shift()));
                if (!relative.host) relative.host = '';
                if (!relative.hostname) relative.hostname = '';
                if (relPath[0] !== '') relPath.unshift('');
                if (relPath.length < 2) relPath.unshift('');
                result.pathname = relPath.join('/');
              } else {
                result.pathname = relative.pathname;
              }
              result.search = relative.search;
              result.query = relative.query;
              result.host = relative.host || '';
              result.auth = relative.auth;
              result.hostname = relative.hostname || relative.host;
              result.port = relative.port;
              if (result.pathname || result.search) {
                var p = result.pathname || '';
                var s = result.search || '';
                result.path = p + s;
              }
              result.slashes = result.slashes || relative.slashes;
              result.href = result.format();
              return result;
            }
            var isSourceAbs =
                result.pathname && result.pathname.charAt(0) === '/',
              isRelAbs =
                relative.host ||
                (relative.pathname && relative.pathname.charAt(0) === '/'),
              mustEndAbs =
                isRelAbs || isSourceAbs || (result.host && relative.pathname),
              removeAllDots = mustEndAbs,
              srcPath = (result.pathname && result.pathname.split('/')) || [],
              relPath =
                (relative.pathname && relative.pathname.split('/')) || [],
              psychotic = result.protocol && !slashedProtocol[result.protocol];
            if (psychotic) {
              result.hostname = '';
              result.port = null;
              if (result.host) {
                if (srcPath[0] === '') srcPath[0] = result.host;
                else srcPath.unshift(result.host);
              }
              result.host = '';
              if (relative.protocol) {
                relative.hostname = null;
                relative.port = null;
                if (relative.host) {
                  if (relPath[0] === '') relPath[0] = relative.host;
                  else relPath.unshift(relative.host);
                }
                relative.host = null;
              }
              mustEndAbs =
                mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
            }
            if (isRelAbs) {
              result.host =
                relative.host || relative.host === ''
                  ? relative.host
                  : result.host;
              result.hostname =
                relative.hostname || relative.hostname === ''
                  ? relative.hostname
                  : result.hostname;
              result.search = relative.search;
              result.query = relative.query;
              srcPath = relPath;
            } else if (relPath.length) {
              if (!srcPath) srcPath = [];
              srcPath.pop();
              srcPath = srcPath.concat(relPath);
              result.search = relative.search;
              result.query = relative.query;
            } else if (!util.isNullOrUndefined(relative.search)) {
              if (psychotic) {
                result.hostname = result.host = srcPath.shift();
                var authInHost =
                  result.host && result.host.indexOf('@') > 0
                    ? result.host.split('@')
                    : false;
                if (authInHost) {
                  result.auth = authInHost.shift();
                  result.host = result.hostname = authInHost.shift();
                }
              }
              result.search = relative.search;
              result.query = relative.query;
              if (
                !util.isNull(result.pathname) ||
                !util.isNull(result.search)
              ) {
                result.path =
                  (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
              }
              result.href = result.format();
              return result;
            }
            if (!srcPath.length) {
              result.pathname = null;
              if (result.search) {
                result.path = '/' + result.search;
              } else {
                result.path = null;
              }
              result.href = result.format();
              return result;
            }
            var last = srcPath.slice(-1)[0];
            var hasTrailingSlash =
              ((result.host || relative.host || srcPath.length > 1) &&
                (last === '.' || last === '..')) ||
              last === '';
            var up = 0;
            for (var i = srcPath.length; i >= 0; i--) {
              last = srcPath[i];
              if (last === '.') {
                srcPath.splice(i, 1);
              } else if (last === '..') {
                srcPath.splice(i, 1);
                up++;
              } else if (up) {
                srcPath.splice(i, 1);
                up--;
              }
            }
            if (!mustEndAbs && !removeAllDots) {
              for (; up--; up) {
                srcPath.unshift('..');
              }
            }
            if (
              mustEndAbs &&
              srcPath[0] !== '' &&
              (!srcPath[0] || srcPath[0].charAt(0) !== '/')
            ) {
              srcPath.unshift('');
            }
            if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {
              srcPath.push('');
            }
            var isAbsolute =
              srcPath[0] === '' || (srcPath[0] && srcPath[0].charAt(0) === '/');
            if (psychotic) {
              result.hostname = result.host = isAbsolute
                ? ''
                : srcPath.length
                ? srcPath.shift()
                : '';
              var authInHost =
                result.host && result.host.indexOf('@') > 0
                  ? result.host.split('@')
                  : false;
              if (authInHost) {
                result.auth = authInHost.shift();
                result.host = result.hostname = authInHost.shift();
              }
            }
            mustEndAbs = mustEndAbs || (result.host && srcPath.length);
            if (mustEndAbs && !isAbsolute) {
              srcPath.unshift('');
            }
            if (!srcPath.length) {
              result.pathname = null;
              result.path = null;
            } else {
              result.pathname = srcPath.join('/');
            }
            if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
              result.path =
                (result.pathname ? result.pathname : '') +
                (result.search ? result.search : '');
            }
            result.auth = relative.auth || result.auth;
            result.slashes = result.slashes || relative.slashes;
            result.href = result.format();
            return result;
          };
          Url.prototype.parseHost = function() {
            var host = this.host;
            var port = portPattern.exec(host);
            if (port) {
              port = port[0];
              if (port !== ':') {
                this.port = port.substr(1);
              }
              host = host.substr(0, host.length - port.length);
            }
            if (host) this.hostname = host;
          };
        },
        { './util': 261, punycode: 230, querystring: 233 }
      ],
      261: [
        function(require, module, exports) {
          'use strict';
          module.exports = {
            isString: function(arg) {
              return typeof arg === 'string';
            },
            isObject: function(arg) {
              return typeof arg === 'object' && arg !== null;
            },
            isNull: function(arg) {
              return arg === null;
            },
            isNullOrUndefined: function(arg) {
              return arg == null;
            }
          };
        },
        {}
      ],
      262: [
        function(require, module, exports) {
          (function(global) {
            module.exports = deprecate;
            function deprecate(fn, msg) {
              if (config('noDeprecation')) {
                return fn;
              }
              var warned = false;
              function deprecated() {
                if (!warned) {
                  if (config('throwDeprecation')) {
                    throw new Error(msg);
                  } else if (config('traceDeprecation')) {
                    console.trace(msg);
                  } else {
                    console.warn(msg);
                  }
                  warned = true;
                }
                return fn.apply(this, arguments);
              }
              return deprecated;
            }
            function config(name) {
              try {
                if (!global.localStorage) return false;
              } catch (_) {
                return false;
              }
              var val = global.localStorage[name];
              if (null == val) return false;
              return String(val).toLowerCase() === 'true';
            }
          }.call(
            this,
            typeof global !== 'undefined'
              ? global
              : typeof self !== 'undefined'
              ? self
              : typeof window !== 'undefined'
              ? window
              : {}
          ));
        },
        {}
      ],
      263: [
        function(require, module, exports) {
          arguments[4][207][0].apply(exports, arguments);
        },
        { dup: 207 }
      ],
      264: [
        function(require, module, exports) {
          module.exports = function isBuffer(arg) {
            return (
              arg &&
              typeof arg === 'object' &&
              typeof arg.copy === 'function' &&
              typeof arg.fill === 'function' &&
              typeof arg.readUInt8 === 'function'
            );
          };
        },
        {}
      ],
      265: [
        function(require, module, exports) {
          (function(process, global) {
            var formatRegExp = /%[sdj%]/g;
            exports.format = function(f) {
              if (!isString(f)) {
                var objects = [];
                for (var i = 0; i < arguments.length; i++) {
                  objects.push(inspect(arguments[i]));
                }
                return objects.join(' ');
              }
              var i = 1;
              var args = arguments;
              var len = args.length;
              var str = String(f).replace(formatRegExp, function(x) {
                if (x === '%%') return '%';
                if (i >= len) return x;
                switch (x) {
                  case '%s':
                    return String(args[i++]);
                  case '%d':
                    return Number(args[i++]);
                  case '%j':
                    try {
                      return JSON.stringify(args[i++]);
                    } catch (_) {
                      return '[Circular]';
                    }
                  default:
                    return x;
                }
              });
              for (var x = args[i]; i < len; x = args[++i]) {
                if (isNull(x) || !isObject(x)) {
                  str += ' ' + x;
                } else {
                  str += ' ' + inspect(x);
                }
              }
              return str;
            };
            exports.deprecate = function(fn, msg) {
              if (isUndefined(global.process)) {
                return function() {
                  return exports.deprecate(fn, msg).apply(this, arguments);
                };
              }
              if (process.noDeprecation === true) {
                return fn;
              }
              var warned = false;
              function deprecated() {
                if (!warned) {
                  if (process.throwDeprecation) {
                    throw new Error(msg);
                  } else if (process.traceDeprecation) {
                    console.trace(msg);
                  } else {
                    console.error(msg);
                  }
                  warned = true;
                }
                return fn.apply(this, arguments);
              }
              return deprecated;
            };
            var debugs = {};
            var debugEnviron;
            exports.debuglog = function(set) {
              if (isUndefined(debugEnviron))
                debugEnviron = process.env.NODE_DEBUG || '';
              set = set.toUpperCase();
              if (!debugs[set]) {
                if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
                  var pid = process.pid;
                  debugs[set] = function() {
                    var msg = exports.format.apply(exports, arguments);
                    console.error('%s %d: %s', set, pid, msg);
                  };
                } else {
                  debugs[set] = function() {};
                }
              }
              return debugs[set];
            };
            function inspect(obj, opts) {
              var ctx = { seen: [], stylize: stylizeNoColor };
              if (arguments.length >= 3) ctx.depth = arguments[2];
              if (arguments.length >= 4) ctx.colors = arguments[3];
              if (isBoolean(opts)) {
                ctx.showHidden = opts;
              } else if (opts) {
                exports._extend(ctx, opts);
              }
              if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
              if (isUndefined(ctx.depth)) ctx.depth = 2;
              if (isUndefined(ctx.colors)) ctx.colors = false;
              if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
              if (ctx.colors) ctx.stylize = stylizeWithColor;
              return formatValue(ctx, obj, ctx.depth);
            }
            exports.inspect = inspect;
            inspect.colors = {
              bold: [1, 22],
              italic: [3, 23],
              underline: [4, 24],
              inverse: [7, 27],
              white: [37, 39],
              grey: [90, 39],
              black: [30, 39],
              blue: [34, 39],
              cyan: [36, 39],
              green: [32, 39],
              magenta: [35, 39],
              red: [31, 39],
              yellow: [33, 39]
            };
            inspect.styles = {
              special: 'cyan',
              number: 'yellow',
              boolean: 'yellow',
              undefined: 'grey',
              null: 'bold',
              string: 'green',
              date: 'magenta',
              regexp: 'red'
            };
            function stylizeWithColor(str, styleType) {
              var style = inspect.styles[styleType];
              if (style) {
                return (
                  '[' +
                  inspect.colors[style][0] +
                  'm' +
                  str +
                  '[' +
                  inspect.colors[style][1] +
                  'm'
                );
              } else {
                return str;
              }
            }
            function stylizeNoColor(str, styleType) {
              return str;
            }
            function arrayToHash(array) {
              var hash = {};
              array.forEach(function(val, idx) {
                hash[val] = true;
              });
              return hash;
            }
            function formatValue(ctx, value, recurseTimes) {
              if (
                ctx.customInspect &&
                value &&
                isFunction(value.inspect) &&
                value.inspect !== exports.inspect &&
                !(value.constructor && value.constructor.prototype === value)
              ) {
                var ret = value.inspect(recurseTimes, ctx);
                if (!isString(ret)) {
                  ret = formatValue(ctx, ret, recurseTimes);
                }
                return ret;
              }
              var primitive = formatPrimitive(ctx, value);
              if (primitive) {
                return primitive;
              }
              var keys = Object.keys(value);
              var visibleKeys = arrayToHash(keys);
              if (ctx.showHidden) {
                keys = Object.getOwnPropertyNames(value);
              }
              if (
                isError(value) &&
                (keys.indexOf('message') >= 0 ||
                  keys.indexOf('description') >= 0)
              ) {
                return formatError(value);
              }
              if (keys.length === 0) {
                if (isFunction(value)) {
                  var name = value.name ? ': ' + value.name : '';
                  return ctx.stylize('[Function' + name + ']', 'special');
                }
                if (isRegExp(value)) {
                  return ctx.stylize(
                    RegExp.prototype.toString.call(value),
                    'regexp'
                  );
                }
                if (isDate(value)) {
                  return ctx.stylize(
                    Date.prototype.toString.call(value),
                    'date'
                  );
                }
                if (isError(value)) {
                  return formatError(value);
                }
              }
              var base = '',
                array = false,
                braces = ['{', '}'];
              if (isArray(value)) {
                array = true;
                braces = ['[', ']'];
              }
              if (isFunction(value)) {
                var n = value.name ? ': ' + value.name : '';
                base = ' [Function' + n + ']';
              }
              if (isRegExp(value)) {
                base = ' ' + RegExp.prototype.toString.call(value);
              }
              if (isDate(value)) {
                base = ' ' + Date.prototype.toUTCString.call(value);
              }
              if (isError(value)) {
                base = ' ' + formatError(value);
              }
              if (keys.length === 0 && (!array || value.length == 0)) {
                return braces[0] + base + braces[1];
              }
              if (recurseTimes < 0) {
                if (isRegExp(value)) {
                  return ctx.stylize(
                    RegExp.prototype.toString.call(value),
                    'regexp'
                  );
                } else {
                  return ctx.stylize('[Object]', 'special');
                }
              }
              ctx.seen.push(value);
              var output;
              if (array) {
                output = formatArray(
                  ctx,
                  value,
                  recurseTimes,
                  visibleKeys,
                  keys
                );
              } else {
                output = keys.map(function(key) {
                  return formatProperty(
                    ctx,
                    value,
                    recurseTimes,
                    visibleKeys,
                    key,
                    array
                  );
                });
              }
              ctx.seen.pop();
              return reduceToSingleString(output, base, braces);
            }
            function formatPrimitive(ctx, value) {
              if (isUndefined(value))
                return ctx.stylize('undefined', 'undefined');
              if (isString(value)) {
                var simple =
                  "'" +
                  JSON.stringify(value)
                    .replace(/^"|"$/g, '')
                    .replace(/'/g, "\\'")
                    .replace(/\\"/g, '"') +
                  "'";
                return ctx.stylize(simple, 'string');
              }
              if (isNumber(value)) return ctx.stylize('' + value, 'number');
              if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
              if (isNull(value)) return ctx.stylize('null', 'null');
            }
            function formatError(value) {
              return '[' + Error.prototype.toString.call(value) + ']';
            }
            function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
              var output = [];
              for (var i = 0, l = value.length; i < l; ++i) {
                if (hasOwnProperty(value, String(i))) {
                  output.push(
                    formatProperty(
                      ctx,
                      value,
                      recurseTimes,
                      visibleKeys,
                      String(i),
                      true
                    )
                  );
                } else {
                  output.push('');
                }
              }
              keys.forEach(function(key) {
                if (!key.match(/^\d+$/)) {
                  output.push(
                    formatProperty(
                      ctx,
                      value,
                      recurseTimes,
                      visibleKeys,
                      key,
                      true
                    )
                  );
                }
              });
              return output;
            }
            function formatProperty(
              ctx,
              value,
              recurseTimes,
              visibleKeys,
              key,
              array
            ) {
              var name, str, desc;
              desc = Object.getOwnPropertyDescriptor(value, key) || {
                value: value[key]
              };
              if (desc.get) {
                if (desc.set) {
                  str = ctx.stylize('[Getter/Setter]', 'special');
                } else {
                  str = ctx.stylize('[Getter]', 'special');
                }
              } else {
                if (desc.set) {
                  str = ctx.stylize('[Setter]', 'special');
                }
              }
              if (!hasOwnProperty(visibleKeys, key)) {
                name = '[' + key + ']';
              }
              if (!str) {
                if (ctx.seen.indexOf(desc.value) < 0) {
                  if (isNull(recurseTimes)) {
                    str = formatValue(ctx, desc.value, null);
                  } else {
                    str = formatValue(ctx, desc.value, recurseTimes - 1);
                  }
                  if (str.indexOf('\n') > -1) {
                    if (array) {
                      str = str
                        .split('\n')
                        .map(function(line) {
                          return '  ' + line;
                        })
                        .join('\n')
                        .substr(2);
                    } else {
                      str =
                        '\n' +
                        str
                          .split('\n')
                          .map(function(line) {
                            return '   ' + line;
                          })
                          .join('\n');
                    }
                  }
                } else {
                  str = ctx.stylize('[Circular]', 'special');
                }
              }
              if (isUndefined(name)) {
                if (array && key.match(/^\d+$/)) {
                  return str;
                }
                name = JSON.stringify('' + key);
                if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                  name = name.substr(1, name.length - 2);
                  name = ctx.stylize(name, 'name');
                } else {
                  name = name
                    .replace(/'/g, "\\'")
                    .replace(/\\"/g, '"')
                    .replace(/(^"|"$)/g, "'");
                  name = ctx.stylize(name, 'string');
                }
              }
              return name + ': ' + str;
            }
            function reduceToSingleString(output, base, braces) {
              var numLinesEst = 0;
              var length = output.reduce(function(prev, cur) {
                numLinesEst++;
                if (cur.indexOf('\n') >= 0) numLinesEst++;
                return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
              }, 0);
              if (length > 60) {
                return (
                  braces[0] +
                  (base === '' ? '' : base + '\n ') +
                  ' ' +
                  output.join(',\n  ') +
                  ' ' +
                  braces[1]
                );
              }
              return (
                braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1]
              );
            }
            function isArray(ar) {
              return Array.isArray(ar);
            }
            exports.isArray = isArray;
            function isBoolean(arg) {
              return typeof arg === 'boolean';
            }
            exports.isBoolean = isBoolean;
            function isNull(arg) {
              return arg === null;
            }
            exports.isNull = isNull;
            function isNullOrUndefined(arg) {
              return arg == null;
            }
            exports.isNullOrUndefined = isNullOrUndefined;
            function isNumber(arg) {
              return typeof arg === 'number';
            }
            exports.isNumber = isNumber;
            function isString(arg) {
              return typeof arg === 'string';
            }
            exports.isString = isString;
            function isSymbol(arg) {
              return typeof arg === 'symbol';
            }
            exports.isSymbol = isSymbol;
            function isUndefined(arg) {
              return arg === void 0;
            }
            exports.isUndefined = isUndefined;
            function isRegExp(re) {
              return isObject(re) && objectToString(re) === '[object RegExp]';
            }
            exports.isRegExp = isRegExp;
            function isObject(arg) {
              return typeof arg === 'object' && arg !== null;
            }
            exports.isObject = isObject;
            function isDate(d) {
              return isObject(d) && objectToString(d) === '[object Date]';
            }
            exports.isDate = isDate;
            function isError(e) {
              return (
                isObject(e) &&
                (objectToString(e) === '[object Error]' || e instanceof Error)
              );
            }
            exports.isError = isError;
            function isFunction(arg) {
              return typeof arg === 'function';
            }
            exports.isFunction = isFunction;
            function isPrimitive(arg) {
              return (
                arg === null ||
                typeof arg === 'boolean' ||
                typeof arg === 'number' ||
                typeof arg === 'string' ||
                typeof arg === 'symbol' ||
                typeof arg === 'undefined'
              );
            }
            exports.isPrimitive = isPrimitive;
            exports.isBuffer = require('./support/isBuffer');
            function objectToString(o) {
              return Object.prototype.toString.call(o);
            }
            function pad(n) {
              return n < 10 ? '0' + n.toString(10) : n.toString(10);
            }
            var months = [
              'Jan',
              'Feb',
              'Mar',
              'Apr',
              'May',
              'Jun',
              'Jul',
              'Aug',
              'Sep',
              'Oct',
              'Nov',
              'Dec'
            ];
            function timestamp() {
              var d = new Date();
              var time = [
                pad(d.getHours()),
                pad(d.getMinutes()),
                pad(d.getSeconds())
              ].join(':');
              return [d.getDate(), months[d.getMonth()], time].join(' ');
            }
            exports.log = function() {
              console.log(
                '%s - %s',
                timestamp(),
                exports.format.apply(exports, arguments)
              );
            };
            exports.inherits = require('inherits');
            exports._extend = function(origin, add) {
              if (!add || !isObject(add)) return origin;
              var keys = Object.keys(add);
              var i = keys.length;
              while (i--) {
                origin[keys[i]] = add[keys[i]];
              }
              return origin;
            };
            function hasOwnProperty(obj, prop) {
              return Object.prototype.hasOwnProperty.call(obj, prop);
            }
          }.call(
            this,
            require('_process'),
            typeof global !== 'undefined'
              ? global
              : typeof self !== 'undefined'
              ? self
              : typeof window !== 'undefined'
              ? window
              : {}
          ));
        },
        { './support/isBuffer': 264, _process: 223, inherits: 263 }
      ],
      266: [
        function(require, module, exports) {
          var indexOf = require('indexof');
          var Object_keys = function(obj) {
            if (Object.keys) return Object.keys(obj);
            else {
              var res = [];
              for (var key in obj) res.push(key);
              return res;
            }
          };
          var forEach = function(xs, fn) {
            if (xs.forEach) return xs.forEach(fn);
            else
              for (var i = 0; i < xs.length; i++) {
                fn(xs[i], i, xs);
              }
          };
          var defineProp = (function() {
            try {
              Object.defineProperty({}, '_', {});
              return function(obj, name, value) {
                Object.defineProperty(obj, name, {
                  writable: true,
                  enumerable: false,
                  configurable: true,
                  value: value
                });
              };
            } catch (e) {
              return function(obj, name, value) {
                obj[name] = value;
              };
            }
          })();
          var globals = [
            'Array',
            'Boolean',
            'Date',
            'Error',
            'EvalError',
            'Function',
            'Infinity',
            'JSON',
            'Math',
            'NaN',
            'Number',
            'Object',
            'RangeError',
            'ReferenceError',
            'RegExp',
            'String',
            'SyntaxError',
            'TypeError',
            'URIError',
            'decodeURI',
            'decodeURIComponent',
            'encodeURI',
            'encodeURIComponent',
            'escape',
            'eval',
            'isFinite',
            'isNaN',
            'parseFloat',
            'parseInt',
            'undefined',
            'unescape'
          ];
          function Context() {}
          Context.prototype = {};
          var Script = (exports.Script = function NodeScript(code) {
            if (!(this instanceof Script)) return new Script(code);
            this.code = code;
          });
          Script.prototype.runInContext = function(context) {
            if (!(context instanceof Context)) {
              throw new TypeError("needs a 'context' argument.");
            }
            var iframe = document.createElement('iframe');
            if (!iframe.style) iframe.style = {};
            iframe.style.display = 'none';
            document.body.appendChild(iframe);
            var win = iframe.contentWindow;
            var wEval = win.eval,
              wExecScript = win.execScript;
            if (!wEval && wExecScript) {
              wExecScript.call(win, 'null');
              wEval = win.eval;
            }
            forEach(Object_keys(context), function(key) {
              win[key] = context[key];
            });
            forEach(globals, function(key) {
              if (context[key]) {
                win[key] = context[key];
              }
            });
            var winKeys = Object_keys(win);
            var res = wEval.call(win, this.code);
            forEach(Object_keys(win), function(key) {
              if (key in context || indexOf(winKeys, key) === -1) {
                context[key] = win[key];
              }
            });
            forEach(globals, function(key) {
              if (!(key in context)) {
                defineProp(context, key, win[key]);
              }
            });
            document.body.removeChild(iframe);
            return res;
          };
          Script.prototype.runInThisContext = function() {
            return eval(this.code);
          };
          Script.prototype.runInNewContext = function(context) {
            var ctx = Script.createContext(context);
            var res = this.runInContext(ctx);
            forEach(Object_keys(ctx), function(key) {
              context[key] = ctx[key];
            });
            return res;
          };
          forEach(Object_keys(Script.prototype), function(name) {
            exports[name] = Script[name] = function(code) {
              var s = Script(code);
              return s[name].apply(s, [].slice.call(arguments, 1));
            };
          });
          exports.createScript = function(code) {
            return exports.Script(code);
          };
          exports.createContext = Script.createContext = function(context) {
            var copy = new Context();
            if (typeof context === 'object') {
              forEach(Object_keys(context), function(key) {
                copy[key] = context[key];
              });
            }
            return copy;
          };
        },
        { indexof: 206 }
      ],
      267: [
        function(require, module, exports) {
          var basex = require('base-x');
          var ALPHABET =
            '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
          module.exports = basex(ALPHABET);
        },
        { 'base-x': 67 }
      ],
      268: [
        function(require, module, exports) {
          'use strict';
          var base58 = require('bs58');
          var Buffer = require('safe-buffer').Buffer;
          module.exports = function(checksumFn) {
            function encode(payload) {
              var checksum = checksumFn(payload);
              return base58.encode(
                Buffer.concat([payload, checksum], payload.length + 4)
              );
            }
            function decodeRaw(buffer) {
              var payload = buffer.slice(0, -4);
              var checksum = buffer.slice(-4);
              var newChecksum = checksumFn(payload);
              if (
                (checksum[0] ^ newChecksum[0]) |
                (checksum[1] ^ newChecksum[1]) |
                (checksum[2] ^ newChecksum[2]) |
                (checksum[3] ^ newChecksum[3])
              )
                return;
              return payload;
            }
            function decodeUnsafe(string) {
              var buffer = base58.decodeUnsafe(string);
              if (!buffer) return;
              return decodeRaw(buffer);
            }
            function decode(string) {
              var buffer = base58.decode(string);
              var payload = decodeRaw(buffer, checksumFn);
              if (!payload) throw new Error('Invalid checksum');
              return payload;
            }
            return {
              encode: encode,
              decode: decode,
              decodeUnsafe: decodeUnsafe
            };
          };
        },
        { bs58: 267, 'safe-buffer': 270 }
      ],
      269: [
        function(require, module, exports) {
          'use strict';
          var createHash = require('create-hash');
          var bs58checkBase = require('./base');
          function sha256x2(buffer) {
            var tmp = createHash('sha256')
              .update(buffer)
              .digest();
            return createHash('sha256')
              .update(tmp)
              .digest();
          }
          module.exports = bs58checkBase(sha256x2);
        },
        { './base': 268, 'create-hash': 283 }
      ],
      270: [
        function(require, module, exports) {
          var buffer = require('buffer');
          var Buffer = buffer.Buffer;
          function copyProps(src, dst) {
            for (var key in src) {
              dst[key] = src[key];
            }
          }
          if (
            Buffer.from &&
            Buffer.alloc &&
            Buffer.allocUnsafe &&
            Buffer.allocUnsafeSlow
          ) {
            module.exports = buffer;
          } else {
            copyProps(buffer, exports);
            exports.Buffer = SafeBuffer;
          }
          function SafeBuffer(arg, encodingOrOffset, length) {
            return Buffer(arg, encodingOrOffset, length);
          }
          copyProps(Buffer, SafeBuffer);
          SafeBuffer.from = function(arg, encodingOrOffset, length) {
            if (typeof arg === 'number') {
              throw new TypeError('Argument must not be a number');
            }
            return Buffer(arg, encodingOrOffset, length);
          };
          SafeBuffer.alloc = function(size, fill, encoding) {
            if (typeof size !== 'number') {
              throw new TypeError('Argument must be a number');
            }
            var buf = Buffer(size);
            if (fill !== undefined) {
              if (typeof encoding === 'string') {
                buf.fill(fill, encoding);
              } else {
                buf.fill(fill);
              }
            } else {
              buf.fill(0);
            }
            return buf;
          };
          SafeBuffer.allocUnsafe = function(size) {
            if (typeof size !== 'number') {
              throw new TypeError('Argument must be a number');
            }
            return Buffer(size);
          };
          SafeBuffer.allocUnsafeSlow = function(size) {
            if (typeof size !== 'number') {
              throw new TypeError('Argument must be a number');
            }
            return buffer.SlowBuffer(size);
          };
        },
        { buffer: 183 }
      ],
      271: [
        function(require, module, exports) {
          exports = module.exports = require('./lib/cheerio');
          exports.version = require('./package.json').version;
        },
        { './lib/cheerio': 277, './package.json': 281 }
      ],
      272: [
        function(require, module, exports) {
          var $ = require('../static'),
            utils = require('../utils'),
            isTag = utils.isTag,
            domEach = utils.domEach,
            hasOwn = Object.prototype.hasOwnProperty,
            camelCase = utils.camelCase,
            cssCase = utils.cssCase,
            rspace = /\s+/,
            dataAttrPrefix = 'data-',
            _ = {
              forEach: require('lodash.foreach'),
              extend: require('lodash.assignin'),
              some: require('lodash.some')
            },
            primitives = { null: null, true: true, false: false },
            rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
            rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/;
          var getAttr = function(elem, name) {
            if (!elem || !isTag(elem)) return;
            if (!elem.attribs) {
              elem.attribs = {};
            }
            if (!name) {
              return elem.attribs;
            }
            if (hasOwn.call(elem.attribs, name)) {
              return rboolean.test(name) ? name : elem.attribs[name];
            }
            if (elem.name === 'option' && name === 'value') {
              return $.text(elem.children);
            }
            if (
              elem.name === 'input' &&
              (elem.attribs.type === 'radio' ||
                elem.attribs.type === 'checkbox') &&
              name === 'value'
            ) {
              return 'on';
            }
          };
          var setAttr = function(el, name, value) {
            if (value === null) {
              removeAttribute(el, name);
            } else {
              el.attribs[name] = value + '';
            }
          };
          exports.attr = function(name, value) {
            if (typeof name === 'object' || value !== undefined) {
              if (typeof value === 'function') {
                return domEach(this, function(i, el) {
                  setAttr(el, name, value.call(el, i, el.attribs[name]));
                });
              }
              return domEach(this, function(i, el) {
                if (!isTag(el)) return;
                if (typeof name === 'object') {
                  _.forEach(name, function(value, name) {
                    setAttr(el, name, value);
                  });
                } else {
                  setAttr(el, name, value);
                }
              });
            }
            return getAttr(this[0], name);
          };
          var getProp = function(el, name) {
            if (!el || !isTag(el)) return;
            return el.hasOwnProperty(name)
              ? el[name]
              : rboolean.test(name)
              ? getAttr(el, name) !== undefined
              : getAttr(el, name);
          };
          var setProp = function(el, name, value) {
            el[name] = rboolean.test(name) ? !!value : value;
          };
          exports.prop = function(name, value) {
            var i = 0,
              property;
            if (typeof name === 'string' && value === undefined) {
              switch (name) {
                case 'style':
                  property = this.css();
                  _.forEach(property, function(v, p) {
                    property[i++] = p;
                  });
                  property.length = i;
                  break;
                case 'tagName':
                case 'nodeName':
                  property = this[0].name.toUpperCase();
                  break;
                default:
                  property = getProp(this[0], name);
              }
              return property;
            }
            if (typeof name === 'object' || value !== undefined) {
              if (typeof value === 'function') {
                return domEach(this, function(i, el) {
                  setProp(el, name, value.call(el, i, getProp(el, name)));
                });
              }
              return domEach(this, function(i, el) {
                if (!isTag(el)) return;
                if (typeof name === 'object') {
                  _.forEach(name, function(val, name) {
                    setProp(el, name, val);
                  });
                } else {
                  setProp(el, name, value);
                }
              });
            }
          };
          var setData = function(el, name, value) {
            if (!el.data) {
              el.data = {};
            }
            if (typeof name === 'object') return _.extend(el.data, name);
            if (typeof name === 'string' && value !== undefined) {
              el.data[name] = value;
            } else if (typeof name === 'object') {
              _.extend(el.data, name);
            }
          };
          var readData = function(el, name) {
            var readAll = arguments.length === 1;
            var domNames, domName, jsNames, jsName, value, idx, length;
            if (readAll) {
              domNames = Object.keys(el.attribs).filter(function(attrName) {
                return (
                  attrName.slice(0, dataAttrPrefix.length) === dataAttrPrefix
                );
              });
              jsNames = domNames.map(function(domName) {
                return camelCase(domName.slice(dataAttrPrefix.length));
              });
            } else {
              domNames = [dataAttrPrefix + cssCase(name)];
              jsNames = [name];
            }
            for (idx = 0, length = domNames.length; idx < length; ++idx) {
              domName = domNames[idx];
              jsName = jsNames[idx];
              if (hasOwn.call(el.attribs, domName)) {
                value = el.attribs[domName];
                if (hasOwn.call(primitives, value)) {
                  value = primitives[value];
                } else if (value === String(Number(value))) {
                  value = Number(value);
                } else if (rbrace.test(value)) {
                  try {
                    value = JSON.parse(value);
                  } catch (e) {}
                }
                el.data[jsName] = value;
              }
            }
            return readAll ? el.data : value;
          };
          exports.data = function(name, value) {
            var elem = this[0];
            if (!elem || !isTag(elem)) return;
            if (!elem.data) {
              elem.data = {};
            }
            if (!name) {
              return readData(elem);
            }
            if (typeof name === 'object' || value !== undefined) {
              domEach(this, function(i, el) {
                setData(el, name, value);
              });
              return this;
            } else if (hasOwn.call(elem.data, name)) {
              return elem.data[name];
            }
            return readData(elem, name);
          };
          exports.val = function(value) {
            var querying = arguments.length === 0,
              element = this[0];
            if (!element) return;
            switch (element.name) {
              case 'textarea':
                return this.text(value);
              case 'input':
                switch (this.attr('type')) {
                  case 'radio':
                    if (querying) {
                      return this.attr('value');
                    } else {
                      this.attr('value', value);
                      return this;
                    }
                    break;
                  default:
                    return this.attr('value', value);
                }
                return;
              case 'select':
                var option = this.find('option:selected'),
                  returnValue;
                if (option === undefined) return undefined;
                if (!querying) {
                  if (
                    !this.attr().hasOwnProperty('multiple') &&
                    typeof value == 'object'
                  ) {
                    return this;
                  }
                  if (typeof value != 'object') {
                    value = [value];
                  }
                  this.find('option').removeAttr('selected');
                  for (var i = 0; i < value.length; i++) {
                    this.find('option[value="' + value[i] + '"]').attr(
                      'selected',
                      ''
                    );
                  }
                  return this;
                }
                returnValue = option.attr('value');
                if (this.attr().hasOwnProperty('multiple')) {
                  returnValue = [];
                  domEach(option, function(i, el) {
                    returnValue.push(getAttr(el, 'value'));
                  });
                }
                return returnValue;
              case 'option':
                if (!querying) {
                  this.attr('value', value);
                  return this;
                }
                return this.attr('value');
            }
          };
          var removeAttribute = function(elem, name) {
            if (!elem.attribs || !hasOwn.call(elem.attribs, name)) return;
            delete elem.attribs[name];
          };
          exports.removeAttr = function(name) {
            domEach(this, function(i, elem) {
              removeAttribute(elem, name);
            });
            return this;
          };
          exports.hasClass = function(className) {
            return _.some(this, function(elem) {
              var attrs = elem.attribs,
                clazz = attrs && attrs['class'],
                idx = -1,
                end;
              if (clazz) {
                while ((idx = clazz.indexOf(className, idx + 1)) > -1) {
                  end = idx + className.length;
                  if (
                    (idx === 0 || rspace.test(clazz[idx - 1])) &&
                    (end === clazz.length || rspace.test(clazz[end]))
                  ) {
                    return true;
                  }
                }
              }
            });
          };
          exports.addClass = function(value) {
            if (typeof value === 'function') {
              return domEach(this, function(i, el) {
                var className = el.attribs['class'] || '';
                exports.addClass.call([el], value.call(el, i, className));
              });
            }
            if (!value || typeof value !== 'string') return this;
            var classNames = value.split(rspace),
              numElements = this.length;
            for (var i = 0; i < numElements; i++) {
              if (!isTag(this[i])) continue;
              var className = getAttr(this[i], 'class'),
                numClasses,
                setClass;
              if (!className) {
                setAttr(this[i], 'class', classNames.join(' ').trim());
              } else {
                setClass = ' ' + className + ' ';
                numClasses = classNames.length;
                for (var j = 0; j < numClasses; j++) {
                  var appendClass = classNames[j] + ' ';
                  if (setClass.indexOf(' ' + appendClass) < 0)
                    setClass += appendClass;
                }
                setAttr(this[i], 'class', setClass.trim());
              }
            }
            return this;
          };
          var splitClass = function(className) {
            return className ? className.trim().split(rspace) : [];
          };
          exports.removeClass = function(value) {
            var classes, numClasses, removeAll;
            if (typeof value === 'function') {
              return domEach(this, function(i, el) {
                exports.removeClass.call(
                  [el],
                  value.call(el, i, el.attribs['class'] || '')
                );
              });
            }
            classes = splitClass(value);
            numClasses = classes.length;
            removeAll = arguments.length === 0;
            return domEach(this, function(i, el) {
              if (!isTag(el)) return;
              if (removeAll) {
                el.attribs.class = '';
              } else {
                var elClasses = splitClass(el.attribs.class),
                  index,
                  changed;
                for (var j = 0; j < numClasses; j++) {
                  index = elClasses.indexOf(classes[j]);
                  if (index >= 0) {
                    elClasses.splice(index, 1);
                    changed = true;
                    j--;
                  }
                }
                if (changed) {
                  el.attribs.class = elClasses.join(' ');
                }
              }
            });
          };
          exports.toggleClass = function(value, stateVal) {
            if (typeof value === 'function') {
              return domEach(this, function(i, el) {
                exports.toggleClass.call(
                  [el],
                  value.call(el, i, el.attribs['class'] || '', stateVal),
                  stateVal
                );
              });
            }
            if (!value || typeof value !== 'string') return this;
            var classNames = value.split(rspace),
              numClasses = classNames.length,
              state = typeof stateVal === 'boolean' ? (stateVal ? 1 : -1) : 0,
              numElements = this.length,
              elementClasses,
              index;
            for (var i = 0; i < numElements; i++) {
              if (!isTag(this[i])) continue;
              elementClasses = splitClass(this[i].attribs.class);
              for (var j = 0; j < numClasses; j++) {
                index = elementClasses.indexOf(classNames[j]);
                if (state >= 0 && index < 0) {
                  elementClasses.push(classNames[j]);
                } else if (state <= 0 && index >= 0) {
                  elementClasses.splice(index, 1);
                }
              }
              this[i].attribs.class = elementClasses.join(' ');
            }
            return this;
          };
          exports.is = function(selector) {
            if (selector) {
              return this.filter(selector).length > 0;
            }
            return false;
          };
        },
        {
          '../static': 279,
          '../utils': 280,
          'lodash.assignin': 425,
          'lodash.foreach': 430,
          'lodash.some': 436
        }
      ],
      273: [
        function(require, module, exports) {
          var domEach = require('../utils').domEach,
            _ = { pick: require('lodash.pick') };
          var toString = Object.prototype.toString;
          exports.css = function(prop, val) {
            if (
              arguments.length === 2 ||
              toString.call(prop) === '[object Object]'
            ) {
              return domEach(this, function(idx, el) {
                setCss(el, prop, val, idx);
              });
            } else {
              return getCss(this[0], prop);
            }
          };
          function setCss(el, prop, val, idx) {
            if ('string' == typeof prop) {
              var styles = getCss(el);
              if (typeof val === 'function') {
                val = val.call(el, idx, styles[prop]);
              }
              if (val === '') {
                delete styles[prop];
              } else if (val != null) {
                styles[prop] = val;
              }
              el.attribs.style = stringify(styles);
            } else if ('object' == typeof prop) {
              Object.keys(prop).forEach(function(k) {
                setCss(el, k, prop[k]);
              });
            }
          }
          function getCss(el, prop) {
            var styles = parse(el.attribs.style);
            if (typeof prop === 'string') {
              return styles[prop];
            } else if (Array.isArray(prop)) {
              return _.pick(styles, prop);
            } else {
              return styles;
            }
          }
          function stringify(obj) {
            return Object.keys(obj || {}).reduce(function(str, prop) {
              return (str +=
                '' + (str ? ' ' : '') + prop + ': ' + obj[prop] + ';');
            }, '');
          }
          function parse(styles) {
            styles = (styles || '').trim();
            if (!styles) return {};
            return styles.split(';').reduce(function(obj, str) {
              var n = str.indexOf(':');
              if (n < 1 || n === str.length - 1) return obj;
              obj[str.slice(0, n).trim()] = str.slice(n + 1).trim();
              return obj;
            }, {});
          }
        },
        { '../utils': 280, 'lodash.pick': 433 }
      ],
      274: [
        function(require, module, exports) {
          var submittableSelector = 'input,select,textarea,keygen',
            r20 = /%20/g,
            rCRLF = /\r?\n/g,
            _ = { map: require('lodash.map') };
          exports.serialize = function() {
            var arr = this.serializeArray();
            var retArr = _.map(arr, function(data) {
              return (
                encodeURIComponent(data.name) +
                '=' +
                encodeURIComponent(data.value)
              );
            });
            return retArr.join('&').replace(r20, '+');
          };
          exports.serializeArray = function() {
            var Cheerio = this.constructor;
            return this.map(function() {
              var elem = this;
              var $elem = Cheerio(elem);
              if (elem.name === 'form') {
                return $elem.find(submittableSelector).toArray();
              } else {
                return $elem.filter(submittableSelector).toArray();
              }
            })
              .filter(
                '[name!=""]:not(:disabled)' +
                  ':not(:submit, :button, :image, :reset, :file)' +
                  ':matches([checked], :not(:checkbox, :radio))'
              )
              .map(function(i, elem) {
                var $elem = Cheerio(elem);
                var name = $elem.attr('name');
                var val = $elem.val();
                if (val == null) {
                  return null;
                } else {
                  if (Array.isArray(val)) {
                    return _.map(val, function(val) {
                      return { name: name, value: val.replace(rCRLF, '\r\n') };
                    });
                  } else {
                    return { name: name, value: val.replace(rCRLF, '\r\n') };
                  }
                }
              })
              .get();
          };
        },
        { 'lodash.map': 431 }
      ],
      275: [
        function(require, module, exports) {
          var parse = require('../parse'),
            $ = require('../static'),
            updateDOM = parse.update,
            evaluate = parse.evaluate,
            utils = require('../utils'),
            domEach = utils.domEach,
            cloneDom = utils.cloneDom,
            isHtml = utils.isHtml,
            slice = Array.prototype.slice,
            _ = {
              flatten: require('lodash.flatten'),
              bind: require('lodash.bind'),
              forEach: require('lodash.foreach')
            };
          exports._makeDomArray = function makeDomArray(elem, clone) {
            if (elem == null) {
              return [];
            } else if (elem.cheerio) {
              return clone ? cloneDom(elem.get(), elem.options) : elem.get();
            } else if (Array.isArray(elem)) {
              return _.flatten(
                elem.map(function(el) {
                  return this._makeDomArray(el, clone);
                }, this)
              );
            } else if (typeof elem === 'string') {
              return evaluate(elem, this.options);
            } else {
              return clone ? cloneDom([elem]) : [elem];
            }
          };
          var _insert = function(concatenator) {
            return function() {
              var elems = slice.call(arguments),
                lastIdx = this.length - 1;
              return domEach(this, function(i, el) {
                var dom, domSrc;
                if (typeof elems[0] === 'function') {
                  domSrc = elems[0].call(el, i, $.html(el.children));
                } else {
                  domSrc = elems;
                }
                dom = this._makeDomArray(domSrc, i < lastIdx);
                concatenator(dom, el.children, el);
              });
            };
          };
          var uniqueSplice = function(
            array,
            spliceIdx,
            spliceCount,
            newElems,
            parent
          ) {
            var spliceArgs = [spliceIdx, spliceCount].concat(newElems),
              prev = array[spliceIdx - 1] || null,
              next = array[spliceIdx] || null;
            var idx, len, prevIdx, node, oldParent;
            for (idx = 0, len = newElems.length; idx < len; ++idx) {
              node = newElems[idx];
              oldParent = node.parent || node.root;
              prevIdx = oldParent && oldParent.children.indexOf(newElems[idx]);
              if (oldParent && prevIdx > -1) {
                oldParent.children.splice(prevIdx, 1);
                if (parent === oldParent && spliceIdx > prevIdx) {
                  spliceArgs[0]--;
                }
              }
              node.root = null;
              node.parent = parent;
              if (node.prev) {
                node.prev.next = node.next || null;
              }
              if (node.next) {
                node.next.prev = node.prev || null;
              }
              node.prev = newElems[idx - 1] || prev;
              node.next = newElems[idx + 1] || next;
            }
            if (prev) {
              prev.next = newElems[0];
            }
            if (next) {
              next.prev = newElems[newElems.length - 1];
            }
            return array.splice.apply(array, spliceArgs);
          };
          exports.appendTo = function(target) {
            if (!target.cheerio) {
              target = this.constructor.call(
                this.constructor,
                target,
                null,
                this._originalRoot
              );
            }
            target.append(this);
            return this;
          };
          exports.prependTo = function(target) {
            if (!target.cheerio) {
              target = this.constructor.call(
                this.constructor,
                target,
                null,
                this._originalRoot
              );
            }
            target.prepend(this);
            return this;
          };
          exports.append = _insert(function(dom, children, parent) {
            uniqueSplice(children, children.length, 0, dom, parent);
          });
          exports.prepend = _insert(function(dom, children, parent) {
            uniqueSplice(children, 0, 0, dom, parent);
          });
          exports.wrap = function(wrapper) {
            var wrapperFn = typeof wrapper === 'function' && wrapper,
              lastIdx = this.length - 1;
            _.forEach(
              this,
              _.bind(function(el, i) {
                var parent = el.parent || el.root,
                  siblings = parent.children,
                  dom,
                  index;
                if (!parent) {
                  return;
                }
                if (wrapperFn) {
                  wrapper = wrapperFn.call(el, i);
                }
                if (typeof wrapper === 'string' && !isHtml(wrapper)) {
                  wrapper = this.parents()
                    .last()
                    .find(wrapper)
                    .clone();
                }
                dom = this._makeDomArray(wrapper, i < lastIdx).slice(0, 1);
                index = siblings.indexOf(el);
                updateDOM([el], dom[0]);
                uniqueSplice(siblings, index, 0, dom, parent);
              }, this)
            );
            return this;
          };
          exports.after = function() {
            var elems = slice.call(arguments),
              lastIdx = this.length - 1;
            domEach(this, function(i, el) {
              var parent = el.parent || el.root;
              if (!parent) {
                return;
              }
              var siblings = parent.children,
                index = siblings.indexOf(el),
                domSrc,
                dom;
              if (index < 0) return;
              if (typeof elems[0] === 'function') {
                domSrc = elems[0].call(el, i, $.html(el.children));
              } else {
                domSrc = elems;
              }
              dom = this._makeDomArray(domSrc, i < lastIdx);
              uniqueSplice(siblings, index + 1, 0, dom, parent);
            });
            return this;
          };
          exports.insertAfter = function(target) {
            var clones = [],
              self = this;
            if (typeof target === 'string') {
              target = this.constructor.call(
                this.constructor,
                target,
                null,
                this._originalRoot
              );
            }
            target = this._makeDomArray(target);
            self.remove();
            domEach(target, function(i, el) {
              var clonedSelf = self._makeDomArray(self.clone());
              var parent = el.parent || el.root;
              if (!parent) {
                return;
              }
              var siblings = parent.children,
                index = siblings.indexOf(el);
              if (index < 0) return;
              uniqueSplice(siblings, index + 1, 0, clonedSelf, parent);
              clones.push(clonedSelf);
            });
            return this.constructor.call(
              this.constructor,
              this._makeDomArray(clones)
            );
          };
          exports.before = function() {
            var elems = slice.call(arguments),
              lastIdx = this.length - 1;
            domEach(this, function(i, el) {
              var parent = el.parent || el.root;
              if (!parent) {
                return;
              }
              var siblings = parent.children,
                index = siblings.indexOf(el),
                domSrc,
                dom;
              if (index < 0) return;
              if (typeof elems[0] === 'function') {
                domSrc = elems[0].call(el, i, $.html(el.children));
              } else {
                domSrc = elems;
              }
              dom = this._makeDomArray(domSrc, i < lastIdx);
              uniqueSplice(siblings, index, 0, dom, parent);
            });
            return this;
          };
          exports.insertBefore = function(target) {
            var clones = [],
              self = this;
            if (typeof target === 'string') {
              target = this.constructor.call(
                this.constructor,
                target,
                null,
                this._originalRoot
              );
            }
            target = this._makeDomArray(target);
            self.remove();
            domEach(target, function(i, el) {
              var clonedSelf = self._makeDomArray(self.clone());
              var parent = el.parent || el.root;
              if (!parent) {
                return;
              }
              var siblings = parent.children,
                index = siblings.indexOf(el);
              if (index < 0) return;
              uniqueSplice(siblings, index, 0, clonedSelf, parent);
              clones.push(clonedSelf);
            });
            return this.constructor.call(
              this.constructor,
              this._makeDomArray(clones)
            );
          };
          exports.remove = function(selector) {
            var elems = this;
            if (selector) elems = elems.filter(selector);
            domEach(elems, function(i, el) {
              var parent = el.parent || el.root;
              if (!parent) {
                return;
              }
              var siblings = parent.children,
                index = siblings.indexOf(el);
              if (index < 0) return;
              siblings.splice(index, 1);
              if (el.prev) {
                el.prev.next = el.next;
              }
              if (el.next) {
                el.next.prev = el.prev;
              }
              el.prev = el.next = el.parent = el.root = null;
            });
            return this;
          };
          exports.replaceWith = function(content) {
            var self = this;
            domEach(this, function(i, el) {
              var parent = el.parent || el.root;
              if (!parent) {
                return;
              }
              var siblings = parent.children,
                dom = self._makeDomArray(
                  typeof content === 'function'
                    ? content.call(el, i, el)
                    : content
                ),
                index;
              updateDOM(dom, null);
              index = siblings.indexOf(el);
              uniqueSplice(siblings, index, 1, dom, parent);
              el.parent = el.prev = el.next = el.root = null;
            });
            return this;
          };
          exports.empty = function() {
            domEach(this, function(i, el) {
              _.forEach(el.children, function(el) {
                el.next = el.prev = el.parent = null;
              });
              el.children.length = 0;
            });
            return this;
          };
          exports.html = function(str) {
            if (str === undefined) {
              if (!this[0] || !this[0].children) return null;
              return $.html(this[0].children, this.options);
            }
            var opts = this.options;
            domEach(this, function(i, el) {
              _.forEach(el.children, function(el) {
                el.next = el.prev = el.parent = null;
              });
              var content = str.cheerio
                ? str.clone().get()
                : evaluate('' + str, opts);
              updateDOM(content, el);
            });
            return this;
          };
          exports.toString = function() {
            return $.html(this, this.options);
          };
          exports.text = function(str) {
            if (str === undefined) {
              return $.text(this);
            } else if (typeof str === 'function') {
              return domEach(this, function(i, el) {
                var $el = [el];
                return exports.text.call($el, str.call(el, i, $.text($el)));
              });
            }
            domEach(this, function(i, el) {
              _.forEach(el.children, function(el) {
                el.next = el.prev = el.parent = null;
              });
              var elem = {
                data: '' + str,
                type: 'text',
                parent: el,
                prev: null,
                next: null,
                children: []
              };
              updateDOM(elem, el);
            });
            return this;
          };
          exports.clone = function() {
            return this._make(cloneDom(this.get(), this.options));
          };
        },
        {
          '../parse': 278,
          '../static': 279,
          '../utils': 280,
          'lodash.bind': 426,
          'lodash.flatten': 429,
          'lodash.foreach': 430
        }
      ],
      276: [
        function(require, module, exports) {
          var select = require('css-select'),
            utils = require('../utils'),
            domEach = utils.domEach,
            uniqueSort = require('htmlparser2').DomUtils.uniqueSort,
            isTag = utils.isTag,
            _ = {
              bind: require('lodash.bind'),
              forEach: require('lodash.foreach'),
              reject: require('lodash.reject'),
              filter: require('lodash.filter'),
              reduce: require('lodash.reduce')
            };
          exports.find = function(selectorOrHaystack) {
            var elems = _.reduce(
              this,
              function(memo, elem) {
                return memo.concat(_.filter(elem.children, isTag));
              },
              []
            );
            var contains = this.constructor.contains;
            var haystack;
            if (selectorOrHaystack && typeof selectorOrHaystack !== 'string') {
              if (selectorOrHaystack.cheerio) {
                haystack = selectorOrHaystack.get();
              } else {
                haystack = [selectorOrHaystack];
              }
              return this._make(
                haystack.filter(function(elem) {
                  var idx, len;
                  for (idx = 0, len = this.length; idx < len; ++idx) {
                    if (contains(this[idx], elem)) {
                      return true;
                    }
                  }
                }, this)
              );
            }
            var options = { __proto__: this.options, context: this.toArray() };
            return this._make(select(selectorOrHaystack, elems, options));
          };
          exports.parent = function(selector) {
            var set = [];
            domEach(this, function(idx, elem) {
              var parentElem = elem.parent;
              if (parentElem && set.indexOf(parentElem) < 0) {
                set.push(parentElem);
              }
            });
            if (arguments.length) {
              set = exports.filter.call(set, selector, this);
            }
            return this._make(set);
          };
          exports.parents = function(selector) {
            var parentNodes = [];
            this.get()
              .reverse()
              .forEach(function(elem) {
                traverseParents(this, elem.parent, selector, Infinity).forEach(
                  function(node) {
                    if (parentNodes.indexOf(node) === -1) {
                      parentNodes.push(node);
                    }
                  }
                );
              }, this);
            return this._make(parentNodes);
          };
          exports.parentsUntil = function(selector, filter) {
            var parentNodes = [],
              untilNode,
              untilNodes;
            if (typeof selector === 'string') {
              untilNode = select(
                selector,
                this.parents().toArray(),
                this.options
              )[0];
            } else if (selector && selector.cheerio) {
              untilNodes = selector.toArray();
            } else if (selector) {
              untilNode = selector;
            }
            this.toArray()
              .reverse()
              .forEach(function(elem) {
                while ((elem = elem.parent)) {
                  if (
                    (untilNode && elem !== untilNode) ||
                    (untilNodes && untilNodes.indexOf(elem) === -1) ||
                    (!untilNode && !untilNodes)
                  ) {
                    if (isTag(elem) && parentNodes.indexOf(elem) === -1) {
                      parentNodes.push(elem);
                    }
                  } else {
                    break;
                  }
                }
              }, this);
            return this._make(
              filter ? select(filter, parentNodes, this.options) : parentNodes
            );
          };
          exports.closest = function(selector) {
            var set = [];
            if (!selector) {
              return this._make(set);
            }
            domEach(
              this,
              function(idx, elem) {
                var closestElem = traverseParents(this, elem, selector, 1)[0];
                if (closestElem && set.indexOf(closestElem) < 0) {
                  set.push(closestElem);
                }
              }.bind(this)
            );
            return this._make(set);
          };
          exports.next = function(selector) {
            if (!this[0]) {
              return this;
            }
            var elems = [];
            _.forEach(this, function(elem) {
              while ((elem = elem.next)) {
                if (isTag(elem)) {
                  elems.push(elem);
                  return;
                }
              }
            });
            return selector
              ? exports.filter.call(elems, selector, this)
              : this._make(elems);
          };
          exports.nextAll = function(selector) {
            if (!this[0]) {
              return this;
            }
            var elems = [];
            _.forEach(this, function(elem) {
              while ((elem = elem.next)) {
                if (isTag(elem) && elems.indexOf(elem) === -1) {
                  elems.push(elem);
                }
              }
            });
            return selector
              ? exports.filter.call(elems, selector, this)
              : this._make(elems);
          };
          exports.nextUntil = function(selector, filterSelector) {
            if (!this[0]) {
              return this;
            }
            var elems = [],
              untilNode,
              untilNodes;
            if (typeof selector === 'string') {
              untilNode = select(
                selector,
                this.nextAll().get(),
                this.options
              )[0];
            } else if (selector && selector.cheerio) {
              untilNodes = selector.get();
            } else if (selector) {
              untilNode = selector;
            }
            _.forEach(this, function(elem) {
              while ((elem = elem.next)) {
                if (
                  (untilNode && elem !== untilNode) ||
                  (untilNodes && untilNodes.indexOf(elem) === -1) ||
                  (!untilNode && !untilNodes)
                ) {
                  if (isTag(elem) && elems.indexOf(elem) === -1) {
                    elems.push(elem);
                  }
                } else {
                  break;
                }
              }
            });
            return filterSelector
              ? exports.filter.call(elems, filterSelector, this)
              : this._make(elems);
          };
          exports.prev = function(selector) {
            if (!this[0]) {
              return this;
            }
            var elems = [];
            _.forEach(this, function(elem) {
              while ((elem = elem.prev)) {
                if (isTag(elem)) {
                  elems.push(elem);
                  return;
                }
              }
            });
            return selector
              ? exports.filter.call(elems, selector, this)
              : this._make(elems);
          };
          exports.prevAll = function(selector) {
            if (!this[0]) {
              return this;
            }
            var elems = [];
            _.forEach(this, function(elem) {
              while ((elem = elem.prev)) {
                if (isTag(elem) && elems.indexOf(elem) === -1) {
                  elems.push(elem);
                }
              }
            });
            return selector
              ? exports.filter.call(elems, selector, this)
              : this._make(elems);
          };
          exports.prevUntil = function(selector, filterSelector) {
            if (!this[0]) {
              return this;
            }
            var elems = [],
              untilNode,
              untilNodes;
            if (typeof selector === 'string') {
              untilNode = select(
                selector,
                this.prevAll().get(),
                this.options
              )[0];
            } else if (selector && selector.cheerio) {
              untilNodes = selector.get();
            } else if (selector) {
              untilNode = selector;
            }
            _.forEach(this, function(elem) {
              while ((elem = elem.prev)) {
                if (
                  (untilNode && elem !== untilNode) ||
                  (untilNodes && untilNodes.indexOf(elem) === -1) ||
                  (!untilNode && !untilNodes)
                ) {
                  if (isTag(elem) && elems.indexOf(elem) === -1) {
                    elems.push(elem);
                  }
                } else {
                  break;
                }
              }
            });
            return filterSelector
              ? exports.filter.call(elems, filterSelector, this)
              : this._make(elems);
          };
          exports.siblings = function(selector) {
            var parent = this.parent();
            var elems = _.filter(
              parent ? parent.children() : this.siblingsAndMe(),
              _.bind(function(elem) {
                return isTag(elem) && !this.is(elem);
              }, this)
            );
            if (selector !== undefined) {
              return exports.filter.call(elems, selector, this);
            } else {
              return this._make(elems);
            }
          };
          exports.children = function(selector) {
            var elems = _.reduce(
              this,
              function(memo, elem) {
                return memo.concat(_.filter(elem.children, isTag));
              },
              []
            );
            if (selector === undefined) return this._make(elems);
            return exports.filter.call(elems, selector, this);
          };
          exports.contents = function() {
            return this._make(
              _.reduce(
                this,
                function(all, elem) {
                  all.push.apply(all, elem.children);
                  return all;
                },
                []
              )
            );
          };
          exports.each = function(fn) {
            var i = 0,
              len = this.length;
            while (i < len && fn.call(this[i], i, this[i]) !== false) ++i;
            return this;
          };
          exports.map = function(fn) {
            return this._make(
              _.reduce(
                this,
                function(memo, el, i) {
                  var val = fn.call(el, i, el);
                  return val == null ? memo : memo.concat(val);
                },
                []
              )
            );
          };
          var makeFilterMethod = function(filterFn) {
            return function(match, container) {
              var testFn;
              container = container || this;
              if (typeof match === 'string') {
                testFn = select.compile(match, container.options);
              } else if (typeof match === 'function') {
                testFn = function(el, i) {
                  return match.call(el, i, el);
                };
              } else if (match.cheerio) {
                testFn = match.is.bind(match);
              } else {
                testFn = function(el) {
                  return match === el;
                };
              }
              return container._make(filterFn(this, testFn));
            };
          };
          exports.filter = makeFilterMethod(_.filter);
          exports.not = makeFilterMethod(_.reject);
          exports.has = function(selectorOrHaystack) {
            var that = this;
            return exports.filter.call(this, function() {
              return that._make(this).find(selectorOrHaystack).length > 0;
            });
          };
          exports.first = function() {
            return this.length > 1 ? this._make(this[0]) : this;
          };
          exports.last = function() {
            return this.length > 1 ? this._make(this[this.length - 1]) : this;
          };
          exports.eq = function(i) {
            i = +i;
            if (i === 0 && this.length <= 1) return this;
            if (i < 0) i = this.length + i;
            return this[i] ? this._make(this[i]) : this._make([]);
          };
          exports.get = function(i) {
            if (i == null) {
              return Array.prototype.slice.call(this);
            } else {
              return this[i < 0 ? this.length + i : i];
            }
          };
          exports.index = function(selectorOrNeedle) {
            var $haystack, needle;
            if (arguments.length === 0) {
              $haystack = this.parent().children();
              needle = this[0];
            } else if (typeof selectorOrNeedle === 'string') {
              $haystack = this._make(selectorOrNeedle);
              needle = this[0];
            } else {
              $haystack = this;
              needle = selectorOrNeedle.cheerio
                ? selectorOrNeedle[0]
                : selectorOrNeedle;
            }
            return $haystack.get().indexOf(needle);
          };
          exports.slice = function() {
            return this._make([].slice.apply(this, arguments));
          };
          function traverseParents(self, elem, selector, limit) {
            var elems = [];
            while (elem && elems.length < limit) {
              if (
                !selector ||
                exports.filter.call([elem], selector, self).length
              ) {
                elems.push(elem);
              }
              elem = elem.parent;
            }
            return elems;
          }
          exports.end = function() {
            return this.prevObject || this._make([]);
          };
          exports.add = function(other, context) {
            var selection = this._make(other, context);
            var contents = uniqueSort(selection.get().concat(this.get()));
            for (var i = 0; i < contents.length; ++i) {
              selection[i] = contents[i];
            }
            selection.length = contents.length;
            return selection;
          };
          exports.addBack = function(selector) {
            return this.add(
              arguments.length
                ? this.prevObject.filter(selector)
                : this.prevObject
            );
          };
        },
        {
          '../utils': 280,
          'css-select': 288,
          htmlparser2: 373,
          'lodash.bind': 426,
          'lodash.filter': 428,
          'lodash.foreach': 430,
          'lodash.reduce': 434,
          'lodash.reject': 435
        }
      ],
      277: [
        function(require, module, exports) {
          var parse = require('./parse'),
            isHtml = require('./utils').isHtml,
            _ = {
              extend: require('lodash.assignin'),
              bind: require('lodash.bind'),
              forEach: require('lodash.foreach'),
              defaults: require('lodash.defaults')
            };
          var api = [
            require('./api/attributes'),
            require('./api/traversing'),
            require('./api/manipulation'),
            require('./api/css'),
            require('./api/forms')
          ];
          var Cheerio = (module.exports = function(
            selector,
            context,
            root,
            options
          ) {
            if (!(this instanceof Cheerio))
              return new Cheerio(selector, context, root, options);
            this.options = _.defaults(options || {}, this.options);
            if (!selector) return this;
            if (root) {
              if (typeof root === 'string') root = parse(root, this.options);
              this._root = Cheerio.call(this, root);
            }
            if (selector.cheerio) return selector;
            if (isNode(selector)) selector = [selector];
            if (Array.isArray(selector)) {
              _.forEach(
                selector,
                _.bind(function(elem, idx) {
                  this[idx] = elem;
                }, this)
              );
              this.length = selector.length;
              return this;
            }
            if (typeof selector === 'string' && isHtml(selector)) {
              return Cheerio.call(this, parse(selector, this.options).children);
            }
            if (!context) {
              context = this._root;
            } else if (typeof context === 'string') {
              if (isHtml(context)) {
                context = parse(context, this.options);
                context = Cheerio.call(this, context);
              } else {
                selector = [context, selector].join(' ');
                context = this._root;
              }
            } else if (!context.cheerio) {
              context = Cheerio.call(this, context);
            }
            if (!context) return this;
            return context.find(selector);
          });
          _.extend(Cheerio, require('./static'));
          Cheerio.prototype.cheerio = '[cheerio object]';
          Cheerio.prototype.options = {
            withDomLvl1: true,
            normalizeWhitespace: false,
            xmlMode: false,
            decodeEntities: true
          };
          Cheerio.prototype.length = 0;
          Cheerio.prototype.splice = Array.prototype.splice;
          Cheerio.prototype._make = function(dom, context) {
            var cheerio = new this.constructor(
              dom,
              context,
              this._root,
              this.options
            );
            cheerio.prevObject = this;
            return cheerio;
          };
          Cheerio.prototype.toArray = function() {
            return this.get();
          };
          api.forEach(function(mod) {
            _.extend(Cheerio.prototype, mod);
          });
          var isNode = function(obj) {
            return obj.name || obj.type === 'text' || obj.type === 'comment';
          };
        },
        {
          './api/attributes': 272,
          './api/css': 273,
          './api/forms': 274,
          './api/manipulation': 275,
          './api/traversing': 276,
          './parse': 278,
          './static': 279,
          './utils': 280,
          'lodash.assignin': 425,
          'lodash.bind': 426,
          'lodash.defaults': 427,
          'lodash.foreach': 430
        }
      ],
      278: [
        function(require, module, exports) {
          (function(Buffer) {
            var htmlparser = require('htmlparser2');
            exports = module.exports = function(content, options) {
              var dom = exports.evaluate(content, options),
                root = exports.evaluate('<root></root>', options)[0];
              root.type = 'root';
              exports.update(dom, root);
              return root;
            };
            exports.evaluate = function(content, options) {
              var dom;
              if (typeof content === 'string' || Buffer.isBuffer(content)) {
                dom = htmlparser.parseDOM(content, options);
              } else {
                dom = content;
              }
              return dom;
            };
            exports.update = function(arr, parent) {
              if (!Array.isArray(arr)) arr = [arr];
              if (parent) {
                parent.children = arr;
              } else {
                parent = null;
              }
              for (var i = 0; i < arr.length; i++) {
                var node = arr[i];
                var oldParent = node.parent || node.root,
                  oldSiblings = oldParent && oldParent.children;
                if (oldSiblings && oldSiblings !== arr) {
                  oldSiblings.splice(oldSiblings.indexOf(node), 1);
                  if (node.prev) {
                    node.prev.next = node.next;
                  }
                  if (node.next) {
                    node.next.prev = node.prev;
                  }
                }
                if (parent) {
                  node.prev = arr[i - 1] || null;
                  node.next = arr[i + 1] || null;
                } else {
                  node.prev = node.next = null;
                }
                if (parent && parent.type === 'root') {
                  node.root = parent;
                  node.parent = null;
                } else {
                  node.root = null;
                  node.parent = parent;
                }
              }
              return parent;
            };
          }.call(this, {
            isBuffer: require('../../browserify/node_modules/is-buffer/index.js')
          }));
        },
        {
          '../../browserify/node_modules/is-buffer/index.js': 208,
          htmlparser2: 373
        }
      ],
      279: [
        function(require, module, exports) {
          var serialize = require('dom-serializer'),
            select = require('css-select'),
            parse = require('./parse'),
            _ = {
              merge: require('lodash.merge'),
              defaults: require('lodash.defaults')
            };
          exports.load = function(content, options) {
            var Cheerio = require('./cheerio');
            options = _.defaults(options || {}, Cheerio.prototype.options);
            var root = parse(content, options);
            var initialize = function(selector, context, r, opts) {
              if (!(this instanceof initialize)) {
                return new initialize(selector, context, r, opts);
              }
              opts = _.defaults(opts || {}, options);
              return Cheerio.call(this, selector, context, r || root, opts);
            };
            initialize.prototype = Object.create(Cheerio.prototype);
            initialize.prototype.constructor = initialize;
            initialize.fn = initialize.prototype;
            initialize.prototype._originalRoot = root;
            _.merge(initialize, exports);
            initialize._root = root;
            initialize._options = options;
            return initialize;
          };
          function render(that, dom, options) {
            if (!dom) {
              if (that._root && that._root.children) {
                dom = that._root.children;
              } else {
                return '';
              }
            } else if (typeof dom === 'string') {
              dom = select(dom, that._root, options);
            }
            return serialize(dom, options);
          }
          exports.html = function(dom, options) {
            var Cheerio = require('./cheerio');
            if (
              Object.prototype.toString.call(dom) === '[object Object]' &&
              !options &&
              !('length' in dom) &&
              !('type' in dom)
            ) {
              options = dom;
              dom = undefined;
            }
            options = _.defaults(
              options || {},
              this._options,
              Cheerio.prototype.options
            );
            return render(this, dom, options);
          };
          exports.xml = function(dom) {
            var options = _.defaults({ xmlMode: true }, this._options);
            return render(this, dom, options);
          };
          exports.text = function(elems) {
            if (!elems) {
              elems = this.root();
            }
            var ret = '',
              len = elems.length,
              elem;
            for (var i = 0; i < len; i++) {
              elem = elems[i];
              if (elem.type === 'text') ret += elem.data;
              else if (elem.children && elem.type !== 'comment') {
                ret += exports.text(elem.children);
              }
            }
            return ret;
          };
          exports.parseHTML = function(data, context, keepScripts) {
            var parsed;
            if (!data || typeof data !== 'string') {
              return null;
            }
            if (typeof context === 'boolean') {
              keepScripts = context;
            }
            parsed = this.load(data);
            if (!keepScripts) {
              parsed('script').remove();
            }
            return parsed.root()[0].children.slice();
          };
          exports.root = function() {
            return this(this._root);
          };
          exports.contains = function(container, contained) {
            if (contained === container) {
              return false;
            }
            while (contained && contained !== contained.parent) {
              contained = contained.parent;
              if (contained === container) {
                return true;
              }
            }
            return false;
          };
        },
        {
          './cheerio': 277,
          './parse': 278,
          'css-select': 288,
          'dom-serializer': 296,
          'lodash.defaults': 427,
          'lodash.merge': 432
        }
      ],
      280: [
        function(require, module, exports) {
          var parse = require('./parse'),
            render = require('dom-serializer');
          var tags = { tag: true, script: true, style: true };
          exports.isTag = function(type) {
            if (type.type) type = type.type;
            return tags[type] || false;
          };
          exports.camelCase = function(str) {
            return str.replace(/[_.-](\w|$)/g, function(_, x) {
              return x.toUpperCase();
            });
          };
          exports.cssCase = function(str) {
            return str.replace(/[A-Z]/g, '-$&').toLowerCase();
          };
          exports.domEach = function(cheerio, fn) {
            var i = 0,
              len = cheerio.length;
            while (i < len && fn.call(cheerio, i, cheerio[i]) !== false) ++i;
            return cheerio;
          };
          exports.cloneDom = function(dom, options) {
            return parse(render(dom, options), options).children;
          };
          var quickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/;
          exports.isHtml = function(str) {
            if (
              str.charAt(0) === '<' &&
              str.charAt(str.length - 1) === '>' &&
              str.length >= 3
            )
              return true;
            var match = quickExpr.exec(str);
            return !!(match && match[1]);
          };
        },
        { './parse': 278, 'dom-serializer': 296 }
      ],
      281: [
        function(require, module, exports) {
          module.exports = {
            _args: [
              [
                'cheerio@0.22.0',
                '/Users/Yukan/Desktop/work/blockstack/blockstack.js'
              ]
            ],
            _from: 'cheerio@0.22.0',
            _id: 'cheerio@0.22.0',
            _inBundle: false,
            _integrity: 'sha1-qbqoYKP5tZWmuBsahocxIe06Jp4=',
            _location: '/cheerio',
            _phantomChildren: {},
            _requested: {
              type: 'version',
              registry: true,
              raw: 'cheerio@0.22.0',
              name: 'cheerio',
              escapedName: 'cheerio',
              rawSpec: '0.22.0',
              saveSpec: null,
              fetchSpec: '0.22.0'
            },
            _requiredBy: ['/'],
            _resolved:
              'https://registry.npmjs.org/cheerio/-/cheerio-0.22.0.tgz',
            _spec: '0.22.0',
            _where: '/Users/Yukan/Desktop/work/blockstack/blockstack.js',
            author: {
              name: 'Matt Mueller',
              email: 'mattmuelle@gmail.com',
              url: 'mat.io'
            },
            bugs: { url: 'https://github.com/cheeriojs/cheerio/issues' },
            dependencies: {
              'css-select': '~1.2.0',
              'dom-serializer': '~0.1.0',
              entities: '~1.1.1',
              htmlparser2: '^3.9.1',
              'lodash.assignin': '^4.0.9',
              'lodash.bind': '^4.1.4',
              'lodash.defaults': '^4.0.1',
              'lodash.filter': '^4.4.0',
              'lodash.flatten': '^4.2.0',
              'lodash.foreach': '^4.3.0',
              'lodash.map': '^4.4.0',
              'lodash.merge': '^4.4.0',
              'lodash.pick': '^4.2.1',
              'lodash.reduce': '^4.4.0',
              'lodash.reject': '^4.4.0',
              'lodash.some': '^4.4.0'
            },
            description:
              'Tiny, fast, and elegant implementation of core jQuery designed specifically for the server',
            devDependencies: {
              benchmark: '^2.1.0',
              coveralls: '^2.11.9',
              'expect.js': '~0.3.1',
              istanbul: '^0.4.3',
              jquery: '^3.0.0',
              jsdom: '^9.2.1',
              jshint: '^2.9.2',
              mocha: '^2.5.3',
              xyz: '~0.5.0'
            },
            engines: { node: '>= 0.6' },
            files: ['index.js', 'lib'],
            homepage: 'https://github.com/cheeriojs/cheerio#readme',
            keywords: [
              'htmlparser',
              'jquery',
              'selector',
              'scraper',
              'parser',
              'html'
            ],
            license: 'MIT',
            main: './index.js',
            name: 'cheerio',
            repository: {
              type: 'git',
              url: 'git://github.com/cheeriojs/cheerio.git'
            },
            scripts: { test: 'make test' },
            version: '0.22.0'
          };
        },
        {}
      ],
      282: [
        function(require, module, exports) {
          arguments[4][184][0].apply(exports, arguments);
        },
        {
          dup: 184,
          inherits: 381,
          'safe-buffer': 460,
          stream: 258,
          string_decoder: 259
        }
      ],
      283: [
        function(require, module, exports) {
          'use strict';
          var inherits = require('inherits');
          var MD5 = require('md5.js');
          var RIPEMD160 = require('ripemd160');
          var sha = require('sha.js');
          var Base = require('cipher-base');
          function Hash(hash) {
            Base.call(this, 'digest');
            this._hash = hash;
          }
          inherits(Hash, Base);
          Hash.prototype._update = function(data) {
            this._hash.update(data);
          };
          Hash.prototype._final = function() {
            return this._hash.digest();
          };
          module.exports = function createHash(alg) {
            alg = alg.toLowerCase();
            if (alg === 'md5') return new MD5();
            if (alg === 'rmd160' || alg === 'ripemd160') return new RIPEMD160();
            return new Hash(sha(alg));
          };
        },
        {
          'cipher-base': 282,
          inherits: 381,
          'md5.js': 437,
          ripemd160: 459,
          'sha.js': 465
        }
      ],
      284: [
        function(require, module, exports) {
          var MD5 = require('md5.js');
          module.exports = function(buffer) {
            return new MD5().update(buffer).digest();
          };
        },
        { 'md5.js': 437 }
      ],
      285: [
        function(require, module, exports) {
          arguments[4][190][0].apply(exports, arguments);
        },
        {
          './legacy': 286,
          'cipher-base': 282,
          'create-hash/md5': 284,
          dup: 190,
          inherits: 381,
          ripemd160: 459,
          'safe-buffer': 460,
          'sha.js': 465
        }
      ],
      286: [
        function(require, module, exports) {
          arguments[4][191][0].apply(exports, arguments);
        },
        { 'cipher-base': 282, dup: 191, inherits: 381, 'safe-buffer': 460 }
      ],
      287: [
        function(require, module, exports) {
          (function(self) {
            if (self.fetch) {
              return;
            }
            var support = {
              searchParams: 'URLSearchParams' in self,
              iterable: 'Symbol' in self && 'iterator' in Symbol,
              blob:
                'FileReader' in self &&
                'Blob' in self &&
                (function() {
                  try {
                    new Blob();
                    return true;
                  } catch (e) {
                    return false;
                  }
                })(),
              formData: 'FormData' in self,
              arrayBuffer: 'ArrayBuffer' in self
            };
            if (support.arrayBuffer) {
              var viewClasses = [
                '[object Int8Array]',
                '[object Uint8Array]',
                '[object Uint8ClampedArray]',
                '[object Int16Array]',
                '[object Uint16Array]',
                '[object Int32Array]',
                '[object Uint32Array]',
                '[object Float32Array]',
                '[object Float64Array]'
              ];
              var isDataView = function(obj) {
                return obj && DataView.prototype.isPrototypeOf(obj);
              };
              var isArrayBufferView =
                ArrayBuffer.isView ||
                function(obj) {
                  return (
                    obj &&
                    viewClasses.indexOf(Object.prototype.toString.call(obj)) >
                      -1
                  );
                };
            }
            function normalizeName(name) {
              if (typeof name !== 'string') {
                name = String(name);
              }
              if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
                throw new TypeError('Invalid character in header field name');
              }
              return name.toLowerCase();
            }
            function normalizeValue(value) {
              if (typeof value !== 'string') {
                value = String(value);
              }
              return value;
            }
            function iteratorFor(items) {
              var iterator = {
                next: function() {
                  var value = items.shift();
                  return { done: value === undefined, value: value };
                }
              };
              if (support.iterable) {
                iterator[Symbol.iterator] = function() {
                  return iterator;
                };
              }
              return iterator;
            }
            function Headers(headers) {
              this.map = {};
              if (headers instanceof Headers) {
                headers.forEach(function(value, name) {
                  this.append(name, value);
                }, this);
              } else if (Array.isArray(headers)) {
                headers.forEach(function(header) {
                  this.append(header[0], header[1]);
                }, this);
              } else if (headers) {
                Object.getOwnPropertyNames(headers).forEach(function(name) {
                  this.append(name, headers[name]);
                }, this);
              }
            }
            Headers.prototype.append = function(name, value) {
              name = normalizeName(name);
              value = normalizeValue(value);
              var oldValue = this.map[name];
              this.map[name] = oldValue ? oldValue + ',' + value : value;
            };
            Headers.prototype['delete'] = function(name) {
              delete this.map[normalizeName(name)];
            };
            Headers.prototype.get = function(name) {
              name = normalizeName(name);
              return this.has(name) ? this.map[name] : null;
            };
            Headers.prototype.has = function(name) {
              return this.map.hasOwnProperty(normalizeName(name));
            };
            Headers.prototype.set = function(name, value) {
              this.map[normalizeName(name)] = normalizeValue(value);
            };
            Headers.prototype.forEach = function(callback, thisArg) {
              for (var name in this.map) {
                if (this.map.hasOwnProperty(name)) {
                  callback.call(thisArg, this.map[name], name, this);
                }
              }
            };
            Headers.prototype.keys = function() {
              var items = [];
              this.forEach(function(value, name) {
                items.push(name);
              });
              return iteratorFor(items);
            };
            Headers.prototype.values = function() {
              var items = [];
              this.forEach(function(value) {
                items.push(value);
              });
              return iteratorFor(items);
            };
            Headers.prototype.entries = function() {
              var items = [];
              this.forEach(function(value, name) {
                items.push([name, value]);
              });
              return iteratorFor(items);
            };
            if (support.iterable) {
              Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
            }
            function consumed(body) {
              if (body.bodyUsed) {
                return Promise.reject(new TypeError('Already read'));
              }
              body.bodyUsed = true;
            }
            function fileReaderReady(reader) {
              return new Promise(function(resolve, reject) {
                reader.onload = function() {
                  resolve(reader.result);
                };
                reader.onerror = function() {
                  reject(reader.error);
                };
              });
            }
            function readBlobAsArrayBuffer(blob) {
              var reader = new FileReader();
              var promise = fileReaderReady(reader);
              reader.readAsArrayBuffer(blob);
              return promise;
            }
            function readBlobAsText(blob) {
              var reader = new FileReader();
              var promise = fileReaderReady(reader);
              reader.readAsText(blob);
              return promise;
            }
            function readArrayBufferAsText(buf) {
              var view = new Uint8Array(buf);
              var chars = new Array(view.length);
              for (var i = 0; i < view.length; i++) {
                chars[i] = String.fromCharCode(view[i]);
              }
              return chars.join('');
            }
            function bufferClone(buf) {
              if (buf.slice) {
                return buf.slice(0);
              } else {
                var view = new Uint8Array(buf.byteLength);
                view.set(new Uint8Array(buf));
                return view.buffer;
              }
            }
            function Body() {
              this.bodyUsed = false;
              this._initBody = function(body) {
                this._bodyInit = body;
                if (!body) {
                  this._bodyText = '';
                } else if (typeof body === 'string') {
                  this._bodyText = body;
                } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
                  this._bodyBlob = body;
                } else if (
                  support.formData &&
                  FormData.prototype.isPrototypeOf(body)
                ) {
                  this._bodyFormData = body;
                } else if (
                  support.searchParams &&
                  URLSearchParams.prototype.isPrototypeOf(body)
                ) {
                  this._bodyText = body.toString();
                } else if (
                  support.arrayBuffer &&
                  support.blob &&
                  isDataView(body)
                ) {
                  this._bodyArrayBuffer = bufferClone(body.buffer);
                  this._bodyInit = new Blob([this._bodyArrayBuffer]);
                } else if (
                  support.arrayBuffer &&
                  (ArrayBuffer.prototype.isPrototypeOf(body) ||
                    isArrayBufferView(body))
                ) {
                  this._bodyArrayBuffer = bufferClone(body);
                } else {
                  throw new Error('unsupported BodyInit type');
                }
                if (!this.headers.get('content-type')) {
                  if (typeof body === 'string') {
                    this.headers.set(
                      'content-type',
                      'text/plain;charset=UTF-8'
                    );
                  } else if (this._bodyBlob && this._bodyBlob.type) {
                    this.headers.set('content-type', this._bodyBlob.type);
                  } else if (
                    support.searchParams &&
                    URLSearchParams.prototype.isPrototypeOf(body)
                  ) {
                    this.headers.set(
                      'content-type',
                      'application/x-www-form-urlencoded;charset=UTF-8'
                    );
                  }
                }
              };
              if (support.blob) {
                this.blob = function() {
                  var rejected = consumed(this);
                  if (rejected) {
                    return rejected;
                  }
                  if (this._bodyBlob) {
                    return Promise.resolve(this._bodyBlob);
                  } else if (this._bodyArrayBuffer) {
                    return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                  } else if (this._bodyFormData) {
                    throw new Error('could not read FormData body as blob');
                  } else {
                    return Promise.resolve(new Blob([this._bodyText]));
                  }
                };
                this.arrayBuffer = function() {
                  if (this._bodyArrayBuffer) {
                    return (
                      consumed(this) || Promise.resolve(this._bodyArrayBuffer)
                    );
                  } else {
                    return this.blob().then(readBlobAsArrayBuffer);
                  }
                };
              }
              this.text = function() {
                var rejected = consumed(this);
                if (rejected) {
                  return rejected;
                }
                if (this._bodyBlob) {
                  return readBlobAsText(this._bodyBlob);
                } else if (this._bodyArrayBuffer) {
                  return Promise.resolve(
                    readArrayBufferAsText(this._bodyArrayBuffer)
                  );
                } else if (this._bodyFormData) {
                  throw new Error('could not read FormData body as text');
                } else {
                  return Promise.resolve(this._bodyText);
                }
              };
              if (support.formData) {
                this.formData = function() {
                  return this.text().then(decode);
                };
              }
              this.json = function() {
                return this.text().then(JSON.parse);
              };
              return this;
            }
            var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];
            function normalizeMethod(method) {
              var upcased = method.toUpperCase();
              return methods.indexOf(upcased) > -1 ? upcased : method;
            }
            function Request(input, options) {
              options = options || {};
              var body = options.body;
              if (input instanceof Request) {
                if (input.bodyUsed) {
                  throw new TypeError('Already read');
                }
                this.url = input.url;
                this.credentials = input.credentials;
                if (!options.headers) {
                  this.headers = new Headers(input.headers);
                }
                this.method = input.method;
                this.mode = input.mode;
                if (!body && input._bodyInit != null) {
                  body = input._bodyInit;
                  input.bodyUsed = true;
                }
              } else {
                this.url = String(input);
              }
              this.credentials =
                options.credentials || this.credentials || 'omit';
              if (options.headers || !this.headers) {
                this.headers = new Headers(options.headers);
              }
              this.method = normalizeMethod(
                options.method || this.method || 'GET'
              );
              this.mode = options.mode || this.mode || null;
              this.referrer = null;
              if ((this.method === 'GET' || this.method === 'HEAD') && body) {
                throw new TypeError(
                  'Body not allowed for GET or HEAD requests'
                );
              }
              this._initBody(body);
            }
            Request.prototype.clone = function() {
              return new Request(this, { body: this._bodyInit });
            };
            function decode(body) {
              var form = new FormData();
              body
                .trim()
                .split('&')
                .forEach(function(bytes) {
                  if (bytes) {
                    var split = bytes.split('=');
                    var name = split.shift().replace(/\+/g, ' ');
                    var value = split.join('=').replace(/\+/g, ' ');
                    form.append(
                      decodeURIComponent(name),
                      decodeURIComponent(value)
                    );
                  }
                });
              return form;
            }
            function parseHeaders(rawHeaders) {
              var headers = new Headers();
              var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
              preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
                var parts = line.split(':');
                var key = parts.shift().trim();
                if (key) {
                  var value = parts.join(':').trim();
                  headers.append(key, value);
                }
              });
              return headers;
            }
            Body.call(Request.prototype);
            function Response(bodyInit, options) {
              if (!options) {
                options = {};
              }
              this.type = 'default';
              this.status = options.status === undefined ? 200 : options.status;
              this.ok = this.status >= 200 && this.status < 300;
              this.statusText =
                'statusText' in options ? options.statusText : 'OK';
              this.headers = new Headers(options.headers);
              this.url = options.url || '';
              this._initBody(bodyInit);
            }
            Body.call(Response.prototype);
            Response.prototype.clone = function() {
              return new Response(this._bodyInit, {
                status: this.status,
                statusText: this.statusText,
                headers: new Headers(this.headers),
                url: this.url
              });
            };
            Response.error = function() {
              var response = new Response(null, { status: 0, statusText: '' });
              response.type = 'error';
              return response;
            };
            var redirectStatuses = [301, 302, 303, 307, 308];
            Response.redirect = function(url, status) {
              if (redirectStatuses.indexOf(status) === -1) {
                throw new RangeError('Invalid status code');
              }
              return new Response(null, {
                status: status,
                headers: { location: url }
              });
            };
            self.Headers = Headers;
            self.Request = Request;
            self.Response = Response;
            self.fetch = function(input, init) {
              return new Promise(function(resolve, reject) {
                var request = new Request(input, init);
                var xhr = new XMLHttpRequest();
                xhr.onload = function() {
                  var options = {
                    status: xhr.status,
                    statusText: xhr.statusText,
                    headers: parseHeaders(xhr.getAllResponseHeaders() || '')
                  };
                  options.url =
                    'responseURL' in xhr
                      ? xhr.responseURL
                      : options.headers.get('X-Request-URL');
                  var body =
                    'response' in xhr ? xhr.response : xhr.responseText;
                  resolve(new Response(body, options));
                };
                xhr.onerror = function() {
                  reject(new TypeError('Network request failed'));
                };
                xhr.ontimeout = function() {
                  reject(new TypeError('Network request failed'));
                };
                xhr.open(request.method, request.url, true);
                if (request.credentials === 'include') {
                  xhr.withCredentials = true;
                } else if (request.credentials === 'omit') {
                  xhr.withCredentials = false;
                }
                if ('responseType' in xhr && support.blob) {
                  xhr.responseType = 'blob';
                }
                request.headers.forEach(function(value, name) {
                  xhr.setRequestHeader(name, value);
                });
                xhr.send(
                  typeof request._bodyInit === 'undefined'
                    ? null
                    : request._bodyInit
                );
              });
            };
            self.fetch.polyfill = true;
          })(typeof self !== 'undefined' ? self : this);
        },
        {}
      ],
      288: [
        function(require, module, exports) {
          'use strict';
          module.exports = CSSselect;
          var Pseudos = require('./lib/pseudos.js'),
            DomUtils = require('domutils'),
            findOne = DomUtils.findOne,
            findAll = DomUtils.findAll,
            getChildren = DomUtils.getChildren,
            removeSubsets = DomUtils.removeSubsets,
            falseFunc = require('boolbase').falseFunc,
            compile = require('./lib/compile.js'),
            compileUnsafe = compile.compileUnsafe,
            compileToken = compile.compileToken;
          function getSelectorFunc(searchFunc) {
            return function select(query, elems, options) {
              if (typeof query !== 'function')
                query = compileUnsafe(query, options, elems);
              if (!Array.isArray(elems)) elems = getChildren(elems);
              else elems = removeSubsets(elems);
              return searchFunc(query, elems);
            };
          }
          var selectAll = getSelectorFunc(function selectAll(query, elems) {
            return query === falseFunc || !elems || elems.length === 0
              ? []
              : findAll(query, elems);
          });
          var selectOne = getSelectorFunc(function selectOne(query, elems) {
            return query === falseFunc || !elems || elems.length === 0
              ? null
              : findOne(query, elems);
          });
          function is(elem, query, options) {
            return (typeof query === 'function'
              ? query
              : compile(query, options))(elem);
          }
          function CSSselect(query, elems, options) {
            return selectAll(query, elems, options);
          }
          CSSselect.compile = compile;
          CSSselect.filters = Pseudos.filters;
          CSSselect.pseudos = Pseudos.pseudos;
          CSSselect.selectAll = selectAll;
          CSSselect.selectOne = selectOne;
          CSSselect.is = is;
          CSSselect.parse = compile;
          CSSselect.iterate = selectAll;
          CSSselect._compileUnsafe = compileUnsafe;
          CSSselect._compileToken = compileToken;
        },
        {
          './lib/compile.js': 290,
          './lib/pseudos.js': 293,
          boolbase: 135,
          domutils: 302
        }
      ],
      289: [
        function(require, module, exports) {
          var DomUtils = require('domutils'),
            hasAttrib = DomUtils.hasAttrib,
            getAttributeValue = DomUtils.getAttributeValue,
            falseFunc = require('boolbase').falseFunc;
          var reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;
          var attributeRules = {
            __proto__: null,
            equals: function(next, data) {
              var name = data.name,
                value = data.value;
              if (data.ignoreCase) {
                value = value.toLowerCase();
                return function equalsIC(elem) {
                  var attr = getAttributeValue(elem, name);
                  return (
                    attr != null && attr.toLowerCase() === value && next(elem)
                  );
                };
              }
              return function equals(elem) {
                return getAttributeValue(elem, name) === value && next(elem);
              };
            },
            hyphen: function(next, data) {
              var name = data.name,
                value = data.value,
                len = value.length;
              if (data.ignoreCase) {
                value = value.toLowerCase();
                return function hyphenIC(elem) {
                  var attr = getAttributeValue(elem, name);
                  return (
                    attr != null &&
                    (attr.length === len || attr.charAt(len) === '-') &&
                    attr.substr(0, len).toLowerCase() === value &&
                    next(elem)
                  );
                };
              }
              return function hyphen(elem) {
                var attr = getAttributeValue(elem, name);
                return (
                  attr != null &&
                  attr.substr(0, len) === value &&
                  (attr.length === len || attr.charAt(len) === '-') &&
                  next(elem)
                );
              };
            },
            element: function(next, data) {
              var name = data.name,
                value = data.value;
              if (/\s/.test(value)) {
                return falseFunc;
              }
              value = value.replace(reChars, '\\$&');
              var pattern = '(?:^|\\s)' + value + '(?:$|\\s)',
                flags = data.ignoreCase ? 'i' : '',
                regex = new RegExp(pattern, flags);
              return function element(elem) {
                var attr = getAttributeValue(elem, name);
                return attr != null && regex.test(attr) && next(elem);
              };
            },
            exists: function(next, data) {
              var name = data.name;
              return function exists(elem) {
                return hasAttrib(elem, name) && next(elem);
              };
            },
            start: function(next, data) {
              var name = data.name,
                value = data.value,
                len = value.length;
              if (len === 0) {
                return falseFunc;
              }
              if (data.ignoreCase) {
                value = value.toLowerCase();
                return function startIC(elem) {
                  var attr = getAttributeValue(elem, name);
                  return (
                    attr != null &&
                    attr.substr(0, len).toLowerCase() === value &&
                    next(elem)
                  );
                };
              }
              return function start(elem) {
                var attr = getAttributeValue(elem, name);
                return (
                  attr != null && attr.substr(0, len) === value && next(elem)
                );
              };
            },
            end: function(next, data) {
              var name = data.name,
                value = data.value,
                len = -value.length;
              if (len === 0) {
                return falseFunc;
              }
              if (data.ignoreCase) {
                value = value.toLowerCase();
                return function endIC(elem) {
                  var attr = getAttributeValue(elem, name);
                  return (
                    attr != null &&
                    attr.substr(len).toLowerCase() === value &&
                    next(elem)
                  );
                };
              }
              return function end(elem) {
                var attr = getAttributeValue(elem, name);
                return attr != null && attr.substr(len) === value && next(elem);
              };
            },
            any: function(next, data) {
              var name = data.name,
                value = data.value;
              if (value === '') {
                return falseFunc;
              }
              if (data.ignoreCase) {
                var regex = new RegExp(value.replace(reChars, '\\$&'), 'i');
                return function anyIC(elem) {
                  var attr = getAttributeValue(elem, name);
                  return attr != null && regex.test(attr) && next(elem);
                };
              }
              return function any(elem) {
                var attr = getAttributeValue(elem, name);
                return attr != null && attr.indexOf(value) >= 0 && next(elem);
              };
            },
            not: function(next, data) {
              var name = data.name,
                value = data.value;
              if (value === '') {
                return function notEmpty(elem) {
                  return !!getAttributeValue(elem, name) && next(elem);
                };
              } else if (data.ignoreCase) {
                value = value.toLowerCase();
                return function notIC(elem) {
                  var attr = getAttributeValue(elem, name);
                  return (
                    attr != null && attr.toLowerCase() !== value && next(elem)
                  );
                };
              }
              return function not(elem) {
                return getAttributeValue(elem, name) !== value && next(elem);
              };
            }
          };
          module.exports = {
            compile: function(next, data, options) {
              if (
                options &&
                options.strict &&
                (data.ignoreCase || data.action === 'not')
              )
                throw SyntaxError('Unsupported attribute selector');
              return attributeRules[data.action](next, data);
            },
            rules: attributeRules
          };
        },
        { boolbase: 135, domutils: 302 }
      ],
      290: [
        function(require, module, exports) {
          module.exports = compile;
          module.exports.compileUnsafe = compileUnsafe;
          module.exports.compileToken = compileToken;
          var parse = require('css-what'),
            DomUtils = require('domutils'),
            isTag = DomUtils.isTag,
            Rules = require('./general.js'),
            sortRules = require('./sort.js'),
            BaseFuncs = require('boolbase'),
            trueFunc = BaseFuncs.trueFunc,
            falseFunc = BaseFuncs.falseFunc,
            procedure = require('./procedure.json');
          function compile(selector, options, context) {
            var next = compileUnsafe(selector, options, context);
            return wrap(next);
          }
          function wrap(next) {
            return function base(elem) {
              return isTag(elem) && next(elem);
            };
          }
          function compileUnsafe(selector, options, context) {
            var token = parse(selector, options);
            return compileToken(token, options, context);
          }
          function includesScopePseudo(t) {
            return (
              t.type === 'pseudo' &&
              (t.name === 'scope' ||
                (Array.isArray(t.data) &&
                  t.data.some(function(data) {
                    return data.some(includesScopePseudo);
                  })))
            );
          }
          var DESCENDANT_TOKEN = { type: 'descendant' },
            SCOPE_TOKEN = { type: 'pseudo', name: 'scope' },
            PLACEHOLDER_ELEMENT = {},
            getParent = DomUtils.getParent;
          function absolutize(token, context) {
            var hasContext =
              !!context &&
              !!context.length &&
              context.every(function(e) {
                return e === PLACEHOLDER_ELEMENT || !!getParent(e);
              });
            token.forEach(function(t) {
              if (
                t.length > 0 &&
                isTraversal(t[0]) &&
                t[0].type !== 'descendant'
              ) {
              } else if (hasContext && !includesScopePseudo(t)) {
                t.unshift(DESCENDANT_TOKEN);
              } else {
                return;
              }
              t.unshift(SCOPE_TOKEN);
            });
          }
          function compileToken(token, options, context) {
            token = token.filter(function(t) {
              return t.length > 0;
            });
            token.forEach(sortRules);
            var isArrayContext = Array.isArray(context);
            context = (options && options.context) || context;
            if (context && !isArrayContext) context = [context];
            absolutize(token, context);
            return token
              .map(function(rules) {
                return compileRules(rules, options, context, isArrayContext);
              })
              .reduce(reduceRules, falseFunc);
          }
          function isTraversal(t) {
            return procedure[t.type] < 0;
          }
          function compileRules(rules, options, context, isArrayContext) {
            var acceptSelf =
              isArrayContext &&
              rules[0].name === 'scope' &&
              rules[1].type === 'descendant';
            return rules.reduce(function(func, rule, index) {
              if (func === falseFunc) return func;
              return Rules[rule.type](
                func,
                rule,
                options,
                context,
                acceptSelf && index === 1
              );
            }, (options && options.rootFunc) || trueFunc);
          }
          function reduceRules(a, b) {
            if (b === falseFunc || a === trueFunc) {
              return a;
            }
            if (a === falseFunc || b === trueFunc) {
              return b;
            }
            return function combine(elem) {
              return a(elem) || b(elem);
            };
          }
          var Pseudos = require('./pseudos.js'),
            filters = Pseudos.filters,
            existsOne = DomUtils.existsOne,
            isTag = DomUtils.isTag,
            getChildren = DomUtils.getChildren;
          function containsTraversal(t) {
            return t.some(isTraversal);
          }
          filters.not = function(next, token, options, context) {
            var opts = {
              xmlMode: !!(options && options.xmlMode),
              strict: !!(options && options.strict)
            };
            if (opts.strict) {
              if (token.length > 1 || token.some(containsTraversal)) {
                throw new SyntaxError(
                  "complex selectors in :not aren't allowed in strict mode"
                );
              }
            }
            var func = compileToken(token, opts, context);
            if (func === falseFunc) return next;
            if (func === trueFunc) return falseFunc;
            return function(elem) {
              return !func(elem) && next(elem);
            };
          };
          filters.has = function(next, token, options) {
            var opts = {
              xmlMode: !!(options && options.xmlMode),
              strict: !!(options && options.strict)
            };
            var context = token.some(containsTraversal)
              ? [PLACEHOLDER_ELEMENT]
              : null;
            var func = compileToken(token, opts, context);
            if (func === falseFunc) return falseFunc;
            if (func === trueFunc)
              return function(elem) {
                return getChildren(elem).some(isTag) && next(elem);
              };
            func = wrap(func);
            if (context) {
              return function has(elem) {
                return (
                  next(elem) &&
                  ((context[0] = elem), existsOne(func, getChildren(elem)))
                );
              };
            }
            return function has(elem) {
              return next(elem) && existsOne(func, getChildren(elem));
            };
          };
          filters.matches = function(next, token, options, context) {
            var opts = {
              xmlMode: !!(options && options.xmlMode),
              strict: !!(options && options.strict),
              rootFunc: next
            };
            return compileToken(token, opts, context);
          };
        },
        {
          './general.js': 291,
          './procedure.json': 292,
          './pseudos.js': 293,
          './sort.js': 294,
          boolbase: 135,
          'css-what': 295,
          domutils: 302
        }
      ],
      291: [
        function(require, module, exports) {
          var DomUtils = require('domutils'),
            isTag = DomUtils.isTag,
            getParent = DomUtils.getParent,
            getChildren = DomUtils.getChildren,
            getSiblings = DomUtils.getSiblings,
            getName = DomUtils.getName;
          module.exports = {
            __proto__: null,
            attribute: require('./attributes.js').compile,
            pseudo: require('./pseudos.js').compile,
            tag: function(next, data) {
              var name = data.name;
              return function tag(elem) {
                return getName(elem) === name && next(elem);
              };
            },
            descendant: function(next, rule, options, context, acceptSelf) {
              return function descendant(elem) {
                if (acceptSelf && next(elem)) return true;
                var found = false;
                while (!found && (elem = getParent(elem))) {
                  found = next(elem);
                }
                return found;
              };
            },
            parent: function(next, data, options) {
              if (options && options.strict)
                throw SyntaxError("Parent selector isn't part of CSS3");
              return function parent(elem) {
                return getChildren(elem).some(test);
              };
              function test(elem) {
                return isTag(elem) && next(elem);
              }
            },
            child: function(next) {
              return function child(elem) {
                var parent = getParent(elem);
                return !!parent && next(parent);
              };
            },
            sibling: function(next) {
              return function sibling(elem) {
                var siblings = getSiblings(elem);
                for (var i = 0; i < siblings.length; i++) {
                  if (isTag(siblings[i])) {
                    if (siblings[i] === elem) break;
                    if (next(siblings[i])) return true;
                  }
                }
                return false;
              };
            },
            adjacent: function(next) {
              return function adjacent(elem) {
                var siblings = getSiblings(elem),
                  lastElement;
                for (var i = 0; i < siblings.length; i++) {
                  if (isTag(siblings[i])) {
                    if (siblings[i] === elem) break;
                    lastElement = siblings[i];
                  }
                }
                return !!lastElement && next(lastElement);
              };
            },
            universal: function(next) {
              return next;
            }
          };
        },
        { './attributes.js': 289, './pseudos.js': 293, domutils: 302 }
      ],
      292: [
        function(require, module, exports) {
          module.exports = {
            universal: 50,
            tag: 30,
            attribute: 1,
            pseudo: 0,
            descendant: -1,
            child: -1,
            parent: -1,
            sibling: -1,
            adjacent: -1
          };
        },
        {}
      ],
      293: [
        function(require, module, exports) {
          var DomUtils = require('domutils'),
            isTag = DomUtils.isTag,
            getText = DomUtils.getText,
            getParent = DomUtils.getParent,
            getChildren = DomUtils.getChildren,
            getSiblings = DomUtils.getSiblings,
            hasAttrib = DomUtils.hasAttrib,
            getName = DomUtils.getName,
            getAttribute = DomUtils.getAttributeValue,
            getNCheck = require('nth-check'),
            checkAttrib = require('./attributes.js').rules.equals,
            BaseFuncs = require('boolbase'),
            trueFunc = BaseFuncs.trueFunc,
            falseFunc = BaseFuncs.falseFunc;
          function getFirstElement(elems) {
            for (var i = 0; elems && i < elems.length; i++) {
              if (isTag(elems[i])) return elems[i];
            }
          }
          function getAttribFunc(name, value) {
            var data = { name: name, value: value };
            return function attribFunc(next) {
              return checkAttrib(next, data);
            };
          }
          function getChildFunc(next) {
            return function(elem) {
              return !!getParent(elem) && next(elem);
            };
          }
          var filters = {
            contains: function(next, text) {
              return function contains(elem) {
                return next(elem) && getText(elem).indexOf(text) >= 0;
              };
            },
            icontains: function(next, text) {
              var itext = text.toLowerCase();
              return function icontains(elem) {
                return (
                  next(elem) &&
                  getText(elem)
                    .toLowerCase()
                    .indexOf(itext) >= 0
                );
              };
            },
            'nth-child': function(next, rule) {
              var func = getNCheck(rule);
              if (func === falseFunc) return func;
              if (func === trueFunc) return getChildFunc(next);
              return function nthChild(elem) {
                var siblings = getSiblings(elem);
                for (var i = 0, pos = 0; i < siblings.length; i++) {
                  if (isTag(siblings[i])) {
                    if (siblings[i] === elem) break;
                    else pos++;
                  }
                }
                return func(pos) && next(elem);
              };
            },
            'nth-last-child': function(next, rule) {
              var func = getNCheck(rule);
              if (func === falseFunc) return func;
              if (func === trueFunc) return getChildFunc(next);
              return function nthLastChild(elem) {
                var siblings = getSiblings(elem);
                for (var pos = 0, i = siblings.length - 1; i >= 0; i--) {
                  if (isTag(siblings[i])) {
                    if (siblings[i] === elem) break;
                    else pos++;
                  }
                }
                return func(pos) && next(elem);
              };
            },
            'nth-of-type': function(next, rule) {
              var func = getNCheck(rule);
              if (func === falseFunc) return func;
              if (func === trueFunc) return getChildFunc(next);
              return function nthOfType(elem) {
                var siblings = getSiblings(elem);
                for (var pos = 0, i = 0; i < siblings.length; i++) {
                  if (isTag(siblings[i])) {
                    if (siblings[i] === elem) break;
                    if (getName(siblings[i]) === getName(elem)) pos++;
                  }
                }
                return func(pos) && next(elem);
              };
            },
            'nth-last-of-type': function(next, rule) {
              var func = getNCheck(rule);
              if (func === falseFunc) return func;
              if (func === trueFunc) return getChildFunc(next);
              return function nthLastOfType(elem) {
                var siblings = getSiblings(elem);
                for (var pos = 0, i = siblings.length - 1; i >= 0; i--) {
                  if (isTag(siblings[i])) {
                    if (siblings[i] === elem) break;
                    if (getName(siblings[i]) === getName(elem)) pos++;
                  }
                }
                return func(pos) && next(elem);
              };
            },
            root: function(next) {
              return function(elem) {
                return !getParent(elem) && next(elem);
              };
            },
            scope: function(next, rule, options, context) {
              if (!context || context.length === 0) {
                return filters.root(next);
              }
              if (context.length === 1) {
                return function(elem) {
                  return context[0] === elem && next(elem);
                };
              }
              return function(elem) {
                return context.indexOf(elem) >= 0 && next(elem);
              };
            },
            checkbox: getAttribFunc('type', 'checkbox'),
            file: getAttribFunc('type', 'file'),
            password: getAttribFunc('type', 'password'),
            radio: getAttribFunc('type', 'radio'),
            reset: getAttribFunc('type', 'reset'),
            image: getAttribFunc('type', 'image'),
            submit: getAttribFunc('type', 'submit')
          };
          var pseudos = {
            empty: function(elem) {
              return !getChildren(elem).some(function(elem) {
                return isTag(elem) || elem.type === 'text';
              });
            },
            'first-child': function(elem) {
              return getFirstElement(getSiblings(elem)) === elem;
            },
            'last-child': function(elem) {
              var siblings = getSiblings(elem);
              for (var i = siblings.length - 1; i >= 0; i--) {
                if (siblings[i] === elem) return true;
                if (isTag(siblings[i])) break;
              }
              return false;
            },
            'first-of-type': function(elem) {
              var siblings = getSiblings(elem);
              for (var i = 0; i < siblings.length; i++) {
                if (isTag(siblings[i])) {
                  if (siblings[i] === elem) return true;
                  if (getName(siblings[i]) === getName(elem)) break;
                }
              }
              return false;
            },
            'last-of-type': function(elem) {
              var siblings = getSiblings(elem);
              for (var i = siblings.length - 1; i >= 0; i--) {
                if (isTag(siblings[i])) {
                  if (siblings[i] === elem) return true;
                  if (getName(siblings[i]) === getName(elem)) break;
                }
              }
              return false;
            },
            'only-of-type': function(elem) {
              var siblings = getSiblings(elem);
              for (var i = 0, j = siblings.length; i < j; i++) {
                if (isTag(siblings[i])) {
                  if (siblings[i] === elem) continue;
                  if (getName(siblings[i]) === getName(elem)) return false;
                }
              }
              return true;
            },
            'only-child': function(elem) {
              var siblings = getSiblings(elem);
              for (var i = 0; i < siblings.length; i++) {
                if (isTag(siblings[i]) && siblings[i] !== elem) return false;
              }
              return true;
            },
            link: function(elem) {
              return hasAttrib(elem, 'href');
            },
            visited: falseFunc,
            selected: function(elem) {
              if (hasAttrib(elem, 'selected')) return true;
              else if (getName(elem) !== 'option') return false;
              var parent = getParent(elem);
              if (
                !parent ||
                getName(parent) !== 'select' ||
                hasAttrib(parent, 'multiple')
              )
                return false;
              var siblings = getChildren(parent),
                sawElem = false;
              for (var i = 0; i < siblings.length; i++) {
                if (isTag(siblings[i])) {
                  if (siblings[i] === elem) {
                    sawElem = true;
                  } else if (!sawElem) {
                    return false;
                  } else if (hasAttrib(siblings[i], 'selected')) {
                    return false;
                  }
                }
              }
              return sawElem;
            },
            disabled: function(elem) {
              return hasAttrib(elem, 'disabled');
            },
            enabled: function(elem) {
              return !hasAttrib(elem, 'disabled');
            },
            checked: function(elem) {
              return hasAttrib(elem, 'checked') || pseudos.selected(elem);
            },
            required: function(elem) {
              return hasAttrib(elem, 'required');
            },
            optional: function(elem) {
              return !hasAttrib(elem, 'required');
            },
            parent: function(elem) {
              return !pseudos.empty(elem);
            },
            header: function(elem) {
              var name = getName(elem);
              return (
                name === 'h1' ||
                name === 'h2' ||
                name === 'h3' ||
                name === 'h4' ||
                name === 'h5' ||
                name === 'h6'
              );
            },
            button: function(elem) {
              var name = getName(elem);
              return (
                name === 'button' ||
                (name === 'input' && getAttribute(elem, 'type') === 'button')
              );
            },
            input: function(elem) {
              var name = getName(elem);
              return (
                name === 'input' ||
                name === 'textarea' ||
                name === 'select' ||
                name === 'button'
              );
            },
            text: function(elem) {
              var attr;
              return (
                getName(elem) === 'input' &&
                (!(attr = getAttribute(elem, 'type')) ||
                  attr.toLowerCase() === 'text')
              );
            }
          };
          function verifyArgs(func, name, subselect) {
            if (subselect === null) {
              if (func.length > 1 && name !== 'scope') {
                throw new SyntaxError(
                  'pseudo-selector :' + name + ' requires an argument'
                );
              }
            } else {
              if (func.length === 1) {
                throw new SyntaxError(
                  'pseudo-selector :' + name + " doesn't have any arguments"
                );
              }
            }
          }
          var re_CSS3 = /^(?:(?:nth|last|first|only)-(?:child|of-type)|root|empty|(?:en|dis)abled|checked|not)$/;
          module.exports = {
            compile: function(next, data, options, context) {
              var name = data.name,
                subselect = data.data;
              if (options && options.strict && !re_CSS3.test(name)) {
                throw SyntaxError(':' + name + " isn't part of CSS3");
              }
              if (typeof filters[name] === 'function') {
                verifyArgs(filters[name], name, subselect);
                return filters[name](next, subselect, options, context);
              } else if (typeof pseudos[name] === 'function') {
                var func = pseudos[name];
                verifyArgs(func, name, subselect);
                if (next === trueFunc) return func;
                return function pseudoArgs(elem) {
                  return func(elem, subselect) && next(elem);
                };
              } else {
                throw new SyntaxError('unmatched pseudo-class :' + name);
              }
            },
            filters: filters,
            pseudos: pseudos
          };
        },
        {
          './attributes.js': 289,
          boolbase: 135,
          domutils: 302,
          'nth-check': 445
        }
      ],
      294: [
        function(require, module, exports) {
          module.exports = sortByProcedure;
          var procedure = require('./procedure.json');
          var attributes = {
            __proto__: null,
            exists: 10,
            equals: 8,
            not: 7,
            start: 6,
            end: 6,
            any: 5,
            hyphen: 4,
            element: 4
          };
          function sortByProcedure(arr) {
            var procs = arr.map(getProcedure);
            for (var i = 1; i < arr.length; i++) {
              var procNew = procs[i];
              if (procNew < 0) continue;
              for (var j = i - 1; j >= 0 && procNew < procs[j]; j--) {
                var token = arr[j + 1];
                arr[j + 1] = arr[j];
                arr[j] = token;
                procs[j + 1] = procs[j];
                procs[j] = procNew;
              }
            }
          }
          function getProcedure(token) {
            var proc = procedure[token.type];
            if (proc === procedure.attribute) {
              proc = attributes[token.action];
              if (proc === attributes.equals && token.name === 'id') {
                proc = 9;
              }
              if (token.ignoreCase) {
                proc >>= 1;
              }
            } else if (proc === procedure.pseudo) {
              if (!token.data) {
                proc = 3;
              } else if (token.name === 'has' || token.name === 'contains') {
                proc = 0;
              } else if (token.name === 'matches' || token.name === 'not') {
                proc = 0;
                for (var i = 0; i < token.data.length; i++) {
                  if (token.data[i].length !== 1) continue;
                  var cur = getProcedure(token.data[i][0]);
                  if (cur === 0) {
                    proc = 0;
                    break;
                  }
                  if (cur > proc) proc = cur;
                }
                if (token.data.length > 1 && proc > 0) proc -= 1;
              } else {
                proc = 1;
              }
            }
            return proc;
          }
        },
        { './procedure.json': 292 }
      ],
      295: [
        function(require, module, exports) {
          'use strict';
          module.exports = parse;
          var re_name = /^(?:\\.|[\w\-\u00c0-\uFFFF])+/,
            re_escape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi,
            re_attr = /^\s*((?:\\.|[\w\u00c0-\uFFFF\-])+)\s*(?:(\S?)=\s*(?:(['"])(.*?)\3|(#?(?:\\.|[\w\u00c0-\uFFFF\-])*)|)|)\s*(i)?\]/;
          var actionTypes = {
            __proto__: null,
            undefined: 'exists',
            '': 'equals',
            '~': 'element',
            '^': 'start',
            $: 'end',
            '*': 'any',
            '!': 'not',
            '|': 'hyphen'
          };
          var simpleSelectors = {
            __proto__: null,
            '>': 'child',
            '<': 'parent',
            '~': 'sibling',
            '+': 'adjacent'
          };
          var attribSelectors = {
            __proto__: null,
            '#': ['id', 'equals'],
            '.': ['class', 'element']
          };
          var unpackPseudos = {
            __proto__: null,
            has: true,
            not: true,
            matches: true
          };
          var stripQuotesFromPseudos = {
            __proto__: null,
            contains: true,
            icontains: true
          };
          var quotes = { __proto__: null, '"': true, "'": true };
          function funescape(_, escaped, escapedWhitespace) {
            var high = '0x' + escaped - 65536;
            return high !== high || escapedWhitespace
              ? escaped
              : high < 0
              ? String.fromCharCode(high + 65536)
              : String.fromCharCode(
                  (high >> 10) | 55296,
                  (high & 1023) | 56320
                );
          }
          function unescapeCSS(str) {
            return str.replace(re_escape, funescape);
          }
          function isWhitespace(c) {
            return (
              c === ' ' || c === '\n' || c === '\t' || c === '\f' || c === '\r'
            );
          }
          function parse(selector, options) {
            var subselects = [];
            selector = parseSelector(subselects, selector + '', options);
            if (selector !== '') {
              throw new SyntaxError('Unmatched selector: ' + selector);
            }
            return subselects;
          }
          function parseSelector(subselects, selector, options) {
            var tokens = [],
              sawWS = false,
              data,
              firstChar,
              name,
              quot;
            function getName() {
              var sub = selector.match(re_name)[0];
              selector = selector.substr(sub.length);
              return unescapeCSS(sub);
            }
            function stripWhitespace(start) {
              while (isWhitespace(selector.charAt(start))) start++;
              selector = selector.substr(start);
            }
            stripWhitespace(0);
            while (selector !== '') {
              firstChar = selector.charAt(0);
              if (isWhitespace(firstChar)) {
                sawWS = true;
                stripWhitespace(1);
              } else if (firstChar in simpleSelectors) {
                tokens.push({ type: simpleSelectors[firstChar] });
                sawWS = false;
                stripWhitespace(1);
              } else if (firstChar === ',') {
                if (tokens.length === 0) {
                  throw new SyntaxError('empty sub-selector');
                }
                subselects.push(tokens);
                tokens = [];
                sawWS = false;
                stripWhitespace(1);
              } else {
                if (sawWS) {
                  if (tokens.length > 0) {
                    tokens.push({ type: 'descendant' });
                  }
                  sawWS = false;
                }
                if (firstChar === '*') {
                  selector = selector.substr(1);
                  tokens.push({ type: 'universal' });
                } else if (firstChar in attribSelectors) {
                  selector = selector.substr(1);
                  tokens.push({
                    type: 'attribute',
                    name: attribSelectors[firstChar][0],
                    action: attribSelectors[firstChar][1],
                    value: getName(),
                    ignoreCase: false
                  });
                } else if (firstChar === '[') {
                  selector = selector.substr(1);
                  data = selector.match(re_attr);
                  if (!data) {
                    throw new SyntaxError(
                      'Malformed attribute selector: ' + selector
                    );
                  }
                  selector = selector.substr(data[0].length);
                  name = unescapeCSS(data[1]);
                  if (
                    !options ||
                    ('lowerCaseAttributeNames' in options
                      ? options.lowerCaseAttributeNames
                      : !options.xmlMode)
                  ) {
                    name = name.toLowerCase();
                  }
                  tokens.push({
                    type: 'attribute',
                    name: name,
                    action: actionTypes[data[2]],
                    value: unescapeCSS(data[4] || data[5] || ''),
                    ignoreCase: !!data[6]
                  });
                } else if (firstChar === ':') {
                  if (selector.charAt(1) === ':') {
                    selector = selector.substr(2);
                    tokens.push({
                      type: 'pseudo-element',
                      name: getName().toLowerCase()
                    });
                    continue;
                  }
                  selector = selector.substr(1);
                  name = getName().toLowerCase();
                  data = null;
                  if (selector.charAt(0) === '(') {
                    if (name in unpackPseudos) {
                      quot = selector.charAt(1);
                      var quoted = quot in quotes;
                      selector = selector.substr(quoted + 1);
                      data = [];
                      selector = parseSelector(data, selector, options);
                      if (quoted) {
                        if (selector.charAt(0) !== quot) {
                          throw new SyntaxError('unmatched quotes in :' + name);
                        } else {
                          selector = selector.substr(1);
                        }
                      }
                      if (selector.charAt(0) !== ')') {
                        throw new SyntaxError(
                          'missing closing parenthesis in :' +
                            name +
                            ' ' +
                            selector
                        );
                      }
                      selector = selector.substr(1);
                    } else {
                      var pos = 1,
                        counter = 1;
                      for (; counter > 0 && pos < selector.length; pos++) {
                        if (selector.charAt(pos) === '(') counter++;
                        else if (selector.charAt(pos) === ')') counter--;
                      }
                      if (counter) {
                        throw new SyntaxError('parenthesis not matched');
                      }
                      data = selector.substr(1, pos - 2);
                      selector = selector.substr(pos);
                      if (name in stripQuotesFromPseudos) {
                        quot = data.charAt(0);
                        if (quot === data.slice(-1) && quot in quotes) {
                          data = data.slice(1, -1);
                        }
                        data = unescapeCSS(data);
                      }
                    }
                  }
                  tokens.push({ type: 'pseudo', name: name, data: data });
                } else if (re_name.test(selector)) {
                  name = getName();
                  if (
                    !options ||
                    ('lowerCaseTags' in options
                      ? options.lowerCaseTags
                      : !options.xmlMode)
                  ) {
                    name = name.toLowerCase();
                  }
                  tokens.push({ type: 'tag', name: name });
                } else {
                  if (
                    tokens.length &&
                    tokens[tokens.length - 1].type === 'descendant'
                  ) {
                    tokens.pop();
                  }
                  addToken(subselects, tokens);
                  return selector;
                }
              }
            }
            addToken(subselects, tokens);
            return selector;
          }
          function addToken(subselects, tokens) {
            if (subselects.length > 0 && tokens.length === 0) {
              throw new SyntaxError('empty sub-selector');
            }
            subselects.push(tokens);
          }
        },
        {}
      ],
      296: [
        function(require, module, exports) {
          var ElementType = require('domelementtype');
          var entities = require('entities');
          var booleanAttributes = {
            __proto__: null,
            allowfullscreen: true,
            async: true,
            autofocus: true,
            autoplay: true,
            checked: true,
            controls: true,
            default: true,
            defer: true,
            disabled: true,
            hidden: true,
            ismap: true,
            loop: true,
            multiple: true,
            muted: true,
            open: true,
            readonly: true,
            required: true,
            reversed: true,
            scoped: true,
            seamless: true,
            selected: true,
            typemustmatch: true
          };
          var unencodedElements = {
            __proto__: null,
            style: true,
            script: true,
            xmp: true,
            iframe: true,
            noembed: true,
            noframes: true,
            plaintext: true,
            noscript: true
          };
          function formatAttrs(attributes, opts) {
            if (!attributes) return;
            var output = '',
              value;
            for (var key in attributes) {
              value = attributes[key];
              if (output) {
                output += ' ';
              }
              if (!value && booleanAttributes[key]) {
                output += key;
              } else {
                output +=
                  key +
                  '="' +
                  (opts.decodeEntities ? entities.encodeXML(value) : value) +
                  '"';
              }
            }
            return output;
          }
          var singleTag = {
            __proto__: null,
            area: true,
            base: true,
            basefont: true,
            br: true,
            col: true,
            command: true,
            embed: true,
            frame: true,
            hr: true,
            img: true,
            input: true,
            isindex: true,
            keygen: true,
            link: true,
            meta: true,
            param: true,
            source: true,
            track: true,
            wbr: true
          };
          var render = (module.exports = function(dom, opts) {
            if (!Array.isArray(dom) && !dom.cheerio) dom = [dom];
            opts = opts || {};
            var output = '';
            for (var i = 0; i < dom.length; i++) {
              var elem = dom[i];
              if (elem.type === 'root') output += render(elem.children, opts);
              else if (ElementType.isTag(elem)) output += renderTag(elem, opts);
              else if (elem.type === ElementType.Directive)
                output += renderDirective(elem);
              else if (elem.type === ElementType.Comment)
                output += renderComment(elem);
              else if (elem.type === ElementType.CDATA)
                output += renderCdata(elem);
              else output += renderText(elem, opts);
            }
            return output;
          });
          function renderTag(elem, opts) {
            if (elem.name === 'svg')
              opts = { decodeEntities: opts.decodeEntities, xmlMode: true };
            var tag = '<' + elem.name,
              attribs = formatAttrs(elem.attribs, opts);
            if (attribs) {
              tag += ' ' + attribs;
            }
            if (
              opts.xmlMode &&
              (!elem.children || elem.children.length === 0)
            ) {
              tag += '/>';
            } else {
              tag += '>';
              if (elem.children) {
                tag += render(elem.children, opts);
              }
              if (!singleTag[elem.name] || opts.xmlMode) {
                tag += '</' + elem.name + '>';
              }
            }
            return tag;
          }
          function renderDirective(elem) {
            return '<' + elem.data + '>';
          }
          function renderText(elem, opts) {
            var data = elem.data || '';
            if (
              opts.decodeEntities &&
              !(elem.parent && elem.parent.name in unencodedElements)
            ) {
              data = entities.encodeXML(data);
            }
            return data;
          }
          function renderCdata(elem) {
            return '<![CDATA[' + elem.children[0].data + ']]>';
          }
          function renderComment(elem) {
            return '\x3c!--' + elem.data + '--\x3e';
          }
        },
        { domelementtype: 297, entities: 343 }
      ],
      297: [
        function(require, module, exports) {
          module.exports = {
            Text: 'text',
            Directive: 'directive',
            Comment: 'comment',
            Script: 'script',
            Style: 'style',
            Tag: 'tag',
            CDATA: 'cdata',
            isTag: function(elem) {
              return (
                elem.type === 'tag' ||
                elem.type === 'script' ||
                elem.type === 'style'
              );
            }
          };
        },
        {}
      ],
      298: [
        function(require, module, exports) {
          module.exports = {
            Text: 'text',
            Directive: 'directive',
            Comment: 'comment',
            Script: 'script',
            Style: 'style',
            Tag: 'tag',
            CDATA: 'cdata',
            Doctype: 'doctype',
            isTag: function(elem) {
              return (
                elem.type === 'tag' ||
                elem.type === 'script' ||
                elem.type === 'style'
              );
            }
          };
        },
        {}
      ],
      299: [
        function(require, module, exports) {
          var ElementType = require('domelementtype');
          var re_whitespace = /\s+/g;
          var NodePrototype = require('./lib/node');
          var ElementPrototype = require('./lib/element');
          function DomHandler(callback, options, elementCB) {
            if (typeof callback === 'object') {
              elementCB = options;
              options = callback;
              callback = null;
            } else if (typeof options === 'function') {
              elementCB = options;
              options = defaultOpts;
            }
            this._callback = callback;
            this._options = options || defaultOpts;
            this._elementCB = elementCB;
            this.dom = [];
            this._done = false;
            this._tagStack = [];
            this._parser = this._parser || null;
          }
          var defaultOpts = {
            normalizeWhitespace: false,
            withStartIndices: false,
            withEndIndices: false
          };
          DomHandler.prototype.onparserinit = function(parser) {
            this._parser = parser;
          };
          DomHandler.prototype.onreset = function() {
            DomHandler.call(
              this,
              this._callback,
              this._options,
              this._elementCB
            );
          };
          DomHandler.prototype.onend = function() {
            if (this._done) return;
            this._done = true;
            this._parser = null;
            this._handleCallback(null);
          };
          DomHandler.prototype._handleCallback = DomHandler.prototype.onerror = function(
            error
          ) {
            if (typeof this._callback === 'function') {
              this._callback(error, this.dom);
            } else {
              if (error) throw error;
            }
          };
          DomHandler.prototype.onclosetag = function() {
            var elem = this._tagStack.pop();
            if (this._options.withEndIndices) {
              elem.endIndex = this._parser.endIndex;
            }
            if (this._elementCB) this._elementCB(elem);
          };
          DomHandler.prototype._createDomElement = function(properties) {
            if (!this._options.withDomLvl1) return properties;
            var element;
            if (properties.type === 'tag') {
              element = Object.create(ElementPrototype);
            } else {
              element = Object.create(NodePrototype);
            }
            for (var key in properties) {
              if (properties.hasOwnProperty(key)) {
                element[key] = properties[key];
              }
            }
            return element;
          };
          DomHandler.prototype._addDomElement = function(element) {
            var parent = this._tagStack[this._tagStack.length - 1];
            var siblings = parent ? parent.children : this.dom;
            var previousSibling = siblings[siblings.length - 1];
            element.next = null;
            if (this._options.withStartIndices) {
              element.startIndex = this._parser.startIndex;
            }
            if (this._options.withEndIndices) {
              element.endIndex = this._parser.endIndex;
            }
            if (previousSibling) {
              element.prev = previousSibling;
              previousSibling.next = element;
            } else {
              element.prev = null;
            }
            siblings.push(element);
            element.parent = parent || null;
          };
          DomHandler.prototype.onopentag = function(name, attribs) {
            var properties = {
              type:
                name === 'script'
                  ? ElementType.Script
                  : name === 'style'
                  ? ElementType.Style
                  : ElementType.Tag,
              name: name,
              attribs: attribs,
              children: []
            };
            var element = this._createDomElement(properties);
            this._addDomElement(element);
            this._tagStack.push(element);
          };
          DomHandler.prototype.ontext = function(data) {
            var normalize =
              this._options.normalizeWhitespace ||
              this._options.ignoreWhitespace;
            var lastTag;
            if (
              !this._tagStack.length &&
              this.dom.length &&
              (lastTag = this.dom[this.dom.length - 1]).type ===
                ElementType.Text
            ) {
              if (normalize) {
                lastTag.data = (lastTag.data + data).replace(
                  re_whitespace,
                  ' '
                );
              } else {
                lastTag.data += data;
              }
            } else {
              if (
                this._tagStack.length &&
                (lastTag = this._tagStack[this._tagStack.length - 1]) &&
                (lastTag = lastTag.children[lastTag.children.length - 1]) &&
                lastTag.type === ElementType.Text
              ) {
                if (normalize) {
                  lastTag.data = (lastTag.data + data).replace(
                    re_whitespace,
                    ' '
                  );
                } else {
                  lastTag.data += data;
                }
              } else {
                if (normalize) {
                  data = data.replace(re_whitespace, ' ');
                }
                var element = this._createDomElement({
                  data: data,
                  type: ElementType.Text
                });
                this._addDomElement(element);
              }
            }
          };
          DomHandler.prototype.oncomment = function(data) {
            var lastTag = this._tagStack[this._tagStack.length - 1];
            if (lastTag && lastTag.type === ElementType.Comment) {
              lastTag.data += data;
              return;
            }
            var properties = { data: data, type: ElementType.Comment };
            var element = this._createDomElement(properties);
            this._addDomElement(element);
            this._tagStack.push(element);
          };
          DomHandler.prototype.oncdatastart = function() {
            var properties = {
              children: [{ data: '', type: ElementType.Text }],
              type: ElementType.CDATA
            };
            var element = this._createDomElement(properties);
            this._addDomElement(element);
            this._tagStack.push(element);
          };
          DomHandler.prototype.oncommentend = DomHandler.prototype.oncdataend = function() {
            this._tagStack.pop();
          };
          DomHandler.prototype.onprocessinginstruction = function(name, data) {
            var element = this._createDomElement({
              name: name,
              data: data,
              type: ElementType.Directive
            });
            this._addDomElement(element);
          };
          module.exports = DomHandler;
        },
        { './lib/element': 300, './lib/node': 301, domelementtype: 298 }
      ],
      300: [
        function(require, module, exports) {
          var NodePrototype = require('./node');
          var ElementPrototype = (module.exports = Object.create(
            NodePrototype
          ));
          var domLvl1 = { tagName: 'name' };
          Object.keys(domLvl1).forEach(function(key) {
            var shorthand = domLvl1[key];
            Object.defineProperty(ElementPrototype, key, {
              get: function() {
                return this[shorthand] || null;
              },
              set: function(val) {
                this[shorthand] = val;
                return val;
              }
            });
          });
        },
        { './node': 301 }
      ],
      301: [
        function(require, module, exports) {
          var NodePrototype = (module.exports = {
            get firstChild() {
              var children = this.children;
              return (children && children[0]) || null;
            },
            get lastChild() {
              var children = this.children;
              return (children && children[children.length - 1]) || null;
            },
            get nodeType() {
              return nodeTypes[this.type] || nodeTypes.element;
            }
          });
          var domLvl1 = {
            tagName: 'name',
            childNodes: 'children',
            parentNode: 'parent',
            previousSibling: 'prev',
            nextSibling: 'next',
            nodeValue: 'data'
          };
          var nodeTypes = { element: 1, text: 3, cdata: 4, comment: 8 };
          Object.keys(domLvl1).forEach(function(key) {
            var shorthand = domLvl1[key];
            Object.defineProperty(NodePrototype, key, {
              get: function() {
                return this[shorthand] || null;
              },
              set: function(val) {
                this[shorthand] = val;
                return val;
              }
            });
          });
        },
        {}
      ],
      302: [
        function(require, module, exports) {
          var DomUtils = module.exports;
          [
            require('./lib/stringify'),
            require('./lib/traversal'),
            require('./lib/manipulation'),
            require('./lib/querying'),
            require('./lib/legacy'),
            require('./lib/helpers')
          ].forEach(function(ext) {
            Object.keys(ext).forEach(function(key) {
              DomUtils[key] = ext[key].bind(DomUtils);
            });
          });
        },
        {
          './lib/helpers': 303,
          './lib/legacy': 304,
          './lib/manipulation': 305,
          './lib/querying': 306,
          './lib/stringify': 307,
          './lib/traversal': 308
        }
      ],
      303: [
        function(require, module, exports) {
          exports.removeSubsets = function(nodes) {
            var idx = nodes.length,
              node,
              ancestor,
              replace;
            while (--idx > -1) {
              node = ancestor = nodes[idx];
              nodes[idx] = null;
              replace = true;
              while (ancestor) {
                if (nodes.indexOf(ancestor) > -1) {
                  replace = false;
                  nodes.splice(idx, 1);
                  break;
                }
                ancestor = ancestor.parent;
              }
              if (replace) {
                nodes[idx] = node;
              }
            }
            return nodes;
          };
          var POSITION = {
            DISCONNECTED: 1,
            PRECEDING: 2,
            FOLLOWING: 4,
            CONTAINS: 8,
            CONTAINED_BY: 16
          };
          var comparePos = (exports.compareDocumentPosition = function(
            nodeA,
            nodeB
          ) {
            var aParents = [];
            var bParents = [];
            var current, sharedParent, siblings, aSibling, bSibling, idx;
            if (nodeA === nodeB) {
              return 0;
            }
            current = nodeA;
            while (current) {
              aParents.unshift(current);
              current = current.parent;
            }
            current = nodeB;
            while (current) {
              bParents.unshift(current);
              current = current.parent;
            }
            idx = 0;
            while (aParents[idx] === bParents[idx]) {
              idx++;
            }
            if (idx === 0) {
              return POSITION.DISCONNECTED;
            }
            sharedParent = aParents[idx - 1];
            siblings = sharedParent.children;
            aSibling = aParents[idx];
            bSibling = bParents[idx];
            if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
              if (sharedParent === nodeB) {
                return POSITION.FOLLOWING | POSITION.CONTAINED_BY;
              }
              return POSITION.FOLLOWING;
            } else {
              if (sharedParent === nodeA) {
                return POSITION.PRECEDING | POSITION.CONTAINS;
              }
              return POSITION.PRECEDING;
            }
          });
          exports.uniqueSort = function(nodes) {
            var idx = nodes.length,
              node,
              position;
            nodes = nodes.slice();
            while (--idx > -1) {
              node = nodes[idx];
              position = nodes.indexOf(node);
              if (position > -1 && position < idx) {
                nodes.splice(idx, 1);
              }
            }
            nodes.sort(function(a, b) {
              var relative = comparePos(a, b);
              if (relative & POSITION.PRECEDING) {
                return -1;
              } else if (relative & POSITION.FOLLOWING) {
                return 1;
              }
              return 0;
            });
            return nodes;
          };
        },
        {}
      ],
      304: [
        function(require, module, exports) {
          var ElementType = require('domelementtype');
          var isTag = (exports.isTag = ElementType.isTag);
          exports.testElement = function(options, element) {
            for (var key in options) {
              if (!options.hasOwnProperty(key));
              else if (key === 'tag_name') {
                if (!isTag(element) || !options.tag_name(element.name)) {
                  return false;
                }
              } else if (key === 'tag_type') {
                if (!options.tag_type(element.type)) return false;
              } else if (key === 'tag_contains') {
                if (isTag(element) || !options.tag_contains(element.data)) {
                  return false;
                }
              } else if (
                !element.attribs ||
                !options[key](element.attribs[key])
              ) {
                return false;
              }
            }
            return true;
          };
          var Checks = {
            tag_name: function(name) {
              if (typeof name === 'function') {
                return function(elem) {
                  return isTag(elem) && name(elem.name);
                };
              } else if (name === '*') {
                return isTag;
              } else {
                return function(elem) {
                  return isTag(elem) && elem.name === name;
                };
              }
            },
            tag_type: function(type) {
              if (typeof type === 'function') {
                return function(elem) {
                  return type(elem.type);
                };
              } else {
                return function(elem) {
                  return elem.type === type;
                };
              }
            },
            tag_contains: function(data) {
              if (typeof data === 'function') {
                return function(elem) {
                  return !isTag(elem) && data(elem.data);
                };
              } else {
                return function(elem) {
                  return !isTag(elem) && elem.data === data;
                };
              }
            }
          };
          function getAttribCheck(attrib, value) {
            if (typeof value === 'function') {
              return function(elem) {
                return elem.attribs && value(elem.attribs[attrib]);
              };
            } else {
              return function(elem) {
                return elem.attribs && elem.attribs[attrib] === value;
              };
            }
          }
          function combineFuncs(a, b) {
            return function(elem) {
              return a(elem) || b(elem);
            };
          }
          exports.getElements = function(options, element, recurse, limit) {
            var funcs = Object.keys(options).map(function(key) {
              var value = options[key];
              return key in Checks
                ? Checks[key](value)
                : getAttribCheck(key, value);
            });
            return funcs.length === 0
              ? []
              : this.filter(
                  funcs.reduce(combineFuncs),
                  element,
                  recurse,
                  limit
                );
          };
          exports.getElementById = function(id, element, recurse) {
            if (!Array.isArray(element)) element = [element];
            return this.findOne(
              getAttribCheck('id', id),
              element,
              recurse !== false
            );
          };
          exports.getElementsByTagName = function(
            name,
            element,
            recurse,
            limit
          ) {
            return this.filter(Checks.tag_name(name), element, recurse, limit);
          };
          exports.getElementsByTagType = function(
            type,
            element,
            recurse,
            limit
          ) {
            return this.filter(Checks.tag_type(type), element, recurse, limit);
          };
        },
        { domelementtype: 298 }
      ],
      305: [
        function(require, module, exports) {
          exports.removeElement = function(elem) {
            if (elem.prev) elem.prev.next = elem.next;
            if (elem.next) elem.next.prev = elem.prev;
            if (elem.parent) {
              var childs = elem.parent.children;
              childs.splice(childs.lastIndexOf(elem), 1);
            }
          };
          exports.replaceElement = function(elem, replacement) {
            var prev = (replacement.prev = elem.prev);
            if (prev) {
              prev.next = replacement;
            }
            var next = (replacement.next = elem.next);
            if (next) {
              next.prev = replacement;
            }
            var parent = (replacement.parent = elem.parent);
            if (parent) {
              var childs = parent.children;
              childs[childs.lastIndexOf(elem)] = replacement;
            }
          };
          exports.appendChild = function(elem, child) {
            child.parent = elem;
            if (elem.children.push(child) !== 1) {
              var sibling = elem.children[elem.children.length - 2];
              sibling.next = child;
              child.prev = sibling;
              child.next = null;
            }
          };
          exports.append = function(elem, next) {
            var parent = elem.parent,
              currNext = elem.next;
            next.next = currNext;
            next.prev = elem;
            elem.next = next;
            next.parent = parent;
            if (currNext) {
              currNext.prev = next;
              if (parent) {
                var childs = parent.children;
                childs.splice(childs.lastIndexOf(currNext), 0, next);
              }
            } else if (parent) {
              parent.children.push(next);
            }
          };
          exports.prepend = function(elem, prev) {
            var parent = elem.parent;
            if (parent) {
              var childs = parent.children;
              childs.splice(childs.lastIndexOf(elem), 0, prev);
            }
            if (elem.prev) {
              elem.prev.next = prev;
            }
            prev.parent = parent;
            prev.prev = elem.prev;
            prev.next = elem;
            elem.prev = prev;
          };
        },
        {}
      ],
      306: [
        function(require, module, exports) {
          var isTag = require('domelementtype').isTag;
          module.exports = {
            filter: filter,
            find: find,
            findOneChild: findOneChild,
            findOne: findOne,
            existsOne: existsOne,
            findAll: findAll
          };
          function filter(test, element, recurse, limit) {
            if (!Array.isArray(element)) element = [element];
            if (typeof limit !== 'number' || !isFinite(limit)) {
              limit = Infinity;
            }
            return find(test, element, recurse !== false, limit);
          }
          function find(test, elems, recurse, limit) {
            var result = [],
              childs;
            for (var i = 0, j = elems.length; i < j; i++) {
              if (test(elems[i])) {
                result.push(elems[i]);
                if (--limit <= 0) break;
              }
              childs = elems[i].children;
              if (recurse && childs && childs.length > 0) {
                childs = find(test, childs, recurse, limit);
                result = result.concat(childs);
                limit -= childs.length;
                if (limit <= 0) break;
              }
            }
            return result;
          }
          function findOneChild(test, elems) {
            for (var i = 0, l = elems.length; i < l; i++) {
              if (test(elems[i])) return elems[i];
            }
            return null;
          }
          function findOne(test, elems) {
            var elem = null;
            for (var i = 0, l = elems.length; i < l && !elem; i++) {
              if (!isTag(elems[i])) {
                continue;
              } else if (test(elems[i])) {
                elem = elems[i];
              } else if (elems[i].children.length > 0) {
                elem = findOne(test, elems[i].children);
              }
            }
            return elem;
          }
          function existsOne(test, elems) {
            for (var i = 0, l = elems.length; i < l; i++) {
              if (
                isTag(elems[i]) &&
                (test(elems[i]) ||
                  (elems[i].children.length > 0 &&
                    existsOne(test, elems[i].children)))
              ) {
                return true;
              }
            }
            return false;
          }
          function findAll(test, elems) {
            var result = [];
            for (var i = 0, j = elems.length; i < j; i++) {
              if (!isTag(elems[i])) continue;
              if (test(elems[i])) result.push(elems[i]);
              if (elems[i].children.length > 0) {
                result = result.concat(findAll(test, elems[i].children));
              }
            }
            return result;
          }
        },
        { domelementtype: 298 }
      ],
      307: [
        function(require, module, exports) {
          var ElementType = require('domelementtype'),
            getOuterHTML = require('dom-serializer'),
            isTag = ElementType.isTag;
          module.exports = {
            getInnerHTML: getInnerHTML,
            getOuterHTML: getOuterHTML,
            getText: getText
          };
          function getInnerHTML(elem, opts) {
            return elem.children
              ? elem.children
                  .map(function(elem) {
                    return getOuterHTML(elem, opts);
                  })
                  .join('')
              : '';
          }
          function getText(elem) {
            if (Array.isArray(elem)) return elem.map(getText).join('');
            if (isTag(elem) || elem.type === ElementType.CDATA)
              return getText(elem.children);
            if (elem.type === ElementType.Text) return elem.data;
            return '';
          }
        },
        { 'dom-serializer': 296, domelementtype: 298 }
      ],
      308: [
        function(require, module, exports) {
          var getChildren = (exports.getChildren = function(elem) {
            return elem.children;
          });
          var getParent = (exports.getParent = function(elem) {
            return elem.parent;
          });
          exports.getSiblings = function(elem) {
            var parent = getParent(elem);
            return parent ? getChildren(parent) : [elem];
          };
          exports.getAttributeValue = function(elem, name) {
            return elem.attribs && elem.attribs[name];
          };
          exports.hasAttrib = function(elem, name) {
            return !!elem.attribs && hasOwnProperty.call(elem.attribs, name);
          };
          exports.getName = function(elem) {
            return elem.name;
          };
        },
        {}
      ],
      309: [
        function(require, module, exports) {
          'use strict';
          var elliptic = exports;
          elliptic.version = require('../package.json').version;
          elliptic.utils = require('./elliptic/utils');
          elliptic.rand = require('brorand');
          elliptic.curve = require('./elliptic/curve');
          elliptic.curves = require('./elliptic/curves');
          elliptic.ec = require('./elliptic/ec');
          elliptic.eddsa = require('./elliptic/eddsa');
        },
        {
          '../package.json': 342,
          './elliptic/curve': 312,
          './elliptic/curves': 315,
          './elliptic/ec': 316,
          './elliptic/eddsa': 319,
          './elliptic/utils': 323,
          brorand: 325
        }
      ],
      310: [
        function(require, module, exports) {
          'use strict';
          var BN = require('bn.js');
          var elliptic = require('../../elliptic');
          var utils = elliptic.utils;
          var getNAF = utils.getNAF;
          var getJSF = utils.getJSF;
          var assert = utils.assert;
          function BaseCurve(type, conf) {
            this.type = type;
            this.p = new BN(conf.p, 16);
            this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
            this.zero = new BN(0).toRed(this.red);
            this.one = new BN(1).toRed(this.red);
            this.two = new BN(2).toRed(this.red);
            this.n = conf.n && new BN(conf.n, 16);
            this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
            this._wnafT1 = new Array(4);
            this._wnafT2 = new Array(4);
            this._wnafT3 = new Array(4);
            this._wnafT4 = new Array(4);
            var adjustCount = this.n && this.p.div(this.n);
            if (!adjustCount || adjustCount.cmpn(100) > 0) {
              this.redN = null;
            } else {
              this._maxwellTrick = true;
              this.redN = this.n.toRed(this.red);
            }
          }
          module.exports = BaseCurve;
          BaseCurve.prototype.point = function point() {
            throw new Error('Not implemented');
          };
          BaseCurve.prototype.validate = function validate() {
            throw new Error('Not implemented');
          };
          BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
            assert(p.precomputed);
            var doubles = p._getDoubles();
            var naf = getNAF(k, 1);
            var I =
              (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
            I /= 3;
            var repr = [];
            for (var j = 0; j < naf.length; j += doubles.step) {
              var nafW = 0;
              for (var k = j + doubles.step - 1; k >= j; k--)
                nafW = (nafW << 1) + naf[k];
              repr.push(nafW);
            }
            var a = this.jpoint(null, null, null);
            var b = this.jpoint(null, null, null);
            for (var i = I; i > 0; i--) {
              for (var j = 0; j < repr.length; j++) {
                var nafW = repr[j];
                if (nafW === i) b = b.mixedAdd(doubles.points[j]);
                else if (nafW === -i) b = b.mixedAdd(doubles.points[j].neg());
              }
              a = a.add(b);
            }
            return a.toP();
          };
          BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
            var w = 4;
            var nafPoints = p._getNAFPoints(w);
            w = nafPoints.wnd;
            var wnd = nafPoints.points;
            var naf = getNAF(k, w);
            var acc = this.jpoint(null, null, null);
            for (var i = naf.length - 1; i >= 0; i--) {
              for (var k = 0; i >= 0 && naf[i] === 0; i--) k++;
              if (i >= 0) k++;
              acc = acc.dblp(k);
              if (i < 0) break;
              var z = naf[i];
              assert(z !== 0);
              if (p.type === 'affine') {
                if (z > 0) acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
                else acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
              } else {
                if (z > 0) acc = acc.add(wnd[(z - 1) >> 1]);
                else acc = acc.add(wnd[(-z - 1) >> 1].neg());
              }
            }
            return p.type === 'affine' ? acc.toP() : acc;
          };
          BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(
            defW,
            points,
            coeffs,
            len,
            jacobianResult
          ) {
            var wndWidth = this._wnafT1;
            var wnd = this._wnafT2;
            var naf = this._wnafT3;
            var max = 0;
            for (var i = 0; i < len; i++) {
              var p = points[i];
              var nafPoints = p._getNAFPoints(defW);
              wndWidth[i] = nafPoints.wnd;
              wnd[i] = nafPoints.points;
            }
            for (var i = len - 1; i >= 1; i -= 2) {
              var a = i - 1;
              var b = i;
              if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
                naf[a] = getNAF(coeffs[a], wndWidth[a]);
                naf[b] = getNAF(coeffs[b], wndWidth[b]);
                max = Math.max(naf[a].length, max);
                max = Math.max(naf[b].length, max);
                continue;
              }
              var comb = [points[a], null, null, points[b]];
              if (points[a].y.cmp(points[b].y) === 0) {
                comb[1] = points[a].add(points[b]);
                comb[2] = points[a].toJ().mixedAdd(points[b].neg());
              } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
                comb[1] = points[a].toJ().mixedAdd(points[b]);
                comb[2] = points[a].add(points[b].neg());
              } else {
                comb[1] = points[a].toJ().mixedAdd(points[b]);
                comb[2] = points[a].toJ().mixedAdd(points[b].neg());
              }
              var index = [-3, -1, -5, -7, 0, 7, 5, 1, 3];
              var jsf = getJSF(coeffs[a], coeffs[b]);
              max = Math.max(jsf[0].length, max);
              naf[a] = new Array(max);
              naf[b] = new Array(max);
              for (var j = 0; j < max; j++) {
                var ja = jsf[0][j] | 0;
                var jb = jsf[1][j] | 0;
                naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
                naf[b][j] = 0;
                wnd[a] = comb;
              }
            }
            var acc = this.jpoint(null, null, null);
            var tmp = this._wnafT4;
            for (var i = max; i >= 0; i--) {
              var k = 0;
              while (i >= 0) {
                var zero = true;
                for (var j = 0; j < len; j++) {
                  tmp[j] = naf[j][i] | 0;
                  if (tmp[j] !== 0) zero = false;
                }
                if (!zero) break;
                k++;
                i--;
              }
              if (i >= 0) k++;
              acc = acc.dblp(k);
              if (i < 0) break;
              for (var j = 0; j < len; j++) {
                var z = tmp[j];
                var p;
                if (z === 0) continue;
                else if (z > 0) p = wnd[j][(z - 1) >> 1];
                else if (z < 0) p = wnd[j][(-z - 1) >> 1].neg();
                if (p.type === 'affine') acc = acc.mixedAdd(p);
                else acc = acc.add(p);
              }
            }
            for (var i = 0; i < len; i++) wnd[i] = null;
            if (jacobianResult) return acc;
            else return acc.toP();
          };
          function BasePoint(curve, type) {
            this.curve = curve;
            this.type = type;
            this.precomputed = null;
          }
          BaseCurve.BasePoint = BasePoint;
          BasePoint.prototype.eq = function eq() {
            throw new Error('Not implemented');
          };
          BasePoint.prototype.validate = function validate() {
            return this.curve.validate(this);
          };
          BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
            bytes = utils.toArray(bytes, enc);
            var len = this.p.byteLength();
            if (
              (bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) &&
              bytes.length - 1 === 2 * len
            ) {
              if (bytes[0] === 6) assert(bytes[bytes.length - 1] % 2 === 0);
              else if (bytes[0] === 7)
                assert(bytes[bytes.length - 1] % 2 === 1);
              var res = this.point(
                bytes.slice(1, 1 + len),
                bytes.slice(1 + len, 1 + 2 * len)
              );
              return res;
            } else if (
              (bytes[0] === 2 || bytes[0] === 3) &&
              bytes.length - 1 === len
            ) {
              return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
            }
            throw new Error('Unknown point format');
          };
          BasePoint.prototype.encodeCompressed = function encodeCompressed(
            enc
          ) {
            return this.encode(enc, true);
          };
          BasePoint.prototype._encode = function _encode(compact) {
            var len = this.curve.p.byteLength();
            var x = this.getX().toArray('be', len);
            if (compact) return [this.getY().isEven() ? 2 : 3].concat(x);
            return [4].concat(x, this.getY().toArray('be', len));
          };
          BasePoint.prototype.encode = function encode(enc, compact) {
            return utils.encode(this._encode(compact), enc);
          };
          BasePoint.prototype.precompute = function precompute(power) {
            if (this.precomputed) return this;
            var precomputed = { doubles: null, naf: null, beta: null };
            precomputed.naf = this._getNAFPoints(8);
            precomputed.doubles = this._getDoubles(4, power);
            precomputed.beta = this._getBeta();
            this.precomputed = precomputed;
            return this;
          };
          BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
            if (!this.precomputed) return false;
            var doubles = this.precomputed.doubles;
            if (!doubles) return false;
            return (
              doubles.points.length >=
              Math.ceil((k.bitLength() + 1) / doubles.step)
            );
          };
          BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
            if (this.precomputed && this.precomputed.doubles)
              return this.precomputed.doubles;
            var doubles = [this];
            var acc = this;
            for (var i = 0; i < power; i += step) {
              for (var j = 0; j < step; j++) acc = acc.dbl();
              doubles.push(acc);
            }
            return { step: step, points: doubles };
          };
          BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
            if (this.precomputed && this.precomputed.naf)
              return this.precomputed.naf;
            var res = [this];
            var max = (1 << wnd) - 1;
            var dbl = max === 1 ? null : this.dbl();
            for (var i = 1; i < max; i++) res[i] = res[i - 1].add(dbl);
            return { wnd: wnd, points: res };
          };
          BasePoint.prototype._getBeta = function _getBeta() {
            return null;
          };
          BasePoint.prototype.dblp = function dblp(k) {
            var r = this;
            for (var i = 0; i < k; i++) r = r.dbl();
            return r;
          };
        },
        { '../../elliptic': 309, 'bn.js': 324 }
      ],
      311: [
        function(require, module, exports) {
          'use strict';
          var curve = require('../curve');
          var elliptic = require('../../elliptic');
          var BN = require('bn.js');
          var inherits = require('inherits');
          var Base = curve.base;
          var assert = elliptic.utils.assert;
          function EdwardsCurve(conf) {
            this.twisted = (conf.a | 0) !== 1;
            this.mOneA = this.twisted && (conf.a | 0) === -1;
            this.extended = this.mOneA;
            Base.call(this, 'edwards', conf);
            this.a = new BN(conf.a, 16).umod(this.red.m);
            this.a = this.a.toRed(this.red);
            this.c = new BN(conf.c, 16).toRed(this.red);
            this.c2 = this.c.redSqr();
            this.d = new BN(conf.d, 16).toRed(this.red);
            this.dd = this.d.redAdd(this.d);
            assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
            this.oneC = (conf.c | 0) === 1;
          }
          inherits(EdwardsCurve, Base);
          module.exports = EdwardsCurve;
          EdwardsCurve.prototype._mulA = function _mulA(num) {
            if (this.mOneA) return num.redNeg();
            else return this.a.redMul(num);
          };
          EdwardsCurve.prototype._mulC = function _mulC(num) {
            if (this.oneC) return num;
            else return this.c.redMul(num);
          };
          EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
            return this.point(x, y, z, t);
          };
          EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
            x = new BN(x, 16);
            if (!x.red) x = x.toRed(this.red);
            var x2 = x.redSqr();
            var rhs = this.c2.redSub(this.a.redMul(x2));
            var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
            var y2 = rhs.redMul(lhs.redInvm());
            var y = y2.redSqrt();
            if (
              y
                .redSqr()
                .redSub(y2)
                .cmp(this.zero) !== 0
            )
              throw new Error('invalid point');
            var isOdd = y.fromRed().isOdd();
            if ((odd && !isOdd) || (!odd && isOdd)) y = y.redNeg();
            return this.point(x, y);
          };
          EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
            y = new BN(y, 16);
            if (!y.red) y = y.toRed(this.red);
            var y2 = y.redSqr();
            var lhs = y2.redSub(this.one);
            var rhs = y2.redMul(this.d).redAdd(this.one);
            var x2 = lhs.redMul(rhs.redInvm());
            if (x2.cmp(this.zero) === 0) {
              if (odd) throw new Error('invalid point');
              else return this.point(this.zero, y);
            }
            var x = x2.redSqrt();
            if (
              x
                .redSqr()
                .redSub(x2)
                .cmp(this.zero) !== 0
            )
              throw new Error('invalid point');
            if (x.isOdd() !== odd) x = x.redNeg();
            return this.point(x, y);
          };
          EdwardsCurve.prototype.validate = function validate(point) {
            if (point.isInfinity()) return true;
            point.normalize();
            var x2 = point.x.redSqr();
            var y2 = point.y.redSqr();
            var lhs = x2.redMul(this.a).redAdd(y2);
            var rhs = this.c2.redMul(
              this.one.redAdd(this.d.redMul(x2).redMul(y2))
            );
            return lhs.cmp(rhs) === 0;
          };
          function Point(curve, x, y, z, t) {
            Base.BasePoint.call(this, curve, 'projective');
            if (x === null && y === null && z === null) {
              this.x = this.curve.zero;
              this.y = this.curve.one;
              this.z = this.curve.one;
              this.t = this.curve.zero;
              this.zOne = true;
            } else {
              this.x = new BN(x, 16);
              this.y = new BN(y, 16);
              this.z = z ? new BN(z, 16) : this.curve.one;
              this.t = t && new BN(t, 16);
              if (!this.x.red) this.x = this.x.toRed(this.curve.red);
              if (!this.y.red) this.y = this.y.toRed(this.curve.red);
              if (!this.z.red) this.z = this.z.toRed(this.curve.red);
              if (this.t && !this.t.red) this.t = this.t.toRed(this.curve.red);
              this.zOne = this.z === this.curve.one;
              if (this.curve.extended && !this.t) {
                this.t = this.x.redMul(this.y);
                if (!this.zOne) this.t = this.t.redMul(this.z.redInvm());
              }
            }
          }
          inherits(Point, Base.BasePoint);
          EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
            return Point.fromJSON(this, obj);
          };
          EdwardsCurve.prototype.point = function point(x, y, z, t) {
            return new Point(this, x, y, z, t);
          };
          Point.fromJSON = function fromJSON(curve, obj) {
            return new Point(curve, obj[0], obj[1], obj[2]);
          };
          Point.prototype.inspect = function inspect() {
            if (this.isInfinity()) return '<EC Point Infinity>';
            return (
              '<EC Point x: ' +
              this.x.fromRed().toString(16, 2) +
              ' y: ' +
              this.y.fromRed().toString(16, 2) +
              ' z: ' +
              this.z.fromRed().toString(16, 2) +
              '>'
            );
          };
          Point.prototype.isInfinity = function isInfinity() {
            return this.x.cmpn(0) === 0 && this.y.cmp(this.z) === 0;
          };
          Point.prototype._extDbl = function _extDbl() {
            var a = this.x.redSqr();
            var b = this.y.redSqr();
            var c = this.z.redSqr();
            c = c.redIAdd(c);
            var d = this.curve._mulA(a);
            var e = this.x
              .redAdd(this.y)
              .redSqr()
              .redISub(a)
              .redISub(b);
            var g = d.redAdd(b);
            var f = g.redSub(c);
            var h = d.redSub(b);
            var nx = e.redMul(f);
            var ny = g.redMul(h);
            var nt = e.redMul(h);
            var nz = f.redMul(g);
            return this.curve.point(nx, ny, nz, nt);
          };
          Point.prototype._projDbl = function _projDbl() {
            var b = this.x.redAdd(this.y).redSqr();
            var c = this.x.redSqr();
            var d = this.y.redSqr();
            var nx;
            var ny;
            var nz;
            if (this.curve.twisted) {
              var e = this.curve._mulA(c);
              var f = e.redAdd(d);
              if (this.zOne) {
                nx = b
                  .redSub(c)
                  .redSub(d)
                  .redMul(f.redSub(this.curve.two));
                ny = f.redMul(e.redSub(d));
                nz = f
                  .redSqr()
                  .redSub(f)
                  .redSub(f);
              } else {
                var h = this.z.redSqr();
                var j = f.redSub(h).redISub(h);
                nx = b
                  .redSub(c)
                  .redISub(d)
                  .redMul(j);
                ny = f.redMul(e.redSub(d));
                nz = f.redMul(j);
              }
            } else {
              var e = c.redAdd(d);
              var h = this.curve._mulC(this.c.redMul(this.z)).redSqr();
              var j = e.redSub(h).redSub(h);
              nx = this.curve._mulC(b.redISub(e)).redMul(j);
              ny = this.curve._mulC(e).redMul(c.redISub(d));
              nz = e.redMul(j);
            }
            return this.curve.point(nx, ny, nz);
          };
          Point.prototype.dbl = function dbl() {
            if (this.isInfinity()) return this;
            if (this.curve.extended) return this._extDbl();
            else return this._projDbl();
          };
          Point.prototype._extAdd = function _extAdd(p) {
            var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
            var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
            var c = this.t.redMul(this.curve.dd).redMul(p.t);
            var d = this.z.redMul(p.z.redAdd(p.z));
            var e = b.redSub(a);
            var f = d.redSub(c);
            var g = d.redAdd(c);
            var h = b.redAdd(a);
            var nx = e.redMul(f);
            var ny = g.redMul(h);
            var nt = e.redMul(h);
            var nz = f.redMul(g);
            return this.curve.point(nx, ny, nz, nt);
          };
          Point.prototype._projAdd = function _projAdd(p) {
            var a = this.z.redMul(p.z);
            var b = a.redSqr();
            var c = this.x.redMul(p.x);
            var d = this.y.redMul(p.y);
            var e = this.curve.d.redMul(c).redMul(d);
            var f = b.redSub(e);
            var g = b.redAdd(e);
            var tmp = this.x
              .redAdd(this.y)
              .redMul(p.x.redAdd(p.y))
              .redISub(c)
              .redISub(d);
            var nx = a.redMul(f).redMul(tmp);
            var ny;
            var nz;
            if (this.curve.twisted) {
              ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
              nz = f.redMul(g);
            } else {
              ny = a.redMul(g).redMul(d.redSub(c));
              nz = this.curve._mulC(f).redMul(g);
            }
            return this.curve.point(nx, ny, nz);
          };
          Point.prototype.add = function add(p) {
            if (this.isInfinity()) return p;
            if (p.isInfinity()) return this;
            if (this.curve.extended) return this._extAdd(p);
            else return this._projAdd(p);
          };
          Point.prototype.mul = function mul(k) {
            if (this._hasDoubles(k)) return this.curve._fixedNafMul(this, k);
            else return this.curve._wnafMul(this, k);
          };
          Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
            return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, false);
          };
          Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
            return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, true);
          };
          Point.prototype.normalize = function normalize() {
            if (this.zOne) return this;
            var zi = this.z.redInvm();
            this.x = this.x.redMul(zi);
            this.y = this.y.redMul(zi);
            if (this.t) this.t = this.t.redMul(zi);
            this.z = this.curve.one;
            this.zOne = true;
            return this;
          };
          Point.prototype.neg = function neg() {
            return this.curve.point(
              this.x.redNeg(),
              this.y,
              this.z,
              this.t && this.t.redNeg()
            );
          };
          Point.prototype.getX = function getX() {
            this.normalize();
            return this.x.fromRed();
          };
          Point.prototype.getY = function getY() {
            this.normalize();
            return this.y.fromRed();
          };
          Point.prototype.eq = function eq(other) {
            return (
              this === other ||
              (this.getX().cmp(other.getX()) === 0 &&
                this.getY().cmp(other.getY()) === 0)
            );
          };
          Point.prototype.eqXToP = function eqXToP(x) {
            var rx = x.toRed(this.curve.red).redMul(this.z);
            if (this.x.cmp(rx) === 0) return true;
            var xc = x.clone();
            var t = this.curve.redN.redMul(this.z);
            for (;;) {
              xc.iadd(this.curve.n);
              if (xc.cmp(this.curve.p) >= 0) return false;
              rx.redIAdd(t);
              if (this.x.cmp(rx) === 0) return true;
            }
            return false;
          };
          Point.prototype.toP = Point.prototype.normalize;
          Point.prototype.mixedAdd = Point.prototype.add;
        },
        { '../../elliptic': 309, '../curve': 312, 'bn.js': 324, inherits: 339 }
      ],
      312: [
        function(require, module, exports) {
          'use strict';
          var curve = exports;
          curve.base = require('./base');
          curve.short = require('./short');
          curve.mont = require('./mont');
          curve.edwards = require('./edwards');
        },
        { './base': 310, './edwards': 311, './mont': 313, './short': 314 }
      ],
      313: [
        function(require, module, exports) {
          'use strict';
          var curve = require('../curve');
          var BN = require('bn.js');
          var inherits = require('inherits');
          var Base = curve.base;
          var elliptic = require('../../elliptic');
          var utils = elliptic.utils;
          function MontCurve(conf) {
            Base.call(this, 'mont', conf);
            this.a = new BN(conf.a, 16).toRed(this.red);
            this.b = new BN(conf.b, 16).toRed(this.red);
            this.i4 = new BN(4).toRed(this.red).redInvm();
            this.two = new BN(2).toRed(this.red);
            this.a24 = this.i4.redMul(this.a.redAdd(this.two));
          }
          inherits(MontCurve, Base);
          module.exports = MontCurve;
          MontCurve.prototype.validate = function validate(point) {
            var x = point.normalize().x;
            var x2 = x.redSqr();
            var rhs = x2
              .redMul(x)
              .redAdd(x2.redMul(this.a))
              .redAdd(x);
            var y = rhs.redSqrt();
            return y.redSqr().cmp(rhs) === 0;
          };
          function Point(curve, x, z) {
            Base.BasePoint.call(this, curve, 'projective');
            if (x === null && z === null) {
              this.x = this.curve.one;
              this.z = this.curve.zero;
            } else {
              this.x = new BN(x, 16);
              this.z = new BN(z, 16);
              if (!this.x.red) this.x = this.x.toRed(this.curve.red);
              if (!this.z.red) this.z = this.z.toRed(this.curve.red);
            }
          }
          inherits(Point, Base.BasePoint);
          MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
            return this.point(utils.toArray(bytes, enc), 1);
          };
          MontCurve.prototype.point = function point(x, z) {
            return new Point(this, x, z);
          };
          MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
            return Point.fromJSON(this, obj);
          };
          Point.prototype.precompute = function precompute() {};
          Point.prototype._encode = function _encode() {
            return this.getX().toArray('be', this.curve.p.byteLength());
          };
          Point.fromJSON = function fromJSON(curve, obj) {
            return new Point(curve, obj[0], obj[1] || curve.one);
          };
          Point.prototype.inspect = function inspect() {
            if (this.isInfinity()) return '<EC Point Infinity>';
            return (
              '<EC Point x: ' +
              this.x.fromRed().toString(16, 2) +
              ' z: ' +
              this.z.fromRed().toString(16, 2) +
              '>'
            );
          };
          Point.prototype.isInfinity = function isInfinity() {
            return this.z.cmpn(0) === 0;
          };
          Point.prototype.dbl = function dbl() {
            var a = this.x.redAdd(this.z);
            var aa = a.redSqr();
            var b = this.x.redSub(this.z);
            var bb = b.redSqr();
            var c = aa.redSub(bb);
            var nx = aa.redMul(bb);
            var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
            return this.curve.point(nx, nz);
          };
          Point.prototype.add = function add() {
            throw new Error('Not supported on Montgomery curve');
          };
          Point.prototype.diffAdd = function diffAdd(p, diff) {
            var a = this.x.redAdd(this.z);
            var b = this.x.redSub(this.z);
            var c = p.x.redAdd(p.z);
            var d = p.x.redSub(p.z);
            var da = d.redMul(a);
            var cb = c.redMul(b);
            var nx = diff.z.redMul(da.redAdd(cb).redSqr());
            var nz = diff.x.redMul(da.redISub(cb).redSqr());
            return this.curve.point(nx, nz);
          };
          Point.prototype.mul = function mul(k) {
            var t = k.clone();
            var a = this;
            var b = this.curve.point(null, null);
            var c = this;
            for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
              bits.push(t.andln(1));
            for (var i = bits.length - 1; i >= 0; i--) {
              if (bits[i] === 0) {
                a = a.diffAdd(b, c);
                b = b.dbl();
              } else {
                b = a.diffAdd(b, c);
                a = a.dbl();
              }
            }
            return b;
          };
          Point.prototype.mulAdd = function mulAdd() {
            throw new Error('Not supported on Montgomery curve');
          };
          Point.prototype.jumlAdd = function jumlAdd() {
            throw new Error('Not supported on Montgomery curve');
          };
          Point.prototype.eq = function eq(other) {
            return this.getX().cmp(other.getX()) === 0;
          };
          Point.prototype.normalize = function normalize() {
            this.x = this.x.redMul(this.z.redInvm());
            this.z = this.curve.one;
            return this;
          };
          Point.prototype.getX = function getX() {
            this.normalize();
            return this.x.fromRed();
          };
        },
        { '../../elliptic': 309, '../curve': 312, 'bn.js': 324, inherits: 339 }
      ],
      314: [
        function(require, module, exports) {
          'use strict';
          var curve = require('../curve');
          var elliptic = require('../../elliptic');
          var BN = require('bn.js');
          var inherits = require('inherits');
          var Base = curve.base;
          var assert = elliptic.utils.assert;
          function ShortCurve(conf) {
            Base.call(this, 'short', conf);
            this.a = new BN(conf.a, 16).toRed(this.red);
            this.b = new BN(conf.b, 16).toRed(this.red);
            this.tinv = this.two.redInvm();
            this.zeroA = this.a.fromRed().cmpn(0) === 0;
            this.threeA =
              this.a
                .fromRed()
                .sub(this.p)
                .cmpn(-3) === 0;
            this.endo = this._getEndomorphism(conf);
            this._endoWnafT1 = new Array(4);
            this._endoWnafT2 = new Array(4);
          }
          inherits(ShortCurve, Base);
          module.exports = ShortCurve;
          ShortCurve.prototype._getEndomorphism = function _getEndomorphism(
            conf
          ) {
            if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
              return;
            var beta;
            var lambda;
            if (conf.beta) {
              beta = new BN(conf.beta, 16).toRed(this.red);
            } else {
              var betas = this._getEndoRoots(this.p);
              beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
              beta = beta.toRed(this.red);
            }
            if (conf.lambda) {
              lambda = new BN(conf.lambda, 16);
            } else {
              var lambdas = this._getEndoRoots(this.n);
              if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
                lambda = lambdas[0];
              } else {
                lambda = lambdas[1];
                assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
              }
            }
            var basis;
            if (conf.basis) {
              basis = conf.basis.map(function(vec) {
                return { a: new BN(vec.a, 16), b: new BN(vec.b, 16) };
              });
            } else {
              basis = this._getEndoBasis(lambda);
            }
            return { beta: beta, lambda: lambda, basis: basis };
          };
          ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
            var red = num === this.p ? this.red : BN.mont(num);
            var tinv = new BN(2).toRed(red).redInvm();
            var ntinv = tinv.redNeg();
            var s = new BN(3)
              .toRed(red)
              .redNeg()
              .redSqrt()
              .redMul(tinv);
            var l1 = ntinv.redAdd(s).fromRed();
            var l2 = ntinv.redSub(s).fromRed();
            return [l1, l2];
          };
          ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
            var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
            var u = lambda;
            var v = this.n.clone();
            var x1 = new BN(1);
            var y1 = new BN(0);
            var x2 = new BN(0);
            var y2 = new BN(1);
            var a0;
            var b0;
            var a1;
            var b1;
            var a2;
            var b2;
            var prevR;
            var i = 0;
            var r;
            var x;
            while (u.cmpn(0) !== 0) {
              var q = v.div(u);
              r = v.sub(q.mul(u));
              x = x2.sub(q.mul(x1));
              var y = y2.sub(q.mul(y1));
              if (!a1 && r.cmp(aprxSqrt) < 0) {
                a0 = prevR.neg();
                b0 = x1;
                a1 = r.neg();
                b1 = x;
              } else if (a1 && ++i === 2) {
                break;
              }
              prevR = r;
              v = u;
              u = r;
              x2 = x1;
              x1 = x;
              y2 = y1;
              y1 = y;
            }
            a2 = r.neg();
            b2 = x;
            var len1 = a1.sqr().add(b1.sqr());
            var len2 = a2.sqr().add(b2.sqr());
            if (len2.cmp(len1) >= 0) {
              a2 = a0;
              b2 = b0;
            }
            if (a1.negative) {
              a1 = a1.neg();
              b1 = b1.neg();
            }
            if (a2.negative) {
              a2 = a2.neg();
              b2 = b2.neg();
            }
            return [{ a: a1, b: b1 }, { a: a2, b: b2 }];
          };
          ShortCurve.prototype._endoSplit = function _endoSplit(k) {
            var basis = this.endo.basis;
            var v1 = basis[0];
            var v2 = basis[1];
            var c1 = v2.b.mul(k).divRound(this.n);
            var c2 = v1.b
              .neg()
              .mul(k)
              .divRound(this.n);
            var p1 = c1.mul(v1.a);
            var p2 = c2.mul(v2.a);
            var q1 = c1.mul(v1.b);
            var q2 = c2.mul(v2.b);
            var k1 = k.sub(p1).sub(p2);
            var k2 = q1.add(q2).neg();
            return { k1: k1, k2: k2 };
          };
          ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
            x = new BN(x, 16);
            if (!x.red) x = x.toRed(this.red);
            var y2 = x
              .redSqr()
              .redMul(x)
              .redIAdd(x.redMul(this.a))
              .redIAdd(this.b);
            var y = y2.redSqrt();
            if (
              y
                .redSqr()
                .redSub(y2)
                .cmp(this.zero) !== 0
            )
              throw new Error('invalid point');
            var isOdd = y.fromRed().isOdd();
            if ((odd && !isOdd) || (!odd && isOdd)) y = y.redNeg();
            return this.point(x, y);
          };
          ShortCurve.prototype.validate = function validate(point) {
            if (point.inf) return true;
            var x = point.x;
            var y = point.y;
            var ax = this.a.redMul(x);
            var rhs = x
              .redSqr()
              .redMul(x)
              .redIAdd(ax)
              .redIAdd(this.b);
            return (
              y
                .redSqr()
                .redISub(rhs)
                .cmpn(0) === 0
            );
          };
          ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(
            points,
            coeffs,
            jacobianResult
          ) {
            var npoints = this._endoWnafT1;
            var ncoeffs = this._endoWnafT2;
            for (var i = 0; i < points.length; i++) {
              var split = this._endoSplit(coeffs[i]);
              var p = points[i];
              var beta = p._getBeta();
              if (split.k1.negative) {
                split.k1.ineg();
                p = p.neg(true);
              }
              if (split.k2.negative) {
                split.k2.ineg();
                beta = beta.neg(true);
              }
              npoints[i * 2] = p;
              npoints[i * 2 + 1] = beta;
              ncoeffs[i * 2] = split.k1;
              ncoeffs[i * 2 + 1] = split.k2;
            }
            var res = this._wnafMulAdd(
              1,
              npoints,
              ncoeffs,
              i * 2,
              jacobianResult
            );
            for (var j = 0; j < i * 2; j++) {
              npoints[j] = null;
              ncoeffs[j] = null;
            }
            return res;
          };
          function Point(curve, x, y, isRed) {
            Base.BasePoint.call(this, curve, 'affine');
            if (x === null && y === null) {
              this.x = null;
              this.y = null;
              this.inf = true;
            } else {
              this.x = new BN(x, 16);
              this.y = new BN(y, 16);
              if (isRed) {
                this.x.forceRed(this.curve.red);
                this.y.forceRed(this.curve.red);
              }
              if (!this.x.red) this.x = this.x.toRed(this.curve.red);
              if (!this.y.red) this.y = this.y.toRed(this.curve.red);
              this.inf = false;
            }
          }
          inherits(Point, Base.BasePoint);
          ShortCurve.prototype.point = function point(x, y, isRed) {
            return new Point(this, x, y, isRed);
          };
          ShortCurve.prototype.pointFromJSON = function pointFromJSON(
            obj,
            red
          ) {
            return Point.fromJSON(this, obj, red);
          };
          Point.prototype._getBeta = function _getBeta() {
            if (!this.curve.endo) return;
            var pre = this.precomputed;
            if (pre && pre.beta) return pre.beta;
            var beta = this.curve.point(
              this.x.redMul(this.curve.endo.beta),
              this.y
            );
            if (pre) {
              var curve = this.curve;
              var endoMul = function(p) {
                return curve.point(p.x.redMul(curve.endo.beta), p.y);
              };
              pre.beta = beta;
              beta.precomputed = {
                beta: null,
                naf: pre.naf && {
                  wnd: pre.naf.wnd,
                  points: pre.naf.points.map(endoMul)
                },
                doubles: pre.doubles && {
                  step: pre.doubles.step,
                  points: pre.doubles.points.map(endoMul)
                }
              };
            }
            return beta;
          };
          Point.prototype.toJSON = function toJSON() {
            if (!this.precomputed) return [this.x, this.y];
            return [
              this.x,
              this.y,
              this.precomputed && {
                doubles: this.precomputed.doubles && {
                  step: this.precomputed.doubles.step,
                  points: this.precomputed.doubles.points.slice(1)
                },
                naf: this.precomputed.naf && {
                  wnd: this.precomputed.naf.wnd,
                  points: this.precomputed.naf.points.slice(1)
                }
              }
            ];
          };
          Point.fromJSON = function fromJSON(curve, obj, red) {
            if (typeof obj === 'string') obj = JSON.parse(obj);
            var res = curve.point(obj[0], obj[1], red);
            if (!obj[2]) return res;
            function obj2point(obj) {
              return curve.point(obj[0], obj[1], red);
            }
            var pre = obj[2];
            res.precomputed = {
              beta: null,
              doubles: pre.doubles && {
                step: pre.doubles.step,
                points: [res].concat(pre.doubles.points.map(obj2point))
              },
              naf: pre.naf && {
                wnd: pre.naf.wnd,
                points: [res].concat(pre.naf.points.map(obj2point))
              }
            };
            return res;
          };
          Point.prototype.inspect = function inspect() {
            if (this.isInfinity()) return '<EC Point Infinity>';
            return (
              '<EC Point x: ' +
              this.x.fromRed().toString(16, 2) +
              ' y: ' +
              this.y.fromRed().toString(16, 2) +
              '>'
            );
          };
          Point.prototype.isInfinity = function isInfinity() {
            return this.inf;
          };
          Point.prototype.add = function add(p) {
            if (this.inf) return p;
            if (p.inf) return this;
            if (this.eq(p)) return this.dbl();
            if (this.neg().eq(p)) return this.curve.point(null, null);
            if (this.x.cmp(p.x) === 0) return this.curve.point(null, null);
            var c = this.y.redSub(p.y);
            if (c.cmpn(0) !== 0) c = c.redMul(this.x.redSub(p.x).redInvm());
            var nx = c
              .redSqr()
              .redISub(this.x)
              .redISub(p.x);
            var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
            return this.curve.point(nx, ny);
          };
          Point.prototype.dbl = function dbl() {
            if (this.inf) return this;
            var ys1 = this.y.redAdd(this.y);
            if (ys1.cmpn(0) === 0) return this.curve.point(null, null);
            var a = this.curve.a;
            var x2 = this.x.redSqr();
            var dyinv = ys1.redInvm();
            var c = x2
              .redAdd(x2)
              .redIAdd(x2)
              .redIAdd(a)
              .redMul(dyinv);
            var nx = c.redSqr().redISub(this.x.redAdd(this.x));
            var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
            return this.curve.point(nx, ny);
          };
          Point.prototype.getX = function getX() {
            return this.x.fromRed();
          };
          Point.prototype.getY = function getY() {
            return this.y.fromRed();
          };
          Point.prototype.mul = function mul(k) {
            k = new BN(k, 16);
            if (this._hasDoubles(k)) return this.curve._fixedNafMul(this, k);
            else if (this.curve.endo)
              return this.curve._endoWnafMulAdd([this], [k]);
            else return this.curve._wnafMul(this, k);
          };
          Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
            var points = [this, p2];
            var coeffs = [k1, k2];
            if (this.curve.endo)
              return this.curve._endoWnafMulAdd(points, coeffs);
            else return this.curve._wnafMulAdd(1, points, coeffs, 2);
          };
          Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
            var points = [this, p2];
            var coeffs = [k1, k2];
            if (this.curve.endo)
              return this.curve._endoWnafMulAdd(points, coeffs, true);
            else return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
          };
          Point.prototype.eq = function eq(p) {
            return (
              this === p ||
              (this.inf === p.inf &&
                (this.inf || (this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0)))
            );
          };
          Point.prototype.neg = function neg(_precompute) {
            if (this.inf) return this;
            var res = this.curve.point(this.x, this.y.redNeg());
            if (_precompute && this.precomputed) {
              var pre = this.precomputed;
              var negate = function(p) {
                return p.neg();
              };
              res.precomputed = {
                naf: pre.naf && {
                  wnd: pre.naf.wnd,
                  points: pre.naf.points.map(negate)
                },
                doubles: pre.doubles && {
                  step: pre.doubles.step,
                  points: pre.doubles.points.map(negate)
                }
              };
            }
            return res;
          };
          Point.prototype.toJ = function toJ() {
            if (this.inf) return this.curve.jpoint(null, null, null);
            var res = this.curve.jpoint(this.x, this.y, this.curve.one);
            return res;
          };
          function JPoint(curve, x, y, z) {
            Base.BasePoint.call(this, curve, 'jacobian');
            if (x === null && y === null && z === null) {
              this.x = this.curve.one;
              this.y = this.curve.one;
              this.z = new BN(0);
            } else {
              this.x = new BN(x, 16);
              this.y = new BN(y, 16);
              this.z = new BN(z, 16);
            }
            if (!this.x.red) this.x = this.x.toRed(this.curve.red);
            if (!this.y.red) this.y = this.y.toRed(this.curve.red);
            if (!this.z.red) this.z = this.z.toRed(this.curve.red);
            this.zOne = this.z === this.curve.one;
          }
          inherits(JPoint, Base.BasePoint);
          ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
            return new JPoint(this, x, y, z);
          };
          JPoint.prototype.toP = function toP() {
            if (this.isInfinity()) return this.curve.point(null, null);
            var zinv = this.z.redInvm();
            var zinv2 = zinv.redSqr();
            var ax = this.x.redMul(zinv2);
            var ay = this.y.redMul(zinv2).redMul(zinv);
            return this.curve.point(ax, ay);
          };
          JPoint.prototype.neg = function neg() {
            return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
          };
          JPoint.prototype.add = function add(p) {
            if (this.isInfinity()) return p;
            if (p.isInfinity()) return this;
            var pz2 = p.z.redSqr();
            var z2 = this.z.redSqr();
            var u1 = this.x.redMul(pz2);
            var u2 = p.x.redMul(z2);
            var s1 = this.y.redMul(pz2.redMul(p.z));
            var s2 = p.y.redMul(z2.redMul(this.z));
            var h = u1.redSub(u2);
            var r = s1.redSub(s2);
            if (h.cmpn(0) === 0) {
              if (r.cmpn(0) !== 0) return this.curve.jpoint(null, null, null);
              else return this.dbl();
            }
            var h2 = h.redSqr();
            var h3 = h2.redMul(h);
            var v = u1.redMul(h2);
            var nx = r
              .redSqr()
              .redIAdd(h3)
              .redISub(v)
              .redISub(v);
            var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
            var nz = this.z.redMul(p.z).redMul(h);
            return this.curve.jpoint(nx, ny, nz);
          };
          JPoint.prototype.mixedAdd = function mixedAdd(p) {
            if (this.isInfinity()) return p.toJ();
            if (p.isInfinity()) return this;
            var z2 = this.z.redSqr();
            var u1 = this.x;
            var u2 = p.x.redMul(z2);
            var s1 = this.y;
            var s2 = p.y.redMul(z2).redMul(this.z);
            var h = u1.redSub(u2);
            var r = s1.redSub(s2);
            if (h.cmpn(0) === 0) {
              if (r.cmpn(0) !== 0) return this.curve.jpoint(null, null, null);
              else return this.dbl();
            }
            var h2 = h.redSqr();
            var h3 = h2.redMul(h);
            var v = u1.redMul(h2);
            var nx = r
              .redSqr()
              .redIAdd(h3)
              .redISub(v)
              .redISub(v);
            var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
            var nz = this.z.redMul(h);
            return this.curve.jpoint(nx, ny, nz);
          };
          JPoint.prototype.dblp = function dblp(pow) {
            if (pow === 0) return this;
            if (this.isInfinity()) return this;
            if (!pow) return this.dbl();
            if (this.curve.zeroA || this.curve.threeA) {
              var r = this;
              for (var i = 0; i < pow; i++) r = r.dbl();
              return r;
            }
            var a = this.curve.a;
            var tinv = this.curve.tinv;
            var jx = this.x;
            var jy = this.y;
            var jz = this.z;
            var jz4 = jz.redSqr().redSqr();
            var jyd = jy.redAdd(jy);
            for (var i = 0; i < pow; i++) {
              var jx2 = jx.redSqr();
              var jyd2 = jyd.redSqr();
              var jyd4 = jyd2.redSqr();
              var c = jx2
                .redAdd(jx2)
                .redIAdd(jx2)
                .redIAdd(a.redMul(jz4));
              var t1 = jx.redMul(jyd2);
              var nx = c.redSqr().redISub(t1.redAdd(t1));
              var t2 = t1.redISub(nx);
              var dny = c.redMul(t2);
              dny = dny.redIAdd(dny).redISub(jyd4);
              var nz = jyd.redMul(jz);
              if (i + 1 < pow) jz4 = jz4.redMul(jyd4);
              jx = nx;
              jz = nz;
              jyd = dny;
            }
            return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
          };
          JPoint.prototype.dbl = function dbl() {
            if (this.isInfinity()) return this;
            if (this.curve.zeroA) return this._zeroDbl();
            else if (this.curve.threeA) return this._threeDbl();
            else return this._dbl();
          };
          JPoint.prototype._zeroDbl = function _zeroDbl() {
            var nx;
            var ny;
            var nz;
            if (this.zOne) {
              var xx = this.x.redSqr();
              var yy = this.y.redSqr();
              var yyyy = yy.redSqr();
              var s = this.x
                .redAdd(yy)
                .redSqr()
                .redISub(xx)
                .redISub(yyyy);
              s = s.redIAdd(s);
              var m = xx.redAdd(xx).redIAdd(xx);
              var t = m
                .redSqr()
                .redISub(s)
                .redISub(s);
              var yyyy8 = yyyy.redIAdd(yyyy);
              yyyy8 = yyyy8.redIAdd(yyyy8);
              yyyy8 = yyyy8.redIAdd(yyyy8);
              nx = t;
              ny = m.redMul(s.redISub(t)).redISub(yyyy8);
              nz = this.y.redAdd(this.y);
            } else {
              var a = this.x.redSqr();
              var b = this.y.redSqr();
              var c = b.redSqr();
              var d = this.x
                .redAdd(b)
                .redSqr()
                .redISub(a)
                .redISub(c);
              d = d.redIAdd(d);
              var e = a.redAdd(a).redIAdd(a);
              var f = e.redSqr();
              var c8 = c.redIAdd(c);
              c8 = c8.redIAdd(c8);
              c8 = c8.redIAdd(c8);
              nx = f.redISub(d).redISub(d);
              ny = e.redMul(d.redISub(nx)).redISub(c8);
              nz = this.y.redMul(this.z);
              nz = nz.redIAdd(nz);
            }
            return this.curve.jpoint(nx, ny, nz);
          };
          JPoint.prototype._threeDbl = function _threeDbl() {
            var nx;
            var ny;
            var nz;
            if (this.zOne) {
              var xx = this.x.redSqr();
              var yy = this.y.redSqr();
              var yyyy = yy.redSqr();
              var s = this.x
                .redAdd(yy)
                .redSqr()
                .redISub(xx)
                .redISub(yyyy);
              s = s.redIAdd(s);
              var m = xx
                .redAdd(xx)
                .redIAdd(xx)
                .redIAdd(this.curve.a);
              var t = m
                .redSqr()
                .redISub(s)
                .redISub(s);
              nx = t;
              var yyyy8 = yyyy.redIAdd(yyyy);
              yyyy8 = yyyy8.redIAdd(yyyy8);
              yyyy8 = yyyy8.redIAdd(yyyy8);
              ny = m.redMul(s.redISub(t)).redISub(yyyy8);
              nz = this.y.redAdd(this.y);
            } else {
              var delta = this.z.redSqr();
              var gamma = this.y.redSqr();
              var beta = this.x.redMul(gamma);
              var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
              alpha = alpha.redAdd(alpha).redIAdd(alpha);
              var beta4 = beta.redIAdd(beta);
              beta4 = beta4.redIAdd(beta4);
              var beta8 = beta4.redAdd(beta4);
              nx = alpha.redSqr().redISub(beta8);
              nz = this.y
                .redAdd(this.z)
                .redSqr()
                .redISub(gamma)
                .redISub(delta);
              var ggamma8 = gamma.redSqr();
              ggamma8 = ggamma8.redIAdd(ggamma8);
              ggamma8 = ggamma8.redIAdd(ggamma8);
              ggamma8 = ggamma8.redIAdd(ggamma8);
              ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
            }
            return this.curve.jpoint(nx, ny, nz);
          };
          JPoint.prototype._dbl = function _dbl() {
            var a = this.curve.a;
            var jx = this.x;
            var jy = this.y;
            var jz = this.z;
            var jz4 = jz.redSqr().redSqr();
            var jx2 = jx.redSqr();
            var jy2 = jy.redSqr();
            var c = jx2
              .redAdd(jx2)
              .redIAdd(jx2)
              .redIAdd(a.redMul(jz4));
            var jxd4 = jx.redAdd(jx);
            jxd4 = jxd4.redIAdd(jxd4);
            var t1 = jxd4.redMul(jy2);
            var nx = c.redSqr().redISub(t1.redAdd(t1));
            var t2 = t1.redISub(nx);
            var jyd8 = jy2.redSqr();
            jyd8 = jyd8.redIAdd(jyd8);
            jyd8 = jyd8.redIAdd(jyd8);
            jyd8 = jyd8.redIAdd(jyd8);
            var ny = c.redMul(t2).redISub(jyd8);
            var nz = jy.redAdd(jy).redMul(jz);
            return this.curve.jpoint(nx, ny, nz);
          };
          JPoint.prototype.trpl = function trpl() {
            if (!this.curve.zeroA) return this.dbl().add(this);
            var xx = this.x.redSqr();
            var yy = this.y.redSqr();
            var zz = this.z.redSqr();
            var yyyy = yy.redSqr();
            var m = xx.redAdd(xx).redIAdd(xx);
            var mm = m.redSqr();
            var e = this.x
              .redAdd(yy)
              .redSqr()
              .redISub(xx)
              .redISub(yyyy);
            e = e.redIAdd(e);
            e = e.redAdd(e).redIAdd(e);
            e = e.redISub(mm);
            var ee = e.redSqr();
            var t = yyyy.redIAdd(yyyy);
            t = t.redIAdd(t);
            t = t.redIAdd(t);
            t = t.redIAdd(t);
            var u = m
              .redIAdd(e)
              .redSqr()
              .redISub(mm)
              .redISub(ee)
              .redISub(t);
            var yyu4 = yy.redMul(u);
            yyu4 = yyu4.redIAdd(yyu4);
            yyu4 = yyu4.redIAdd(yyu4);
            var nx = this.x.redMul(ee).redISub(yyu4);
            nx = nx.redIAdd(nx);
            nx = nx.redIAdd(nx);
            var ny = this.y.redMul(
              u.redMul(t.redISub(u)).redISub(e.redMul(ee))
            );
            ny = ny.redIAdd(ny);
            ny = ny.redIAdd(ny);
            ny = ny.redIAdd(ny);
            var nz = this.z
              .redAdd(e)
              .redSqr()
              .redISub(zz)
              .redISub(ee);
            return this.curve.jpoint(nx, ny, nz);
          };
          JPoint.prototype.mul = function mul(k, kbase) {
            k = new BN(k, kbase);
            return this.curve._wnafMul(this, k);
          };
          JPoint.prototype.eq = function eq(p) {
            if (p.type === 'affine') return this.eq(p.toJ());
            if (this === p) return true;
            var z2 = this.z.redSqr();
            var pz2 = p.z.redSqr();
            if (
              this.x
                .redMul(pz2)
                .redISub(p.x.redMul(z2))
                .cmpn(0) !== 0
            )
              return false;
            var z3 = z2.redMul(this.z);
            var pz3 = pz2.redMul(p.z);
            return (
              this.y
                .redMul(pz3)
                .redISub(p.y.redMul(z3))
                .cmpn(0) === 0
            );
          };
          JPoint.prototype.eqXToP = function eqXToP(x) {
            var zs = this.z.redSqr();
            var rx = x.toRed(this.curve.red).redMul(zs);
            if (this.x.cmp(rx) === 0) return true;
            var xc = x.clone();
            var t = this.curve.redN.redMul(zs);
            for (;;) {
              xc.iadd(this.curve.n);
              if (xc.cmp(this.curve.p) >= 0) return false;
              rx.redIAdd(t);
              if (this.x.cmp(rx) === 0) return true;
            }
            return false;
          };
          JPoint.prototype.inspect = function inspect() {
            if (this.isInfinity()) return '<EC JPoint Infinity>';
            return (
              '<EC JPoint x: ' +
              this.x.toString(16, 2) +
              ' y: ' +
              this.y.toString(16, 2) +
              ' z: ' +
              this.z.toString(16, 2) +
              '>'
            );
          };
          JPoint.prototype.isInfinity = function isInfinity() {
            return this.z.cmpn(0) === 0;
          };
        },
        { '../../elliptic': 309, '../curve': 312, 'bn.js': 324, inherits: 339 }
      ],
      315: [
        function(require, module, exports) {
          'use strict';
          var curves = exports;
          var hash = require('hash.js');
          var elliptic = require('../elliptic');
          var assert = elliptic.utils.assert;
          function PresetCurve(options) {
            if (options.type === 'short')
              this.curve = new elliptic.curve.short(options);
            else if (options.type === 'edwards')
              this.curve = new elliptic.curve.edwards(options);
            else this.curve = new elliptic.curve.mont(options);
            this.g = this.curve.g;
            this.n = this.curve.n;
            this.hash = options.hash;
            assert(this.g.validate(), 'Invalid curve');
            assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
          }
          curves.PresetCurve = PresetCurve;
          function defineCurve(name, options) {
            Object.defineProperty(curves, name, {
              configurable: true,
              enumerable: true,
              get: function() {
                var curve = new PresetCurve(options);
                Object.defineProperty(curves, name, {
                  configurable: true,
                  enumerable: true,
                  value: curve
                });
                return curve;
              }
            });
          }
          defineCurve('p192', {
            type: 'short',
            prime: 'p192',
            p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
            a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
            b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
            n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
            hash: hash.sha256,
            gRed: false,
            g: [
              '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
              '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811'
            ]
          });
          defineCurve('p224', {
            type: 'short',
            prime: 'p224',
            p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
            a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
            b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
            n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
            hash: hash.sha256,
            gRed: false,
            g: [
              'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
              'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34'
            ]
          });
          defineCurve('p256', {
            type: 'short',
            prime: null,
            p:
              'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
            a:
              'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
            b:
              '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
            n:
              'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
            hash: hash.sha256,
            gRed: false,
            g: [
              '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
              '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5'
            ]
          });
          defineCurve('p384', {
            type: 'short',
            prime: null,
            p:
              'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
              'fffffffe ffffffff 00000000 00000000 ffffffff',
            a:
              'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
              'fffffffe ffffffff 00000000 00000000 fffffffc',
            b:
              'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
              '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
            n:
              'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
              'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
            hash: hash.sha384,
            gRed: false,
            g: [
              'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
                '5502f25d bf55296c 3a545e38 72760ab7',
              '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
                '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f'
            ]
          });
          defineCurve('p521', {
            type: 'short',
            prime: null,
            p:
              '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
              'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
              'ffffffff ffffffff ffffffff ffffffff ffffffff',
            a:
              '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
              'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
              'ffffffff ffffffff ffffffff ffffffff fffffffc',
            b:
              '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
              '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
              '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
            n:
              '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
              'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
              'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
            hash: hash.sha512,
            gRed: false,
            g: [
              '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
                '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
                'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
              '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
                '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
                '3fad0761 353c7086 a272c240 88be9476 9fd16650'
            ]
          });
          defineCurve('curve25519', {
            type: 'mont',
            prime: 'p25519',
            p:
              '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
            a: '76d06',
            b: '1',
            n:
              '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
            hash: hash.sha256,
            gRed: false,
            g: ['9']
          });
          defineCurve('ed25519', {
            type: 'edwards',
            prime: 'p25519',
            p:
              '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
            a: '-1',
            c: '1',
            d:
              '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
            n:
              '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
            hash: hash.sha256,
            gRed: false,
            g: [
              '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',
              '6666666666666666666666666666666666666666666666666666666666666658'
            ]
          });
          var pre;
          try {
            pre = require('./precomputed/secp256k1');
          } catch (e) {
            pre = undefined;
          }
          defineCurve('secp256k1', {
            type: 'short',
            prime: 'k256',
            p:
              'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
            a: '0',
            b: '7',
            n:
              'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
            h: '1',
            hash: hash.sha256,
            beta:
              '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
            lambda:
              '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
            basis: [
              {
                a: '3086d221a7d46bcde86c90e49284eb15',
                b: '-e4437ed6010e88286f547fa90abfe4c3'
              },
              {
                a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
                b: '3086d221a7d46bcde86c90e49284eb15'
              }
            ],
            gRed: false,
            g: [
              '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
              '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
              pre
            ]
          });
        },
        { '../elliptic': 309, './precomputed/secp256k1': 322, 'hash.js': 326 }
      ],
      316: [
        function(require, module, exports) {
          'use strict';
          var BN = require('bn.js');
          var HmacDRBG = require('hmac-drbg');
          var elliptic = require('../../elliptic');
          var utils = elliptic.utils;
          var assert = utils.assert;
          var KeyPair = require('./key');
          var Signature = require('./signature');
          function EC(options) {
            if (!(this instanceof EC)) return new EC(options);
            if (typeof options === 'string') {
              assert(
                elliptic.curves.hasOwnProperty(options),
                'Unknown curve ' + options
              );
              options = elliptic.curves[options];
            }
            if (options instanceof elliptic.curves.PresetCurve)
              options = { curve: options };
            this.curve = options.curve.curve;
            this.n = this.curve.n;
            this.nh = this.n.ushrn(1);
            this.g = this.curve.g;
            this.g = options.curve.g;
            this.g.precompute(options.curve.n.bitLength() + 1);
            this.hash = options.hash || options.curve.hash;
          }
          module.exports = EC;
          EC.prototype.keyPair = function keyPair(options) {
            return new KeyPair(this, options);
          };
          EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
            return KeyPair.fromPrivate(this, priv, enc);
          };
          EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
            return KeyPair.fromPublic(this, pub, enc);
          };
          EC.prototype.genKeyPair = function genKeyPair(options) {
            if (!options) options = {};
            var drbg = new HmacDRBG({
              hash: this.hash,
              pers: options.pers,
              persEnc: options.persEnc || 'utf8',
              entropy: options.entropy || elliptic.rand(this.hash.hmacStrength),
              entropyEnc: (options.entropy && options.entropyEnc) || 'utf8',
              nonce: this.n.toArray()
            });
            var bytes = this.n.byteLength();
            var ns2 = this.n.sub(new BN(2));
            do {
              var priv = new BN(drbg.generate(bytes));
              if (priv.cmp(ns2) > 0) continue;
              priv.iaddn(1);
              return this.keyFromPrivate(priv);
            } while (true);
          };
          EC.prototype._truncateToN = function truncateToN(msg, truncOnly) {
            var delta = msg.byteLength() * 8 - this.n.bitLength();
            if (delta > 0) msg = msg.ushrn(delta);
            if (!truncOnly && msg.cmp(this.n) >= 0) return msg.sub(this.n);
            else return msg;
          };
          EC.prototype.sign = function sign(msg, key, enc, options) {
            if (typeof enc === 'object') {
              options = enc;
              enc = null;
            }
            if (!options) options = {};
            key = this.keyFromPrivate(key, enc);
            msg = this._truncateToN(new BN(msg, 16));
            var bytes = this.n.byteLength();
            var bkey = key.getPrivate().toArray('be', bytes);
            var nonce = msg.toArray('be', bytes);
            var drbg = new HmacDRBG({
              hash: this.hash,
              entropy: bkey,
              nonce: nonce,
              pers: options.pers,
              persEnc: options.persEnc || 'utf8'
            });
            var ns1 = this.n.sub(new BN(1));
            for (var iter = 0; true; iter++) {
              var k = options.k
                ? options.k(iter)
                : new BN(drbg.generate(this.n.byteLength()));
              k = this._truncateToN(k, true);
              if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0) continue;
              var kp = this.g.mul(k);
              if (kp.isInfinity()) continue;
              var kpX = kp.getX();
              var r = kpX.umod(this.n);
              if (r.cmpn(0) === 0) continue;
              var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
              s = s.umod(this.n);
              if (s.cmpn(0) === 0) continue;
              var recoveryParam =
                (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
              if (options.canonical && s.cmp(this.nh) > 0) {
                s = this.n.sub(s);
                recoveryParam ^= 1;
              }
              return new Signature({
                r: r,
                s: s,
                recoveryParam: recoveryParam
              });
            }
          };
          EC.prototype.verify = function verify(msg, signature, key, enc) {
            msg = this._truncateToN(new BN(msg, 16));
            key = this.keyFromPublic(key, enc);
            signature = new Signature(signature, 'hex');
            var r = signature.r;
            var s = signature.s;
            if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0) return false;
            if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0) return false;
            var sinv = s.invm(this.n);
            var u1 = sinv.mul(msg).umod(this.n);
            var u2 = sinv.mul(r).umod(this.n);
            if (!this.curve._maxwellTrick) {
              var p = this.g.mulAdd(u1, key.getPublic(), u2);
              if (p.isInfinity()) return false;
              return (
                p
                  .getX()
                  .umod(this.n)
                  .cmp(r) === 0
              );
            }
            var p = this.g.jmulAdd(u1, key.getPublic(), u2);
            if (p.isInfinity()) return false;
            return p.eqXToP(r);
          };
          EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
            assert((3 & j) === j, 'The recovery param is more than two bits');
            signature = new Signature(signature, enc);
            var n = this.n;
            var e = new BN(msg);
            var r = signature.r;
            var s = signature.s;
            var isYOdd = j & 1;
            var isSecondKey = j >> 1;
            if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
              throw new Error('Unable to find sencond key candinate');
            if (isSecondKey)
              r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
            else r = this.curve.pointFromX(r, isYOdd);
            var rInv = signature.r.invm(n);
            var s1 = n
              .sub(e)
              .mul(rInv)
              .umod(n);
            var s2 = s.mul(rInv).umod(n);
            return this.g.mulAdd(s1, r, s2);
          };
          EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
            signature = new Signature(signature, enc);
            if (signature.recoveryParam !== null)
              return signature.recoveryParam;
            for (var i = 0; i < 4; i++) {
              var Qprime;
              try {
                Qprime = this.recoverPubKey(e, signature, i);
              } catch (e) {
                continue;
              }
              if (Qprime.eq(Q)) return i;
            }
            throw new Error('Unable to find valid recovery factor');
          };
        },
        {
          '../../elliptic': 309,
          './key': 317,
          './signature': 318,
          'bn.js': 324,
          'hmac-drbg': 338
        }
      ],
      317: [
        function(require, module, exports) {
          'use strict';
          var BN = require('bn.js');
          var elliptic = require('../../elliptic');
          var utils = elliptic.utils;
          var assert = utils.assert;
          function KeyPair(ec, options) {
            this.ec = ec;
            this.priv = null;
            this.pub = null;
            if (options.priv)
              this._importPrivate(options.priv, options.privEnc);
            if (options.pub) this._importPublic(options.pub, options.pubEnc);
          }
          module.exports = KeyPair;
          KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
            if (pub instanceof KeyPair) return pub;
            return new KeyPair(ec, { pub: pub, pubEnc: enc });
          };
          KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
            if (priv instanceof KeyPair) return priv;
            return new KeyPair(ec, { priv: priv, privEnc: enc });
          };
          KeyPair.prototype.validate = function validate() {
            var pub = this.getPublic();
            if (pub.isInfinity())
              return { result: false, reason: 'Invalid public key' };
            if (!pub.validate())
              return { result: false, reason: 'Public key is not a point' };
            if (!pub.mul(this.ec.curve.n).isInfinity())
              return { result: false, reason: 'Public key * N != O' };
            return { result: true, reason: null };
          };
          KeyPair.prototype.getPublic = function getPublic(compact, enc) {
            if (typeof compact === 'string') {
              enc = compact;
              compact = null;
            }
            if (!this.pub) this.pub = this.ec.g.mul(this.priv);
            if (!enc) return this.pub;
            return this.pub.encode(enc, compact);
          };
          KeyPair.prototype.getPrivate = function getPrivate(enc) {
            if (enc === 'hex') return this.priv.toString(16, 2);
            else return this.priv;
          };
          KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
            this.priv = new BN(key, enc || 16);
            this.priv = this.priv.umod(this.ec.curve.n);
          };
          KeyPair.prototype._importPublic = function _importPublic(key, enc) {
            if (key.x || key.y) {
              if (this.ec.curve.type === 'mont') {
                assert(key.x, 'Need x coordinate');
              } else if (
                this.ec.curve.type === 'short' ||
                this.ec.curve.type === 'edwards'
              ) {
                assert(key.x && key.y, 'Need both x and y coordinate');
              }
              this.pub = this.ec.curve.point(key.x, key.y);
              return;
            }
            this.pub = this.ec.curve.decodePoint(key, enc);
          };
          KeyPair.prototype.derive = function derive(pub) {
            return pub.mul(this.priv).getX();
          };
          KeyPair.prototype.sign = function sign(msg, enc, options) {
            return this.ec.sign(msg, this, enc, options);
          };
          KeyPair.prototype.verify = function verify(msg, signature) {
            return this.ec.verify(msg, signature, this);
          };
          KeyPair.prototype.inspect = function inspect() {
            return (
              '<Key priv: ' +
              (this.priv && this.priv.toString(16, 2)) +
              ' pub: ' +
              (this.pub && this.pub.inspect()) +
              ' >'
            );
          };
        },
        { '../../elliptic': 309, 'bn.js': 324 }
      ],
      318: [
        function(require, module, exports) {
          'use strict';
          var BN = require('bn.js');
          var elliptic = require('../../elliptic');
          var utils = elliptic.utils;
          var assert = utils.assert;
          function Signature(options, enc) {
            if (options instanceof Signature) return options;
            if (this._importDER(options, enc)) return;
            assert(options.r && options.s, 'Signature without r or s');
            this.r = new BN(options.r, 16);
            this.s = new BN(options.s, 16);
            if (options.recoveryParam === undefined) this.recoveryParam = null;
            else this.recoveryParam = options.recoveryParam;
          }
          module.exports = Signature;
          function Position() {
            this.place = 0;
          }
          function getLength(buf, p) {
            var initial = buf[p.place++];
            if (!(initial & 128)) {
              return initial;
            }
            var octetLen = initial & 15;
            var val = 0;
            for (var i = 0, off = p.place; i < octetLen; i++, off++) {
              val <<= 8;
              val |= buf[off];
            }
            p.place = off;
            return val;
          }
          function rmPadding(buf) {
            var i = 0;
            var len = buf.length - 1;
            while (!buf[i] && !(buf[i + 1] & 128) && i < len) {
              i++;
            }
            if (i === 0) {
              return buf;
            }
            return buf.slice(i);
          }
          Signature.prototype._importDER = function _importDER(data, enc) {
            data = utils.toArray(data, enc);
            var p = new Position();
            if (data[p.place++] !== 48) {
              return false;
            }
            var len = getLength(data, p);
            if (len + p.place !== data.length) {
              return false;
            }
            if (data[p.place++] !== 2) {
              return false;
            }
            var rlen = getLength(data, p);
            var r = data.slice(p.place, rlen + p.place);
            p.place += rlen;
            if (data[p.place++] !== 2) {
              return false;
            }
            var slen = getLength(data, p);
            if (data.length !== slen + p.place) {
              return false;
            }
            var s = data.slice(p.place, slen + p.place);
            if (r[0] === 0 && r[1] & 128) {
              r = r.slice(1);
            }
            if (s[0] === 0 && s[1] & 128) {
              s = s.slice(1);
            }
            this.r = new BN(r);
            this.s = new BN(s);
            this.recoveryParam = null;
            return true;
          };
          function constructLength(arr, len) {
            if (len < 128) {
              arr.push(len);
              return;
            }
            var octets = 1 + ((Math.log(len) / Math.LN2) >>> 3);
            arr.push(octets | 128);
            while (--octets) {
              arr.push((len >>> (octets << 3)) & 255);
            }
            arr.push(len);
          }
          Signature.prototype.toDER = function toDER(enc) {
            var r = this.r.toArray();
            var s = this.s.toArray();
            if (r[0] & 128) r = [0].concat(r);
            if (s[0] & 128) s = [0].concat(s);
            r = rmPadding(r);
            s = rmPadding(s);
            while (!s[0] && !(s[1] & 128)) {
              s = s.slice(1);
            }
            var arr = [2];
            constructLength(arr, r.length);
            arr = arr.concat(r);
            arr.push(2);
            constructLength(arr, s.length);
            var backHalf = arr.concat(s);
            var res = [48];
            constructLength(res, backHalf.length);
            res = res.concat(backHalf);
            return utils.encode(res, enc);
          };
        },
        { '../../elliptic': 309, 'bn.js': 324 }
      ],
      319: [
        function(require, module, exports) {
          'use strict';
          var hash = require('hash.js');
          var elliptic = require('../../elliptic');
          var utils = elliptic.utils;
          var assert = utils.assert;
          var parseBytes = utils.parseBytes;
          var KeyPair = require('./key');
          var Signature = require('./signature');
          function EDDSA(curve) {
            assert(curve === 'ed25519', 'only tested with ed25519 so far');
            if (!(this instanceof EDDSA)) return new EDDSA(curve);
            var curve = elliptic.curves[curve].curve;
            this.curve = curve;
            this.g = curve.g;
            this.g.precompute(curve.n.bitLength() + 1);
            this.pointClass = curve.point().constructor;
            this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
            this.hash = hash.sha512;
          }
          module.exports = EDDSA;
          EDDSA.prototype.sign = function sign(message, secret) {
            message = parseBytes(message);
            var key = this.keyFromSecret(secret);
            var r = this.hashInt(key.messagePrefix(), message);
            var R = this.g.mul(r);
            var Rencoded = this.encodePoint(R);
            var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(
              key.priv()
            );
            var S = r.add(s_).umod(this.curve.n);
            return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });
          };
          EDDSA.prototype.verify = function verify(message, sig, pub) {
            message = parseBytes(message);
            sig = this.makeSignature(sig);
            var key = this.keyFromPublic(pub);
            var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
            var SG = this.g.mul(sig.S());
            var RplusAh = sig.R().add(key.pub().mul(h));
            return RplusAh.eq(SG);
          };
          EDDSA.prototype.hashInt = function hashInt() {
            var hash = this.hash();
            for (var i = 0; i < arguments.length; i++)
              hash.update(arguments[i]);
            return utils.intFromLE(hash.digest()).umod(this.curve.n);
          };
          EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
            return KeyPair.fromPublic(this, pub);
          };
          EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
            return KeyPair.fromSecret(this, secret);
          };
          EDDSA.prototype.makeSignature = function makeSignature(sig) {
            if (sig instanceof Signature) return sig;
            return new Signature(this, sig);
          };
          EDDSA.prototype.encodePoint = function encodePoint(point) {
            var enc = point.getY().toArray('le', this.encodingLength);
            enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0;
            return enc;
          };
          EDDSA.prototype.decodePoint = function decodePoint(bytes) {
            bytes = utils.parseBytes(bytes);
            var lastIx = bytes.length - 1;
            var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~128);
            var xIsOdd = (bytes[lastIx] & 128) !== 0;
            var y = utils.intFromLE(normed);
            return this.curve.pointFromY(y, xIsOdd);
          };
          EDDSA.prototype.encodeInt = function encodeInt(num) {
            return num.toArray('le', this.encodingLength);
          };
          EDDSA.prototype.decodeInt = function decodeInt(bytes) {
            return utils.intFromLE(bytes);
          };
          EDDSA.prototype.isPoint = function isPoint(val) {
            return val instanceof this.pointClass;
          };
        },
        {
          '../../elliptic': 309,
          './key': 320,
          './signature': 321,
          'hash.js': 326
        }
      ],
      320: [
        function(require, module, exports) {
          'use strict';
          var elliptic = require('../../elliptic');
          var utils = elliptic.utils;
          var assert = utils.assert;
          var parseBytes = utils.parseBytes;
          var cachedProperty = utils.cachedProperty;
          function KeyPair(eddsa, params) {
            this.eddsa = eddsa;
            this._secret = parseBytes(params.secret);
            if (eddsa.isPoint(params.pub)) this._pub = params.pub;
            else this._pubBytes = parseBytes(params.pub);
          }
          KeyPair.fromPublic = function fromPublic(eddsa, pub) {
            if (pub instanceof KeyPair) return pub;
            return new KeyPair(eddsa, { pub: pub });
          };
          KeyPair.fromSecret = function fromSecret(eddsa, secret) {
            if (secret instanceof KeyPair) return secret;
            return new KeyPair(eddsa, { secret: secret });
          };
          KeyPair.prototype.secret = function secret() {
            return this._secret;
          };
          cachedProperty(KeyPair, 'pubBytes', function pubBytes() {
            return this.eddsa.encodePoint(this.pub());
          });
          cachedProperty(KeyPair, 'pub', function pub() {
            if (this._pubBytes) return this.eddsa.decodePoint(this._pubBytes);
            return this.eddsa.g.mul(this.priv());
          });
          cachedProperty(KeyPair, 'privBytes', function privBytes() {
            var eddsa = this.eddsa;
            var hash = this.hash();
            var lastIx = eddsa.encodingLength - 1;
            var a = hash.slice(0, eddsa.encodingLength);
            a[0] &= 248;
            a[lastIx] &= 127;
            a[lastIx] |= 64;
            return a;
          });
          cachedProperty(KeyPair, 'priv', function priv() {
            return this.eddsa.decodeInt(this.privBytes());
          });
          cachedProperty(KeyPair, 'hash', function hash() {
            return this.eddsa
              .hash()
              .update(this.secret())
              .digest();
          });
          cachedProperty(KeyPair, 'messagePrefix', function messagePrefix() {
            return this.hash().slice(this.eddsa.encodingLength);
          });
          KeyPair.prototype.sign = function sign(message) {
            assert(this._secret, 'KeyPair can only verify');
            return this.eddsa.sign(message, this);
          };
          KeyPair.prototype.verify = function verify(message, sig) {
            return this.eddsa.verify(message, sig, this);
          };
          KeyPair.prototype.getSecret = function getSecret(enc) {
            assert(this._secret, 'KeyPair is public only');
            return utils.encode(this.secret(), enc);
          };
          KeyPair.prototype.getPublic = function getPublic(enc) {
            return utils.encode(this.pubBytes(), enc);
          };
          module.exports = KeyPair;
        },
        { '../../elliptic': 309 }
      ],
      321: [
        function(require, module, exports) {
          'use strict';
          var BN = require('bn.js');
          var elliptic = require('../../elliptic');
          var utils = elliptic.utils;
          var assert = utils.assert;
          var cachedProperty = utils.cachedProperty;
          var parseBytes = utils.parseBytes;
          function Signature(eddsa, sig) {
            this.eddsa = eddsa;
            if (typeof sig !== 'object') sig = parseBytes(sig);
            if (Array.isArray(sig)) {
              sig = {
                R: sig.slice(0, eddsa.encodingLength),
                S: sig.slice(eddsa.encodingLength)
              };
            }
            assert(sig.R && sig.S, 'Signature without R or S');
            if (eddsa.isPoint(sig.R)) this._R = sig.R;
            if (sig.S instanceof BN) this._S = sig.S;
            this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
            this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
          }
          cachedProperty(Signature, 'S', function S() {
            return this.eddsa.decodeInt(this.Sencoded());
          });
          cachedProperty(Signature, 'R', function R() {
            return this.eddsa.decodePoint(this.Rencoded());
          });
          cachedProperty(Signature, 'Rencoded', function Rencoded() {
            return this.eddsa.encodePoint(this.R());
          });
          cachedProperty(Signature, 'Sencoded', function Sencoded() {
            return this.eddsa.encodeInt(this.S());
          });
          Signature.prototype.toBytes = function toBytes() {
            return this.Rencoded().concat(this.Sencoded());
          };
          Signature.prototype.toHex = function toHex() {
            return utils.encode(this.toBytes(), 'hex').toUpperCase();
          };
          module.exports = Signature;
        },
        { '../../elliptic': 309, 'bn.js': 324 }
      ],
      322: [
        function(require, module, exports) {
          module.exports = {
            doubles: {
              step: 4,
              points: [
                [
                  'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
                  'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'
                ],
                [
                  '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
                  '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'
                ],
                [
                  '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
                  'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'
                ],
                [
                  '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
                  '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'
                ],
                [
                  '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
                  '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'
                ],
                [
                  '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
                  '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'
                ],
                [
                  'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
                  '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'
                ],
                [
                  '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
                  'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'
                ],
                [
                  'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
                  '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'
                ],
                [
                  'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
                  'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'
                ],
                [
                  'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
                  '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'
                ],
                [
                  '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
                  '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'
                ],
                [
                  '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
                  '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'
                ],
                [
                  '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
                  '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'
                ],
                [
                  '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
                  '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'
                ],
                [
                  '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
                  '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'
                ],
                [
                  '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
                  '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'
                ],
                [
                  '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
                  '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'
                ],
                [
                  '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
                  'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'
                ],
                [
                  'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
                  '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'
                ],
                [
                  'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
                  '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'
                ],
                [
                  '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
                  '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'
                ],
                [
                  '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
                  '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'
                ],
                [
                  'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
                  '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'
                ],
                [
                  '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
                  'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'
                ],
                [
                  'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
                  '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'
                ],
                [
                  'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
                  'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'
                ],
                [
                  'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
                  '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'
                ],
                [
                  'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
                  'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'
                ],
                [
                  'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
                  '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'
                ],
                [
                  '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
                  'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'
                ],
                [
                  '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
                  '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'
                ],
                [
                  'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
                  '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'
                ],
                [
                  '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
                  'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'
                ],
                [
                  'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
                  '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'
                ],
                [
                  'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
                  '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'
                ],
                [
                  'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
                  'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'
                ],
                [
                  '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
                  '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'
                ],
                [
                  '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
                  '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'
                ],
                [
                  '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
                  'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'
                ],
                [
                  '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
                  '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'
                ],
                [
                  'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
                  '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'
                ],
                [
                  '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
                  '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'
                ],
                [
                  '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
                  'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'
                ],
                [
                  '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
                  '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'
                ],
                [
                  'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
                  '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'
                ],
                [
                  '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
                  'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'
                ],
                [
                  'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
                  'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'
                ],
                [
                  'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
                  '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'
                ],
                [
                  '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
                  'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'
                ],
                [
                  '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
                  'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'
                ],
                [
                  'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
                  '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'
                ],
                [
                  'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
                  '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'
                ],
                [
                  'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
                  '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'
                ],
                [
                  '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
                  'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'
                ],
                [
                  '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
                  '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'
                ],
                [
                  'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
                  'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'
                ],
                [
                  '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
                  'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'
                ],
                [
                  '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
                  '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'
                ],
                [
                  '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
                  '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'
                ],
                [
                  'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
                  'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'
                ],
                [
                  '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
                  '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'
                ],
                [
                  '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
                  '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'
                ],
                [
                  'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
                  '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'
                ],
                [
                  'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
                  'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82'
                ]
              ]
            },
            naf: {
              wnd: 7,
              points: [
                [
                  'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
                  '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'
                ],
                [
                  '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
                  'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'
                ],
                [
                  '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
                  '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'
                ],
                [
                  'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
                  'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'
                ],
                [
                  '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
                  'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'
                ],
                [
                  'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
                  'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'
                ],
                [
                  'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
                  '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'
                ],
                [
                  'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
                  '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'
                ],
                [
                  '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
                  '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'
                ],
                [
                  '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
                  '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'
                ],
                [
                  '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
                  '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'
                ],
                [
                  '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
                  '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'
                ],
                [
                  'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
                  'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'
                ],
                [
                  'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
                  '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'
                ],
                [
                  '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
                  'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'
                ],
                [
                  '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
                  'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'
                ],
                [
                  '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
                  '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'
                ],
                [
                  '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
                  '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'
                ],
                [
                  '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
                  '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'
                ],
                [
                  '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
                  'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'
                ],
                [
                  'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
                  'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'
                ],
                [
                  '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
                  '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'
                ],
                [
                  '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
                  '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'
                ],
                [
                  'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
                  'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'
                ],
                [
                  '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
                  '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'
                ],
                [
                  'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
                  'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'
                ],
                [
                  'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
                  'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'
                ],
                [
                  '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
                  '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'
                ],
                [
                  '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
                  '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'
                ],
                [
                  '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
                  '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'
                ],
                [
                  'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
                  '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'
                ],
                [
                  '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
                  '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'
                ],
                [
                  'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
                  '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'
                ],
                [
                  '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
                  'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'
                ],
                [
                  '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
                  'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'
                ],
                [
                  'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
                  'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'
                ],
                [
                  '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
                  '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'
                ],
                [
                  '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
                  'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'
                ],
                [
                  'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
                  'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'
                ],
                [
                  '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
                  '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'
                ],
                [
                  '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
                  'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'
                ],
                [
                  '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
                  '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'
                ],
                [
                  '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
                  'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'
                ],
                [
                  'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
                  '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'
                ],
                [
                  '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
                  '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'
                ],
                [
                  '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
                  'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'
                ],
                [
                  '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
                  'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'
                ],
                [
                  'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
                  'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'
                ],
                [
                  'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
                  'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'
                ],
                [
                  '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
                  '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'
                ],
                [
                  '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
                  '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'
                ],
                [
                  'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
                  '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'
                ],
                [
                  'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
                  'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'
                ],
                [
                  '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
                  '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'
                ],
                [
                  '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
                  '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'
                ],
                [
                  'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
                  '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'
                ],
                [
                  '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
                  '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'
                ],
                [
                  'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
                  'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'
                ],
                [
                  '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
                  'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'
                ],
                [
                  '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
                  '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'
                ],
                [
                  'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
                  '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'
                ],
                [
                  'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
                  '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'
                ],
                [
                  '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
                  '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'
                ],
                [
                  '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
                  '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'
                ],
                [
                  '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
                  'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'
                ],
                [
                  '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
                  'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'
                ],
                [
                  '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
                  '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'
                ],
                [
                  '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
                  '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'
                ],
                [
                  '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
                  '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'
                ],
                [
                  '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
                  'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'
                ],
                [
                  'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
                  'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'
                ],
                [
                  '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
                  'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'
                ],
                [
                  'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
                  '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'
                ],
                [
                  'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
                  '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'
                ],
                [
                  'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
                  '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'
                ],
                [
                  'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
                  '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'
                ],
                [
                  '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
                  'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'
                ],
                [
                  '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
                  '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'
                ],
                [
                  '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
                  'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'
                ],
                [
                  'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
                  'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'
                ],
                [
                  'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
                  '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'
                ],
                [
                  'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
                  'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'
                ],
                [
                  'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
                  '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'
                ],
                [
                  '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
                  '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'
                ],
                [
                  'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
                  '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'
                ],
                [
                  'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
                  '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'
                ],
                [
                  '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
                  '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'
                ],
                [
                  '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
                  'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'
                ],
                [
                  'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
                  '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'
                ],
                [
                  'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
                  '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'
                ],
                [
                  'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
                  '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'
                ],
                [
                  '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
                  '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'
                ],
                [
                  'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
                  'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'
                ],
                [
                  '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
                  'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'
                ],
                [
                  'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
                  'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'
                ],
                [
                  'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
                  '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'
                ],
                [
                  '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
                  'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'
                ],
                [
                  'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
                  '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'
                ],
                [
                  'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
                  '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'
                ],
                [
                  'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
                  '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'
                ],
                [
                  '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
                  'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'
                ],
                [
                  '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
                  'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'
                ],
                [
                  'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
                  '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'
                ],
                [
                  '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
                  'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'
                ],
                [
                  '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
                  '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'
                ],
                [
                  '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
                  'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'
                ],
                [
                  'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
                  'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'
                ],
                [
                  '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
                  'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'
                ],
                [
                  '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
                  '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'
                ],
                [
                  '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
                  'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'
                ],
                [
                  '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
                  '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'
                ],
                [
                  'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
                  'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'
                ],
                [
                  '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
                  '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'
                ],
                [
                  'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
                  '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'
                ],
                [
                  '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
                  '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'
                ],
                [
                  'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
                  'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'
                ],
                [
                  'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
                  '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'
                ],
                [
                  'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
                  'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'
                ],
                [
                  '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
                  'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'
                ],
                [
                  '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
                  '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'
                ],
                [
                  '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
                  'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'
                ],
                [
                  '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
                  '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'
                ],
                [
                  '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
                  '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'
                ],
                [
                  '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
                  'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'
                ],
                [
                  '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
                  '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'
                ],
                [
                  '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
                  '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'
                ],
                [
                  '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
                  '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9'
                ]
              ]
            }
          };
        },
        {}
      ],
      323: [
        function(require, module, exports) {
          'use strict';
          var utils = exports;
          var BN = require('bn.js');
          var minAssert = require('minimalistic-assert');
          var minUtils = require('minimalistic-crypto-utils');
          utils.assert = minAssert;
          utils.toArray = minUtils.toArray;
          utils.zero2 = minUtils.zero2;
          utils.toHex = minUtils.toHex;
          utils.encode = minUtils.encode;
          function getNAF(num, w) {
            var naf = [];
            var ws = 1 << (w + 1);
            var k = num.clone();
            while (k.cmpn(1) >= 0) {
              var z;
              if (k.isOdd()) {
                var mod = k.andln(ws - 1);
                if (mod > (ws >> 1) - 1) z = (ws >> 1) - mod;
                else z = mod;
                k.isubn(z);
              } else {
                z = 0;
              }
              naf.push(z);
              var shift = k.cmpn(0) !== 0 && k.andln(ws - 1) === 0 ? w + 1 : 1;
              for (var i = 1; i < shift; i++) naf.push(0);
              k.iushrn(shift);
            }
            return naf;
          }
          utils.getNAF = getNAF;
          function getJSF(k1, k2) {
            var jsf = [[], []];
            k1 = k1.clone();
            k2 = k2.clone();
            var d1 = 0;
            var d2 = 0;
            while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
              var m14 = (k1.andln(3) + d1) & 3;
              var m24 = (k2.andln(3) + d2) & 3;
              if (m14 === 3) m14 = -1;
              if (m24 === 3) m24 = -1;
              var u1;
              if ((m14 & 1) === 0) {
                u1 = 0;
              } else {
                var m8 = (k1.andln(7) + d1) & 7;
                if ((m8 === 3 || m8 === 5) && m24 === 2) u1 = -m14;
                else u1 = m14;
              }
              jsf[0].push(u1);
              var u2;
              if ((m24 & 1) === 0) {
                u2 = 0;
              } else {
                var m8 = (k2.andln(7) + d2) & 7;
                if ((m8 === 3 || m8 === 5) && m14 === 2) u2 = -m24;
                else u2 = m24;
              }
              jsf[1].push(u2);
              if (2 * d1 === u1 + 1) d1 = 1 - d1;
              if (2 * d2 === u2 + 1) d2 = 1 - d2;
              k1.iushrn(1);
              k2.iushrn(1);
            }
            return jsf;
          }
          utils.getJSF = getJSF;
          function cachedProperty(obj, name, computer) {
            var key = '_' + name;
            obj.prototype[name] = function cachedProperty() {
              return this[key] !== undefined
                ? this[key]
                : (this[key] = computer.call(this));
            };
          }
          utils.cachedProperty = cachedProperty;
          function parseBytes(bytes) {
            return typeof bytes === 'string'
              ? utils.toArray(bytes, 'hex')
              : bytes;
          }
          utils.parseBytes = parseBytes;
          function intFromLE(bytes) {
            return new BN(bytes, 'hex', 'le');
          }
          utils.intFromLE = intFromLE;
        },
        {
          'bn.js': 324,
          'minimalistic-assert': 340,
          'minimalistic-crypto-utils': 341
        }
      ],
      324: [
        function(require, module, exports) {
          arguments[4][134][0].apply(exports, arguments);
        },
        { buffer: 155, dup: 134 }
      ],
      325: [
        function(require, module, exports) {
          arguments[4][136][0].apply(exports, arguments);
        },
        { crypto: 155, dup: 136 }
      ],
      326: [
        function(require, module, exports) {
          var hash = exports;
          hash.utils = require('./hash/utils');
          hash.common = require('./hash/common');
          hash.sha = require('./hash/sha');
          hash.ripemd = require('./hash/ripemd');
          hash.hmac = require('./hash/hmac');
          hash.sha1 = hash.sha.sha1;
          hash.sha256 = hash.sha.sha256;
          hash.sha224 = hash.sha.sha224;
          hash.sha384 = hash.sha.sha384;
          hash.sha512 = hash.sha.sha512;
          hash.ripemd160 = hash.ripemd.ripemd160;
        },
        {
          './hash/common': 327,
          './hash/hmac': 328,
          './hash/ripemd': 329,
          './hash/sha': 330,
          './hash/utils': 337
        }
      ],
      327: [
        function(require, module, exports) {
          'use strict';
          var utils = require('./utils');
          var assert = require('minimalistic-assert');
          function BlockHash() {
            this.pending = null;
            this.pendingTotal = 0;
            this.blockSize = this.constructor.blockSize;
            this.outSize = this.constructor.outSize;
            this.hmacStrength = this.constructor.hmacStrength;
            this.padLength = this.constructor.padLength / 8;
            this.endian = 'big';
            this._delta8 = this.blockSize / 8;
            this._delta32 = this.blockSize / 32;
          }
          exports.BlockHash = BlockHash;
          BlockHash.prototype.update = function update(msg, enc) {
            msg = utils.toArray(msg, enc);
            if (!this.pending) this.pending = msg;
            else this.pending = this.pending.concat(msg);
            this.pendingTotal += msg.length;
            if (this.pending.length >= this._delta8) {
              msg = this.pending;
              var r = msg.length % this._delta8;
              this.pending = msg.slice(msg.length - r, msg.length);
              if (this.pending.length === 0) this.pending = null;
              msg = utils.join32(msg, 0, msg.length - r, this.endian);
              for (var i = 0; i < msg.length; i += this._delta32)
                this._update(msg, i, i + this._delta32);
            }
            return this;
          };
          BlockHash.prototype.digest = function digest(enc) {
            this.update(this._pad());
            assert(this.pending === null);
            return this._digest(enc);
          };
          BlockHash.prototype._pad = function pad() {
            var len = this.pendingTotal;
            var bytes = this._delta8;
            var k = bytes - ((len + this.padLength) % bytes);
            var res = new Array(k + this.padLength);
            res[0] = 128;
            for (var i = 1; i < k; i++) res[i] = 0;
            len <<= 3;
            if (this.endian === 'big') {
              for (var t = 8; t < this.padLength; t++) res[i++] = 0;
              res[i++] = 0;
              res[i++] = 0;
              res[i++] = 0;
              res[i++] = 0;
              res[i++] = (len >>> 24) & 255;
              res[i++] = (len >>> 16) & 255;
              res[i++] = (len >>> 8) & 255;
              res[i++] = len & 255;
            } else {
              res[i++] = len & 255;
              res[i++] = (len >>> 8) & 255;
              res[i++] = (len >>> 16) & 255;
              res[i++] = (len >>> 24) & 255;
              res[i++] = 0;
              res[i++] = 0;
              res[i++] = 0;
              res[i++] = 0;
              for (t = 8; t < this.padLength; t++) res[i++] = 0;
            }
            return res;
          };
        },
        { './utils': 337, 'minimalistic-assert': 340 }
      ],
      328: [
        function(require, module, exports) {
          'use strict';
          var utils = require('./utils');
          var assert = require('minimalistic-assert');
          function Hmac(hash, key, enc) {
            if (!(this instanceof Hmac)) return new Hmac(hash, key, enc);
            this.Hash = hash;
            this.blockSize = hash.blockSize / 8;
            this.outSize = hash.outSize / 8;
            this.inner = null;
            this.outer = null;
            this._init(utils.toArray(key, enc));
          }
          module.exports = Hmac;
          Hmac.prototype._init = function init(key) {
            if (key.length > this.blockSize)
              key = new this.Hash().update(key).digest();
            assert(key.length <= this.blockSize);
            for (var i = key.length; i < this.blockSize; i++) key.push(0);
            for (i = 0; i < key.length; i++) key[i] ^= 54;
            this.inner = new this.Hash().update(key);
            for (i = 0; i < key.length; i++) key[i] ^= 106;
            this.outer = new this.Hash().update(key);
          };
          Hmac.prototype.update = function update(msg, enc) {
            this.inner.update(msg, enc);
            return this;
          };
          Hmac.prototype.digest = function digest(enc) {
            this.outer.update(this.inner.digest());
            return this.outer.digest(enc);
          };
        },
        { './utils': 337, 'minimalistic-assert': 340 }
      ],
      329: [
        function(require, module, exports) {
          'use strict';
          var utils = require('./utils');
          var common = require('./common');
          var rotl32 = utils.rotl32;
          var sum32 = utils.sum32;
          var sum32_3 = utils.sum32_3;
          var sum32_4 = utils.sum32_4;
          var BlockHash = common.BlockHash;
          function RIPEMD160() {
            if (!(this instanceof RIPEMD160)) return new RIPEMD160();
            BlockHash.call(this);
            this.h = [
              1732584193,
              4023233417,
              2562383102,
              271733878,
              3285377520
            ];
            this.endian = 'little';
          }
          utils.inherits(RIPEMD160, BlockHash);
          exports.ripemd160 = RIPEMD160;
          RIPEMD160.blockSize = 512;
          RIPEMD160.outSize = 160;
          RIPEMD160.hmacStrength = 192;
          RIPEMD160.padLength = 64;
          RIPEMD160.prototype._update = function update(msg, start) {
            var A = this.h[0];
            var B = this.h[1];
            var C = this.h[2];
            var D = this.h[3];
            var E = this.h[4];
            var Ah = A;
            var Bh = B;
            var Ch = C;
            var Dh = D;
            var Eh = E;
            for (var j = 0; j < 80; j++) {
              var T = sum32(
                rotl32(
                  sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
                  s[j]
                ),
                E
              );
              A = E;
              E = D;
              D = rotl32(C, 10);
              C = B;
              B = T;
              T = sum32(
                rotl32(
                  sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
                  sh[j]
                ),
                Eh
              );
              Ah = Eh;
              Eh = Dh;
              Dh = rotl32(Ch, 10);
              Ch = Bh;
              Bh = T;
            }
            T = sum32_3(this.h[1], C, Dh);
            this.h[1] = sum32_3(this.h[2], D, Eh);
            this.h[2] = sum32_3(this.h[3], E, Ah);
            this.h[3] = sum32_3(this.h[4], A, Bh);
            this.h[4] = sum32_3(this.h[0], B, Ch);
            this.h[0] = T;
          };
          RIPEMD160.prototype._digest = function digest(enc) {
            if (enc === 'hex') return utils.toHex32(this.h, 'little');
            else return utils.split32(this.h, 'little');
          };
          function f(j, x, y, z) {
            if (j <= 15) return x ^ y ^ z;
            else if (j <= 31) return (x & y) | (~x & z);
            else if (j <= 47) return (x | ~y) ^ z;
            else if (j <= 63) return (x & z) | (y & ~z);
            else return x ^ (y | ~z);
          }
          function K(j) {
            if (j <= 15) return 0;
            else if (j <= 31) return 1518500249;
            else if (j <= 47) return 1859775393;
            else if (j <= 63) return 2400959708;
            else return 2840853838;
          }
          function Kh(j) {
            if (j <= 15) return 1352829926;
            else if (j <= 31) return 1548603684;
            else if (j <= 47) return 1836072691;
            else if (j <= 63) return 2053994217;
            else return 0;
          }
          var r = [
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            7,
            4,
            13,
            1,
            10,
            6,
            15,
            3,
            12,
            0,
            9,
            5,
            2,
            14,
            11,
            8,
            3,
            10,
            14,
            4,
            9,
            15,
            8,
            1,
            2,
            7,
            0,
            6,
            13,
            11,
            5,
            12,
            1,
            9,
            11,
            10,
            0,
            8,
            12,
            4,
            13,
            3,
            7,
            15,
            14,
            5,
            6,
            2,
            4,
            0,
            5,
            9,
            7,
            12,
            2,
            10,
            14,
            1,
            3,
            8,
            11,
            6,
            15,
            13
          ];
          var rh = [
            5,
            14,
            7,
            0,
            9,
            2,
            11,
            4,
            13,
            6,
            15,
            8,
            1,
            10,
            3,
            12,
            6,
            11,
            3,
            7,
            0,
            13,
            5,
            10,
            14,
            15,
            8,
            12,
            4,
            9,
            1,
            2,
            15,
            5,
            1,
            3,
            7,
            14,
            6,
            9,
            11,
            8,
            12,
            2,
            10,
            0,
            4,
            13,
            8,
            6,
            4,
            1,
            3,
            11,
            15,
            0,
            5,
            12,
            2,
            13,
            9,
            7,
            10,
            14,
            12,
            15,
            10,
            4,
            1,
            5,
            8,
            7,
            6,
            2,
            13,
            14,
            0,
            3,
            9,
            11
          ];
          var s = [
            11,
            14,
            15,
            12,
            5,
            8,
            7,
            9,
            11,
            13,
            14,
            15,
            6,
            7,
            9,
            8,
            7,
            6,
            8,
            13,
            11,
            9,
            7,
            15,
            7,
            12,
            15,
            9,
            11,
            7,
            13,
            12,
            11,
            13,
            6,
            7,
            14,
            9,
            13,
            15,
            14,
            8,
            13,
            6,
            5,
            12,
            7,
            5,
            11,
            12,
            14,
            15,
            14,
            15,
            9,
            8,
            9,
            14,
            5,
            6,
            8,
            6,
            5,
            12,
            9,
            15,
            5,
            11,
            6,
            8,
            13,
            12,
            5,
            12,
            13,
            14,
            11,
            8,
            5,
            6
          ];
          var sh = [
            8,
            9,
            9,
            11,
            13,
            15,
            15,
            5,
            7,
            7,
            8,
            11,
            14,
            14,
            12,
            6,
            9,
            13,
            15,
            7,
            12,
            8,
            9,
            11,
            7,
            7,
            12,
            7,
            6,
            15,
            13,
            11,
            9,
            7,
            15,
            11,
            8,
            6,
            6,
            14,
            12,
            13,
            5,
            14,
            13,
            13,
            7,
            5,
            15,
            5,
            8,
            11,
            14,
            14,
            6,
            14,
            6,
            9,
            12,
            9,
            12,
            5,
            15,
            8,
            8,
            5,
            12,
            9,
            12,
            5,
            14,
            6,
            8,
            13,
            6,
            5,
            15,
            13,
            11,
            11
          ];
        },
        { './common': 327, './utils': 337 }
      ],
      330: [
        function(require, module, exports) {
          'use strict';
          exports.sha1 = require('./sha/1');
          exports.sha224 = require('./sha/224');
          exports.sha256 = require('./sha/256');
          exports.sha384 = require('./sha/384');
          exports.sha512 = require('./sha/512');
        },
        {
          './sha/1': 331,
          './sha/224': 332,
          './sha/256': 333,
          './sha/384': 334,
          './sha/512': 335
        }
      ],
      331: [
        function(require, module, exports) {
          'use strict';
          var utils = require('../utils');
          var common = require('../common');
          var shaCommon = require('./common');
          var rotl32 = utils.rotl32;
          var sum32 = utils.sum32;
          var sum32_5 = utils.sum32_5;
          var ft_1 = shaCommon.ft_1;
          var BlockHash = common.BlockHash;
          var sha1_K = [1518500249, 1859775393, 2400959708, 3395469782];
          function SHA1() {
            if (!(this instanceof SHA1)) return new SHA1();
            BlockHash.call(this);
            this.h = [
              1732584193,
              4023233417,
              2562383102,
              271733878,
              3285377520
            ];
            this.W = new Array(80);
          }
          utils.inherits(SHA1, BlockHash);
          module.exports = SHA1;
          SHA1.blockSize = 512;
          SHA1.outSize = 160;
          SHA1.hmacStrength = 80;
          SHA1.padLength = 64;
          SHA1.prototype._update = function _update(msg, start) {
            var W = this.W;
            for (var i = 0; i < 16; i++) W[i] = msg[start + i];
            for (; i < W.length; i++)
              W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
            var a = this.h[0];
            var b = this.h[1];
            var c = this.h[2];
            var d = this.h[3];
            var e = this.h[4];
            for (i = 0; i < W.length; i++) {
              var s = ~~(i / 20);
              var t = sum32_5(
                rotl32(a, 5),
                ft_1(s, b, c, d),
                e,
                W[i],
                sha1_K[s]
              );
              e = d;
              d = c;
              c = rotl32(b, 30);
              b = a;
              a = t;
            }
            this.h[0] = sum32(this.h[0], a);
            this.h[1] = sum32(this.h[1], b);
            this.h[2] = sum32(this.h[2], c);
            this.h[3] = sum32(this.h[3], d);
            this.h[4] = sum32(this.h[4], e);
          };
          SHA1.prototype._digest = function digest(enc) {
            if (enc === 'hex') return utils.toHex32(this.h, 'big');
            else return utils.split32(this.h, 'big');
          };
        },
        { '../common': 327, '../utils': 337, './common': 336 }
      ],
      332: [
        function(require, module, exports) {
          'use strict';
          var utils = require('../utils');
          var SHA256 = require('./256');
          function SHA224() {
            if (!(this instanceof SHA224)) return new SHA224();
            SHA256.call(this);
            this.h = [
              3238371032,
              914150663,
              812702999,
              4144912697,
              4290775857,
              1750603025,
              1694076839,
              3204075428
            ];
          }
          utils.inherits(SHA224, SHA256);
          module.exports = SHA224;
          SHA224.blockSize = 512;
          SHA224.outSize = 224;
          SHA224.hmacStrength = 192;
          SHA224.padLength = 64;
          SHA224.prototype._digest = function digest(enc) {
            if (enc === 'hex') return utils.toHex32(this.h.slice(0, 7), 'big');
            else return utils.split32(this.h.slice(0, 7), 'big');
          };
        },
        { '../utils': 337, './256': 333 }
      ],
      333: [
        function(require, module, exports) {
          'use strict';
          var utils = require('../utils');
          var common = require('../common');
          var shaCommon = require('./common');
          var assert = require('minimalistic-assert');
          var sum32 = utils.sum32;
          var sum32_4 = utils.sum32_4;
          var sum32_5 = utils.sum32_5;
          var ch32 = shaCommon.ch32;
          var maj32 = shaCommon.maj32;
          var s0_256 = shaCommon.s0_256;
          var s1_256 = shaCommon.s1_256;
          var g0_256 = shaCommon.g0_256;
          var g1_256 = shaCommon.g1_256;
          var BlockHash = common.BlockHash;
          var sha256_K = [
            1116352408,
            1899447441,
            3049323471,
            3921009573,
            961987163,
            1508970993,
            2453635748,
            2870763221,
            3624381080,
            310598401,
            607225278,
            1426881987,
            1925078388,
            2162078206,
            2614888103,
            3248222580,
            3835390401,
            4022224774,
            264347078,
            604807628,
            770255983,
            1249150122,
            1555081692,
            1996064986,
            2554220882,
            2821834349,
            2952996808,
            3210313671,
            3336571891,
            3584528711,
            113926993,
            338241895,
            666307205,
            773529912,
            1294757372,
            1396182291,
            1695183700,
            1986661051,
            2177026350,
            2456956037,
            2730485921,
            2820302411,
            3259730800,
            3345764771,
            3516065817,
            3600352804,
            4094571909,
            275423344,
            430227734,
            506948616,
            659060556,
            883997877,
            958139571,
            1322822218,
            1537002063,
            1747873779,
            1955562222,
            2024104815,
            2227730452,
            2361852424,
            2428436474,
            2756734187,
            3204031479,
            3329325298
          ];
          function SHA256() {
            if (!(this instanceof SHA256)) return new SHA256();
            BlockHash.call(this);
            this.h = [
              1779033703,
              3144134277,
              1013904242,
              2773480762,
              1359893119,
              2600822924,
              528734635,
              1541459225
            ];
            this.k = sha256_K;
            this.W = new Array(64);
          }
          utils.inherits(SHA256, BlockHash);
          module.exports = SHA256;
          SHA256.blockSize = 512;
          SHA256.outSize = 256;
          SHA256.hmacStrength = 192;
          SHA256.padLength = 64;
          SHA256.prototype._update = function _update(msg, start) {
            var W = this.W;
            for (var i = 0; i < 16; i++) W[i] = msg[start + i];
            for (; i < W.length; i++)
              W[i] = sum32_4(
                g1_256(W[i - 2]),
                W[i - 7],
                g0_256(W[i - 15]),
                W[i - 16]
              );
            var a = this.h[0];
            var b = this.h[1];
            var c = this.h[2];
            var d = this.h[3];
            var e = this.h[4];
            var f = this.h[5];
            var g = this.h[6];
            var h = this.h[7];
            assert(this.k.length === W.length);
            for (i = 0; i < W.length; i++) {
              var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
              var T2 = sum32(s0_256(a), maj32(a, b, c));
              h = g;
              g = f;
              f = e;
              e = sum32(d, T1);
              d = c;
              c = b;
              b = a;
              a = sum32(T1, T2);
            }
            this.h[0] = sum32(this.h[0], a);
            this.h[1] = sum32(this.h[1], b);
            this.h[2] = sum32(this.h[2], c);
            this.h[3] = sum32(this.h[3], d);
            this.h[4] = sum32(this.h[4], e);
            this.h[5] = sum32(this.h[5], f);
            this.h[6] = sum32(this.h[6], g);
            this.h[7] = sum32(this.h[7], h);
          };
          SHA256.prototype._digest = function digest(enc) {
            if (enc === 'hex') return utils.toHex32(this.h, 'big');
            else return utils.split32(this.h, 'big');
          };
        },
        {
          '../common': 327,
          '../utils': 337,
          './common': 336,
          'minimalistic-assert': 340
        }
      ],
      334: [
        function(require, module, exports) {
          'use strict';
          var utils = require('../utils');
          var SHA512 = require('./512');
          function SHA384() {
            if (!(this instanceof SHA384)) return new SHA384();
            SHA512.call(this);
            this.h = [
              3418070365,
              3238371032,
              1654270250,
              914150663,
              2438529370,
              812702999,
              355462360,
              4144912697,
              1731405415,
              4290775857,
              2394180231,
              1750603025,
              3675008525,
              1694076839,
              1203062813,
              3204075428
            ];
          }
          utils.inherits(SHA384, SHA512);
          module.exports = SHA384;
          SHA384.blockSize = 1024;
          SHA384.outSize = 384;
          SHA384.hmacStrength = 192;
          SHA384.padLength = 128;
          SHA384.prototype._digest = function digest(enc) {
            if (enc === 'hex') return utils.toHex32(this.h.slice(0, 12), 'big');
            else return utils.split32(this.h.slice(0, 12), 'big');
          };
        },
        { '../utils': 337, './512': 335 }
      ],
      335: [
        function(require, module, exports) {
          'use strict';
          var utils = require('../utils');
          var common = require('../common');
          var assert = require('minimalistic-assert');
          var rotr64_hi = utils.rotr64_hi;
          var rotr64_lo = utils.rotr64_lo;
          var shr64_hi = utils.shr64_hi;
          var shr64_lo = utils.shr64_lo;
          var sum64 = utils.sum64;
          var sum64_hi = utils.sum64_hi;
          var sum64_lo = utils.sum64_lo;
          var sum64_4_hi = utils.sum64_4_hi;
          var sum64_4_lo = utils.sum64_4_lo;
          var sum64_5_hi = utils.sum64_5_hi;
          var sum64_5_lo = utils.sum64_5_lo;
          var BlockHash = common.BlockHash;
          var sha512_K = [
            1116352408,
            3609767458,
            1899447441,
            602891725,
            3049323471,
            3964484399,
            3921009573,
            2173295548,
            961987163,
            4081628472,
            1508970993,
            3053834265,
            2453635748,
            2937671579,
            2870763221,
            3664609560,
            3624381080,
            2734883394,
            310598401,
            1164996542,
            607225278,
            1323610764,
            1426881987,
            3590304994,
            1925078388,
            4068182383,
            2162078206,
            991336113,
            2614888103,
            633803317,
            3248222580,
            3479774868,
            3835390401,
            2666613458,
            4022224774,
            944711139,
            264347078,
            2341262773,
            604807628,
            2007800933,
            770255983,
            1495990901,
            1249150122,
            1856431235,
            1555081692,
            3175218132,
            1996064986,
            2198950837,
            2554220882,
            3999719339,
            2821834349,
            766784016,
            2952996808,
            2566594879,
            3210313671,
            3203337956,
            3336571891,
            1034457026,
            3584528711,
            2466948901,
            113926993,
            3758326383,
            338241895,
            168717936,
            666307205,
            1188179964,
            773529912,
            1546045734,
            1294757372,
            1522805485,
            1396182291,
            2643833823,
            1695183700,
            2343527390,
            1986661051,
            1014477480,
            2177026350,
            1206759142,
            2456956037,
            344077627,
            2730485921,
            1290863460,
            2820302411,
            3158454273,
            3259730800,
            3505952657,
            3345764771,
            106217008,
            3516065817,
            3606008344,
            3600352804,
            1432725776,
            4094571909,
            1467031594,
            275423344,
            851169720,
            430227734,
            3100823752,
            506948616,
            1363258195,
            659060556,
            3750685593,
            883997877,
            3785050280,
            958139571,
            3318307427,
            1322822218,
            3812723403,
            1537002063,
            2003034995,
            1747873779,
            3602036899,
            1955562222,
            1575990012,
            2024104815,
            1125592928,
            2227730452,
            2716904306,
            2361852424,
            442776044,
            2428436474,
            593698344,
            2756734187,
            3733110249,
            3204031479,
            2999351573,
            3329325298,
            3815920427,
            3391569614,
            3928383900,
            3515267271,
            566280711,
            3940187606,
            3454069534,
            4118630271,
            4000239992,
            116418474,
            1914138554,
            174292421,
            2731055270,
            289380356,
            3203993006,
            460393269,
            320620315,
            685471733,
            587496836,
            852142971,
            1086792851,
            1017036298,
            365543100,
            1126000580,
            2618297676,
            1288033470,
            3409855158,
            1501505948,
            4234509866,
            1607167915,
            987167468,
            1816402316,
            1246189591
          ];
          function SHA512() {
            if (!(this instanceof SHA512)) return new SHA512();
            BlockHash.call(this);
            this.h = [
              1779033703,
              4089235720,
              3144134277,
              2227873595,
              1013904242,
              4271175723,
              2773480762,
              1595750129,
              1359893119,
              2917565137,
              2600822924,
              725511199,
              528734635,
              4215389547,
              1541459225,
              327033209
            ];
            this.k = sha512_K;
            this.W = new Array(160);
          }
          utils.inherits(SHA512, BlockHash);
          module.exports = SHA512;
          SHA512.blockSize = 1024;
          SHA512.outSize = 512;
          SHA512.hmacStrength = 192;
          SHA512.padLength = 128;
          SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
            var W = this.W;
            for (var i = 0; i < 32; i++) W[i] = msg[start + i];
            for (; i < W.length; i += 2) {
              var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);
              var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
              var c1_hi = W[i - 14];
              var c1_lo = W[i - 13];
              var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);
              var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
              var c3_hi = W[i - 32];
              var c3_lo = W[i - 31];
              W[i] = sum64_4_hi(
                c0_hi,
                c0_lo,
                c1_hi,
                c1_lo,
                c2_hi,
                c2_lo,
                c3_hi,
                c3_lo
              );
              W[i + 1] = sum64_4_lo(
                c0_hi,
                c0_lo,
                c1_hi,
                c1_lo,
                c2_hi,
                c2_lo,
                c3_hi,
                c3_lo
              );
            }
          };
          SHA512.prototype._update = function _update(msg, start) {
            this._prepareBlock(msg, start);
            var W = this.W;
            var ah = this.h[0];
            var al = this.h[1];
            var bh = this.h[2];
            var bl = this.h[3];
            var ch = this.h[4];
            var cl = this.h[5];
            var dh = this.h[6];
            var dl = this.h[7];
            var eh = this.h[8];
            var el = this.h[9];
            var fh = this.h[10];
            var fl = this.h[11];
            var gh = this.h[12];
            var gl = this.h[13];
            var hh = this.h[14];
            var hl = this.h[15];
            assert(this.k.length === W.length);
            for (var i = 0; i < W.length; i += 2) {
              var c0_hi = hh;
              var c0_lo = hl;
              var c1_hi = s1_512_hi(eh, el);
              var c1_lo = s1_512_lo(eh, el);
              var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
              var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
              var c3_hi = this.k[i];
              var c3_lo = this.k[i + 1];
              var c4_hi = W[i];
              var c4_lo = W[i + 1];
              var T1_hi = sum64_5_hi(
                c0_hi,
                c0_lo,
                c1_hi,
                c1_lo,
                c2_hi,
                c2_lo,
                c3_hi,
                c3_lo,
                c4_hi,
                c4_lo
              );
              var T1_lo = sum64_5_lo(
                c0_hi,
                c0_lo,
                c1_hi,
                c1_lo,
                c2_hi,
                c2_lo,
                c3_hi,
                c3_lo,
                c4_hi,
                c4_lo
              );
              c0_hi = s0_512_hi(ah, al);
              c0_lo = s0_512_lo(ah, al);
              c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
              c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
              var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
              var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
              hh = gh;
              hl = gl;
              gh = fh;
              gl = fl;
              fh = eh;
              fl = el;
              eh = sum64_hi(dh, dl, T1_hi, T1_lo);
              el = sum64_lo(dl, dl, T1_hi, T1_lo);
              dh = ch;
              dl = cl;
              ch = bh;
              cl = bl;
              bh = ah;
              bl = al;
              ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
              al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
            }
            sum64(this.h, 0, ah, al);
            sum64(this.h, 2, bh, bl);
            sum64(this.h, 4, ch, cl);
            sum64(this.h, 6, dh, dl);
            sum64(this.h, 8, eh, el);
            sum64(this.h, 10, fh, fl);
            sum64(this.h, 12, gh, gl);
            sum64(this.h, 14, hh, hl);
          };
          SHA512.prototype._digest = function digest(enc) {
            if (enc === 'hex') return utils.toHex32(this.h, 'big');
            else return utils.split32(this.h, 'big');
          };
          function ch64_hi(xh, xl, yh, yl, zh) {
            var r = (xh & yh) ^ (~xh & zh);
            if (r < 0) r += 4294967296;
            return r;
          }
          function ch64_lo(xh, xl, yh, yl, zh, zl) {
            var r = (xl & yl) ^ (~xl & zl);
            if (r < 0) r += 4294967296;
            return r;
          }
          function maj64_hi(xh, xl, yh, yl, zh) {
            var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
            if (r < 0) r += 4294967296;
            return r;
          }
          function maj64_lo(xh, xl, yh, yl, zh, zl) {
            var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
            if (r < 0) r += 4294967296;
            return r;
          }
          function s0_512_hi(xh, xl) {
            var c0_hi = rotr64_hi(xh, xl, 28);
            var c1_hi = rotr64_hi(xl, xh, 2);
            var c2_hi = rotr64_hi(xl, xh, 7);
            var r = c0_hi ^ c1_hi ^ c2_hi;
            if (r < 0) r += 4294967296;
            return r;
          }
          function s0_512_lo(xh, xl) {
            var c0_lo = rotr64_lo(xh, xl, 28);
            var c1_lo = rotr64_lo(xl, xh, 2);
            var c2_lo = rotr64_lo(xl, xh, 7);
            var r = c0_lo ^ c1_lo ^ c2_lo;
            if (r < 0) r += 4294967296;
            return r;
          }
          function s1_512_hi(xh, xl) {
            var c0_hi = rotr64_hi(xh, xl, 14);
            var c1_hi = rotr64_hi(xh, xl, 18);
            var c2_hi = rotr64_hi(xl, xh, 9);
            var r = c0_hi ^ c1_hi ^ c2_hi;
            if (r < 0) r += 4294967296;
            return r;
          }
          function s1_512_lo(xh, xl) {
            var c0_lo = rotr64_lo(xh, xl, 14);
            var c1_lo = rotr64_lo(xh, xl, 18);
            var c2_lo = rotr64_lo(xl, xh, 9);
            var r = c0_lo ^ c1_lo ^ c2_lo;
            if (r < 0) r += 4294967296;
            return r;
          }
          function g0_512_hi(xh, xl) {
            var c0_hi = rotr64_hi(xh, xl, 1);
            var c1_hi = rotr64_hi(xh, xl, 8);
            var c2_hi = shr64_hi(xh, xl, 7);
            var r = c0_hi ^ c1_hi ^ c2_hi;
            if (r < 0) r += 4294967296;
            return r;
          }
          function g0_512_lo(xh, xl) {
            var c0_lo = rotr64_lo(xh, xl, 1);
            var c1_lo = rotr64_lo(xh, xl, 8);
            var c2_lo = shr64_lo(xh, xl, 7);
            var r = c0_lo ^ c1_lo ^ c2_lo;
            if (r < 0) r += 4294967296;
            return r;
          }
          function g1_512_hi(xh, xl) {
            var c0_hi = rotr64_hi(xh, xl, 19);
            var c1_hi = rotr64_hi(xl, xh, 29);
            var c2_hi = shr64_hi(xh, xl, 6);
            var r = c0_hi ^ c1_hi ^ c2_hi;
            if (r < 0) r += 4294967296;
            return r;
          }
          function g1_512_lo(xh, xl) {
            var c0_lo = rotr64_lo(xh, xl, 19);
            var c1_lo = rotr64_lo(xl, xh, 29);
            var c2_lo = shr64_lo(xh, xl, 6);
            var r = c0_lo ^ c1_lo ^ c2_lo;
            if (r < 0) r += 4294967296;
            return r;
          }
        },
        { '../common': 327, '../utils': 337, 'minimalistic-assert': 340 }
      ],
      336: [
        function(require, module, exports) {
          'use strict';
          var utils = require('../utils');
          var rotr32 = utils.rotr32;
          function ft_1(s, x, y, z) {
            if (s === 0) return ch32(x, y, z);
            if (s === 1 || s === 3) return p32(x, y, z);
            if (s === 2) return maj32(x, y, z);
          }
          exports.ft_1 = ft_1;
          function ch32(x, y, z) {
            return (x & y) ^ (~x & z);
          }
          exports.ch32 = ch32;
          function maj32(x, y, z) {
            return (x & y) ^ (x & z) ^ (y & z);
          }
          exports.maj32 = maj32;
          function p32(x, y, z) {
            return x ^ y ^ z;
          }
          exports.p32 = p32;
          function s0_256(x) {
            return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
          }
          exports.s0_256 = s0_256;
          function s1_256(x) {
            return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
          }
          exports.s1_256 = s1_256;
          function g0_256(x) {
            return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
          }
          exports.g0_256 = g0_256;
          function g1_256(x) {
            return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
          }
          exports.g1_256 = g1_256;
        },
        { '../utils': 337 }
      ],
      337: [
        function(require, module, exports) {
          'use strict';
          var assert = require('minimalistic-assert');
          var inherits = require('inherits');
          exports.inherits = inherits;
          function toArray(msg, enc) {
            if (Array.isArray(msg)) return msg.slice();
            if (!msg) return [];
            var res = [];
            if (typeof msg === 'string') {
              if (!enc) {
                for (var i = 0; i < msg.length; i++) {
                  var c = msg.charCodeAt(i);
                  var hi = c >> 8;
                  var lo = c & 255;
                  if (hi) res.push(hi, lo);
                  else res.push(lo);
                }
              } else if (enc === 'hex') {
                msg = msg.replace(/[^a-z0-9]+/gi, '');
                if (msg.length % 2 !== 0) msg = '0' + msg;
                for (i = 0; i < msg.length; i += 2)
                  res.push(parseInt(msg[i] + msg[i + 1], 16));
              }
            } else {
              for (i = 0; i < msg.length; i++) res[i] = msg[i] | 0;
            }
            return res;
          }
          exports.toArray = toArray;
          function toHex(msg) {
            var res = '';
            for (var i = 0; i < msg.length; i++)
              res += zero2(msg[i].toString(16));
            return res;
          }
          exports.toHex = toHex;
          function htonl(w) {
            var res =
              (w >>> 24) |
              ((w >>> 8) & 65280) |
              ((w << 8) & 16711680) |
              ((w & 255) << 24);
            return res >>> 0;
          }
          exports.htonl = htonl;
          function toHex32(msg, endian) {
            var res = '';
            for (var i = 0; i < msg.length; i++) {
              var w = msg[i];
              if (endian === 'little') w = htonl(w);
              res += zero8(w.toString(16));
            }
            return res;
          }
          exports.toHex32 = toHex32;
          function zero2(word) {
            if (word.length === 1) return '0' + word;
            else return word;
          }
          exports.zero2 = zero2;
          function zero8(word) {
            if (word.length === 7) return '0' + word;
            else if (word.length === 6) return '00' + word;
            else if (word.length === 5) return '000' + word;
            else if (word.length === 4) return '0000' + word;
            else if (word.length === 3) return '00000' + word;
            else if (word.length === 2) return '000000' + word;
            else if (word.length === 1) return '0000000' + word;
            else return word;
          }
          exports.zero8 = zero8;
          function join32(msg, start, end, endian) {
            var len = end - start;
            assert(len % 4 === 0);
            var res = new Array(len / 4);
            for (var i = 0, k = start; i < res.length; i++, k += 4) {
              var w;
              if (endian === 'big')
                w =
                  (msg[k] << 24) |
                  (msg[k + 1] << 16) |
                  (msg[k + 2] << 8) |
                  msg[k + 3];
              else
                w =
                  (msg[k + 3] << 24) |
                  (msg[k + 2] << 16) |
                  (msg[k + 1] << 8) |
                  msg[k];
              res[i] = w >>> 0;
            }
            return res;
          }
          exports.join32 = join32;
          function split32(msg, endian) {
            var res = new Array(msg.length * 4);
            for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
              var m = msg[i];
              if (endian === 'big') {
                res[k] = m >>> 24;
                res[k + 1] = (m >>> 16) & 255;
                res[k + 2] = (m >>> 8) & 255;
                res[k + 3] = m & 255;
              } else {
                res[k + 3] = m >>> 24;
                res[k + 2] = (m >>> 16) & 255;
                res[k + 1] = (m >>> 8) & 255;
                res[k] = m & 255;
              }
            }
            return res;
          }
          exports.split32 = split32;
          function rotr32(w, b) {
            return (w >>> b) | (w << (32 - b));
          }
          exports.rotr32 = rotr32;
          function rotl32(w, b) {
            return (w << b) | (w >>> (32 - b));
          }
          exports.rotl32 = rotl32;
          function sum32(a, b) {
            return (a + b) >>> 0;
          }
          exports.sum32 = sum32;
          function sum32_3(a, b, c) {
            return (a + b + c) >>> 0;
          }
          exports.sum32_3 = sum32_3;
          function sum32_4(a, b, c, d) {
            return (a + b + c + d) >>> 0;
          }
          exports.sum32_4 = sum32_4;
          function sum32_5(a, b, c, d, e) {
            return (a + b + c + d + e) >>> 0;
          }
          exports.sum32_5 = sum32_5;
          function sum64(buf, pos, ah, al) {
            var bh = buf[pos];
            var bl = buf[pos + 1];
            var lo = (al + bl) >>> 0;
            var hi = (lo < al ? 1 : 0) + ah + bh;
            buf[pos] = hi >>> 0;
            buf[pos + 1] = lo;
          }
          exports.sum64 = sum64;
          function sum64_hi(ah, al, bh, bl) {
            var lo = (al + bl) >>> 0;
            var hi = (lo < al ? 1 : 0) + ah + bh;
            return hi >>> 0;
          }
          exports.sum64_hi = sum64_hi;
          function sum64_lo(ah, al, bh, bl) {
            var lo = al + bl;
            return lo >>> 0;
          }
          exports.sum64_lo = sum64_lo;
          function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
            var carry = 0;
            var lo = al;
            lo = (lo + bl) >>> 0;
            carry += lo < al ? 1 : 0;
            lo = (lo + cl) >>> 0;
            carry += lo < cl ? 1 : 0;
            lo = (lo + dl) >>> 0;
            carry += lo < dl ? 1 : 0;
            var hi = ah + bh + ch + dh + carry;
            return hi >>> 0;
          }
          exports.sum64_4_hi = sum64_4_hi;
          function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
            var lo = al + bl + cl + dl;
            return lo >>> 0;
          }
          exports.sum64_4_lo = sum64_4_lo;
          function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
            var carry = 0;
            var lo = al;
            lo = (lo + bl) >>> 0;
            carry += lo < al ? 1 : 0;
            lo = (lo + cl) >>> 0;
            carry += lo < cl ? 1 : 0;
            lo = (lo + dl) >>> 0;
            carry += lo < dl ? 1 : 0;
            lo = (lo + el) >>> 0;
            carry += lo < el ? 1 : 0;
            var hi = ah + bh + ch + dh + eh + carry;
            return hi >>> 0;
          }
          exports.sum64_5_hi = sum64_5_hi;
          function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
            var lo = al + bl + cl + dl + el;
            return lo >>> 0;
          }
          exports.sum64_5_lo = sum64_5_lo;
          function rotr64_hi(ah, al, num) {
            var r = (al << (32 - num)) | (ah >>> num);
            return r >>> 0;
          }
          exports.rotr64_hi = rotr64_hi;
          function rotr64_lo(ah, al, num) {
            var r = (ah << (32 - num)) | (al >>> num);
            return r >>> 0;
          }
          exports.rotr64_lo = rotr64_lo;
          function shr64_hi(ah, al, num) {
            return ah >>> num;
          }
          exports.shr64_hi = shr64_hi;
          function shr64_lo(ah, al, num) {
            var r = (ah << (32 - num)) | (al >>> num);
            return r >>> 0;
          }
          exports.shr64_lo = shr64_lo;
        },
        { inherits: 339, 'minimalistic-assert': 340 }
      ],
      338: [
        function(require, module, exports) {
          'use strict';
          var hash = require('hash.js');
          var utils = require('minimalistic-crypto-utils');
          var assert = require('minimalistic-assert');
          function HmacDRBG(options) {
            if (!(this instanceof HmacDRBG)) return new HmacDRBG(options);
            this.hash = options.hash;
            this.predResist = !!options.predResist;
            this.outLen = this.hash.outSize;
            this.minEntropy = options.minEntropy || this.hash.hmacStrength;
            this._reseed = null;
            this.reseedInterval = null;
            this.K = null;
            this.V = null;
            var entropy = utils.toArray(
              options.entropy,
              options.entropyEnc || 'hex'
            );
            var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');
            var pers = utils.toArray(options.pers, options.persEnc || 'hex');
            assert(
              entropy.length >= this.minEntropy / 8,
              'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits'
            );
            this._init(entropy, nonce, pers);
          }
          module.exports = HmacDRBG;
          HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
            var seed = entropy.concat(nonce).concat(pers);
            this.K = new Array(this.outLen / 8);
            this.V = new Array(this.outLen / 8);
            for (var i = 0; i < this.V.length; i++) {
              this.K[i] = 0;
              this.V[i] = 1;
            }
            this._update(seed);
            this._reseed = 1;
            this.reseedInterval = 281474976710656;
          };
          HmacDRBG.prototype._hmac = function hmac() {
            return new hash.hmac(this.hash, this.K);
          };
          HmacDRBG.prototype._update = function update(seed) {
            var kmac = this._hmac()
              .update(this.V)
              .update([0]);
            if (seed) kmac = kmac.update(seed);
            this.K = kmac.digest();
            this.V = this._hmac()
              .update(this.V)
              .digest();
            if (!seed) return;
            this.K = this._hmac()
              .update(this.V)
              .update([1])
              .update(seed)
              .digest();
            this.V = this._hmac()
              .update(this.V)
              .digest();
          };
          HmacDRBG.prototype.reseed = function reseed(
            entropy,
            entropyEnc,
            add,
            addEnc
          ) {
            if (typeof entropyEnc !== 'string') {
              addEnc = add;
              add = entropyEnc;
              entropyEnc = null;
            }
            entropy = utils.toArray(entropy, entropyEnc);
            add = utils.toArray(add, addEnc);
            assert(
              entropy.length >= this.minEntropy / 8,
              'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits'
            );
            this._update(entropy.concat(add || []));
            this._reseed = 1;
          };
          HmacDRBG.prototype.generate = function generate(
            len,
            enc,
            add,
            addEnc
          ) {
            if (this._reseed > this.reseedInterval)
              throw new Error('Reseed is required');
            if (typeof enc !== 'string') {
              addEnc = add;
              add = enc;
              enc = null;
            }
            if (add) {
              add = utils.toArray(add, addEnc || 'hex');
              this._update(add);
            }
            var temp = [];
            while (temp.length < len) {
              this.V = this._hmac()
                .update(this.V)
                .digest();
              temp = temp.concat(this.V);
            }
            var res = temp.slice(0, len);
            this._update(add);
            this._reseed++;
            return utils.encode(res, enc);
          };
        },
        {
          'hash.js': 326,
          'minimalistic-assert': 340,
          'minimalistic-crypto-utils': 341
        }
      ],
      339: [
        function(require, module, exports) {
          arguments[4][207][0].apply(exports, arguments);
        },
        { dup: 207 }
      ],
      340: [
        function(require, module, exports) {
          arguments[4][211][0].apply(exports, arguments);
        },
        { dup: 211 }
      ],
      341: [
        function(require, module, exports) {
          'use strict';
          var utils = exports;
          function toArray(msg, enc) {
            if (Array.isArray(msg)) return msg.slice();
            if (!msg) return [];
            var res = [];
            if (typeof msg !== 'string') {
              for (var i = 0; i < msg.length; i++) res[i] = msg[i] | 0;
              return res;
            }
            if (enc === 'hex') {
              msg = msg.replace(/[^a-z0-9]+/gi, '');
              if (msg.length % 2 !== 0) msg = '0' + msg;
              for (var i = 0; i < msg.length; i += 2)
                res.push(parseInt(msg[i] + msg[i + 1], 16));
            } else {
              for (var i = 0; i < msg.length; i++) {
                var c = msg.charCodeAt(i);
                var hi = c >> 8;
                var lo = c & 255;
                if (hi) res.push(hi, lo);
                else res.push(lo);
              }
            }
            return res;
          }
          utils.toArray = toArray;
          function zero2(word) {
            if (word.length === 1) return '0' + word;
            else return word;
          }
          utils.zero2 = zero2;
          function toHex(msg) {
            var res = '';
            for (var i = 0; i < msg.length; i++)
              res += zero2(msg[i].toString(16));
            return res;
          }
          utils.toHex = toHex;
          utils.encode = function encode(arr, enc) {
            if (enc === 'hex') return toHex(arr);
            else return arr;
          };
        },
        {}
      ],
      342: [
        function(require, module, exports) {
          module.exports = {
            _args: [
              [
                'elliptic@6.4.0',
                '/Users/Yukan/Desktop/work/blockstack/blockstack.js'
              ]
            ],
            _from: 'elliptic@6.4.0',
            _id: 'elliptic@6.4.0',
            _inBundle: false,
            _integrity: 'sha1-ysmvh2LIWDYYcAPI3+GT5eLq5d8=',
            _location: '/elliptic',
            _phantomChildren: {},
            _requested: {
              type: 'version',
              registry: true,
              raw: 'elliptic@6.4.0',
              name: 'elliptic',
              escapedName: 'elliptic',
              rawSpec: '6.4.0',
              saveSpec: null,
              fetchSpec: '6.4.0'
            },
            _requiredBy: [
              '/',
              '/browserify/browserify-sign',
              '/browserify/create-ecdh',
              '/jsontokens',
              '/tiny-secp256k1'
            ],
            _resolved:
              'https://registry.npmjs.org/elliptic/-/elliptic-6.4.0.tgz',
            _spec: '6.4.0',
            _where: '/Users/Yukan/Desktop/work/blockstack/blockstack.js',
            author: { name: 'Fedor Indutny', email: 'fedor@indutny.com' },
            bugs: { url: 'https://github.com/indutny/elliptic/issues' },
            dependencies: {
              'bn.js': '^4.4.0',
              brorand: '^1.0.1',
              'hash.js': '^1.0.0',
              'hmac-drbg': '^1.0.0',
              inherits: '^2.0.1',
              'minimalistic-assert': '^1.0.0',
              'minimalistic-crypto-utils': '^1.0.0'
            },
            description: 'EC cryptography',
            devDependencies: {
              brfs: '^1.4.3',
              coveralls: '^2.11.3',
              grunt: '^0.4.5',
              'grunt-browserify': '^5.0.0',
              'grunt-cli': '^1.2.0',
              'grunt-contrib-connect': '^1.0.0',
              'grunt-contrib-copy': '^1.0.0',
              'grunt-contrib-uglify': '^1.0.1',
              'grunt-mocha-istanbul': '^3.0.1',
              'grunt-saucelabs': '^8.6.2',
              istanbul: '^0.4.2',
              jscs: '^2.9.0',
              jshint: '^2.6.0',
              mocha: '^2.1.0'
            },
            files: ['lib'],
            homepage: 'https://github.com/indutny/elliptic',
            keywords: ['EC', 'Elliptic', 'curve', 'Cryptography'],
            license: 'MIT',
            main: 'lib/elliptic.js',
            name: 'elliptic',
            repository: {
              type: 'git',
              url: 'git+ssh://git@github.com/indutny/elliptic.git'
            },
            scripts: {
              jscs:
                'jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js',
              jshint:
                'jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js',
              lint: 'npm run jscs && npm run jshint',
              test: 'npm run lint && npm run unit',
              unit: 'istanbul test _mocha --reporter=spec test/index.js',
              version: 'grunt dist && git add dist/'
            },
            version: '6.4.0'
          };
        },
        {}
      ],
      343: [
        function(require, module, exports) {
          var encode = require('./lib/encode.js'),
            decode = require('./lib/decode.js');
          exports.decode = function(data, level) {
            return (!level || level <= 0 ? decode.XML : decode.HTML)(data);
          };
          exports.decodeStrict = function(data, level) {
            return (!level || level <= 0 ? decode.XML : decode.HTMLStrict)(
              data
            );
          };
          exports.encode = function(data, level) {
            return (!level || level <= 0 ? encode.XML : encode.HTML)(data);
          };
          exports.encodeXML = encode.XML;
          exports.encodeHTML4 = exports.encodeHTML5 = exports.encodeHTML =
            encode.HTML;
          exports.decodeXML = exports.decodeXMLStrict = decode.XML;
          exports.decodeHTML4 = exports.decodeHTML5 = exports.decodeHTML =
            decode.HTML;
          exports.decodeHTML4Strict = exports.decodeHTML5Strict = exports.decodeHTMLStrict =
            decode.HTMLStrict;
          exports.escape = encode.escape;
        },
        { './lib/decode.js': 344, './lib/encode.js': 346 }
      ],
      344: [
        function(require, module, exports) {
          var entityMap = require('../maps/entities.json'),
            legacyMap = require('../maps/legacy.json'),
            xmlMap = require('../maps/xml.json'),
            decodeCodePoint = require('./decode_codepoint.js');
          var decodeXMLStrict = getStrictDecoder(xmlMap),
            decodeHTMLStrict = getStrictDecoder(entityMap);
          function getStrictDecoder(map) {
            var keys = Object.keys(map).join('|'),
              replace = getReplacer(map);
            keys += '|#[xX][\\da-fA-F]+|#\\d+';
            var re = new RegExp('&(?:' + keys + ');', 'g');
            return function(str) {
              return String(str).replace(re, replace);
            };
          }
          var decodeHTML = (function() {
            var legacy = Object.keys(legacyMap).sort(sorter);
            var keys = Object.keys(entityMap).sort(sorter);
            for (var i = 0, j = 0; i < keys.length; i++) {
              if (legacy[j] === keys[i]) {
                keys[i] += ';?';
                j++;
              } else {
                keys[i] += ';';
              }
            }
            var re = new RegExp(
                '&(?:' + keys.join('|') + '|#[xX][\\da-fA-F]+;?|#\\d+;?)',
                'g'
              ),
              replace = getReplacer(entityMap);
            function replacer(str) {
              if (str.substr(-1) !== ';') str += ';';
              return replace(str);
            }
            return function(str) {
              return String(str).replace(re, replacer);
            };
          })();
          function sorter(a, b) {
            return a < b ? 1 : -1;
          }
          function getReplacer(map) {
            return function replace(str) {
              if (str.charAt(1) === '#') {
                if (str.charAt(2) === 'X' || str.charAt(2) === 'x') {
                  return decodeCodePoint(parseInt(str.substr(3), 16));
                }
                return decodeCodePoint(parseInt(str.substr(2), 10));
              }
              return map[str.slice(1, -1)];
            };
          }
          module.exports = {
            XML: decodeXMLStrict,
            HTML: decodeHTML,
            HTMLStrict: decodeHTMLStrict
          };
        },
        {
          '../maps/entities.json': 348,
          '../maps/legacy.json': 349,
          '../maps/xml.json': 350,
          './decode_codepoint.js': 345
        }
      ],
      345: [
        function(require, module, exports) {
          var decodeMap = require('../maps/decode.json');
          module.exports = decodeCodePoint;
          function decodeCodePoint(codePoint) {
            if (
              (codePoint >= 55296 && codePoint <= 57343) ||
              codePoint > 1114111
            ) {
              return '�';
            }
            if (codePoint in decodeMap) {
              codePoint = decodeMap[codePoint];
            }
            var output = '';
            if (codePoint > 65535) {
              codePoint -= 65536;
              output += String.fromCharCode(
                ((codePoint >>> 10) & 1023) | 55296
              );
              codePoint = 56320 | (codePoint & 1023);
            }
            output += String.fromCharCode(codePoint);
            return output;
          }
        },
        { '../maps/decode.json': 347 }
      ],
      346: [
        function(require, module, exports) {
          var inverseXML = getInverseObj(require('../maps/xml.json')),
            xmlReplacer = getInverseReplacer(inverseXML);
          exports.XML = getInverse(inverseXML, xmlReplacer);
          var inverseHTML = getInverseObj(require('../maps/entities.json')),
            htmlReplacer = getInverseReplacer(inverseHTML);
          exports.HTML = getInverse(inverseHTML, htmlReplacer);
          function getInverseObj(obj) {
            return Object.keys(obj)
              .sort()
              .reduce(function(inverse, name) {
                inverse[obj[name]] = '&' + name + ';';
                return inverse;
              }, {});
          }
          function getInverseReplacer(inverse) {
            var single = [],
              multiple = [];
            Object.keys(inverse).forEach(function(k) {
              if (k.length === 1) {
                single.push('\\' + k);
              } else {
                multiple.push(k);
              }
            });
            multiple.unshift('[' + single.join('') + ']');
            return new RegExp(multiple.join('|'), 'g');
          }
          var re_nonASCII = /[^\0-\x7F]/g,
            re_astralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
          function singleCharReplacer(c) {
            return (
              '&#x' +
              c
                .charCodeAt(0)
                .toString(16)
                .toUpperCase() +
              ';'
            );
          }
          function astralReplacer(c) {
            var high = c.charCodeAt(0);
            var low = c.charCodeAt(1);
            var codePoint = (high - 55296) * 1024 + low - 56320 + 65536;
            return '&#x' + codePoint.toString(16).toUpperCase() + ';';
          }
          function getInverse(inverse, re) {
            function func(name) {
              return inverse[name];
            }
            return function(data) {
              return data
                .replace(re, func)
                .replace(re_astralSymbols, astralReplacer)
                .replace(re_nonASCII, singleCharReplacer);
            };
          }
          var re_xmlChars = getInverseReplacer(inverseXML);
          function escapeXML(data) {
            return data
              .replace(re_xmlChars, singleCharReplacer)
              .replace(re_astralSymbols, astralReplacer)
              .replace(re_nonASCII, singleCharReplacer);
          }
          exports.escape = escapeXML;
        },
        { '../maps/entities.json': 348, '../maps/xml.json': 350 }
      ],
      347: [
        function(require, module, exports) {
          module.exports = {
            0: 65533,
            128: 8364,
            130: 8218,
            131: 402,
            132: 8222,
            133: 8230,
            134: 8224,
            135: 8225,
            136: 710,
            137: 8240,
            138: 352,
            139: 8249,
            140: 338,
            142: 381,
            145: 8216,
            146: 8217,
            147: 8220,
            148: 8221,
            149: 8226,
            150: 8211,
            151: 8212,
            152: 732,
            153: 8482,
            154: 353,
            155: 8250,
            156: 339,
            158: 382,
            159: 376
          };
        },
        {}
      ],
      348: [
        function(require, module, exports) {
          module.exports = {
            Aacute: 'Á',
            aacute: 'á',
            Abreve: 'Ă',
            abreve: 'ă',
            ac: '∾',
            acd: '∿',
            acE: '∾̳',
            Acirc: 'Â',
            acirc: 'â',
            acute: '´',
            Acy: 'А',
            acy: 'а',
            AElig: 'Æ',
            aelig: 'æ',
            af: '⁡',
            Afr: '𝔄',
            afr: '𝔞',
            Agrave: 'À',
            agrave: 'à',
            alefsym: 'ℵ',
            aleph: 'ℵ',
            Alpha: 'Α',
            alpha: 'α',
            Amacr: 'Ā',
            amacr: 'ā',
            amalg: '⨿',
            amp: '&',
            AMP: '&',
            andand: '⩕',
            And: '⩓',
            and: '∧',
            andd: '⩜',
            andslope: '⩘',
            andv: '⩚',
            ang: '∠',
            ange: '⦤',
            angle: '∠',
            angmsdaa: '⦨',
            angmsdab: '⦩',
            angmsdac: '⦪',
            angmsdad: '⦫',
            angmsdae: '⦬',
            angmsdaf: '⦭',
            angmsdag: '⦮',
            angmsdah: '⦯',
            angmsd: '∡',
            angrt: '∟',
            angrtvb: '⊾',
            angrtvbd: '⦝',
            angsph: '∢',
            angst: 'Å',
            angzarr: '⍼',
            Aogon: 'Ą',
            aogon: 'ą',
            Aopf: '𝔸',
            aopf: '𝕒',
            apacir: '⩯',
            ap: '≈',
            apE: '⩰',
            ape: '≊',
            apid: '≋',
            apos: "'",
            ApplyFunction: '⁡',
            approx: '≈',
            approxeq: '≊',
            Aring: 'Å',
            aring: 'å',
            Ascr: '𝒜',
            ascr: '𝒶',
            Assign: '≔',
            ast: '*',
            asymp: '≈',
            asympeq: '≍',
            Atilde: 'Ã',
            atilde: 'ã',
            Auml: 'Ä',
            auml: 'ä',
            awconint: '∳',
            awint: '⨑',
            backcong: '≌',
            backepsilon: '϶',
            backprime: '‵',
            backsim: '∽',
            backsimeq: '⋍',
            Backslash: '∖',
            Barv: '⫧',
            barvee: '⊽',
            barwed: '⌅',
            Barwed: '⌆',
            barwedge: '⌅',
            bbrk: '⎵',
            bbrktbrk: '⎶',
            bcong: '≌',
            Bcy: 'Б',
            bcy: 'б',
            bdquo: '„',
            becaus: '∵',
            because: '∵',
            Because: '∵',
            bemptyv: '⦰',
            bepsi: '϶',
            bernou: 'ℬ',
            Bernoullis: 'ℬ',
            Beta: 'Β',
            beta: 'β',
            beth: 'ℶ',
            between: '≬',
            Bfr: '𝔅',
            bfr: '𝔟',
            bigcap: '⋂',
            bigcirc: '◯',
            bigcup: '⋃',
            bigodot: '⨀',
            bigoplus: '⨁',
            bigotimes: '⨂',
            bigsqcup: '⨆',
            bigstar: '★',
            bigtriangledown: '▽',
            bigtriangleup: '△',
            biguplus: '⨄',
            bigvee: '⋁',
            bigwedge: '⋀',
            bkarow: '⤍',
            blacklozenge: '⧫',
            blacksquare: '▪',
            blacktriangle: '▴',
            blacktriangledown: '▾',
            blacktriangleleft: '◂',
            blacktriangleright: '▸',
            blank: '␣',
            blk12: '▒',
            blk14: '░',
            blk34: '▓',
            block: '█',
            bne: '=⃥',
            bnequiv: '≡⃥',
            bNot: '⫭',
            bnot: '⌐',
            Bopf: '𝔹',
            bopf: '𝕓',
            bot: '⊥',
            bottom: '⊥',
            bowtie: '⋈',
            boxbox: '⧉',
            boxdl: '┐',
            boxdL: '╕',
            boxDl: '╖',
            boxDL: '╗',
            boxdr: '┌',
            boxdR: '╒',
            boxDr: '╓',
            boxDR: '╔',
            boxh: '─',
            boxH: '═',
            boxhd: '┬',
            boxHd: '╤',
            boxhD: '╥',
            boxHD: '╦',
            boxhu: '┴',
            boxHu: '╧',
            boxhU: '╨',
            boxHU: '╩',
            boxminus: '⊟',
            boxplus: '⊞',
            boxtimes: '⊠',
            boxul: '┘',
            boxuL: '╛',
            boxUl: '╜',
            boxUL: '╝',
            boxur: '└',
            boxuR: '╘',
            boxUr: '╙',
            boxUR: '╚',
            boxv: '│',
            boxV: '║',
            boxvh: '┼',
            boxvH: '╪',
            boxVh: '╫',
            boxVH: '╬',
            boxvl: '┤',
            boxvL: '╡',
            boxVl: '╢',
            boxVL: '╣',
            boxvr: '├',
            boxvR: '╞',
            boxVr: '╟',
            boxVR: '╠',
            bprime: '‵',
            breve: '˘',
            Breve: '˘',
            brvbar: '¦',
            bscr: '𝒷',
            Bscr: 'ℬ',
            bsemi: '⁏',
            bsim: '∽',
            bsime: '⋍',
            bsolb: '⧅',
            bsol: '\\',
            bsolhsub: '⟈',
            bull: '•',
            bullet: '•',
            bump: '≎',
            bumpE: '⪮',
            bumpe: '≏',
            Bumpeq: '≎',
            bumpeq: '≏',
            Cacute: 'Ć',
            cacute: 'ć',
            capand: '⩄',
            capbrcup: '⩉',
            capcap: '⩋',
            cap: '∩',
            Cap: '⋒',
            capcup: '⩇',
            capdot: '⩀',
            CapitalDifferentialD: 'ⅅ',
            caps: '∩︀',
            caret: '⁁',
            caron: 'ˇ',
            Cayleys: 'ℭ',
            ccaps: '⩍',
            Ccaron: 'Č',
            ccaron: 'č',
            Ccedil: 'Ç',
            ccedil: 'ç',
            Ccirc: 'Ĉ',
            ccirc: 'ĉ',
            Cconint: '∰',
            ccups: '⩌',
            ccupssm: '⩐',
            Cdot: 'Ċ',
            cdot: 'ċ',
            cedil: '¸',
            Cedilla: '¸',
            cemptyv: '⦲',
            cent: '¢',
            centerdot: '·',
            CenterDot: '·',
            cfr: '𝔠',
            Cfr: 'ℭ',
            CHcy: 'Ч',
            chcy: 'ч',
            check: '✓',
            checkmark: '✓',
            Chi: 'Χ',
            chi: 'χ',
            circ: 'ˆ',
            circeq: '≗',
            circlearrowleft: '↺',
            circlearrowright: '↻',
            circledast: '⊛',
            circledcirc: '⊚',
            circleddash: '⊝',
            CircleDot: '⊙',
            circledR: '®',
            circledS: 'Ⓢ',
            CircleMinus: '⊖',
            CirclePlus: '⊕',
            CircleTimes: '⊗',
            cir: '○',
            cirE: '⧃',
            cire: '≗',
            cirfnint: '⨐',
            cirmid: '⫯',
            cirscir: '⧂',
            ClockwiseContourIntegral: '∲',
            CloseCurlyDoubleQuote: '”',
            CloseCurlyQuote: '’',
            clubs: '♣',
            clubsuit: '♣',
            colon: ':',
            Colon: '∷',
            Colone: '⩴',
            colone: '≔',
            coloneq: '≔',
            comma: ',',
            commat: '@',
            comp: '∁',
            compfn: '∘',
            complement: '∁',
            complexes: 'ℂ',
            cong: '≅',
            congdot: '⩭',
            Congruent: '≡',
            conint: '∮',
            Conint: '∯',
            ContourIntegral: '∮',
            copf: '𝕔',
            Copf: 'ℂ',
            coprod: '∐',
            Coproduct: '∐',
            copy: '©',
            COPY: '©',
            copysr: '℗',
            CounterClockwiseContourIntegral: '∳',
            crarr: '↵',
            cross: '✗',
            Cross: '⨯',
            Cscr: '𝒞',
            cscr: '𝒸',
            csub: '⫏',
            csube: '⫑',
            csup: '⫐',
            csupe: '⫒',
            ctdot: '⋯',
            cudarrl: '⤸',
            cudarrr: '⤵',
            cuepr: '⋞',
            cuesc: '⋟',
            cularr: '↶',
            cularrp: '⤽',
            cupbrcap: '⩈',
            cupcap: '⩆',
            CupCap: '≍',
            cup: '∪',
            Cup: '⋓',
            cupcup: '⩊',
            cupdot: '⊍',
            cupor: '⩅',
            cups: '∪︀',
            curarr: '↷',
            curarrm: '⤼',
            curlyeqprec: '⋞',
            curlyeqsucc: '⋟',
            curlyvee: '⋎',
            curlywedge: '⋏',
            curren: '¤',
            curvearrowleft: '↶',
            curvearrowright: '↷',
            cuvee: '⋎',
            cuwed: '⋏',
            cwconint: '∲',
            cwint: '∱',
            cylcty: '⌭',
            dagger: '†',
            Dagger: '‡',
            daleth: 'ℸ',
            darr: '↓',
            Darr: '↡',
            dArr: '⇓',
            dash: '‐',
            Dashv: '⫤',
            dashv: '⊣',
            dbkarow: '⤏',
            dblac: '˝',
            Dcaron: 'Ď',
            dcaron: 'ď',
            Dcy: 'Д',
            dcy: 'д',
            ddagger: '‡',
            ddarr: '⇊',
            DD: 'ⅅ',
            dd: 'ⅆ',
            DDotrahd: '⤑',
            ddotseq: '⩷',
            deg: '°',
            Del: '∇',
            Delta: 'Δ',
            delta: 'δ',
            demptyv: '⦱',
            dfisht: '⥿',
            Dfr: '𝔇',
            dfr: '𝔡',
            dHar: '⥥',
            dharl: '⇃',
            dharr: '⇂',
            DiacriticalAcute: '´',
            DiacriticalDot: '˙',
            DiacriticalDoubleAcute: '˝',
            DiacriticalGrave: '`',
            DiacriticalTilde: '˜',
            diam: '⋄',
            diamond: '⋄',
            Diamond: '⋄',
            diamondsuit: '♦',
            diams: '♦',
            die: '¨',
            DifferentialD: 'ⅆ',
            digamma: 'ϝ',
            disin: '⋲',
            div: '÷',
            divide: '÷',
            divideontimes: '⋇',
            divonx: '⋇',
            DJcy: 'Ђ',
            djcy: 'ђ',
            dlcorn: '⌞',
            dlcrop: '⌍',
            dollar: '$',
            Dopf: '𝔻',
            dopf: '𝕕',
            Dot: '¨',
            dot: '˙',
            DotDot: '⃜',
            doteq: '≐',
            doteqdot: '≑',
            DotEqual: '≐',
            dotminus: '∸',
            dotplus: '∔',
            dotsquare: '⊡',
            doublebarwedge: '⌆',
            DoubleContourIntegral: '∯',
            DoubleDot: '¨',
            DoubleDownArrow: '⇓',
            DoubleLeftArrow: '⇐',
            DoubleLeftRightArrow: '⇔',
            DoubleLeftTee: '⫤',
            DoubleLongLeftArrow: '⟸',
            DoubleLongLeftRightArrow: '⟺',
            DoubleLongRightArrow: '⟹',
            DoubleRightArrow: '⇒',
            DoubleRightTee: '⊨',
            DoubleUpArrow: '⇑',
            DoubleUpDownArrow: '⇕',
            DoubleVerticalBar: '∥',
            DownArrowBar: '⤓',
            downarrow: '↓',
            DownArrow: '↓',
            Downarrow: '⇓',
            DownArrowUpArrow: '⇵',
            DownBreve: '̑',
            downdownarrows: '⇊',
            downharpoonleft: '⇃',
            downharpoonright: '⇂',
            DownLeftRightVector: '⥐',
            DownLeftTeeVector: '⥞',
            DownLeftVectorBar: '⥖',
            DownLeftVector: '↽',
            DownRightTeeVector: '⥟',
            DownRightVectorBar: '⥗',
            DownRightVector: '⇁',
            DownTeeArrow: '↧',
            DownTee: '⊤',
            drbkarow: '⤐',
            drcorn: '⌟',
            drcrop: '⌌',
            Dscr: '𝒟',
            dscr: '𝒹',
            DScy: 'Ѕ',
            dscy: 'ѕ',
            dsol: '⧶',
            Dstrok: 'Đ',
            dstrok: 'đ',
            dtdot: '⋱',
            dtri: '▿',
            dtrif: '▾',
            duarr: '⇵',
            duhar: '⥯',
            dwangle: '⦦',
            DZcy: 'Џ',
            dzcy: 'џ',
            dzigrarr: '⟿',
            Eacute: 'É',
            eacute: 'é',
            easter: '⩮',
            Ecaron: 'Ě',
            ecaron: 'ě',
            Ecirc: 'Ê',
            ecirc: 'ê',
            ecir: '≖',
            ecolon: '≕',
            Ecy: 'Э',
            ecy: 'э',
            eDDot: '⩷',
            Edot: 'Ė',
            edot: 'ė',
            eDot: '≑',
            ee: 'ⅇ',
            efDot: '≒',
            Efr: '𝔈',
            efr: '𝔢',
            eg: '⪚',
            Egrave: 'È',
            egrave: 'è',
            egs: '⪖',
            egsdot: '⪘',
            el: '⪙',
            Element: '∈',
            elinters: '⏧',
            ell: 'ℓ',
            els: '⪕',
            elsdot: '⪗',
            Emacr: 'Ē',
            emacr: 'ē',
            empty: '∅',
            emptyset: '∅',
            EmptySmallSquare: '◻',
            emptyv: '∅',
            EmptyVerySmallSquare: '▫',
            emsp13: ' ',
            emsp14: ' ',
            emsp: ' ',
            ENG: 'Ŋ',
            eng: 'ŋ',
            ensp: ' ',
            Eogon: 'Ę',
            eogon: 'ę',
            Eopf: '𝔼',
            eopf: '𝕖',
            epar: '⋕',
            eparsl: '⧣',
            eplus: '⩱',
            epsi: 'ε',
            Epsilon: 'Ε',
            epsilon: 'ε',
            epsiv: 'ϵ',
            eqcirc: '≖',
            eqcolon: '≕',
            eqsim: '≂',
            eqslantgtr: '⪖',
            eqslantless: '⪕',
            Equal: '⩵',
            equals: '=',
            EqualTilde: '≂',
            equest: '≟',
            Equilibrium: '⇌',
            equiv: '≡',
            equivDD: '⩸',
            eqvparsl: '⧥',
            erarr: '⥱',
            erDot: '≓',
            escr: 'ℯ',
            Escr: 'ℰ',
            esdot: '≐',
            Esim: '⩳',
            esim: '≂',
            Eta: 'Η',
            eta: 'η',
            ETH: 'Ð',
            eth: 'ð',
            Euml: 'Ë',
            euml: 'ë',
            euro: '€',
            excl: '!',
            exist: '∃',
            Exists: '∃',
            expectation: 'ℰ',
            exponentiale: 'ⅇ',
            ExponentialE: 'ⅇ',
            fallingdotseq: '≒',
            Fcy: 'Ф',
            fcy: 'ф',
            female: '♀',
            ffilig: 'ﬃ',
            fflig: 'ﬀ',
            ffllig: 'ﬄ',
            Ffr: '𝔉',
            ffr: '𝔣',
            filig: 'ﬁ',
            FilledSmallSquare: '◼',
            FilledVerySmallSquare: '▪',
            fjlig: 'fj',
            flat: '♭',
            fllig: 'ﬂ',
            fltns: '▱',
            fnof: 'ƒ',
            Fopf: '𝔽',
            fopf: '𝕗',
            forall: '∀',
            ForAll: '∀',
            fork: '⋔',
            forkv: '⫙',
            Fouriertrf: 'ℱ',
            fpartint: '⨍',
            frac12: '½',
            frac13: '⅓',
            frac14: '¼',
            frac15: '⅕',
            frac16: '⅙',
            frac18: '⅛',
            frac23: '⅔',
            frac25: '⅖',
            frac34: '¾',
            frac35: '⅗',
            frac38: '⅜',
            frac45: '⅘',
            frac56: '⅚',
            frac58: '⅝',
            frac78: '⅞',
            frasl: '⁄',
            frown: '⌢',
            fscr: '𝒻',
            Fscr: 'ℱ',
            gacute: 'ǵ',
            Gamma: 'Γ',
            gamma: 'γ',
            Gammad: 'Ϝ',
            gammad: 'ϝ',
            gap: '⪆',
            Gbreve: 'Ğ',
            gbreve: 'ğ',
            Gcedil: 'Ģ',
            Gcirc: 'Ĝ',
            gcirc: 'ĝ',
            Gcy: 'Г',
            gcy: 'г',
            Gdot: 'Ġ',
            gdot: 'ġ',
            ge: '≥',
            gE: '≧',
            gEl: '⪌',
            gel: '⋛',
            geq: '≥',
            geqq: '≧',
            geqslant: '⩾',
            gescc: '⪩',
            ges: '⩾',
            gesdot: '⪀',
            gesdoto: '⪂',
            gesdotol: '⪄',
            gesl: '⋛︀',
            gesles: '⪔',
            Gfr: '𝔊',
            gfr: '𝔤',
            gg: '≫',
            Gg: '⋙',
            ggg: '⋙',
            gimel: 'ℷ',
            GJcy: 'Ѓ',
            gjcy: 'ѓ',
            gla: '⪥',
            gl: '≷',
            glE: '⪒',
            glj: '⪤',
            gnap: '⪊',
            gnapprox: '⪊',
            gne: '⪈',
            gnE: '≩',
            gneq: '⪈',
            gneqq: '≩',
            gnsim: '⋧',
            Gopf: '𝔾',
            gopf: '𝕘',
            grave: '`',
            GreaterEqual: '≥',
            GreaterEqualLess: '⋛',
            GreaterFullEqual: '≧',
            GreaterGreater: '⪢',
            GreaterLess: '≷',
            GreaterSlantEqual: '⩾',
            GreaterTilde: '≳',
            Gscr: '𝒢',
            gscr: 'ℊ',
            gsim: '≳',
            gsime: '⪎',
            gsiml: '⪐',
            gtcc: '⪧',
            gtcir: '⩺',
            gt: '>',
            GT: '>',
            Gt: '≫',
            gtdot: '⋗',
            gtlPar: '⦕',
            gtquest: '⩼',
            gtrapprox: '⪆',
            gtrarr: '⥸',
            gtrdot: '⋗',
            gtreqless: '⋛',
            gtreqqless: '⪌',
            gtrless: '≷',
            gtrsim: '≳',
            gvertneqq: '≩︀',
            gvnE: '≩︀',
            Hacek: 'ˇ',
            hairsp: ' ',
            half: '½',
            hamilt: 'ℋ',
            HARDcy: 'Ъ',
            hardcy: 'ъ',
            harrcir: '⥈',
            harr: '↔',
            hArr: '⇔',
            harrw: '↭',
            Hat: '^',
            hbar: 'ℏ',
            Hcirc: 'Ĥ',
            hcirc: 'ĥ',
            hearts: '♥',
            heartsuit: '♥',
            hellip: '…',
            hercon: '⊹',
            hfr: '𝔥',
            Hfr: 'ℌ',
            HilbertSpace: 'ℋ',
            hksearow: '⤥',
            hkswarow: '⤦',
            hoarr: '⇿',
            homtht: '∻',
            hookleftarrow: '↩',
            hookrightarrow: '↪',
            hopf: '𝕙',
            Hopf: 'ℍ',
            horbar: '―',
            HorizontalLine: '─',
            hscr: '𝒽',
            Hscr: 'ℋ',
            hslash: 'ℏ',
            Hstrok: 'Ħ',
            hstrok: 'ħ',
            HumpDownHump: '≎',
            HumpEqual: '≏',
            hybull: '⁃',
            hyphen: '‐',
            Iacute: 'Í',
            iacute: 'í',
            ic: '⁣',
            Icirc: 'Î',
            icirc: 'î',
            Icy: 'И',
            icy: 'и',
            Idot: 'İ',
            IEcy: 'Е',
            iecy: 'е',
            iexcl: '¡',
            iff: '⇔',
            ifr: '𝔦',
            Ifr: 'ℑ',
            Igrave: 'Ì',
            igrave: 'ì',
            ii: 'ⅈ',
            iiiint: '⨌',
            iiint: '∭',
            iinfin: '⧜',
            iiota: '℩',
            IJlig: 'Ĳ',
            ijlig: 'ĳ',
            Imacr: 'Ī',
            imacr: 'ī',
            image: 'ℑ',
            ImaginaryI: 'ⅈ',
            imagline: 'ℐ',
            imagpart: 'ℑ',
            imath: 'ı',
            Im: 'ℑ',
            imof: '⊷',
            imped: 'Ƶ',
            Implies: '⇒',
            incare: '℅',
            in: '∈',
            infin: '∞',
            infintie: '⧝',
            inodot: 'ı',
            intcal: '⊺',
            int: '∫',
            Int: '∬',
            integers: 'ℤ',
            Integral: '∫',
            intercal: '⊺',
            Intersection: '⋂',
            intlarhk: '⨗',
            intprod: '⨼',
            InvisibleComma: '⁣',
            InvisibleTimes: '⁢',
            IOcy: 'Ё',
            iocy: 'ё',
            Iogon: 'Į',
            iogon: 'į',
            Iopf: '𝕀',
            iopf: '𝕚',
            Iota: 'Ι',
            iota: 'ι',
            iprod: '⨼',
            iquest: '¿',
            iscr: '𝒾',
            Iscr: 'ℐ',
            isin: '∈',
            isindot: '⋵',
            isinE: '⋹',
            isins: '⋴',
            isinsv: '⋳',
            isinv: '∈',
            it: '⁢',
            Itilde: 'Ĩ',
            itilde: 'ĩ',
            Iukcy: 'І',
            iukcy: 'і',
            Iuml: 'Ï',
            iuml: 'ï',
            Jcirc: 'Ĵ',
            jcirc: 'ĵ',
            Jcy: 'Й',
            jcy: 'й',
            Jfr: '𝔍',
            jfr: '𝔧',
            jmath: 'ȷ',
            Jopf: '𝕁',
            jopf: '𝕛',
            Jscr: '𝒥',
            jscr: '𝒿',
            Jsercy: 'Ј',
            jsercy: 'ј',
            Jukcy: 'Є',
            jukcy: 'є',
            Kappa: 'Κ',
            kappa: 'κ',
            kappav: 'ϰ',
            Kcedil: 'Ķ',
            kcedil: 'ķ',
            Kcy: 'К',
            kcy: 'к',
            Kfr: '𝔎',
            kfr: '𝔨',
            kgreen: 'ĸ',
            KHcy: 'Х',
            khcy: 'х',
            KJcy: 'Ќ',
            kjcy: 'ќ',
            Kopf: '𝕂',
            kopf: '𝕜',
            Kscr: '𝒦',
            kscr: '𝓀',
            lAarr: '⇚',
            Lacute: 'Ĺ',
            lacute: 'ĺ',
            laemptyv: '⦴',
            lagran: 'ℒ',
            Lambda: 'Λ',
            lambda: 'λ',
            lang: '⟨',
            Lang: '⟪',
            langd: '⦑',
            langle: '⟨',
            lap: '⪅',
            Laplacetrf: 'ℒ',
            laquo: '«',
            larrb: '⇤',
            larrbfs: '⤟',
            larr: '←',
            Larr: '↞',
            lArr: '⇐',
            larrfs: '⤝',
            larrhk: '↩',
            larrlp: '↫',
            larrpl: '⤹',
            larrsim: '⥳',
            larrtl: '↢',
            latail: '⤙',
            lAtail: '⤛',
            lat: '⪫',
            late: '⪭',
            lates: '⪭︀',
            lbarr: '⤌',
            lBarr: '⤎',
            lbbrk: '❲',
            lbrace: '{',
            lbrack: '[',
            lbrke: '⦋',
            lbrksld: '⦏',
            lbrkslu: '⦍',
            Lcaron: 'Ľ',
            lcaron: 'ľ',
            Lcedil: 'Ļ',
            lcedil: 'ļ',
            lceil: '⌈',
            lcub: '{',
            Lcy: 'Л',
            lcy: 'л',
            ldca: '⤶',
            ldquo: '“',
            ldquor: '„',
            ldrdhar: '⥧',
            ldrushar: '⥋',
            ldsh: '↲',
            le: '≤',
            lE: '≦',
            LeftAngleBracket: '⟨',
            LeftArrowBar: '⇤',
            leftarrow: '←',
            LeftArrow: '←',
            Leftarrow: '⇐',
            LeftArrowRightArrow: '⇆',
            leftarrowtail: '↢',
            LeftCeiling: '⌈',
            LeftDoubleBracket: '⟦',
            LeftDownTeeVector: '⥡',
            LeftDownVectorBar: '⥙',
            LeftDownVector: '⇃',
            LeftFloor: '⌊',
            leftharpoondown: '↽',
            leftharpoonup: '↼',
            leftleftarrows: '⇇',
            leftrightarrow: '↔',
            LeftRightArrow: '↔',
            Leftrightarrow: '⇔',
            leftrightarrows: '⇆',
            leftrightharpoons: '⇋',
            leftrightsquigarrow: '↭',
            LeftRightVector: '⥎',
            LeftTeeArrow: '↤',
            LeftTee: '⊣',
            LeftTeeVector: '⥚',
            leftthreetimes: '⋋',
            LeftTriangleBar: '⧏',
            LeftTriangle: '⊲',
            LeftTriangleEqual: '⊴',
            LeftUpDownVector: '⥑',
            LeftUpTeeVector: '⥠',
            LeftUpVectorBar: '⥘',
            LeftUpVector: '↿',
            LeftVectorBar: '⥒',
            LeftVector: '↼',
            lEg: '⪋',
            leg: '⋚',
            leq: '≤',
            leqq: '≦',
            leqslant: '⩽',
            lescc: '⪨',
            les: '⩽',
            lesdot: '⩿',
            lesdoto: '⪁',
            lesdotor: '⪃',
            lesg: '⋚︀',
            lesges: '⪓',
            lessapprox: '⪅',
            lessdot: '⋖',
            lesseqgtr: '⋚',
            lesseqqgtr: '⪋',
            LessEqualGreater: '⋚',
            LessFullEqual: '≦',
            LessGreater: '≶',
            lessgtr: '≶',
            LessLess: '⪡',
            lesssim: '≲',
            LessSlantEqual: '⩽',
            LessTilde: '≲',
            lfisht: '⥼',
            lfloor: '⌊',
            Lfr: '𝔏',
            lfr: '𝔩',
            lg: '≶',
            lgE: '⪑',
            lHar: '⥢',
            lhard: '↽',
            lharu: '↼',
            lharul: '⥪',
            lhblk: '▄',
            LJcy: 'Љ',
            ljcy: 'љ',
            llarr: '⇇',
            ll: '≪',
            Ll: '⋘',
            llcorner: '⌞',
            Lleftarrow: '⇚',
            llhard: '⥫',
            lltri: '◺',
            Lmidot: 'Ŀ',
            lmidot: 'ŀ',
            lmoustache: '⎰',
            lmoust: '⎰',
            lnap: '⪉',
            lnapprox: '⪉',
            lne: '⪇',
            lnE: '≨',
            lneq: '⪇',
            lneqq: '≨',
            lnsim: '⋦',
            loang: '⟬',
            loarr: '⇽',
            lobrk: '⟦',
            longleftarrow: '⟵',
            LongLeftArrow: '⟵',
            Longleftarrow: '⟸',
            longleftrightarrow: '⟷',
            LongLeftRightArrow: '⟷',
            Longleftrightarrow: '⟺',
            longmapsto: '⟼',
            longrightarrow: '⟶',
            LongRightArrow: '⟶',
            Longrightarrow: '⟹',
            looparrowleft: '↫',
            looparrowright: '↬',
            lopar: '⦅',
            Lopf: '𝕃',
            lopf: '𝕝',
            loplus: '⨭',
            lotimes: '⨴',
            lowast: '∗',
            lowbar: '_',
            LowerLeftArrow: '↙',
            LowerRightArrow: '↘',
            loz: '◊',
            lozenge: '◊',
            lozf: '⧫',
            lpar: '(',
            lparlt: '⦓',
            lrarr: '⇆',
            lrcorner: '⌟',
            lrhar: '⇋',
            lrhard: '⥭',
            lrm: '‎',
            lrtri: '⊿',
            lsaquo: '‹',
            lscr: '𝓁',
            Lscr: 'ℒ',
            lsh: '↰',
            Lsh: '↰',
            lsim: '≲',
            lsime: '⪍',
            lsimg: '⪏',
            lsqb: '[',
            lsquo: '‘',
            lsquor: '‚',
            Lstrok: 'Ł',
            lstrok: 'ł',
            ltcc: '⪦',
            ltcir: '⩹',
            lt: '<',
            LT: '<',
            Lt: '≪',
            ltdot: '⋖',
            lthree: '⋋',
            ltimes: '⋉',
            ltlarr: '⥶',
            ltquest: '⩻',
            ltri: '◃',
            ltrie: '⊴',
            ltrif: '◂',
            ltrPar: '⦖',
            lurdshar: '⥊',
            luruhar: '⥦',
            lvertneqq: '≨︀',
            lvnE: '≨︀',
            macr: '¯',
            male: '♂',
            malt: '✠',
            maltese: '✠',
            Map: '⤅',
            map: '↦',
            mapsto: '↦',
            mapstodown: '↧',
            mapstoleft: '↤',
            mapstoup: '↥',
            marker: '▮',
            mcomma: '⨩',
            Mcy: 'М',
            mcy: 'м',
            mdash: '—',
            mDDot: '∺',
            measuredangle: '∡',
            MediumSpace: ' ',
            Mellintrf: 'ℳ',
            Mfr: '𝔐',
            mfr: '𝔪',
            mho: '℧',
            micro: 'µ',
            midast: '*',
            midcir: '⫰',
            mid: '∣',
            middot: '·',
            minusb: '⊟',
            minus: '−',
            minusd: '∸',
            minusdu: '⨪',
            MinusPlus: '∓',
            mlcp: '⫛',
            mldr: '…',
            mnplus: '∓',
            models: '⊧',
            Mopf: '𝕄',
            mopf: '𝕞',
            mp: '∓',
            mscr: '𝓂',
            Mscr: 'ℳ',
            mstpos: '∾',
            Mu: 'Μ',
            mu: 'μ',
            multimap: '⊸',
            mumap: '⊸',
            nabla: '∇',
            Nacute: 'Ń',
            nacute: 'ń',
            nang: '∠⃒',
            nap: '≉',
            napE: '⩰̸',
            napid: '≋̸',
            napos: 'ŉ',
            napprox: '≉',
            natural: '♮',
            naturals: 'ℕ',
            natur: '♮',
            nbsp: ' ',
            nbump: '≎̸',
            nbumpe: '≏̸',
            ncap: '⩃',
            Ncaron: 'Ň',
            ncaron: 'ň',
            Ncedil: 'Ņ',
            ncedil: 'ņ',
            ncong: '≇',
            ncongdot: '⩭̸',
            ncup: '⩂',
            Ncy: 'Н',
            ncy: 'н',
            ndash: '–',
            nearhk: '⤤',
            nearr: '↗',
            neArr: '⇗',
            nearrow: '↗',
            ne: '≠',
            nedot: '≐̸',
            NegativeMediumSpace: '​',
            NegativeThickSpace: '​',
            NegativeThinSpace: '​',
            NegativeVeryThinSpace: '​',
            nequiv: '≢',
            nesear: '⤨',
            nesim: '≂̸',
            NestedGreaterGreater: '≫',
            NestedLessLess: '≪',
            NewLine: '\n',
            nexist: '∄',
            nexists: '∄',
            Nfr: '𝔑',
            nfr: '𝔫',
            ngE: '≧̸',
            nge: '≱',
            ngeq: '≱',
            ngeqq: '≧̸',
            ngeqslant: '⩾̸',
            nges: '⩾̸',
            nGg: '⋙̸',
            ngsim: '≵',
            nGt: '≫⃒',
            ngt: '≯',
            ngtr: '≯',
            nGtv: '≫̸',
            nharr: '↮',
            nhArr: '⇎',
            nhpar: '⫲',
            ni: '∋',
            nis: '⋼',
            nisd: '⋺',
            niv: '∋',
            NJcy: 'Њ',
            njcy: 'њ',
            nlarr: '↚',
            nlArr: '⇍',
            nldr: '‥',
            nlE: '≦̸',
            nle: '≰',
            nleftarrow: '↚',
            nLeftarrow: '⇍',
            nleftrightarrow: '↮',
            nLeftrightarrow: '⇎',
            nleq: '≰',
            nleqq: '≦̸',
            nleqslant: '⩽̸',
            nles: '⩽̸',
            nless: '≮',
            nLl: '⋘̸',
            nlsim: '≴',
            nLt: '≪⃒',
            nlt: '≮',
            nltri: '⋪',
            nltrie: '⋬',
            nLtv: '≪̸',
            nmid: '∤',
            NoBreak: '⁠',
            NonBreakingSpace: ' ',
            nopf: '𝕟',
            Nopf: 'ℕ',
            Not: '⫬',
            not: '¬',
            NotCongruent: '≢',
            NotCupCap: '≭',
            NotDoubleVerticalBar: '∦',
            NotElement: '∉',
            NotEqual: '≠',
            NotEqualTilde: '≂̸',
            NotExists: '∄',
            NotGreater: '≯',
            NotGreaterEqual: '≱',
            NotGreaterFullEqual: '≧̸',
            NotGreaterGreater: '≫̸',
            NotGreaterLess: '≹',
            NotGreaterSlantEqual: '⩾̸',
            NotGreaterTilde: '≵',
            NotHumpDownHump: '≎̸',
            NotHumpEqual: '≏̸',
            notin: '∉',
            notindot: '⋵̸',
            notinE: '⋹̸',
            notinva: '∉',
            notinvb: '⋷',
            notinvc: '⋶',
            NotLeftTriangleBar: '⧏̸',
            NotLeftTriangle: '⋪',
            NotLeftTriangleEqual: '⋬',
            NotLess: '≮',
            NotLessEqual: '≰',
            NotLessGreater: '≸',
            NotLessLess: '≪̸',
            NotLessSlantEqual: '⩽̸',
            NotLessTilde: '≴',
            NotNestedGreaterGreater: '⪢̸',
            NotNestedLessLess: '⪡̸',
            notni: '∌',
            notniva: '∌',
            notnivb: '⋾',
            notnivc: '⋽',
            NotPrecedes: '⊀',
            NotPrecedesEqual: '⪯̸',
            NotPrecedesSlantEqual: '⋠',
            NotReverseElement: '∌',
            NotRightTriangleBar: '⧐̸',
            NotRightTriangle: '⋫',
            NotRightTriangleEqual: '⋭',
            NotSquareSubset: '⊏̸',
            NotSquareSubsetEqual: '⋢',
            NotSquareSuperset: '⊐̸',
            NotSquareSupersetEqual: '⋣',
            NotSubset: '⊂⃒',
            NotSubsetEqual: '⊈',
            NotSucceeds: '⊁',
            NotSucceedsEqual: '⪰̸',
            NotSucceedsSlantEqual: '⋡',
            NotSucceedsTilde: '≿̸',
            NotSuperset: '⊃⃒',
            NotSupersetEqual: '⊉',
            NotTilde: '≁',
            NotTildeEqual: '≄',
            NotTildeFullEqual: '≇',
            NotTildeTilde: '≉',
            NotVerticalBar: '∤',
            nparallel: '∦',
            npar: '∦',
            nparsl: '⫽⃥',
            npart: '∂̸',
            npolint: '⨔',
            npr: '⊀',
            nprcue: '⋠',
            nprec: '⊀',
            npreceq: '⪯̸',
            npre: '⪯̸',
            nrarrc: '⤳̸',
            nrarr: '↛',
            nrArr: '⇏',
            nrarrw: '↝̸',
            nrightarrow: '↛',
            nRightarrow: '⇏',
            nrtri: '⋫',
            nrtrie: '⋭',
            nsc: '⊁',
            nsccue: '⋡',
            nsce: '⪰̸',
            Nscr: '𝒩',
            nscr: '𝓃',
            nshortmid: '∤',
            nshortparallel: '∦',
            nsim: '≁',
            nsime: '≄',
            nsimeq: '≄',
            nsmid: '∤',
            nspar: '∦',
            nsqsube: '⋢',
            nsqsupe: '⋣',
            nsub: '⊄',
            nsubE: '⫅̸',
            nsube: '⊈',
            nsubset: '⊂⃒',
            nsubseteq: '⊈',
            nsubseteqq: '⫅̸',
            nsucc: '⊁',
            nsucceq: '⪰̸',
            nsup: '⊅',
            nsupE: '⫆̸',
            nsupe: '⊉',
            nsupset: '⊃⃒',
            nsupseteq: '⊉',
            nsupseteqq: '⫆̸',
            ntgl: '≹',
            Ntilde: 'Ñ',
            ntilde: 'ñ',
            ntlg: '≸',
            ntriangleleft: '⋪',
            ntrianglelefteq: '⋬',
            ntriangleright: '⋫',
            ntrianglerighteq: '⋭',
            Nu: 'Ν',
            nu: 'ν',
            num: '#',
            numero: '№',
            numsp: ' ',
            nvap: '≍⃒',
            nvdash: '⊬',
            nvDash: '⊭',
            nVdash: '⊮',
            nVDash: '⊯',
            nvge: '≥⃒',
            nvgt: '>⃒',
            nvHarr: '⤄',
            nvinfin: '⧞',
            nvlArr: '⤂',
            nvle: '≤⃒',
            nvlt: '<⃒',
            nvltrie: '⊴⃒',
            nvrArr: '⤃',
            nvrtrie: '⊵⃒',
            nvsim: '∼⃒',
            nwarhk: '⤣',
            nwarr: '↖',
            nwArr: '⇖',
            nwarrow: '↖',
            nwnear: '⤧',
            Oacute: 'Ó',
            oacute: 'ó',
            oast: '⊛',
            Ocirc: 'Ô',
            ocirc: 'ô',
            ocir: '⊚',
            Ocy: 'О',
            ocy: 'о',
            odash: '⊝',
            Odblac: 'Ő',
            odblac: 'ő',
            odiv: '⨸',
            odot: '⊙',
            odsold: '⦼',
            OElig: 'Œ',
            oelig: 'œ',
            ofcir: '⦿',
            Ofr: '𝔒',
            ofr: '𝔬',
            ogon: '˛',
            Ograve: 'Ò',
            ograve: 'ò',
            ogt: '⧁',
            ohbar: '⦵',
            ohm: 'Ω',
            oint: '∮',
            olarr: '↺',
            olcir: '⦾',
            olcross: '⦻',
            oline: '‾',
            olt: '⧀',
            Omacr: 'Ō',
            omacr: 'ō',
            Omega: 'Ω',
            omega: 'ω',
            Omicron: 'Ο',
            omicron: 'ο',
            omid: '⦶',
            ominus: '⊖',
            Oopf: '𝕆',
            oopf: '𝕠',
            opar: '⦷',
            OpenCurlyDoubleQuote: '“',
            OpenCurlyQuote: '‘',
            operp: '⦹',
            oplus: '⊕',
            orarr: '↻',
            Or: '⩔',
            or: '∨',
            ord: '⩝',
            order: 'ℴ',
            orderof: 'ℴ',
            ordf: 'ª',
            ordm: 'º',
            origof: '⊶',
            oror: '⩖',
            orslope: '⩗',
            orv: '⩛',
            oS: 'Ⓢ',
            Oscr: '𝒪',
            oscr: 'ℴ',
            Oslash: 'Ø',
            oslash: 'ø',
            osol: '⊘',
            Otilde: 'Õ',
            otilde: 'õ',
            otimesas: '⨶',
            Otimes: '⨷',
            otimes: '⊗',
            Ouml: 'Ö',
            ouml: 'ö',
            ovbar: '⌽',
            OverBar: '‾',
            OverBrace: '⏞',
            OverBracket: '⎴',
            OverParenthesis: '⏜',
            para: '¶',
            parallel: '∥',
            par: '∥',
            parsim: '⫳',
            parsl: '⫽',
            part: '∂',
            PartialD: '∂',
            Pcy: 'П',
            pcy: 'п',
            percnt: '%',
            period: '.',
            permil: '‰',
            perp: '⊥',
            pertenk: '‱',
            Pfr: '𝔓',
            pfr: '𝔭',
            Phi: 'Φ',
            phi: 'φ',
            phiv: 'ϕ',
            phmmat: 'ℳ',
            phone: '☎',
            Pi: 'Π',
            pi: 'π',
            pitchfork: '⋔',
            piv: 'ϖ',
            planck: 'ℏ',
            planckh: 'ℎ',
            plankv: 'ℏ',
            plusacir: '⨣',
            plusb: '⊞',
            pluscir: '⨢',
            plus: '+',
            plusdo: '∔',
            plusdu: '⨥',
            pluse: '⩲',
            PlusMinus: '±',
            plusmn: '±',
            plussim: '⨦',
            plustwo: '⨧',
            pm: '±',
            Poincareplane: 'ℌ',
            pointint: '⨕',
            popf: '𝕡',
            Popf: 'ℙ',
            pound: '£',
            prap: '⪷',
            Pr: '⪻',
            pr: '≺',
            prcue: '≼',
            precapprox: '⪷',
            prec: '≺',
            preccurlyeq: '≼',
            Precedes: '≺',
            PrecedesEqual: '⪯',
            PrecedesSlantEqual: '≼',
            PrecedesTilde: '≾',
            preceq: '⪯',
            precnapprox: '⪹',
            precneqq: '⪵',
            precnsim: '⋨',
            pre: '⪯',
            prE: '⪳',
            precsim: '≾',
            prime: '′',
            Prime: '″',
            primes: 'ℙ',
            prnap: '⪹',
            prnE: '⪵',
            prnsim: '⋨',
            prod: '∏',
            Product: '∏',
            profalar: '⌮',
            profline: '⌒',
            profsurf: '⌓',
            prop: '∝',
            Proportional: '∝',
            Proportion: '∷',
            propto: '∝',
            prsim: '≾',
            prurel: '⊰',
            Pscr: '𝒫',
            pscr: '𝓅',
            Psi: 'Ψ',
            psi: 'ψ',
            puncsp: ' ',
            Qfr: '𝔔',
            qfr: '𝔮',
            qint: '⨌',
            qopf: '𝕢',
            Qopf: 'ℚ',
            qprime: '⁗',
            Qscr: '𝒬',
            qscr: '𝓆',
            quaternions: 'ℍ',
            quatint: '⨖',
            quest: '?',
            questeq: '≟',
            quot: '"',
            QUOT: '"',
            rAarr: '⇛',
            race: '∽̱',
            Racute: 'Ŕ',
            racute: 'ŕ',
            radic: '√',
            raemptyv: '⦳',
            rang: '⟩',
            Rang: '⟫',
            rangd: '⦒',
            range: '⦥',
            rangle: '⟩',
            raquo: '»',
            rarrap: '⥵',
            rarrb: '⇥',
            rarrbfs: '⤠',
            rarrc: '⤳',
            rarr: '→',
            Rarr: '↠',
            rArr: '⇒',
            rarrfs: '⤞',
            rarrhk: '↪',
            rarrlp: '↬',
            rarrpl: '⥅',
            rarrsim: '⥴',
            Rarrtl: '⤖',
            rarrtl: '↣',
            rarrw: '↝',
            ratail: '⤚',
            rAtail: '⤜',
            ratio: '∶',
            rationals: 'ℚ',
            rbarr: '⤍',
            rBarr: '⤏',
            RBarr: '⤐',
            rbbrk: '❳',
            rbrace: '}',
            rbrack: ']',
            rbrke: '⦌',
            rbrksld: '⦎',
            rbrkslu: '⦐',
            Rcaron: 'Ř',
            rcaron: 'ř',
            Rcedil: 'Ŗ',
            rcedil: 'ŗ',
            rceil: '⌉',
            rcub: '}',
            Rcy: 'Р',
            rcy: 'р',
            rdca: '⤷',
            rdldhar: '⥩',
            rdquo: '”',
            rdquor: '”',
            rdsh: '↳',
            real: 'ℜ',
            realine: 'ℛ',
            realpart: 'ℜ',
            reals: 'ℝ',
            Re: 'ℜ',
            rect: '▭',
            reg: '®',
            REG: '®',
            ReverseElement: '∋',
            ReverseEquilibrium: '⇋',
            ReverseUpEquilibrium: '⥯',
            rfisht: '⥽',
            rfloor: '⌋',
            rfr: '𝔯',
            Rfr: 'ℜ',
            rHar: '⥤',
            rhard: '⇁',
            rharu: '⇀',
            rharul: '⥬',
            Rho: 'Ρ',
            rho: 'ρ',
            rhov: 'ϱ',
            RightAngleBracket: '⟩',
            RightArrowBar: '⇥',
            rightarrow: '→',
            RightArrow: '→',
            Rightarrow: '⇒',
            RightArrowLeftArrow: '⇄',
            rightarrowtail: '↣',
            RightCeiling: '⌉',
            RightDoubleBracket: '⟧',
            RightDownTeeVector: '⥝',
            RightDownVectorBar: '⥕',
            RightDownVector: '⇂',
            RightFloor: '⌋',
            rightharpoondown: '⇁',
            rightharpoonup: '⇀',
            rightleftarrows: '⇄',
            rightleftharpoons: '⇌',
            rightrightarrows: '⇉',
            rightsquigarrow: '↝',
            RightTeeArrow: '↦',
            RightTee: '⊢',
            RightTeeVector: '⥛',
            rightthreetimes: '⋌',
            RightTriangleBar: '⧐',
            RightTriangle: '⊳',
            RightTriangleEqual: '⊵',
            RightUpDownVector: '⥏',
            RightUpTeeVector: '⥜',
            RightUpVectorBar: '⥔',
            RightUpVector: '↾',
            RightVectorBar: '⥓',
            RightVector: '⇀',
            ring: '˚',
            risingdotseq: '≓',
            rlarr: '⇄',
            rlhar: '⇌',
            rlm: '‏',
            rmoustache: '⎱',
            rmoust: '⎱',
            rnmid: '⫮',
            roang: '⟭',
            roarr: '⇾',
            robrk: '⟧',
            ropar: '⦆',
            ropf: '𝕣',
            Ropf: 'ℝ',
            roplus: '⨮',
            rotimes: '⨵',
            RoundImplies: '⥰',
            rpar: ')',
            rpargt: '⦔',
            rppolint: '⨒',
            rrarr: '⇉',
            Rrightarrow: '⇛',
            rsaquo: '›',
            rscr: '𝓇',
            Rscr: 'ℛ',
            rsh: '↱',
            Rsh: '↱',
            rsqb: ']',
            rsquo: '’',
            rsquor: '’',
            rthree: '⋌',
            rtimes: '⋊',
            rtri: '▹',
            rtrie: '⊵',
            rtrif: '▸',
            rtriltri: '⧎',
            RuleDelayed: '⧴',
            ruluhar: '⥨',
            rx: '℞',
            Sacute: 'Ś',
            sacute: 'ś',
            sbquo: '‚',
            scap: '⪸',
            Scaron: 'Š',
            scaron: 'š',
            Sc: '⪼',
            sc: '≻',
            sccue: '≽',
            sce: '⪰',
            scE: '⪴',
            Scedil: 'Ş',
            scedil: 'ş',
            Scirc: 'Ŝ',
            scirc: 'ŝ',
            scnap: '⪺',
            scnE: '⪶',
            scnsim: '⋩',
            scpolint: '⨓',
            scsim: '≿',
            Scy: 'С',
            scy: 'с',
            sdotb: '⊡',
            sdot: '⋅',
            sdote: '⩦',
            searhk: '⤥',
            searr: '↘',
            seArr: '⇘',
            searrow: '↘',
            sect: '§',
            semi: ';',
            seswar: '⤩',
            setminus: '∖',
            setmn: '∖',
            sext: '✶',
            Sfr: '𝔖',
            sfr: '𝔰',
            sfrown: '⌢',
            sharp: '♯',
            SHCHcy: 'Щ',
            shchcy: 'щ',
            SHcy: 'Ш',
            shcy: 'ш',
            ShortDownArrow: '↓',
            ShortLeftArrow: '←',
            shortmid: '∣',
            shortparallel: '∥',
            ShortRightArrow: '→',
            ShortUpArrow: '↑',
            shy: '­',
            Sigma: 'Σ',
            sigma: 'σ',
            sigmaf: 'ς',
            sigmav: 'ς',
            sim: '∼',
            simdot: '⩪',
            sime: '≃',
            simeq: '≃',
            simg: '⪞',
            simgE: '⪠',
            siml: '⪝',
            simlE: '⪟',
            simne: '≆',
            simplus: '⨤',
            simrarr: '⥲',
            slarr: '←',
            SmallCircle: '∘',
            smallsetminus: '∖',
            smashp: '⨳',
            smeparsl: '⧤',
            smid: '∣',
            smile: '⌣',
            smt: '⪪',
            smte: '⪬',
            smtes: '⪬︀',
            SOFTcy: 'Ь',
            softcy: 'ь',
            solbar: '⌿',
            solb: '⧄',
            sol: '/',
            Sopf: '𝕊',
            sopf: '𝕤',
            spades: '♠',
            spadesuit: '♠',
            spar: '∥',
            sqcap: '⊓',
            sqcaps: '⊓︀',
            sqcup: '⊔',
            sqcups: '⊔︀',
            Sqrt: '√',
            sqsub: '⊏',
            sqsube: '⊑',
            sqsubset: '⊏',
            sqsubseteq: '⊑',
            sqsup: '⊐',
            sqsupe: '⊒',
            sqsupset: '⊐',
            sqsupseteq: '⊒',
            square: '□',
            Square: '□',
            SquareIntersection: '⊓',
            SquareSubset: '⊏',
            SquareSubsetEqual: '⊑',
            SquareSuperset: '⊐',
            SquareSupersetEqual: '⊒',
            SquareUnion: '⊔',
            squarf: '▪',
            squ: '□',
            squf: '▪',
            srarr: '→',
            Sscr: '𝒮',
            sscr: '𝓈',
            ssetmn: '∖',
            ssmile: '⌣',
            sstarf: '⋆',
            Star: '⋆',
            star: '☆',
            starf: '★',
            straightepsilon: 'ϵ',
            straightphi: 'ϕ',
            strns: '¯',
            sub: '⊂',
            Sub: '⋐',
            subdot: '⪽',
            subE: '⫅',
            sube: '⊆',
            subedot: '⫃',
            submult: '⫁',
            subnE: '⫋',
            subne: '⊊',
            subplus: '⪿',
            subrarr: '⥹',
            subset: '⊂',
            Subset: '⋐',
            subseteq: '⊆',
            subseteqq: '⫅',
            SubsetEqual: '⊆',
            subsetneq: '⊊',
            subsetneqq: '⫋',
            subsim: '⫇',
            subsub: '⫕',
            subsup: '⫓',
            succapprox: '⪸',
            succ: '≻',
            succcurlyeq: '≽',
            Succeeds: '≻',
            SucceedsEqual: '⪰',
            SucceedsSlantEqual: '≽',
            SucceedsTilde: '≿',
            succeq: '⪰',
            succnapprox: '⪺',
            succneqq: '⪶',
            succnsim: '⋩',
            succsim: '≿',
            SuchThat: '∋',
            sum: '∑',
            Sum: '∑',
            sung: '♪',
            sup1: '¹',
            sup2: '²',
            sup3: '³',
            sup: '⊃',
            Sup: '⋑',
            supdot: '⪾',
            supdsub: '⫘',
            supE: '⫆',
            supe: '⊇',
            supedot: '⫄',
            Superset: '⊃',
            SupersetEqual: '⊇',
            suphsol: '⟉',
            suphsub: '⫗',
            suplarr: '⥻',
            supmult: '⫂',
            supnE: '⫌',
            supne: '⊋',
            supplus: '⫀',
            supset: '⊃',
            Supset: '⋑',
            supseteq: '⊇',
            supseteqq: '⫆',
            supsetneq: '⊋',
            supsetneqq: '⫌',
            supsim: '⫈',
            supsub: '⫔',
            supsup: '⫖',
            swarhk: '⤦',
            swarr: '↙',
            swArr: '⇙',
            swarrow: '↙',
            swnwar: '⤪',
            szlig: 'ß',
            Tab: '\t',
            target: '⌖',
            Tau: 'Τ',
            tau: 'τ',
            tbrk: '⎴',
            Tcaron: 'Ť',
            tcaron: 'ť',
            Tcedil: 'Ţ',
            tcedil: 'ţ',
            Tcy: 'Т',
            tcy: 'т',
            tdot: '⃛',
            telrec: '⌕',
            Tfr: '𝔗',
            tfr: '𝔱',
            there4: '∴',
            therefore: '∴',
            Therefore: '∴',
            Theta: 'Θ',
            theta: 'θ',
            thetasym: 'ϑ',
            thetav: 'ϑ',
            thickapprox: '≈',
            thicksim: '∼',
            ThickSpace: '  ',
            ThinSpace: ' ',
            thinsp: ' ',
            thkap: '≈',
            thksim: '∼',
            THORN: 'Þ',
            thorn: 'þ',
            tilde: '˜',
            Tilde: '∼',
            TildeEqual: '≃',
            TildeFullEqual: '≅',
            TildeTilde: '≈',
            timesbar: '⨱',
            timesb: '⊠',
            times: '×',
            timesd: '⨰',
            tint: '∭',
            toea: '⤨',
            topbot: '⌶',
            topcir: '⫱',
            top: '⊤',
            Topf: '𝕋',
            topf: '𝕥',
            topfork: '⫚',
            tosa: '⤩',
            tprime: '‴',
            trade: '™',
            TRADE: '™',
            triangle: '▵',
            triangledown: '▿',
            triangleleft: '◃',
            trianglelefteq: '⊴',
            triangleq: '≜',
            triangleright: '▹',
            trianglerighteq: '⊵',
            tridot: '◬',
            trie: '≜',
            triminus: '⨺',
            TripleDot: '⃛',
            triplus: '⨹',
            trisb: '⧍',
            tritime: '⨻',
            trpezium: '⏢',
            Tscr: '𝒯',
            tscr: '𝓉',
            TScy: 'Ц',
            tscy: 'ц',
            TSHcy: 'Ћ',
            tshcy: 'ћ',
            Tstrok: 'Ŧ',
            tstrok: 'ŧ',
            twixt: '≬',
            twoheadleftarrow: '↞',
            twoheadrightarrow: '↠',
            Uacute: 'Ú',
            uacute: 'ú',
            uarr: '↑',
            Uarr: '↟',
            uArr: '⇑',
            Uarrocir: '⥉',
            Ubrcy: 'Ў',
            ubrcy: 'ў',
            Ubreve: 'Ŭ',
            ubreve: 'ŭ',
            Ucirc: 'Û',
            ucirc: 'û',
            Ucy: 'У',
            ucy: 'у',
            udarr: '⇅',
            Udblac: 'Ű',
            udblac: 'ű',
            udhar: '⥮',
            ufisht: '⥾',
            Ufr: '𝔘',
            ufr: '𝔲',
            Ugrave: 'Ù',
            ugrave: 'ù',
            uHar: '⥣',
            uharl: '↿',
            uharr: '↾',
            uhblk: '▀',
            ulcorn: '⌜',
            ulcorner: '⌜',
            ulcrop: '⌏',
            ultri: '◸',
            Umacr: 'Ū',
            umacr: 'ū',
            uml: '¨',
            UnderBar: '_',
            UnderBrace: '⏟',
            UnderBracket: '⎵',
            UnderParenthesis: '⏝',
            Union: '⋃',
            UnionPlus: '⊎',
            Uogon: 'Ų',
            uogon: 'ų',
            Uopf: '𝕌',
            uopf: '𝕦',
            UpArrowBar: '⤒',
            uparrow: '↑',
            UpArrow: '↑',
            Uparrow: '⇑',
            UpArrowDownArrow: '⇅',
            updownarrow: '↕',
            UpDownArrow: '↕',
            Updownarrow: '⇕',
            UpEquilibrium: '⥮',
            upharpoonleft: '↿',
            upharpoonright: '↾',
            uplus: '⊎',
            UpperLeftArrow: '↖',
            UpperRightArrow: '↗',
            upsi: 'υ',
            Upsi: 'ϒ',
            upsih: 'ϒ',
            Upsilon: 'Υ',
            upsilon: 'υ',
            UpTeeArrow: '↥',
            UpTee: '⊥',
            upuparrows: '⇈',
            urcorn: '⌝',
            urcorner: '⌝',
            urcrop: '⌎',
            Uring: 'Ů',
            uring: 'ů',
            urtri: '◹',
            Uscr: '𝒰',
            uscr: '𝓊',
            utdot: '⋰',
            Utilde: 'Ũ',
            utilde: 'ũ',
            utri: '▵',
            utrif: '▴',
            uuarr: '⇈',
            Uuml: 'Ü',
            uuml: 'ü',
            uwangle: '⦧',
            vangrt: '⦜',
            varepsilon: 'ϵ',
            varkappa: 'ϰ',
            varnothing: '∅',
            varphi: 'ϕ',
            varpi: 'ϖ',
            varpropto: '∝',
            varr: '↕',
            vArr: '⇕',
            varrho: 'ϱ',
            varsigma: 'ς',
            varsubsetneq: '⊊︀',
            varsubsetneqq: '⫋︀',
            varsupsetneq: '⊋︀',
            varsupsetneqq: '⫌︀',
            vartheta: 'ϑ',
            vartriangleleft: '⊲',
            vartriangleright: '⊳',
            vBar: '⫨',
            Vbar: '⫫',
            vBarv: '⫩',
            Vcy: 'В',
            vcy: 'в',
            vdash: '⊢',
            vDash: '⊨',
            Vdash: '⊩',
            VDash: '⊫',
            Vdashl: '⫦',
            veebar: '⊻',
            vee: '∨',
            Vee: '⋁',
            veeeq: '≚',
            vellip: '⋮',
            verbar: '|',
            Verbar: '‖',
            vert: '|',
            Vert: '‖',
            VerticalBar: '∣',
            VerticalLine: '|',
            VerticalSeparator: '❘',
            VerticalTilde: '≀',
            VeryThinSpace: ' ',
            Vfr: '𝔙',
            vfr: '𝔳',
            vltri: '⊲',
            vnsub: '⊂⃒',
            vnsup: '⊃⃒',
            Vopf: '𝕍',
            vopf: '𝕧',
            vprop: '∝',
            vrtri: '⊳',
            Vscr: '𝒱',
            vscr: '𝓋',
            vsubnE: '⫋︀',
            vsubne: '⊊︀',
            vsupnE: '⫌︀',
            vsupne: '⊋︀',
            Vvdash: '⊪',
            vzigzag: '⦚',
            Wcirc: 'Ŵ',
            wcirc: 'ŵ',
            wedbar: '⩟',
            wedge: '∧',
            Wedge: '⋀',
            wedgeq: '≙',
            weierp: '℘',
            Wfr: '𝔚',
            wfr: '𝔴',
            Wopf: '𝕎',
            wopf: '𝕨',
            wp: '℘',
            wr: '≀',
            wreath: '≀',
            Wscr: '𝒲',
            wscr: '𝓌',
            xcap: '⋂',
            xcirc: '◯',
            xcup: '⋃',
            xdtri: '▽',
            Xfr: '𝔛',
            xfr: '𝔵',
            xharr: '⟷',
            xhArr: '⟺',
            Xi: 'Ξ',
            xi: 'ξ',
            xlarr: '⟵',
            xlArr: '⟸',
            xmap: '⟼',
            xnis: '⋻',
            xodot: '⨀',
            Xopf: '𝕏',
            xopf: '𝕩',
            xoplus: '⨁',
            xotime: '⨂',
            xrarr: '⟶',
            xrArr: '⟹',
            Xscr: '𝒳',
            xscr: '𝓍',
            xsqcup: '⨆',
            xuplus: '⨄',
            xutri: '△',
            xvee: '⋁',
            xwedge: '⋀',
            Yacute: 'Ý',
            yacute: 'ý',
            YAcy: 'Я',
            yacy: 'я',
            Ycirc: 'Ŷ',
            ycirc: 'ŷ',
            Ycy: 'Ы',
            ycy: 'ы',
            yen: '¥',
            Yfr: '𝔜',
            yfr: '𝔶',
            YIcy: 'Ї',
            yicy: 'ї',
            Yopf: '𝕐',
            yopf: '𝕪',
            Yscr: '𝒴',
            yscr: '𝓎',
            YUcy: 'Ю',
            yucy: 'ю',
            yuml: 'ÿ',
            Yuml: 'Ÿ',
            Zacute: 'Ź',
            zacute: 'ź',
            Zcaron: 'Ž',
            zcaron: 'ž',
            Zcy: 'З',
            zcy: 'з',
            Zdot: 'Ż',
            zdot: 'ż',
            zeetrf: 'ℨ',
            ZeroWidthSpace: '​',
            Zeta: 'Ζ',
            zeta: 'ζ',
            zfr: '𝔷',
            Zfr: 'ℨ',
            ZHcy: 'Ж',
            zhcy: 'ж',
            zigrarr: '⇝',
            zopf: '𝕫',
            Zopf: 'ℤ',
            Zscr: '𝒵',
            zscr: '𝓏',
            zwj: '‍',
            zwnj: '‌'
          };
        },
        {}
      ],
      349: [
        function(require, module, exports) {
          module.exports = {
            Aacute: 'Á',
            aacute: 'á',
            Acirc: 'Â',
            acirc: 'â',
            acute: '´',
            AElig: 'Æ',
            aelig: 'æ',
            Agrave: 'À',
            agrave: 'à',
            amp: '&',
            AMP: '&',
            Aring: 'Å',
            aring: 'å',
            Atilde: 'Ã',
            atilde: 'ã',
            Auml: 'Ä',
            auml: 'ä',
            brvbar: '¦',
            Ccedil: 'Ç',
            ccedil: 'ç',
            cedil: '¸',
            cent: '¢',
            copy: '©',
            COPY: '©',
            curren: '¤',
            deg: '°',
            divide: '÷',
            Eacute: 'É',
            eacute: 'é',
            Ecirc: 'Ê',
            ecirc: 'ê',
            Egrave: 'È',
            egrave: 'è',
            ETH: 'Ð',
            eth: 'ð',
            Euml: 'Ë',
            euml: 'ë',
            frac12: '½',
            frac14: '¼',
            frac34: '¾',
            gt: '>',
            GT: '>',
            Iacute: 'Í',
            iacute: 'í',
            Icirc: 'Î',
            icirc: 'î',
            iexcl: '¡',
            Igrave: 'Ì',
            igrave: 'ì',
            iquest: '¿',
            Iuml: 'Ï',
            iuml: 'ï',
            laquo: '«',
            lt: '<',
            LT: '<',
            macr: '¯',
            micro: 'µ',
            middot: '·',
            nbsp: ' ',
            not: '¬',
            Ntilde: 'Ñ',
            ntilde: 'ñ',
            Oacute: 'Ó',
            oacute: 'ó',
            Ocirc: 'Ô',
            ocirc: 'ô',
            Ograve: 'Ò',
            ograve: 'ò',
            ordf: 'ª',
            ordm: 'º',
            Oslash: 'Ø',
            oslash: 'ø',
            Otilde: 'Õ',
            otilde: 'õ',
            Ouml: 'Ö',
            ouml: 'ö',
            para: '¶',
            plusmn: '±',
            pound: '£',
            quot: '"',
            QUOT: '"',
            raquo: '»',
            reg: '®',
            REG: '®',
            sect: '§',
            shy: '­',
            sup1: '¹',
            sup2: '²',
            sup3: '³',
            szlig: 'ß',
            THORN: 'Þ',
            thorn: 'þ',
            times: '×',
            Uacute: 'Ú',
            uacute: 'ú',
            Ucirc: 'Û',
            ucirc: 'û',
            Ugrave: 'Ù',
            ugrave: 'ù',
            uml: '¨',
            Uuml: 'Ü',
            uuml: 'ü',
            Yacute: 'Ý',
            yacute: 'ý',
            yen: '¥',
            yuml: 'ÿ'
          };
        },
        {}
      ],
      350: [
        function(require, module, exports) {
          module.exports = { amp: '&', apos: "'", gt: '>', lt: '<', quot: '"' };
        },
        {}
      ],
      351: [
        function(require, module, exports) {
          module.exports =
            typeof self == 'object' ? self.FormData : window.FormData;
        },
        {}
      ],
      352: [
        function(require, module, exports) {
          (function(Buffer) {
            'use strict';
            var Transform = require('stream').Transform;
            var inherits = require('inherits');
            function HashBase(blockSize) {
              Transform.call(this);
              this._block = new Buffer(blockSize);
              this._blockSize = blockSize;
              this._blockOffset = 0;
              this._length = [0, 0, 0, 0];
              this._finalized = false;
            }
            inherits(HashBase, Transform);
            HashBase.prototype._transform = function(
              chunk,
              encoding,
              callback
            ) {
              var error = null;
              try {
                if (encoding !== 'buffer') chunk = new Buffer(chunk, encoding);
                this.update(chunk);
              } catch (err) {
                error = err;
              }
              callback(error);
            };
            HashBase.prototype._flush = function(callback) {
              var error = null;
              try {
                this.push(this._digest());
              } catch (err) {
                error = err;
              }
              callback(error);
            };
            HashBase.prototype.update = function(data, encoding) {
              if (!Buffer.isBuffer(data) && typeof data !== 'string')
                throw new TypeError('Data must be a string or a buffer');
              if (this._finalized) throw new Error('Digest already called');
              if (!Buffer.isBuffer(data))
                data = new Buffer(data, encoding || 'binary');
              var block = this._block;
              var offset = 0;
              while (
                this._blockOffset + data.length - offset >=
                this._blockSize
              ) {
                for (var i = this._blockOffset; i < this._blockSize; )
                  block[i++] = data[offset++];
                this._update();
                this._blockOffset = 0;
              }
              while (offset < data.length)
                block[this._blockOffset++] = data[offset++];
              for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
                this._length[j] += carry;
                carry = (this._length[j] / 4294967296) | 0;
                if (carry > 0) this._length[j] -= 4294967296 * carry;
              }
              return this;
            };
            HashBase.prototype._update = function(data) {
              throw new Error('_update is not implemented');
            };
            HashBase.prototype.digest = function(encoding) {
              if (this._finalized) throw new Error('Digest already called');
              this._finalized = true;
              var digest = this._digest();
              if (encoding !== undefined) digest = digest.toString(encoding);
              return digest;
            };
            HashBase.prototype._digest = function() {
              throw new Error('_digest is not implemented');
            };
            module.exports = HashBase;
          }.call(this, require('buffer').Buffer));
        },
        { buffer: 183, inherits: 353, stream: 258 }
      ],
      353: [
        function(require, module, exports) {
          arguments[4][207][0].apply(exports, arguments);
        },
        { dup: 207 }
      ],
      354: [
        function(require, module, exports) {
          arguments[4][326][0].apply(exports, arguments);
        },
        {
          './hash/common': 355,
          './hash/hmac': 356,
          './hash/ripemd': 357,
          './hash/sha': 358,
          './hash/utils': 365,
          dup: 326
        }
      ],
      355: [
        function(require, module, exports) {
          arguments[4][327][0].apply(exports, arguments);
        },
        { './utils': 365, dup: 327, 'minimalistic-assert': 441 }
      ],
      356: [
        function(require, module, exports) {
          arguments[4][328][0].apply(exports, arguments);
        },
        { './utils': 365, dup: 328, 'minimalistic-assert': 441 }
      ],
      357: [
        function(require, module, exports) {
          arguments[4][329][0].apply(exports, arguments);
        },
        { './common': 355, './utils': 365, dup: 329 }
      ],
      358: [
        function(require, module, exports) {
          arguments[4][330][0].apply(exports, arguments);
        },
        {
          './sha/1': 359,
          './sha/224': 360,
          './sha/256': 361,
          './sha/384': 362,
          './sha/512': 363,
          dup: 330
        }
      ],
      359: [
        function(require, module, exports) {
          arguments[4][331][0].apply(exports, arguments);
        },
        { '../common': 355, '../utils': 365, './common': 364, dup: 331 }
      ],
      360: [
        function(require, module, exports) {
          arguments[4][332][0].apply(exports, arguments);
        },
        { '../utils': 365, './256': 361, dup: 332 }
      ],
      361: [
        function(require, module, exports) {
          arguments[4][333][0].apply(exports, arguments);
        },
        {
          '../common': 355,
          '../utils': 365,
          './common': 364,
          dup: 333,
          'minimalistic-assert': 441
        }
      ],
      362: [
        function(require, module, exports) {
          arguments[4][334][0].apply(exports, arguments);
        },
        { '../utils': 365, './512': 363, dup: 334 }
      ],
      363: [
        function(require, module, exports) {
          arguments[4][335][0].apply(exports, arguments);
        },
        {
          '../common': 355,
          '../utils': 365,
          dup: 335,
          'minimalistic-assert': 441
        }
      ],
      364: [
        function(require, module, exports) {
          arguments[4][336][0].apply(exports, arguments);
        },
        { '../utils': 365, dup: 336 }
      ],
      365: [
        function(require, module, exports) {
          arguments[4][337][0].apply(exports, arguments);
        },
        { dup: 337, inherits: 381, 'minimalistic-assert': 441 }
      ],
      366: [
        function(require, module, exports) {
          module.exports = CollectingHandler;
          function CollectingHandler(cbs) {
            this._cbs = cbs || {};
            this.events = [];
          }
          var EVENTS = require('./').EVENTS;
          Object.keys(EVENTS).forEach(function(name) {
            if (EVENTS[name] === 0) {
              name = 'on' + name;
              CollectingHandler.prototype[name] = function() {
                this.events.push([name]);
                if (this._cbs[name]) this._cbs[name]();
              };
            } else if (EVENTS[name] === 1) {
              name = 'on' + name;
              CollectingHandler.prototype[name] = function(a) {
                this.events.push([name, a]);
                if (this._cbs[name]) this._cbs[name](a);
              };
            } else if (EVENTS[name] === 2) {
              name = 'on' + name;
              CollectingHandler.prototype[name] = function(a, b) {
                this.events.push([name, a, b]);
                if (this._cbs[name]) this._cbs[name](a, b);
              };
            } else {
              throw Error('wrong number of arguments');
            }
          });
          CollectingHandler.prototype.onreset = function() {
            this.events = [];
            if (this._cbs.onreset) this._cbs.onreset();
          };
          CollectingHandler.prototype.restart = function() {
            if (this._cbs.onreset) this._cbs.onreset();
            for (var i = 0, len = this.events.length; i < len; i++) {
              if (this._cbs[this.events[i][0]]) {
                var num = this.events[i].length;
                if (num === 1) {
                  this._cbs[this.events[i][0]]();
                } else if (num === 2) {
                  this._cbs[this.events[i][0]](this.events[i][1]);
                } else {
                  this._cbs[this.events[i][0]](
                    this.events[i][1],
                    this.events[i][2]
                  );
                }
              }
            }
          };
        },
        { './': 373 }
      ],
      367: [
        function(require, module, exports) {
          var index = require('./index.js'),
            DomHandler = index.DomHandler,
            DomUtils = index.DomUtils;
          function FeedHandler(callback, options) {
            this.init(callback, options);
          }
          require('inherits')(FeedHandler, DomHandler);
          FeedHandler.prototype.init = DomHandler;
          function getElements(what, where) {
            return DomUtils.getElementsByTagName(what, where, true);
          }
          function getOneElement(what, where) {
            return DomUtils.getElementsByTagName(what, where, true, 1)[0];
          }
          function fetch(what, where, recurse) {
            return DomUtils.getText(
              DomUtils.getElementsByTagName(what, where, recurse, 1)
            ).trim();
          }
          function addConditionally(obj, prop, what, where, recurse) {
            var tmp = fetch(what, where, recurse);
            if (tmp) obj[prop] = tmp;
          }
          var isValidFeed = function(value) {
            return value === 'rss' || value === 'feed' || value === 'rdf:RDF';
          };
          FeedHandler.prototype.onend = function() {
            var feed = {},
              feedRoot = getOneElement(isValidFeed, this.dom),
              tmp,
              childs;
            if (feedRoot) {
              if (feedRoot.name === 'feed') {
                childs = feedRoot.children;
                feed.type = 'atom';
                addConditionally(feed, 'id', 'id', childs);
                addConditionally(feed, 'title', 'title', childs);
                if (
                  (tmp = getOneElement('link', childs)) &&
                  (tmp = tmp.attribs) &&
                  (tmp = tmp.href)
                )
                  feed.link = tmp;
                addConditionally(feed, 'description', 'subtitle', childs);
                if ((tmp = fetch('updated', childs)))
                  feed.updated = new Date(tmp);
                addConditionally(feed, 'author', 'email', childs, true);
                feed.items = getElements('entry', childs).map(function(item) {
                  var entry = {},
                    tmp;
                  item = item.children;
                  addConditionally(entry, 'id', 'id', item);
                  addConditionally(entry, 'title', 'title', item);
                  if (
                    (tmp = getOneElement('link', item)) &&
                    (tmp = tmp.attribs) &&
                    (tmp = tmp.href)
                  )
                    entry.link = tmp;
                  if ((tmp = fetch('summary', item) || fetch('content', item)))
                    entry.description = tmp;
                  if ((tmp = fetch('updated', item)))
                    entry.pubDate = new Date(tmp);
                  return entry;
                });
              } else {
                childs = getOneElement('channel', feedRoot.children).children;
                feed.type = feedRoot.name.substr(0, 3);
                feed.id = '';
                addConditionally(feed, 'title', 'title', childs);
                addConditionally(feed, 'link', 'link', childs);
                addConditionally(feed, 'description', 'description', childs);
                if ((tmp = fetch('lastBuildDate', childs)))
                  feed.updated = new Date(tmp);
                addConditionally(
                  feed,
                  'author',
                  'managingEditor',
                  childs,
                  true
                );
                feed.items = getElements('item', feedRoot.children).map(
                  function(item) {
                    var entry = {},
                      tmp;
                    item = item.children;
                    addConditionally(entry, 'id', 'guid', item);
                    addConditionally(entry, 'title', 'title', item);
                    addConditionally(entry, 'link', 'link', item);
                    addConditionally(entry, 'description', 'description', item);
                    if ((tmp = fetch('pubDate', item)))
                      entry.pubDate = new Date(tmp);
                    return entry;
                  }
                );
              }
            }
            this.dom = feed;
            DomHandler.prototype._handleCallback.call(
              this,
              feedRoot ? null : Error("couldn't find root of feed")
            );
          };
          module.exports = FeedHandler;
        },
        { './index.js': 373, inherits: 374 }
      ],
      368: [
        function(require, module, exports) {
          var Tokenizer = require('./Tokenizer.js');
          var formTags = {
            input: true,
            option: true,
            optgroup: true,
            select: true,
            button: true,
            datalist: true,
            textarea: true
          };
          var openImpliesClose = {
            tr: { tr: true, th: true, td: true },
            th: { th: true },
            td: { thead: true, th: true, td: true },
            body: { head: true, link: true, script: true },
            li: { li: true },
            p: { p: true },
            h1: { p: true },
            h2: { p: true },
            h3: { p: true },
            h4: { p: true },
            h5: { p: true },
            h6: { p: true },
            select: formTags,
            input: formTags,
            output: formTags,
            button: formTags,
            datalist: formTags,
            textarea: formTags,
            option: { option: true },
            optgroup: { optgroup: true }
          };
          var voidElements = {
            __proto__: null,
            area: true,
            base: true,
            basefont: true,
            br: true,
            col: true,
            command: true,
            embed: true,
            frame: true,
            hr: true,
            img: true,
            input: true,
            isindex: true,
            keygen: true,
            link: true,
            meta: true,
            param: true,
            source: true,
            track: true,
            wbr: true,
            path: true,
            circle: true,
            ellipse: true,
            line: true,
            rect: true,
            use: true,
            stop: true,
            polyline: true,
            polygon: true
          };
          var re_nameEnd = /\s|\//;
          function Parser(cbs, options) {
            this._options = options || {};
            this._cbs = cbs || {};
            this._tagname = '';
            this._attribname = '';
            this._attribvalue = '';
            this._attribs = null;
            this._stack = [];
            this.startIndex = 0;
            this.endIndex = null;
            this._lowerCaseTagNames =
              'lowerCaseTags' in this._options
                ? !!this._options.lowerCaseTags
                : !this._options.xmlMode;
            this._lowerCaseAttributeNames =
              'lowerCaseAttributeNames' in this._options
                ? !!this._options.lowerCaseAttributeNames
                : !this._options.xmlMode;
            if (this._options.Tokenizer) {
              Tokenizer = this._options.Tokenizer;
            }
            this._tokenizer = new Tokenizer(this._options, this);
            if (this._cbs.onparserinit) this._cbs.onparserinit(this);
          }
          require('inherits')(Parser, require('events').EventEmitter);
          Parser.prototype._updatePosition = function(initialOffset) {
            if (this.endIndex === null) {
              if (this._tokenizer._sectionStart <= initialOffset) {
                this.startIndex = 0;
              } else {
                this.startIndex = this._tokenizer._sectionStart - initialOffset;
              }
            } else this.startIndex = this.endIndex + 1;
            this.endIndex = this._tokenizer.getAbsoluteIndex();
          };
          Parser.prototype.ontext = function(data) {
            this._updatePosition(1);
            this.endIndex--;
            if (this._cbs.ontext) this._cbs.ontext(data);
          };
          Parser.prototype.onopentagname = function(name) {
            if (this._lowerCaseTagNames) {
              name = name.toLowerCase();
            }
            this._tagname = name;
            if (!this._options.xmlMode && name in openImpliesClose) {
              for (
                var el;
                (el = this._stack[this._stack.length - 1]) in
                openImpliesClose[name];
                this.onclosetag(el)
              );
            }
            if (this._options.xmlMode || !(name in voidElements)) {
              this._stack.push(name);
            }
            if (this._cbs.onopentagname) this._cbs.onopentagname(name);
            if (this._cbs.onopentag) this._attribs = {};
          };
          Parser.prototype.onopentagend = function() {
            this._updatePosition(1);
            if (this._attribs) {
              if (this._cbs.onopentag)
                this._cbs.onopentag(this._tagname, this._attribs);
              this._attribs = null;
            }
            if (
              !this._options.xmlMode &&
              this._cbs.onclosetag &&
              this._tagname in voidElements
            ) {
              this._cbs.onclosetag(this._tagname);
            }
            this._tagname = '';
          };
          Parser.prototype.onclosetag = function(name) {
            this._updatePosition(1);
            if (this._lowerCaseTagNames) {
              name = name.toLowerCase();
            }
            if (
              this._stack.length &&
              (!(name in voidElements) || this._options.xmlMode)
            ) {
              var pos = this._stack.lastIndexOf(name);
              if (pos !== -1) {
                if (this._cbs.onclosetag) {
                  pos = this._stack.length - pos;
                  while (pos--) this._cbs.onclosetag(this._stack.pop());
                } else this._stack.length = pos;
              } else if (name === 'p' && !this._options.xmlMode) {
                this.onopentagname(name);
                this._closeCurrentTag();
              }
            } else if (
              !this._options.xmlMode &&
              (name === 'br' || name === 'p')
            ) {
              this.onopentagname(name);
              this._closeCurrentTag();
            }
          };
          Parser.prototype.onselfclosingtag = function() {
            if (this._options.xmlMode || this._options.recognizeSelfClosing) {
              this._closeCurrentTag();
            } else {
              this.onopentagend();
            }
          };
          Parser.prototype._closeCurrentTag = function() {
            var name = this._tagname;
            this.onopentagend();
            if (this._stack[this._stack.length - 1] === name) {
              if (this._cbs.onclosetag) {
                this._cbs.onclosetag(name);
              }
              this._stack.pop();
            }
          };
          Parser.prototype.onattribname = function(name) {
            if (this._lowerCaseAttributeNames) {
              name = name.toLowerCase();
            }
            this._attribname = name;
          };
          Parser.prototype.onattribdata = function(value) {
            this._attribvalue += value;
          };
          Parser.prototype.onattribend = function() {
            if (this._cbs.onattribute)
              this._cbs.onattribute(this._attribname, this._attribvalue);
            if (
              this._attribs &&
              !Object.prototype.hasOwnProperty.call(
                this._attribs,
                this._attribname
              )
            ) {
              this._attribs[this._attribname] = this._attribvalue;
            }
            this._attribname = '';
            this._attribvalue = '';
          };
          Parser.prototype._getInstructionName = function(value) {
            var idx = value.search(re_nameEnd),
              name = idx < 0 ? value : value.substr(0, idx);
            if (this._lowerCaseTagNames) {
              name = name.toLowerCase();
            }
            return name;
          };
          Parser.prototype.ondeclaration = function(value) {
            if (this._cbs.onprocessinginstruction) {
              var name = this._getInstructionName(value);
              this._cbs.onprocessinginstruction('!' + name, '!' + value);
            }
          };
          Parser.prototype.onprocessinginstruction = function(value) {
            if (this._cbs.onprocessinginstruction) {
              var name = this._getInstructionName(value);
              this._cbs.onprocessinginstruction('?' + name, '?' + value);
            }
          };
          Parser.prototype.oncomment = function(value) {
            this._updatePosition(4);
            if (this._cbs.oncomment) this._cbs.oncomment(value);
            if (this._cbs.oncommentend) this._cbs.oncommentend();
          };
          Parser.prototype.oncdata = function(value) {
            this._updatePosition(1);
            if (this._options.xmlMode || this._options.recognizeCDATA) {
              if (this._cbs.oncdatastart) this._cbs.oncdatastart();
              if (this._cbs.ontext) this._cbs.ontext(value);
              if (this._cbs.oncdataend) this._cbs.oncdataend();
            } else {
              this.oncomment('[CDATA[' + value + ']]');
            }
          };
          Parser.prototype.onerror = function(err) {
            if (this._cbs.onerror) this._cbs.onerror(err);
          };
          Parser.prototype.onend = function() {
            if (this._cbs.onclosetag) {
              for (
                var i = this._stack.length;
                i > 0;
                this._cbs.onclosetag(this._stack[--i])
              );
            }
            if (this._cbs.onend) this._cbs.onend();
          };
          Parser.prototype.reset = function() {
            if (this._cbs.onreset) this._cbs.onreset();
            this._tokenizer.reset();
            this._tagname = '';
            this._attribname = '';
            this._attribs = null;
            this._stack = [];
            if (this._cbs.onparserinit) this._cbs.onparserinit(this);
          };
          Parser.prototype.parseComplete = function(data) {
            this.reset();
            this.end(data);
          };
          Parser.prototype.write = function(chunk) {
            this._tokenizer.write(chunk);
          };
          Parser.prototype.end = function(chunk) {
            this._tokenizer.end(chunk);
          };
          Parser.prototype.pause = function() {
            this._tokenizer.pause();
          };
          Parser.prototype.resume = function() {
            this._tokenizer.resume();
          };
          Parser.prototype.parseChunk = Parser.prototype.write;
          Parser.prototype.done = Parser.prototype.end;
          module.exports = Parser;
        },
        { './Tokenizer.js': 371, events: 203, inherits: 374 }
      ],
      369: [
        function(require, module, exports) {
          module.exports = ProxyHandler;
          function ProxyHandler(cbs) {
            this._cbs = cbs || {};
          }
          var EVENTS = require('./').EVENTS;
          Object.keys(EVENTS).forEach(function(name) {
            if (EVENTS[name] === 0) {
              name = 'on' + name;
              ProxyHandler.prototype[name] = function() {
                if (this._cbs[name]) this._cbs[name]();
              };
            } else if (EVENTS[name] === 1) {
              name = 'on' + name;
              ProxyHandler.prototype[name] = function(a) {
                if (this._cbs[name]) this._cbs[name](a);
              };
            } else if (EVENTS[name] === 2) {
              name = 'on' + name;
              ProxyHandler.prototype[name] = function(a, b) {
                if (this._cbs[name]) this._cbs[name](a, b);
              };
            } else {
              throw Error('wrong number of arguments');
            }
          });
        },
        { './': 373 }
      ],
      370: [
        function(require, module, exports) {
          module.exports = Stream;
          var Parser = require('./WritableStream.js');
          function Stream(options) {
            Parser.call(this, new Cbs(this), options);
          }
          require('inherits')(Stream, Parser);
          Stream.prototype.readable = true;
          function Cbs(scope) {
            this.scope = scope;
          }
          var EVENTS = require('../').EVENTS;
          Object.keys(EVENTS).forEach(function(name) {
            if (EVENTS[name] === 0) {
              Cbs.prototype['on' + name] = function() {
                this.scope.emit(name);
              };
            } else if (EVENTS[name] === 1) {
              Cbs.prototype['on' + name] = function(a) {
                this.scope.emit(name, a);
              };
            } else if (EVENTS[name] === 2) {
              Cbs.prototype['on' + name] = function(a, b) {
                this.scope.emit(name, a, b);
              };
            } else {
              throw Error('wrong number of arguments!');
            }
          });
        },
        { '../': 373, './WritableStream.js': 372, inherits: 374 }
      ],
      371: [
        function(require, module, exports) {
          module.exports = Tokenizer;
          var decodeCodePoint = require('entities/lib/decode_codepoint.js'),
            entityMap = require('entities/maps/entities.json'),
            legacyMap = require('entities/maps/legacy.json'),
            xmlMap = require('entities/maps/xml.json'),
            i = 0,
            TEXT = i++,
            BEFORE_TAG_NAME = i++,
            IN_TAG_NAME = i++,
            IN_SELF_CLOSING_TAG = i++,
            BEFORE_CLOSING_TAG_NAME = i++,
            IN_CLOSING_TAG_NAME = i++,
            AFTER_CLOSING_TAG_NAME = i++,
            BEFORE_ATTRIBUTE_NAME = i++,
            IN_ATTRIBUTE_NAME = i++,
            AFTER_ATTRIBUTE_NAME = i++,
            BEFORE_ATTRIBUTE_VALUE = i++,
            IN_ATTRIBUTE_VALUE_DQ = i++,
            IN_ATTRIBUTE_VALUE_SQ = i++,
            IN_ATTRIBUTE_VALUE_NQ = i++,
            BEFORE_DECLARATION = i++,
            IN_DECLARATION = i++,
            IN_PROCESSING_INSTRUCTION = i++,
            BEFORE_COMMENT = i++,
            IN_COMMENT = i++,
            AFTER_COMMENT_1 = i++,
            AFTER_COMMENT_2 = i++,
            BEFORE_CDATA_1 = i++,
            BEFORE_CDATA_2 = i++,
            BEFORE_CDATA_3 = i++,
            BEFORE_CDATA_4 = i++,
            BEFORE_CDATA_5 = i++,
            BEFORE_CDATA_6 = i++,
            IN_CDATA = i++,
            AFTER_CDATA_1 = i++,
            AFTER_CDATA_2 = i++,
            BEFORE_SPECIAL = i++,
            BEFORE_SPECIAL_END = i++,
            BEFORE_SCRIPT_1 = i++,
            BEFORE_SCRIPT_2 = i++,
            BEFORE_SCRIPT_3 = i++,
            BEFORE_SCRIPT_4 = i++,
            BEFORE_SCRIPT_5 = i++,
            AFTER_SCRIPT_1 = i++,
            AFTER_SCRIPT_2 = i++,
            AFTER_SCRIPT_3 = i++,
            AFTER_SCRIPT_4 = i++,
            AFTER_SCRIPT_5 = i++,
            BEFORE_STYLE_1 = i++,
            BEFORE_STYLE_2 = i++,
            BEFORE_STYLE_3 = i++,
            BEFORE_STYLE_4 = i++,
            AFTER_STYLE_1 = i++,
            AFTER_STYLE_2 = i++,
            AFTER_STYLE_3 = i++,
            AFTER_STYLE_4 = i++,
            BEFORE_ENTITY = i++,
            BEFORE_NUMERIC_ENTITY = i++,
            IN_NAMED_ENTITY = i++,
            IN_NUMERIC_ENTITY = i++,
            IN_HEX_ENTITY = i++,
            j = 0,
            SPECIAL_NONE = j++,
            SPECIAL_SCRIPT = j++,
            SPECIAL_STYLE = j++;
          function whitespace(c) {
            return (
              c === ' ' || c === '\n' || c === '\t' || c === '\f' || c === '\r'
            );
          }
          function characterState(char, SUCCESS) {
            return function(c) {
              if (c === char) this._state = SUCCESS;
            };
          }
          function ifElseState(upper, SUCCESS, FAILURE) {
            var lower = upper.toLowerCase();
            if (upper === lower) {
              return function(c) {
                if (c === lower) {
                  this._state = SUCCESS;
                } else {
                  this._state = FAILURE;
                  this._index--;
                }
              };
            } else {
              return function(c) {
                if (c === lower || c === upper) {
                  this._state = SUCCESS;
                } else {
                  this._state = FAILURE;
                  this._index--;
                }
              };
            }
          }
          function consumeSpecialNameChar(upper, NEXT_STATE) {
            var lower = upper.toLowerCase();
            return function(c) {
              if (c === lower || c === upper) {
                this._state = NEXT_STATE;
              } else {
                this._state = IN_TAG_NAME;
                this._index--;
              }
            };
          }
          function Tokenizer(options, cbs) {
            this._state = TEXT;
            this._buffer = '';
            this._sectionStart = 0;
            this._index = 0;
            this._bufferOffset = 0;
            this._baseState = TEXT;
            this._special = SPECIAL_NONE;
            this._cbs = cbs;
            this._running = true;
            this._ended = false;
            this._xmlMode = !!(options && options.xmlMode);
            this._decodeEntities = !!(options && options.decodeEntities);
          }
          Tokenizer.prototype._stateText = function(c) {
            if (c === '<') {
              if (this._index > this._sectionStart) {
                this._cbs.ontext(this._getSection());
              }
              this._state = BEFORE_TAG_NAME;
              this._sectionStart = this._index;
            } else if (
              this._decodeEntities &&
              this._special === SPECIAL_NONE &&
              c === '&'
            ) {
              if (this._index > this._sectionStart) {
                this._cbs.ontext(this._getSection());
              }
              this._baseState = TEXT;
              this._state = BEFORE_ENTITY;
              this._sectionStart = this._index;
            }
          };
          Tokenizer.prototype._stateBeforeTagName = function(c) {
            if (c === '/') {
              this._state = BEFORE_CLOSING_TAG_NAME;
            } else if (c === '<') {
              this._cbs.ontext(this._getSection());
              this._sectionStart = this._index;
            } else if (
              c === '>' ||
              this._special !== SPECIAL_NONE ||
              whitespace(c)
            ) {
              this._state = TEXT;
            } else if (c === '!') {
              this._state = BEFORE_DECLARATION;
              this._sectionStart = this._index + 1;
            } else if (c === '?') {
              this._state = IN_PROCESSING_INSTRUCTION;
              this._sectionStart = this._index + 1;
            } else {
              this._state =
                !this._xmlMode && (c === 's' || c === 'S')
                  ? BEFORE_SPECIAL
                  : IN_TAG_NAME;
              this._sectionStart = this._index;
            }
          };
          Tokenizer.prototype._stateInTagName = function(c) {
            if (c === '/' || c === '>' || whitespace(c)) {
              this._emitToken('onopentagname');
              this._state = BEFORE_ATTRIBUTE_NAME;
              this._index--;
            }
          };
          Tokenizer.prototype._stateBeforeCloseingTagName = function(c) {
            if (whitespace(c));
            else if (c === '>') {
              this._state = TEXT;
            } else if (this._special !== SPECIAL_NONE) {
              if (c === 's' || c === 'S') {
                this._state = BEFORE_SPECIAL_END;
              } else {
                this._state = TEXT;
                this._index--;
              }
            } else {
              this._state = IN_CLOSING_TAG_NAME;
              this._sectionStart = this._index;
            }
          };
          Tokenizer.prototype._stateInCloseingTagName = function(c) {
            if (c === '>' || whitespace(c)) {
              this._emitToken('onclosetag');
              this._state = AFTER_CLOSING_TAG_NAME;
              this._index--;
            }
          };
          Tokenizer.prototype._stateAfterCloseingTagName = function(c) {
            if (c === '>') {
              this._state = TEXT;
              this._sectionStart = this._index + 1;
            }
          };
          Tokenizer.prototype._stateBeforeAttributeName = function(c) {
            if (c === '>') {
              this._cbs.onopentagend();
              this._state = TEXT;
              this._sectionStart = this._index + 1;
            } else if (c === '/') {
              this._state = IN_SELF_CLOSING_TAG;
            } else if (!whitespace(c)) {
              this._state = IN_ATTRIBUTE_NAME;
              this._sectionStart = this._index;
            }
          };
          Tokenizer.prototype._stateInSelfClosingTag = function(c) {
            if (c === '>') {
              this._cbs.onselfclosingtag();
              this._state = TEXT;
              this._sectionStart = this._index + 1;
            } else if (!whitespace(c)) {
              this._state = BEFORE_ATTRIBUTE_NAME;
              this._index--;
            }
          };
          Tokenizer.prototype._stateInAttributeName = function(c) {
            if (c === '=' || c === '/' || c === '>' || whitespace(c)) {
              this._cbs.onattribname(this._getSection());
              this._sectionStart = -1;
              this._state = AFTER_ATTRIBUTE_NAME;
              this._index--;
            }
          };
          Tokenizer.prototype._stateAfterAttributeName = function(c) {
            if (c === '=') {
              this._state = BEFORE_ATTRIBUTE_VALUE;
            } else if (c === '/' || c === '>') {
              this._cbs.onattribend();
              this._state = BEFORE_ATTRIBUTE_NAME;
              this._index--;
            } else if (!whitespace(c)) {
              this._cbs.onattribend();
              this._state = IN_ATTRIBUTE_NAME;
              this._sectionStart = this._index;
            }
          };
          Tokenizer.prototype._stateBeforeAttributeValue = function(c) {
            if (c === '"') {
              this._state = IN_ATTRIBUTE_VALUE_DQ;
              this._sectionStart = this._index + 1;
            } else if (c === "'") {
              this._state = IN_ATTRIBUTE_VALUE_SQ;
              this._sectionStart = this._index + 1;
            } else if (!whitespace(c)) {
              this._state = IN_ATTRIBUTE_VALUE_NQ;
              this._sectionStart = this._index;
              this._index--;
            }
          };
          Tokenizer.prototype._stateInAttributeValueDoubleQuotes = function(c) {
            if (c === '"') {
              this._emitToken('onattribdata');
              this._cbs.onattribend();
              this._state = BEFORE_ATTRIBUTE_NAME;
            } else if (this._decodeEntities && c === '&') {
              this._emitToken('onattribdata');
              this._baseState = this._state;
              this._state = BEFORE_ENTITY;
              this._sectionStart = this._index;
            }
          };
          Tokenizer.prototype._stateInAttributeValueSingleQuotes = function(c) {
            if (c === "'") {
              this._emitToken('onattribdata');
              this._cbs.onattribend();
              this._state = BEFORE_ATTRIBUTE_NAME;
            } else if (this._decodeEntities && c === '&') {
              this._emitToken('onattribdata');
              this._baseState = this._state;
              this._state = BEFORE_ENTITY;
              this._sectionStart = this._index;
            }
          };
          Tokenizer.prototype._stateInAttributeValueNoQuotes = function(c) {
            if (whitespace(c) || c === '>') {
              this._emitToken('onattribdata');
              this._cbs.onattribend();
              this._state = BEFORE_ATTRIBUTE_NAME;
              this._index--;
            } else if (this._decodeEntities && c === '&') {
              this._emitToken('onattribdata');
              this._baseState = this._state;
              this._state = BEFORE_ENTITY;
              this._sectionStart = this._index;
            }
          };
          Tokenizer.prototype._stateBeforeDeclaration = function(c) {
            this._state =
              c === '['
                ? BEFORE_CDATA_1
                : c === '-'
                ? BEFORE_COMMENT
                : IN_DECLARATION;
          };
          Tokenizer.prototype._stateInDeclaration = function(c) {
            if (c === '>') {
              this._cbs.ondeclaration(this._getSection());
              this._state = TEXT;
              this._sectionStart = this._index + 1;
            }
          };
          Tokenizer.prototype._stateInProcessingInstruction = function(c) {
            if (c === '>') {
              this._cbs.onprocessinginstruction(this._getSection());
              this._state = TEXT;
              this._sectionStart = this._index + 1;
            }
          };
          Tokenizer.prototype._stateBeforeComment = function(c) {
            if (c === '-') {
              this._state = IN_COMMENT;
              this._sectionStart = this._index + 1;
            } else {
              this._state = IN_DECLARATION;
            }
          };
          Tokenizer.prototype._stateInComment = function(c) {
            if (c === '-') this._state = AFTER_COMMENT_1;
          };
          Tokenizer.prototype._stateAfterComment1 = function(c) {
            if (c === '-') {
              this._state = AFTER_COMMENT_2;
            } else {
              this._state = IN_COMMENT;
            }
          };
          Tokenizer.prototype._stateAfterComment2 = function(c) {
            if (c === '>') {
              this._cbs.oncomment(
                this._buffer.substring(this._sectionStart, this._index - 2)
              );
              this._state = TEXT;
              this._sectionStart = this._index + 1;
            } else if (c !== '-') {
              this._state = IN_COMMENT;
            }
          };
          Tokenizer.prototype._stateBeforeCdata1 = ifElseState(
            'C',
            BEFORE_CDATA_2,
            IN_DECLARATION
          );
          Tokenizer.prototype._stateBeforeCdata2 = ifElseState(
            'D',
            BEFORE_CDATA_3,
            IN_DECLARATION
          );
          Tokenizer.prototype._stateBeforeCdata3 = ifElseState(
            'A',
            BEFORE_CDATA_4,
            IN_DECLARATION
          );
          Tokenizer.prototype._stateBeforeCdata4 = ifElseState(
            'T',
            BEFORE_CDATA_5,
            IN_DECLARATION
          );
          Tokenizer.prototype._stateBeforeCdata5 = ifElseState(
            'A',
            BEFORE_CDATA_6,
            IN_DECLARATION
          );
          Tokenizer.prototype._stateBeforeCdata6 = function(c) {
            if (c === '[') {
              this._state = IN_CDATA;
              this._sectionStart = this._index + 1;
            } else {
              this._state = IN_DECLARATION;
              this._index--;
            }
          };
          Tokenizer.prototype._stateInCdata = function(c) {
            if (c === ']') this._state = AFTER_CDATA_1;
          };
          Tokenizer.prototype._stateAfterCdata1 = characterState(
            ']',
            AFTER_CDATA_2
          );
          Tokenizer.prototype._stateAfterCdata2 = function(c) {
            if (c === '>') {
              this._cbs.oncdata(
                this._buffer.substring(this._sectionStart, this._index - 2)
              );
              this._state = TEXT;
              this._sectionStart = this._index + 1;
            } else if (c !== ']') {
              this._state = IN_CDATA;
            }
          };
          Tokenizer.prototype._stateBeforeSpecial = function(c) {
            if (c === 'c' || c === 'C') {
              this._state = BEFORE_SCRIPT_1;
            } else if (c === 't' || c === 'T') {
              this._state = BEFORE_STYLE_1;
            } else {
              this._state = IN_TAG_NAME;
              this._index--;
            }
          };
          Tokenizer.prototype._stateBeforeSpecialEnd = function(c) {
            if (this._special === SPECIAL_SCRIPT && (c === 'c' || c === 'C')) {
              this._state = AFTER_SCRIPT_1;
            } else if (
              this._special === SPECIAL_STYLE &&
              (c === 't' || c === 'T')
            ) {
              this._state = AFTER_STYLE_1;
            } else this._state = TEXT;
          };
          Tokenizer.prototype._stateBeforeScript1 = consumeSpecialNameChar(
            'R',
            BEFORE_SCRIPT_2
          );
          Tokenizer.prototype._stateBeforeScript2 = consumeSpecialNameChar(
            'I',
            BEFORE_SCRIPT_3
          );
          Tokenizer.prototype._stateBeforeScript3 = consumeSpecialNameChar(
            'P',
            BEFORE_SCRIPT_4
          );
          Tokenizer.prototype._stateBeforeScript4 = consumeSpecialNameChar(
            'T',
            BEFORE_SCRIPT_5
          );
          Tokenizer.prototype._stateBeforeScript5 = function(c) {
            if (c === '/' || c === '>' || whitespace(c)) {
              this._special = SPECIAL_SCRIPT;
            }
            this._state = IN_TAG_NAME;
            this._index--;
          };
          Tokenizer.prototype._stateAfterScript1 = ifElseState(
            'R',
            AFTER_SCRIPT_2,
            TEXT
          );
          Tokenizer.prototype._stateAfterScript2 = ifElseState(
            'I',
            AFTER_SCRIPT_3,
            TEXT
          );
          Tokenizer.prototype._stateAfterScript3 = ifElseState(
            'P',
            AFTER_SCRIPT_4,
            TEXT
          );
          Tokenizer.prototype._stateAfterScript4 = ifElseState(
            'T',
            AFTER_SCRIPT_5,
            TEXT
          );
          Tokenizer.prototype._stateAfterScript5 = function(c) {
            if (c === '>' || whitespace(c)) {
              this._special = SPECIAL_NONE;
              this._state = IN_CLOSING_TAG_NAME;
              this._sectionStart = this._index - 6;
              this._index--;
            } else this._state = TEXT;
          };
          Tokenizer.prototype._stateBeforeStyle1 = consumeSpecialNameChar(
            'Y',
            BEFORE_STYLE_2
          );
          Tokenizer.prototype._stateBeforeStyle2 = consumeSpecialNameChar(
            'L',
            BEFORE_STYLE_3
          );
          Tokenizer.prototype._stateBeforeStyle3 = consumeSpecialNameChar(
            'E',
            BEFORE_STYLE_4
          );
          Tokenizer.prototype._stateBeforeStyle4 = function(c) {
            if (c === '/' || c === '>' || whitespace(c)) {
              this._special = SPECIAL_STYLE;
            }
            this._state = IN_TAG_NAME;
            this._index--;
          };
          Tokenizer.prototype._stateAfterStyle1 = ifElseState(
            'Y',
            AFTER_STYLE_2,
            TEXT
          );
          Tokenizer.prototype._stateAfterStyle2 = ifElseState(
            'L',
            AFTER_STYLE_3,
            TEXT
          );
          Tokenizer.prototype._stateAfterStyle3 = ifElseState(
            'E',
            AFTER_STYLE_4,
            TEXT
          );
          Tokenizer.prototype._stateAfterStyle4 = function(c) {
            if (c === '>' || whitespace(c)) {
              this._special = SPECIAL_NONE;
              this._state = IN_CLOSING_TAG_NAME;
              this._sectionStart = this._index - 5;
              this._index--;
            } else this._state = TEXT;
          };
          Tokenizer.prototype._stateBeforeEntity = ifElseState(
            '#',
            BEFORE_NUMERIC_ENTITY,
            IN_NAMED_ENTITY
          );
          Tokenizer.prototype._stateBeforeNumericEntity = ifElseState(
            'X',
            IN_HEX_ENTITY,
            IN_NUMERIC_ENTITY
          );
          Tokenizer.prototype._parseNamedEntityStrict = function() {
            if (this._sectionStart + 1 < this._index) {
              var entity = this._buffer.substring(
                  this._sectionStart + 1,
                  this._index
                ),
                map = this._xmlMode ? xmlMap : entityMap;
              if (map.hasOwnProperty(entity)) {
                this._emitPartial(map[entity]);
                this._sectionStart = this._index + 1;
              }
            }
          };
          Tokenizer.prototype._parseLegacyEntity = function() {
            var start = this._sectionStart + 1,
              limit = this._index - start;
            if (limit > 6) limit = 6;
            while (limit >= 2) {
              var entity = this._buffer.substr(start, limit);
              if (legacyMap.hasOwnProperty(entity)) {
                this._emitPartial(legacyMap[entity]);
                this._sectionStart += limit + 1;
                return;
              } else {
                limit--;
              }
            }
          };
          Tokenizer.prototype._stateInNamedEntity = function(c) {
            if (c === ';') {
              this._parseNamedEntityStrict();
              if (this._sectionStart + 1 < this._index && !this._xmlMode) {
                this._parseLegacyEntity();
              }
              this._state = this._baseState;
            } else if (
              (c < 'a' || c > 'z') &&
              (c < 'A' || c > 'Z') &&
              (c < '0' || c > '9')
            ) {
              if (this._xmlMode);
              else if (this._sectionStart + 1 === this._index);
              else if (this._baseState !== TEXT) {
                if (c !== '=') {
                  this._parseNamedEntityStrict();
                }
              } else {
                this._parseLegacyEntity();
              }
              this._state = this._baseState;
              this._index--;
            }
          };
          Tokenizer.prototype._decodeNumericEntity = function(offset, base) {
            var sectionStart = this._sectionStart + offset;
            if (sectionStart !== this._index) {
              var entity = this._buffer.substring(sectionStart, this._index);
              var parsed = parseInt(entity, base);
              this._emitPartial(decodeCodePoint(parsed));
              this._sectionStart = this._index;
            } else {
              this._sectionStart--;
            }
            this._state = this._baseState;
          };
          Tokenizer.prototype._stateInNumericEntity = function(c) {
            if (c === ';') {
              this._decodeNumericEntity(2, 10);
              this._sectionStart++;
            } else if (c < '0' || c > '9') {
              if (!this._xmlMode) {
                this._decodeNumericEntity(2, 10);
              } else {
                this._state = this._baseState;
              }
              this._index--;
            }
          };
          Tokenizer.prototype._stateInHexEntity = function(c) {
            if (c === ';') {
              this._decodeNumericEntity(3, 16);
              this._sectionStart++;
            } else if (
              (c < 'a' || c > 'f') &&
              (c < 'A' || c > 'F') &&
              (c < '0' || c > '9')
            ) {
              if (!this._xmlMode) {
                this._decodeNumericEntity(3, 16);
              } else {
                this._state = this._baseState;
              }
              this._index--;
            }
          };
          Tokenizer.prototype._cleanup = function() {
            if (this._sectionStart < 0) {
              this._buffer = '';
              this._bufferOffset += this._index;
              this._index = 0;
            } else if (this._running) {
              if (this._state === TEXT) {
                if (this._sectionStart !== this._index) {
                  this._cbs.ontext(this._buffer.substr(this._sectionStart));
                }
                this._buffer = '';
                this._bufferOffset += this._index;
                this._index = 0;
              } else if (this._sectionStart === this._index) {
                this._buffer = '';
                this._bufferOffset += this._index;
                this._index = 0;
              } else {
                this._buffer = this._buffer.substr(this._sectionStart);
                this._index -= this._sectionStart;
                this._bufferOffset += this._sectionStart;
              }
              this._sectionStart = 0;
            }
          };
          Tokenizer.prototype.write = function(chunk) {
            if (this._ended) this._cbs.onerror(Error('.write() after done!'));
            this._buffer += chunk;
            this._parse();
          };
          Tokenizer.prototype._parse = function() {
            while (this._index < this._buffer.length && this._running) {
              var c = this._buffer.charAt(this._index);
              if (this._state === TEXT) {
                this._stateText(c);
              } else if (this._state === BEFORE_TAG_NAME) {
                this._stateBeforeTagName(c);
              } else if (this._state === IN_TAG_NAME) {
                this._stateInTagName(c);
              } else if (this._state === BEFORE_CLOSING_TAG_NAME) {
                this._stateBeforeCloseingTagName(c);
              } else if (this._state === IN_CLOSING_TAG_NAME) {
                this._stateInCloseingTagName(c);
              } else if (this._state === AFTER_CLOSING_TAG_NAME) {
                this._stateAfterCloseingTagName(c);
              } else if (this._state === IN_SELF_CLOSING_TAG) {
                this._stateInSelfClosingTag(c);
              } else if (this._state === BEFORE_ATTRIBUTE_NAME) {
                this._stateBeforeAttributeName(c);
              } else if (this._state === IN_ATTRIBUTE_NAME) {
                this._stateInAttributeName(c);
              } else if (this._state === AFTER_ATTRIBUTE_NAME) {
                this._stateAfterAttributeName(c);
              } else if (this._state === BEFORE_ATTRIBUTE_VALUE) {
                this._stateBeforeAttributeValue(c);
              } else if (this._state === IN_ATTRIBUTE_VALUE_DQ) {
                this._stateInAttributeValueDoubleQuotes(c);
              } else if (this._state === IN_ATTRIBUTE_VALUE_SQ) {
                this._stateInAttributeValueSingleQuotes(c);
              } else if (this._state === IN_ATTRIBUTE_VALUE_NQ) {
                this._stateInAttributeValueNoQuotes(c);
              } else if (this._state === BEFORE_DECLARATION) {
                this._stateBeforeDeclaration(c);
              } else if (this._state === IN_DECLARATION) {
                this._stateInDeclaration(c);
              } else if (this._state === IN_PROCESSING_INSTRUCTION) {
                this._stateInProcessingInstruction(c);
              } else if (this._state === BEFORE_COMMENT) {
                this._stateBeforeComment(c);
              } else if (this._state === IN_COMMENT) {
                this._stateInComment(c);
              } else if (this._state === AFTER_COMMENT_1) {
                this._stateAfterComment1(c);
              } else if (this._state === AFTER_COMMENT_2) {
                this._stateAfterComment2(c);
              } else if (this._state === BEFORE_CDATA_1) {
                this._stateBeforeCdata1(c);
              } else if (this._state === BEFORE_CDATA_2) {
                this._stateBeforeCdata2(c);
              } else if (this._state === BEFORE_CDATA_3) {
                this._stateBeforeCdata3(c);
              } else if (this._state === BEFORE_CDATA_4) {
                this._stateBeforeCdata4(c);
              } else if (this._state === BEFORE_CDATA_5) {
                this._stateBeforeCdata5(c);
              } else if (this._state === BEFORE_CDATA_6) {
                this._stateBeforeCdata6(c);
              } else if (this._state === IN_CDATA) {
                this._stateInCdata(c);
              } else if (this._state === AFTER_CDATA_1) {
                this._stateAfterCdata1(c);
              } else if (this._state === AFTER_CDATA_2) {
                this._stateAfterCdata2(c);
              } else if (this._state === BEFORE_SPECIAL) {
                this._stateBeforeSpecial(c);
              } else if (this._state === BEFORE_SPECIAL_END) {
                this._stateBeforeSpecialEnd(c);
              } else if (this._state === BEFORE_SCRIPT_1) {
                this._stateBeforeScript1(c);
              } else if (this._state === BEFORE_SCRIPT_2) {
                this._stateBeforeScript2(c);
              } else if (this._state === BEFORE_SCRIPT_3) {
                this._stateBeforeScript3(c);
              } else if (this._state === BEFORE_SCRIPT_4) {
                this._stateBeforeScript4(c);
              } else if (this._state === BEFORE_SCRIPT_5) {
                this._stateBeforeScript5(c);
              } else if (this._state === AFTER_SCRIPT_1) {
                this._stateAfterScript1(c);
              } else if (this._state === AFTER_SCRIPT_2) {
                this._stateAfterScript2(c);
              } else if (this._state === AFTER_SCRIPT_3) {
                this._stateAfterScript3(c);
              } else if (this._state === AFTER_SCRIPT_4) {
                this._stateAfterScript4(c);
              } else if (this._state === AFTER_SCRIPT_5) {
                this._stateAfterScript5(c);
              } else if (this._state === BEFORE_STYLE_1) {
                this._stateBeforeStyle1(c);
              } else if (this._state === BEFORE_STYLE_2) {
                this._stateBeforeStyle2(c);
              } else if (this._state === BEFORE_STYLE_3) {
                this._stateBeforeStyle3(c);
              } else if (this._state === BEFORE_STYLE_4) {
                this._stateBeforeStyle4(c);
              } else if (this._state === AFTER_STYLE_1) {
                this._stateAfterStyle1(c);
              } else if (this._state === AFTER_STYLE_2) {
                this._stateAfterStyle2(c);
              } else if (this._state === AFTER_STYLE_3) {
                this._stateAfterStyle3(c);
              } else if (this._state === AFTER_STYLE_4) {
                this._stateAfterStyle4(c);
              } else if (this._state === BEFORE_ENTITY) {
                this._stateBeforeEntity(c);
              } else if (this._state === BEFORE_NUMERIC_ENTITY) {
                this._stateBeforeNumericEntity(c);
              } else if (this._state === IN_NAMED_ENTITY) {
                this._stateInNamedEntity(c);
              } else if (this._state === IN_NUMERIC_ENTITY) {
                this._stateInNumericEntity(c);
              } else if (this._state === IN_HEX_ENTITY) {
                this._stateInHexEntity(c);
              } else {
                this._cbs.onerror(Error('unknown _state'), this._state);
              }
              this._index++;
            }
            this._cleanup();
          };
          Tokenizer.prototype.pause = function() {
            this._running = false;
          };
          Tokenizer.prototype.resume = function() {
            this._running = true;
            if (this._index < this._buffer.length) {
              this._parse();
            }
            if (this._ended) {
              this._finish();
            }
          };
          Tokenizer.prototype.end = function(chunk) {
            if (this._ended) this._cbs.onerror(Error('.end() after done!'));
            if (chunk) this.write(chunk);
            this._ended = true;
            if (this._running) this._finish();
          };
          Tokenizer.prototype._finish = function() {
            if (this._sectionStart < this._index) {
              this._handleTrailingData();
            }
            this._cbs.onend();
          };
          Tokenizer.prototype._handleTrailingData = function() {
            var data = this._buffer.substr(this._sectionStart);
            if (
              this._state === IN_CDATA ||
              this._state === AFTER_CDATA_1 ||
              this._state === AFTER_CDATA_2
            ) {
              this._cbs.oncdata(data);
            } else if (
              this._state === IN_COMMENT ||
              this._state === AFTER_COMMENT_1 ||
              this._state === AFTER_COMMENT_2
            ) {
              this._cbs.oncomment(data);
            } else if (this._state === IN_NAMED_ENTITY && !this._xmlMode) {
              this._parseLegacyEntity();
              if (this._sectionStart < this._index) {
                this._state = this._baseState;
                this._handleTrailingData();
              }
            } else if (this._state === IN_NUMERIC_ENTITY && !this._xmlMode) {
              this._decodeNumericEntity(2, 10);
              if (this._sectionStart < this._index) {
                this._state = this._baseState;
                this._handleTrailingData();
              }
            } else if (this._state === IN_HEX_ENTITY && !this._xmlMode) {
              this._decodeNumericEntity(3, 16);
              if (this._sectionStart < this._index) {
                this._state = this._baseState;
                this._handleTrailingData();
              }
            } else if (
              this._state !== IN_TAG_NAME &&
              this._state !== BEFORE_ATTRIBUTE_NAME &&
              this._state !== BEFORE_ATTRIBUTE_VALUE &&
              this._state !== AFTER_ATTRIBUTE_NAME &&
              this._state !== IN_ATTRIBUTE_NAME &&
              this._state !== IN_ATTRIBUTE_VALUE_SQ &&
              this._state !== IN_ATTRIBUTE_VALUE_DQ &&
              this._state !== IN_ATTRIBUTE_VALUE_NQ &&
              this._state !== IN_CLOSING_TAG_NAME
            ) {
              this._cbs.ontext(data);
            }
          };
          Tokenizer.prototype.reset = function() {
            Tokenizer.call(
              this,
              { xmlMode: this._xmlMode, decodeEntities: this._decodeEntities },
              this._cbs
            );
          };
          Tokenizer.prototype.getAbsoluteIndex = function() {
            return this._bufferOffset + this._index;
          };
          Tokenizer.prototype._getSection = function() {
            return this._buffer.substring(this._sectionStart, this._index);
          };
          Tokenizer.prototype._emitToken = function(name) {
            this._cbs[name](this._getSection());
            this._sectionStart = -1;
          };
          Tokenizer.prototype._emitPartial = function(value) {
            if (this._baseState !== TEXT) {
              this._cbs.onattribdata(value);
            } else {
              this._cbs.ontext(value);
            }
          };
        },
        {
          'entities/lib/decode_codepoint.js': 345,
          'entities/maps/entities.json': 348,
          'entities/maps/legacy.json': 349,
          'entities/maps/xml.json': 350
        }
      ],
      372: [
        function(require, module, exports) {
          module.exports = Stream;
          var Parser = require('./Parser.js'),
            WritableStream =
              require('stream').Writable || require('readable-stream').Writable,
            StringDecoder = require('string_decoder').StringDecoder,
            Buffer = require('buffer').Buffer;
          function Stream(cbs, options) {
            var parser = (this._parser = new Parser(cbs, options));
            var decoder = (this._decoder = new StringDecoder());
            WritableStream.call(this, { decodeStrings: false });
            this.once('finish', function() {
              parser.end(decoder.end());
            });
          }
          require('inherits')(Stream, WritableStream);
          WritableStream.prototype._write = function(chunk, encoding, cb) {
            if (chunk instanceof Buffer) chunk = this._decoder.write(chunk);
            this._parser.write(chunk);
            cb();
          };
        },
        {
          './Parser.js': 368,
          buffer: 183,
          inherits: 374,
          'readable-stream': 155,
          stream: 258,
          string_decoder: 259
        }
      ],
      373: [
        function(require, module, exports) {
          var Parser = require('./Parser.js'),
            DomHandler = require('domhandler');
          function defineProp(name, value) {
            delete module.exports[name];
            module.exports[name] = value;
            return value;
          }
          module.exports = {
            Parser: Parser,
            Tokenizer: require('./Tokenizer.js'),
            ElementType: require('domelementtype'),
            DomHandler: DomHandler,
            get FeedHandler() {
              return defineProp('FeedHandler', require('./FeedHandler.js'));
            },
            get Stream() {
              return defineProp('Stream', require('./Stream.js'));
            },
            get WritableStream() {
              return defineProp(
                'WritableStream',
                require('./WritableStream.js')
              );
            },
            get ProxyHandler() {
              return defineProp('ProxyHandler', require('./ProxyHandler.js'));
            },
            get DomUtils() {
              return defineProp('DomUtils', require('domutils'));
            },
            get CollectingHandler() {
              return defineProp(
                'CollectingHandler',
                require('./CollectingHandler.js')
              );
            },
            DefaultHandler: DomHandler,
            get RssHandler() {
              return defineProp('RssHandler', this.FeedHandler);
            },
            parseDOM: function(data, options) {
              var handler = new DomHandler(options);
              new Parser(handler, options).end(data);
              return handler.dom;
            },
            parseFeed: function(feed, options) {
              var handler = new module.exports.FeedHandler(options);
              new Parser(handler, options).end(feed);
              return handler.dom;
            },
            createDomStream: function(cb, options, elementCb) {
              var handler = new DomHandler(cb, options, elementCb);
              return new Parser(handler, options);
            },
            EVENTS: {
              attribute: 2,
              cdatastart: 0,
              cdataend: 0,
              text: 1,
              processinginstruction: 2,
              comment: 1,
              commentend: 0,
              closetag: 1,
              opentag: 2,
              opentagname: 1,
              error: 1,
              end: 0
            }
          };
        },
        {
          './CollectingHandler.js': 366,
          './FeedHandler.js': 367,
          './Parser.js': 368,
          './ProxyHandler.js': 369,
          './Stream.js': 370,
          './Tokenizer.js': 371,
          './WritableStream.js': 372,
          domelementtype: 298,
          domhandler: 299,
          domutils: 302
        }
      ],
      374: [
        function(require, module, exports) {
          arguments[4][207][0].apply(exports, arguments);
        },
        { dup: 207 }
      ],
      375: [
        function(require, module, exports) {
          (function() {
            var BaseError,
              C,
              Canceler,
              EscErr,
              EscOk,
              c_to_camel,
              copy_trace,
              ipush,
              make_error_klass,
              make_errors,
              make_esc,
              to_lower,
              util,
              __slice = [].slice;
            util = require('util');
            C = require('iced-runtime')['const'];
            exports.BaseError = BaseError = function(msg, constructor) {
              if (typeof Error.captureStackTrace === 'function') {
                Error.captureStackTrace(this, this.constructor);
              }
              return (this.message = msg || 'Error');
            };
            util.inherits(BaseError, Error);
            BaseError.prototype.name = 'BaseError';
            to_lower = function(s) {
              return s[0].toUpperCase() + s.slice(1).toLowerCase();
            };
            c_to_camel = function(s) {
              var p;
              return (function() {
                var _i, _len, _ref, _results;
                _ref = s.split(/_/);
                _results = [];
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                  p = _ref[_i];
                  _results.push(to_lower(p));
                }
                return _results;
              })().join('');
            };
            make_error_klass = function(k, code, default_msg) {
              var ctor;
              ctor = function(msg) {
                BaseError.call(this, msg || default_msg, this.constructor);
                this.istack = [];
                this.code = code;
                return this;
              };
              util.inherits(ctor, BaseError);
              ctor.prototype.name = k;
              ctor.prototype.inspect = function() {
                return (
                  '[' + k + ': ' + this.message + ' (code ' + this.code + ')]'
                );
              };
              return ctor;
            };
            copy_trace = function(src, dst) {
              dst[C.trace] = src[C.trace];
              return dst;
            };
            exports.make_errors = make_errors = function(d) {
              var enam, errno, k, msg, out, val;
              out = { msg: {}, name: {}, code: {} };
              d.OK = 'Success';
              errno = 100;
              for (k in d) {
                msg = d[k];
                if (k !== 'OK') {
                  enam = c_to_camel(k) + 'Error';
                  val = errno++;
                  out[enam] = make_error_klass(enam, val, msg);
                } else {
                  val = 0;
                }
                out[k] = val;
                out.msg[k] = out.msg[val] = msg;
                out.name[k] = out.name[val] = k;
                out.code[k] = val;
              }
              return out;
            };
            ipush = function(e, msg) {
              if (msg != null) {
                if (e.istack == null) {
                  e.istack = [];
                }
                return e.istack.push(msg);
              }
            };
            exports.make_esc = make_esc = function(gcb, where) {
              return function(lcb) {
                return copy_trace(lcb, function() {
                  var args, err, _ref, _ref1, _ref2;
                  (err = arguments[0]),
                    (args =
                      2 <= arguments.length ? __slice.call(arguments, 1) : []);
                  if (err == null) {
                    return lcb.apply(null, args);
                  } else if (!gcb.__esc) {
                    gcb.__esc = true;
                    ipush(
                      err,
                      (_ref =
                        where != null
                          ? where
                          : arguments != null
                          ? (_ref1 = arguments.caller) != null
                            ? (_ref2 = _ref1.callee) != null
                              ? _ref2.name
                              : void 0
                            : void 0
                          : void 0) != null
                        ? _ref
                        : 'unnamed error'
                    );
                    return gcb(err);
                  }
                });
              };
            };
            exports.EscOk = EscOk = (function() {
              function EscOk(gcb, where) {
                this.gcb = gcb;
                this.where = where;
              }
              EscOk.prototype.bailout = function() {
                var t;
                if (this.gcb) {
                  t = this.gcb;
                  this.gcb = null;
                  return t(false);
                }
              };
              EscOk.prototype.check_ok = function(cb) {
                return copy_trace(
                  cb,
                  (function(_this) {
                    return function() {
                      var args, ok;
                      (ok = arguments[0]),
                        (args =
                          2 <= arguments.length
                            ? __slice.call(arguments, 1)
                            : []);
                      if (!ok) {
                        return _this.bailout();
                      } else {
                        return cb.apply(null, args);
                      }
                    };
                  })(this)
                );
              };
              EscOk.prototype.check_err = function(cb) {
                return copy_trace(
                  cb,
                  (function(_this) {
                    return function() {
                      var args, err;
                      (err = arguments[0]),
                        (args =
                          2 <= arguments.length
                            ? __slice.call(arguments, 1)
                            : []);
                      if (err != null) {
                        ipush(err, _this.where);
                        return _this.bailout();
                      } else {
                        return cb.apply(null, args);
                      }
                    };
                  })(this)
                );
              };
              EscOk.prototype.check_non_null = function(cb) {
                return copy_trace(
                  cb,
                  (function(_this) {
                    return function() {
                      var args;
                      args =
                        1 <= arguments.length ? __slice.call(arguments, 0) : [];
                      if (args[0] == null) {
                        return _this.bailout();
                      } else {
                        return cb.apply(null, args);
                      }
                    };
                  })(this)
                );
              };
              return EscOk;
            })();
            exports.EscErr = EscErr = (function() {
              function EscErr(gcb, where) {
                this.gcb = gcb;
                this.where = where;
              }
              EscErr.prototype.finish = function(err) {
                var t;
                if (this.gcb) {
                  t = this.gcb;
                  this.gcb = null;
                  return t(err);
                }
              };
              EscErr.prototype.check_ok = function(cb, eclass, emsg) {
                if (eclass == null) {
                  eclass = Error;
                }
                if (emsg == null) {
                  emsg = null;
                }
                return copy_trace(cb, function() {
                  var args, err, ok;
                  (ok = arguments[0]),
                    (args =
                      2 <= arguments.length ? __slice.call(arguments, 1) : []);
                  if (!ok) {
                    err = new eclass(emsg);
                    ipush(err, this.where);
                    return this.finish(err);
                  } else {
                    return cb.apply(null, args);
                  }
                });
              };
              EscErr.prototype.check_err = function(cb) {
                return copy_trace(cb, function() {
                  var args, err;
                  (err = arguments[0]),
                    (args =
                      2 <= arguments.length ? __slice.call(arguments, 1) : []);
                  if (err != null) {
                    ipush(err, this.where);
                    return this.finish(err);
                  } else {
                    return cb.apply(null, args);
                  }
                });
              };
              return EscErr;
            })();
            exports.Canceler = Canceler = (function() {
              function Canceler(klass) {
                this.klass = klass != null ? klass : Error;
                this._canceled = false;
              }
              Canceler.prototype.is_canceled = function() {
                return this._canceled;
              };
              Canceler.prototype.is_ok = function() {
                return !this._canceled;
              };
              Canceler.prototype.cancel = function() {
                return (this._canceled = true);
              };
              Canceler.prototype.err = function() {
                if (this._canceled) {
                  return new this.klass('Aborted');
                } else {
                  return null;
                }
              };
              return Canceler;
            })();
            exports.chain = function(cb, f) {
              return function() {
                var args;
                args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                return f(function() {
                  return cb.apply(null, args);
                });
              };
            };
            exports.chain_err = function(cb, f) {
              return function() {
                var args0;
                args0 = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                return f(function() {
                  var args1;
                  args1 =
                    1 <= arguments.length ? __slice.call(arguments, 0) : [];
                  return cb.apply(
                    null,
                    args1[0] != null && !(args0[0] != null) ? args1 : args0
                  );
                });
              };
            };
          }.call(this));
        },
        { 'iced-runtime': 379, util: 265 }
      ],
      376: [
        function(require, module, exports) {
          (function() {
            var Lock,
              NamedLock,
              SingleFlightTable,
              SingleFlighter,
              Table,
              iced,
              __iced_k,
              __iced_k_noop,
              __hasProp = {}.hasOwnProperty,
              __extends = function(child, parent) {
                for (var key in parent) {
                  if (__hasProp.call(parent, key)) child[key] = parent[key];
                }
                function ctor() {
                  this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
              };
            iced = require('iced-runtime');
            __iced_k = __iced_k_noop = function() {};
            exports.Lock = Lock = (function() {
              function Lock() {
                this._open = true;
                this._waiters = [];
              }
              Lock.prototype.acquire = function(cb) {
                if (this._open) {
                  this._open = false;
                  return cb();
                } else {
                  return this._waiters.push(cb);
                }
              };
              Lock.prototype.release = function() {
                var w;
                if (this._waiters.length) {
                  w = this._waiters.shift();
                  return w();
                } else {
                  return (this._open = true);
                }
              };
              Lock.prototype.open = function() {
                return this._open;
              };
              return Lock;
            })();
            NamedLock = (function(_super) {
              __extends(NamedLock, _super);
              function NamedLock(tab, name) {
                this.tab = tab;
                this.name = name;
                NamedLock.__super__.constructor.call(this);
                this.refs = 0;
              }
              NamedLock.prototype.incref = function() {
                return ++this.refs;
              };
              NamedLock.prototype.decref = function() {
                return --this.refs;
              };
              NamedLock.prototype.release = function() {
                NamedLock.__super__.release.call(this);
                if (this.decref() === 0) {
                  return delete this.tab.locks[this.name];
                }
              };
              return NamedLock;
            })(Lock);
            exports.Table = Table = (function() {
              function Table() {
                this.locks = {};
              }
              Table.prototype.create = function(name) {
                var l;
                l = new NamedLock(this, name);
                return (this.locks[name] = l);
              };
              Table.prototype.acquire = function(name, cb, wait) {
                var l,
                  was_open,
                  ___iced_passed_deferral,
                  __iced_deferrals,
                  __iced_k;
                __iced_k = __iced_k_noop;
                ___iced_passed_deferral = iced.findDeferral(arguments);
                l = this.locks[name] || this.create(name);
                was_open = l._open;
                l.incref();
                (function(_this) {
                  return function(__iced_k) {
                    if (wait || l._open) {
                      (function(__iced_k) {
                        __iced_deferrals = new iced.Deferrals(__iced_k, {
                          parent: ___iced_passed_deferral,
                          filename: '/Users/max/src/iced/iced-lock/index.iced',
                          funcname: 'Table.acquire'
                        });
                        l.acquire(__iced_deferrals.defer({ lineno: 69 }));
                        __iced_deferrals._fulfill();
                      })(__iced_k);
                    } else {
                      return __iced_k((l = null));
                    }
                  };
                })(this)(
                  (function(_this) {
                    return function() {
                      return cb(l, was_open);
                    };
                  })(this)
                );
              };
              Table.prototype.lookup = function(name) {
                return this.locks[name];
              };
              return Table;
            })();
            SingleFlighter = (function() {
              function SingleFlighter(_arg) {
                (this.table = _arg.table), (this.key = _arg.key);
                this.seqid = null;
                this.waiter = null;
                this.open = true;
                this.refs = 0;
              }
              SingleFlighter.prototype._incref = function() {
                return ++this.refs;
              };
              SingleFlighter.prototype._decref = function() {
                if (--this.refs === 0) {
                  return this.table._remove({ key: this.key });
                }
              };
              SingleFlighter.prototype._enter = function(_arg, cb) {
                var seqid, tmp;
                seqid = _arg.seqid;
                if (this.open) {
                  this.open = false;
                  this.seqid = seqid;
                  return cb(null, this);
                } else if (this.waiter != null) {
                  if (seqid > this.waiter.seqid) {
                    tmp = this.waiter;
                    this.waiter = { cb: cb, seqid: seqid };
                    tmp.cb(
                      new Error(
                        'our seqid=' + tmp.seqid + ' was preempted by ' + seqid
                      )
                    );
                  } else {
                    cb(
                      new Error(
                        'our seqid=' +
                          seqid +
                          ' is too stale (since ' +
                          this.waiter.seqid +
                          ' is ahead of us)'
                      )
                    );
                  }
                  return this._decref();
                } else if (seqid > this.seqid) {
                  return (this.waiter = { seqid: seqid, cb: cb });
                } else {
                  cb(
                    new Error(
                      'our seqid=' +
                        seqid +
                        ' is too stale (since ' +
                        this.seqid +
                        ' is already in flight)'
                    )
                  );
                  return this._decref();
                }
              };
              SingleFlighter.prototype.release = function() {
                var cb, _ref;
                if (this.waiter != null) {
                  (_ref = this.waiter),
                    (this.seqid = _ref.seqid),
                    (cb = _ref.cb);
                  this.waiter = null;
                  cb(null, this);
                } else {
                  this.open = true;
                  this.seqid = null;
                }
                return this._decref();
              };
              return SingleFlighter;
            })();
            exports.SingleFlightTable = SingleFlightTable = (function() {
              function SingleFlightTable() {
                this._jobs = {};
              }
              SingleFlightTable.prototype._create = function(_arg) {
                var key;
                key = _arg.key;
                return (this._jobs[key] = new SingleFlighter({
                  table: this,
                  key: key
                }));
              };
              SingleFlightTable.prototype._remove = function(_arg) {
                var key;
                key = _arg.key;
                return delete this._jobs[key];
              };
              SingleFlightTable.prototype.enter = function(_arg, cb) {
                var key, s, seqid;
                (seqid = _arg.seqid), (key = _arg.key);
                s = this._jobs[key] || this._create({ key: key });
                s._incref();
                return s._enter({ seqid: seqid }, cb);
              };
              return SingleFlightTable;
            })();
          }.call(this));
        },
        { 'iced-runtime': 379 }
      ],
      377: [
        function(require, module, exports) {
          (function() {
            module.exports = {
              k: '__iced_k',
              k_noop: '__iced_k_noop',
              param: '__iced_p_',
              ns: 'iced',
              runtime: 'runtime',
              Deferrals: 'Deferrals',
              deferrals: '__iced_deferrals',
              fulfill: '_fulfill',
              b_while: '_break',
              t_while: '_while',
              c_while: '_continue',
              n_while: '_next',
              n_arg: '__iced_next_arg',
              defer_method: 'defer',
              slot: '__slot',
              assign_fn: 'assign_fn',
              autocb: 'autocb',
              retslot: 'ret',
              trace: '__iced_trace',
              passed_deferral: '__iced_passed_deferral',
              findDeferral: 'findDeferral',
              lineno: 'lineno',
              parent: 'parent',
              filename: 'filename',
              funcname: 'funcname',
              catchExceptions: 'catchExceptions',
              runtime_modes: [
                'node',
                'inline',
                'window',
                'none',
                'browserify',
                'interp'
              ],
              trampoline: 'trampoline',
              context: 'context',
              defer_arg: '__iced_defer_'
            };
          }.call(this));
        },
        {}
      ],
      378: [
        function(require, module, exports) {
          (function() {
            var C,
              Pipeliner,
              iced,
              __iced_k,
              __iced_k_noop,
              _iand,
              _ior,
              _timeout,
              __slice = [].slice;
            __iced_k = __iced_k_noop = function() {};
            C = require('./const');
            exports.iced = iced = require('./runtime');
            _timeout = function(cb, t, res, tmp) {
              var arr,
                rv,
                which,
                ___iced_passed_deferral,
                __iced_deferrals,
                __iced_k;
              __iced_k = __iced_k_noop;
              ___iced_passed_deferral = iced.findDeferral(arguments);
              rv = new iced.Rendezvous();
              tmp[0] = rv.id(true).defer({
                assign_fn: (function(_this) {
                  return function() {
                    return function() {
                      return (arr = __slice.call(arguments, 0));
                    };
                  };
                })(this)(),
                lineno: 20,
                context: __iced_deferrals
              });
              setTimeout(
                rv.id(false).defer({ lineno: 21, context: __iced_deferrals }),
                t
              );
              (function(_this) {
                return function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename:
                      '/Users/max/src/iced/iced-runtime/src/library.iced'
                  });
                  rv.wait(
                    __iced_deferrals.defer({
                      assign_fn: (function() {
                        return function() {
                          return (which = arguments[0]);
                        };
                      })(),
                      lineno: 22
                    })
                  );
                  __iced_deferrals._fulfill();
                };
              })(this)(
                (function(_this) {
                  return function() {
                    if (res) {
                      res[0] = which;
                    }
                    return cb.apply(null, arr);
                  };
                })(this)
              );
            };
            exports.timeout = function(cb, t, res) {
              var tmp;
              tmp = [];
              _timeout(cb, t, res, tmp);
              return tmp[0];
            };
            _iand = function(cb, res, tmp) {
              var ok, ___iced_passed_deferral, __iced_deferrals, __iced_k;
              __iced_k = __iced_k_noop;
              ___iced_passed_deferral = iced.findDeferral(arguments);
              (function(_this) {
                return function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename:
                      '/Users/max/src/iced/iced-runtime/src/library.iced'
                  });
                  tmp[0] = __iced_deferrals.defer({
                    assign_fn: (function() {
                      return function() {
                        return (ok = arguments[0]);
                      };
                    })(),
                    lineno: 39
                  });
                  __iced_deferrals._fulfill();
                };
              })(this)(
                (function(_this) {
                  return function() {
                    if (!ok) {
                      res[0] = false;
                    }
                    return cb();
                  };
                })(this)
              );
            };
            exports.iand = function(cb, res) {
              var tmp;
              tmp = [];
              _iand(cb, res, tmp);
              return tmp[0];
            };
            _ior = function(cb, res, tmp) {
              var ok, ___iced_passed_deferral, __iced_deferrals, __iced_k;
              __iced_k = __iced_k_noop;
              ___iced_passed_deferral = iced.findDeferral(arguments);
              (function(_this) {
                return function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename:
                      '/Users/max/src/iced/iced-runtime/src/library.iced'
                  });
                  tmp[0] = __iced_deferrals.defer({
                    assign_fn: (function() {
                      return function() {
                        return (ok = arguments[0]);
                      };
                    })(),
                    lineno: 58
                  });
                  __iced_deferrals._fulfill();
                };
              })(this)(
                (function(_this) {
                  return function() {
                    if (ok) {
                      res[0] = true;
                    }
                    return cb();
                  };
                })(this)
              );
            };
            exports.ior = function(cb, res) {
              var tmp;
              tmp = [];
              _ior(cb, res, tmp);
              return tmp[0];
            };
            exports.Pipeliner = Pipeliner = (function() {
              function Pipeliner(window, delay) {
                this.window = window || 1;
                this.delay = delay || 0;
                this.queue = [];
                this.n_out = 0;
                this.cb = null;
                this[C.deferrals] = this;
                this['defer'] = this._defer;
              }
              Pipeliner.prototype.waitInQueue = function(cb) {
                var ___iced_passed_deferral, __iced_deferrals, __iced_k;
                __iced_k = __iced_k_noop;
                ___iced_passed_deferral = iced.findDeferral(arguments);
                (function(_this) {
                  return function(__iced_k) {
                    var _while;
                    _while = function(__iced_k) {
                      var _break, _continue, _next;
                      _break = __iced_k;
                      _continue = function() {
                        return iced.trampoline(function() {
                          return _while(__iced_k);
                        });
                      };
                      _next = _continue;
                      if (!(_this.n_out >= _this.window)) {
                        return _break();
                      } else {
                        (function(__iced_k) {
                          __iced_deferrals = new iced.Deferrals(__iced_k, {
                            parent: ___iced_passed_deferral,
                            filename:
                              '/Users/max/src/iced/iced-runtime/src/library.iced',
                            funcname: 'Pipeliner.waitInQueue'
                          });
                          _this.cb = __iced_deferrals.defer({ lineno: 100 });
                          __iced_deferrals._fulfill();
                        })(_next);
                      }
                    };
                    _while(__iced_k);
                  };
                })(this)(
                  (function(_this) {
                    return function() {
                      _this.n_out++;
                      (function(__iced_k) {
                        if (_this.delay) {
                          (function(__iced_k) {
                            __iced_deferrals = new iced.Deferrals(__iced_k, {
                              parent: ___iced_passed_deferral,
                              filename:
                                '/Users/max/src/iced/iced-runtime/src/library.iced',
                              funcname: 'Pipeliner.waitInQueue'
                            });
                            setTimeout(
                              __iced_deferrals.defer({ lineno: 108 }),
                              _this.delay
                            );
                            __iced_deferrals._fulfill();
                          })(__iced_k);
                        } else {
                          return __iced_k();
                        }
                      })(function() {
                        return cb();
                      });
                    };
                  })(this)
                );
              };
              Pipeliner.prototype.__defer = function(out, deferArgs) {
                var tmp,
                  voidCb,
                  ___iced_passed_deferral,
                  __iced_deferrals,
                  __iced_k;
                __iced_k = __iced_k_noop;
                ___iced_passed_deferral = iced.findDeferral(arguments);
                (function(_this) {
                  return function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename:
                        '/Users/max/src/iced/iced-runtime/src/library.iced',
                      funcname: 'Pipeliner.__defer'
                    });
                    voidCb = __iced_deferrals.defer({ lineno: 122 });
                    out[0] = function() {
                      var args, _ref;
                      args =
                        1 <= arguments.length ? __slice.call(arguments, 0) : [];
                      if ((_ref = deferArgs.assign_fn) != null) {
                        _ref.apply(null, args);
                      }
                      return voidCb();
                    };
                    __iced_deferrals._fulfill();
                  };
                })(this)(
                  (function(_this) {
                    return function() {
                      _this.n_out--;
                      if (_this.cb) {
                        tmp = _this.cb;
                        _this.cb = null;
                        return tmp();
                      }
                    };
                  })(this)
                );
              };
              Pipeliner.prototype._defer = function(deferArgs) {
                var tmp;
                tmp = [];
                this.__defer(tmp, deferArgs);
                return tmp[0];
              };
              Pipeliner.prototype.flush = function(autocb) {
                var ___iced_passed_deferral, __iced_k, _while;
                __iced_k = autocb;
                ___iced_passed_deferral = iced.findDeferral(arguments);
                _while = (function(_this) {
                  var __iced_deferrals;
                  return function(__iced_k) {
                    var _break, _continue, _next;
                    _break = __iced_k;
                    _continue = function() {
                      return iced.trampoline(function() {
                        return _while(__iced_k);
                      });
                    };
                    _next = _continue;
                    if (!_this.n_out) {
                      return _break();
                    } else {
                      (function(__iced_k) {
                        __iced_deferrals = new iced.Deferrals(__iced_k, {
                          parent: ___iced_passed_deferral,
                          filename:
                            '/Users/max/src/iced/iced-runtime/src/library.iced',
                          funcname: 'Pipeliner.flush'
                        });
                        _this.cb = __iced_deferrals.defer({ lineno: 151 });
                        __iced_deferrals._fulfill();
                      })(_next);
                    }
                  };
                })(this);
                _while(__iced_k);
              };
              return Pipeliner;
            })();
          }.call(this));
        },
        { './const': 377, './runtime': 380 }
      ],
      379: [
        function(require, module, exports) {
          (function() {
            var k, mod, mods, v, _i, _len;
            exports['const'] = require('./const');
            mods = [require('./runtime'), require('./library')];
            for (_i = 0, _len = mods.length; _i < _len; _i++) {
              mod = mods[_i];
              for (k in mod) {
                v = mod[k];
                exports[k] = v;
              }
            }
          }.call(this));
        },
        { './const': 377, './library': 378, './runtime': 380 }
      ],
      380: [
        function(require, module, exports) {
          (function(process) {
            (function() {
              var C,
                Deferrals,
                Rendezvous,
                exceptionHandler,
                findDeferral,
                make_defer_return,
                stackWalk,
                tick_counter,
                trampoline,
                warn,
                __active_trace,
                __c,
                _trace_to_string,
                __slice = [].slice;
              C = require('./const');
              make_defer_return = function(
                obj,
                defer_args,
                id,
                trace_template,
                multi
              ) {
                var k, ret, trace, v;
                trace = {};
                for (k in trace_template) {
                  v = trace_template[k];
                  trace[k] = v;
                }
                trace[C.lineno] =
                  defer_args != null ? defer_args[C.lineno] : void 0;
                ret = function() {
                  var inner_args, o, _ref;
                  inner_args =
                    1 <= arguments.length ? __slice.call(arguments, 0) : [];
                  if (defer_args != null) {
                    if ((_ref = defer_args.assign_fn) != null) {
                      _ref.apply(null, inner_args);
                    }
                  }
                  if (obj) {
                    o = obj;
                    if (!multi) {
                      obj = null;
                    }
                    return o._fulfill(id, trace);
                  } else {
                    return warn(
                      'overused deferral at ' + _trace_to_string(trace)
                    );
                  }
                };
                ret[C.trace] = trace;
                return ret;
              };
              __c = 0;
              tick_counter = function(mod) {
                __c++;
                if (__c % mod === 0) {
                  __c = 0;
                  return true;
                } else {
                  return false;
                }
              };
              __active_trace = null;
              _trace_to_string = function(tr) {
                var fn;
                fn = tr[C.funcname] || '<anonymous>';
                return (
                  '' +
                  fn +
                  ' (' +
                  tr[C.filename] +
                  ':' +
                  (tr[C.lineno] + 1) +
                  ')'
                );
              };
              warn = function(m) {
                return typeof console !== 'undefined' && console !== null
                  ? console.error('ICED warning: ' + m)
                  : void 0;
              };
              exports.trampoline = trampoline = function(fn) {
                if (!tick_counter(500)) {
                  return fn();
                } else if (
                  (typeof process !== 'undefined' && process !== null
                    ? process.nextTick
                    : void 0) != null
                ) {
                  return process.nextTick(fn);
                } else {
                  return setTimeout(fn);
                }
              };
              exports.Deferrals = Deferrals = (function() {
                function Deferrals(k, trace) {
                  this.trace = trace;
                  this.continuation = k;
                  this.count = 1;
                  this.ret = null;
                }
                Deferrals.prototype._call = function(trace) {
                  var c;
                  if (this.continuation) {
                    __active_trace = trace;
                    c = this.continuation;
                    this.continuation = null;
                    return c(this.ret);
                  } else {
                    return warn(
                      'Entered dead await at ' + _trace_to_string(trace)
                    );
                  }
                };
                Deferrals.prototype._fulfill = function(id, trace) {
                  if (--this.count > 0) {
                  } else {
                    return trampoline(
                      (function(_this) {
                        return function() {
                          return _this._call(trace);
                        };
                      })(this)
                    );
                  }
                };
                Deferrals.prototype.defer = function(args) {
                  var self;
                  this.count++;
                  self = this;
                  return make_defer_return(self, args, null, this.trace);
                };
                return Deferrals;
              })();
              exports.findDeferral = findDeferral = function(args) {
                var a, _i, _len;
                for (_i = 0, _len = args.length; _i < _len; _i++) {
                  a = args[_i];
                  if (a != null ? a[C.trace] : void 0) {
                    return a;
                  }
                }
                return null;
              };
              exports.Rendezvous = Rendezvous = (function() {
                var RvId;
                function Rendezvous() {
                  this.completed = [];
                  this.waiters = [];
                  this.defer_id = 0;
                }
                RvId = (function() {
                  function RvId(rv, id, multi) {
                    this.rv = rv;
                    this.id = id;
                    this.multi = multi;
                  }
                  RvId.prototype.defer = function(defer_args) {
                    return this.rv._defer_with_id(
                      this.id,
                      defer_args,
                      this.multi
                    );
                  };
                  return RvId;
                })();
                Rendezvous.prototype.wait = function(cb) {
                  var x;
                  if (this.completed.length) {
                    x = this.completed.shift();
                    return cb(x);
                  } else {
                    return this.waiters.push(cb);
                  }
                };
                Rendezvous.prototype.defer = function(defer_args) {
                  var id;
                  id = this.defer_id++;
                  return this._defer_with_id(id, defer_args);
                };
                Rendezvous.prototype.id = function(i, multi) {
                  multi = !!multi;
                  return new RvId(this, i, multi);
                };
                Rendezvous.prototype._fulfill = function(id, trace) {
                  var cb;
                  if (this.waiters.length) {
                    cb = this.waiters.shift();
                    return cb(id);
                  } else {
                    return this.completed.push(id);
                  }
                };
                Rendezvous.prototype._defer_with_id = function(
                  id,
                  defer_args,
                  multi
                ) {
                  this.count++;
                  return make_defer_return(this, defer_args, id, {}, multi);
                };
                return Rendezvous;
              })();
              exports.stackWalk = stackWalk = function(cb) {
                var line, ret, tr, _ref;
                ret = [];
                tr = cb ? cb[C.trace] : __active_trace;
                while (tr) {
                  line = '   at ' + _trace_to_string(tr);
                  ret.push(line);
                  tr =
                    tr != null
                      ? (_ref = tr[C.parent]) != null
                        ? _ref[C.trace]
                        : void 0
                      : void 0;
                }
                return ret;
              };
              exports.exceptionHandler = exceptionHandler = function(
                err,
                logger
              ) {
                var stack;
                if (!logger) {
                  logger = console.error;
                }
                logger(err.stack);
                stack = stackWalk();
                if (stack.length) {
                  logger("Iced 'stack' trace (w/ real line numbers):");
                  return logger(stack.join('\n'));
                }
              };
              exports.catchExceptions = function(logger) {
                return typeof process !== 'undefined' && process !== null
                  ? process.on('uncaughtException', function(err) {
                      exceptionHandler(err, logger);
                      return process.exit(1);
                    })
                  : void 0;
              };
            }.call(this));
          }.call(this, require('_process')));
        },
        { './const': 377, _process: 223 }
      ],
      381: [
        function(require, module, exports) {
          arguments[4][207][0].apply(exports, arguments);
        },
        { dup: 207 }
      ],
      382: [
        function(require, module, exports) {
          (function(Buffer) {
            'use strict';
            Object.defineProperty(exports, '__esModule', { value: true });
            exports.derToJose = derToJose;
            exports.joseToDer = joseToDer;
            var asn1 = require('asn1.js');
            function base64UrlEscape(str) {
              return str
                .replace(/\+/g, '-')
                .replace(/\//g, '_')
                .replace(/=/g, '');
            }
            var ECDSASigValue = asn1.define('ECDSASigValue', function() {
              this.seq().obj(this.key('r').int(), this.key('s').int());
            });
            var seq = 16,
              int = 2;
            function getParamSize(keySize) {
              var result = ((keySize / 8) | 0) + (keySize % 8 === 0 ? 0 : 1);
              return result;
            }
            var paramBytesForAlg = {
              ES256: getParamSize(256),
              ES384: getParamSize(384),
              ES512: getParamSize(512)
            };
            function getParamBytesForAlg(alg) {
              var paramBytes = paramBytesForAlg[alg];
              if (paramBytes) {
                return paramBytes;
              }
              throw new Error('Unknown algorithm "' + alg + '"');
            }
            function bignumToBuf(bn, numBytes) {
              var buf = new Buffer(bn.toString('hex', numBytes), 'hex');
              return buf;
            }
            function signatureAsBuffer(signature) {
              if (Buffer.isBuffer(signature)) {
                return new Buffer(signature);
              } else if ('string' === typeof signature) {
                return new Buffer(signature, 'base64');
              }
              throw new TypeError(
                'ECDSA signature must be a Base64 string or a Buffer'
              );
            }
            function reduceBuffer(buf) {
              var padding = 0;
              for (var n = buf.length; padding < n && buf[padding] === 0; ) {
                ++padding;
              }
              var needsSign = buf[padding] >= 128;
              if (needsSign) {
                --padding;
                if (padding < 0) {
                  var old = buf;
                  buf = new Buffer(1 + buf.length);
                  buf[0] = 0;
                  old.copy(buf, 1);
                  return buf;
                }
              }
              if (padding === 0) {
                return buf;
              }
              buf = buf.slice(padding);
              return buf;
            }
            function derToJose(signature, alg) {
              signature = signatureAsBuffer(signature);
              var paramBytes = getParamBytesForAlg(alg);
              signature = ECDSASigValue.decode(signature, 'der');
              var r = bignumToBuf(signature.r, paramBytes);
              var s = bignumToBuf(signature.s, paramBytes);
              signature = Buffer.concat([r, s], r.length + s.length);
              signature = signature.toString('base64');
              signature = base64UrlEscape(signature);
              return signature;
            }
            function joseToDer(signature, alg) {
              signature = signatureAsBuffer(signature);
              var paramBytes = getParamBytesForAlg(alg);
              var signatureBytes = signature.length;
              if (signatureBytes !== paramBytes * 2) {
                throw new TypeError(
                  '"' +
                    alg +
                    '" signatures must be "' +
                    paramBytes * 2 +
                    '" bytes, saw "' +
                    signatureBytes +
                    '"'
                );
              }
              var r = reduceBuffer(signature.slice(0, paramBytes));
              var s = reduceBuffer(signature.slice(paramBytes));
              var rsBytes = 1 + 1 + r.length + 1 + 1 + s.length;
              var oneByteLength = rsBytes < 128;
              signature = new Buffer((oneByteLength ? 2 : 3) + rsBytes);
              var offset = 0;
              signature[offset++] = seq | 32 | (0 << 6);
              if (oneByteLength) {
                signature[offset++] = rsBytes;
              } else {
                signature[offset++] = 128 | 1;
                signature[offset++] = rsBytes & 255;
              }
              signature[offset++] = int | (0 << 6);
              signature[offset++] = r.length;
              r.copy(signature, offset);
              offset += r.length;
              signature[offset++] = int | (0 << 6);
              signature[offset++] = s.length;
              s.copy(signature, offset);
              return signature;
            }
          }.call(this, require('buffer').Buffer));
        },
        { 'asn1.js': 52, buffer: 183 }
      ],
      383: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.cryptoClients = exports.SECP256K1Client = undefined;
          var _secp256k = require('./secp256k1');
          var cryptoClients = { ES256K: _secp256k.SECP256K1Client };
          exports.SECP256K1Client = _secp256k.SECP256K1Client;
          exports.cryptoClients = cryptoClients;
        },
        { './secp256k1': 384 }
      ],
      384: [
        function(require, module, exports) {
          (function(Buffer) {
            'use strict';
            Object.defineProperty(exports, '__esModule', { value: true });
            exports.SECP256K1Client = undefined;
            var _createClass = (function() {
              function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ('value' in descriptor) descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps)
                  defineProperties(Constructor.prototype, protoProps);
                if (staticProps) defineProperties(Constructor, staticProps);
                return Constructor;
              };
            })();
            var _elliptic = require('elliptic');
            var _crypto = require('crypto');
            var _keyEncoder = require('key-encoder');
            var _keyEncoder2 = _interopRequireDefault(_keyEncoder);
            var _validator = require('validator');
            var _ecdsaSigFormatter = require('./ecdsaSigFormatter');
            var _errors = require('../errors');
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError('Cannot call a class as a function');
              }
            }
            var SECP256K1Client = (exports.SECP256K1Client = (function() {
              function SECP256K1Client() {
                _classCallCheck(this, SECP256K1Client);
              }
              _createClass(SECP256K1Client, null, [
                {
                  key: 'createHash',
                  value: function createHash(signingInput) {
                    return (0, _crypto.createHash)('sha256')
                      .update(signingInput)
                      .digest();
                  }
                },
                {
                  key: 'loadPrivateKey',
                  value: function loadPrivateKey(rawPrivateKey) {
                    if (rawPrivateKey.length === 66) {
                      rawPrivateKey = rawPrivateKey.slice(0, 64);
                    }
                    return SECP256K1Client.ec.keyFromPrivate(rawPrivateKey);
                  }
                },
                {
                  key: 'loadPublicKey',
                  value: function loadPublicKey(rawPublicKey) {
                    return SECP256K1Client.ec.keyFromPublic(
                      rawPublicKey,
                      'hex'
                    );
                  }
                },
                {
                  key: 'encodePublicKey',
                  value: function encodePublicKey(
                    publicKey,
                    originalFormat,
                    destinationFormat
                  ) {
                    return SECP256K1Client.keyEncoder.encodePublic(
                      publicKey,
                      originalFormat,
                      destinationFormat
                    );
                  }
                },
                {
                  key: 'derivePublicKey',
                  value: function derivePublicKey(privateKey, compressed) {
                    if (typeof privateKey !== 'string') {
                      throw Error('private key must be a string');
                    }
                    if (!(0, _validator.isHexadecimal)(privateKey)) {
                      throw Error('private key must be a hex string');
                    }
                    if (privateKey.length == 66) {
                      privateKey = privateKey.slice(0, 64);
                    } else if (privateKey.length <= 64) {
                    } else {
                      throw Error('private key must be 66 characters or less');
                    }
                    if (compressed === undefined) {
                      compressed = true;
                    }
                    var keypair = SECP256K1Client.ec.keyFromPrivate(privateKey);
                    return keypair.getPublic(compressed, 'hex');
                  }
                },
                {
                  key: 'signHash',
                  value: function signHash(signingInputHash, rawPrivateKey) {
                    var format =
                      arguments.length > 2 && arguments[2] !== undefined
                        ? arguments[2]
                        : 'jose';
                    if (!(signingInputHash && rawPrivateKey)) {
                      throw new _errors.MissingParametersError(
                        'a signing input hash and private key are all required'
                      );
                    }
                    var privateKeyObject = SECP256K1Client.loadPrivateKey(
                      rawPrivateKey
                    );
                    var signatureObject = privateKeyObject.sign(
                      signingInputHash
                    );
                    var derSignature = new Buffer(signatureObject.toDER());
                    if (format === 'der') {
                      return derSignature.toString('hex');
                    } else if (format === 'jose') {
                      return (0, _ecdsaSigFormatter.derToJose)(
                        derSignature,
                        'ES256'
                      );
                    } else {
                      throw Error('Invalid signature format');
                    }
                  }
                },
                {
                  key: 'loadSignature',
                  value: function loadSignature(joseSignature) {
                    return (0, _ecdsaSigFormatter.joseToDer)(
                      joseSignature,
                      'ES256'
                    );
                  }
                },
                {
                  key: 'verifyHash',
                  value: function verifyHash(
                    signingInputHash,
                    derSignatureBuffer,
                    rawPublicKey
                  ) {
                    if (
                      !(signingInputHash && derSignatureBuffer && rawPublicKey)
                    ) {
                      throw new _errors.MissingParametersError(
                        'a signing input hash, der signature, and public key are all required'
                      );
                    }
                    var publicKeyObject = SECP256K1Client.loadPublicKey(
                      rawPublicKey
                    );
                    return publicKeyObject.verify(
                      signingInputHash,
                      derSignatureBuffer
                    );
                  }
                }
              ]);
              return SECP256K1Client;
            })());
            SECP256K1Client.algorithmName = 'ES256K';
            SECP256K1Client.ec = new _elliptic.ec('secp256k1');
            SECP256K1Client.keyEncoder = new _keyEncoder2.default({
              curveParameters: [1, 3, 132, 0, 10],
              privatePEMOptions: { label: 'EC PRIVATE KEY' },
              publicPEMOptions: { label: 'PUBLIC KEY' },
              curve: SECP256K1Client.ec
            });
          }.call(this, require('buffer').Buffer));
        },
        {
          '../errors': 386,
          './ecdsaSigFormatter': 382,
          buffer: 183,
          crypto: 192,
          elliptic: 309,
          'key-encoder': 390,
          validator: 502
        }
      ],
      385: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          var _typeof =
            typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
              ? function(obj) {
                  return typeof obj;
                }
              : function(obj) {
                  return obj &&
                    typeof Symbol === 'function' &&
                    obj.constructor === Symbol &&
                    obj !== Symbol.prototype
                    ? 'symbol'
                    : typeof obj;
                };
          exports.decodeToken = decodeToken;
          var _base64url = require('base64url');
          var _base64url2 = _interopRequireDefault(_base64url);
          var _errors = require('./errors');
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function decodeToken(token) {
            if (typeof token === 'string') {
              var tokenParts = token.split('.');
              var header = JSON.parse(
                _base64url2.default.decode(tokenParts[0])
              );
              var payload = JSON.parse(
                _base64url2.default.decode(tokenParts[1])
              );
              var signature = tokenParts[2];
              return { header: header, payload: payload, signature: signature };
            } else if (
              (typeof token === 'undefined' ? 'undefined' : _typeof(token)) ===
              'object'
            ) {
              var _payload = token.payload;
              if (token.payload[0] !== '{') {
                _payload = _base64url2.default.decode(_payload);
              }
              var allHeaders = [];
              token.header.map(function(headerValue) {
                var header = JSON.parse(
                  _base64url2.default.decode(headerValue)
                );
                allHeaders.push(header);
              });
              return {
                header: allHeaders,
                payload: JSON.parse(_payload),
                signature: token.signature
              };
            }
          }
        },
        { './errors': 386, base64url: 70 }
      ],
      386: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError(
                "this hasn't been initialised - super() hasn't been called"
              );
            }
            return call &&
              (typeof call === 'object' || typeof call === 'function')
              ? call
              : self;
          }
          function _inherits(subClass, superClass) {
            if (typeof superClass !== 'function' && superClass !== null) {
              throw new TypeError(
                'Super expression must either be null or a function, not ' +
                  typeof superClass
              );
            }
            subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              }
            );
            if (superClass)
              Object.setPrototypeOf
                ? Object.setPrototypeOf(subClass, superClass)
                : (subClass.__proto__ = superClass);
          }
          var MissingParametersError = (exports.MissingParametersError = (function(
            _Error
          ) {
            _inherits(MissingParametersError, _Error);
            function MissingParametersError(message) {
              _classCallCheck(this, MissingParametersError);
              var _this = _possibleConstructorReturn(
                this,
                (
                  MissingParametersError.__proto__ ||
                  Object.getPrototypeOf(MissingParametersError)
                ).call(this)
              );
              _this.name = 'MissingParametersError';
              _this.message = message || '';
              return _this;
            }
            return MissingParametersError;
          })(Error));
          var InvalidTokenError = (exports.InvalidTokenError = (function(
            _Error2
          ) {
            _inherits(InvalidTokenError, _Error2);
            function InvalidTokenError(message) {
              _classCallCheck(this, InvalidTokenError);
              var _this2 = _possibleConstructorReturn(
                this,
                (
                  InvalidTokenError.__proto__ ||
                  Object.getPrototypeOf(InvalidTokenError)
                ).call(this)
              );
              _this2.name = 'InvalidTokenError';
              _this2.message = message || '';
              return _this2;
            }
            return InvalidTokenError;
          })(Error));
        },
        {}
      ],
      387: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          var _signer = require('./signer');
          Object.defineProperty(exports, 'TokenSigner', {
            enumerable: true,
            get: function get() {
              return _signer.TokenSigner;
            }
          });
          Object.defineProperty(exports, 'createUnsecuredToken', {
            enumerable: true,
            get: function get() {
              return _signer.createUnsecuredToken;
            }
          });
          var _verifier = require('./verifier');
          Object.defineProperty(exports, 'TokenVerifier', {
            enumerable: true,
            get: function get() {
              return _verifier.TokenVerifier;
            }
          });
          var _decode = require('./decode');
          Object.defineProperty(exports, 'decodeToken', {
            enumerable: true,
            get: function get() {
              return _decode.decodeToken;
            }
          });
          var _errors = require('./errors');
          Object.defineProperty(exports, 'MissingParametersError', {
            enumerable: true,
            get: function get() {
              return _errors.MissingParametersError;
            }
          });
          Object.defineProperty(exports, 'InvalidTokenError', {
            enumerable: true,
            get: function get() {
              return _errors.InvalidTokenError;
            }
          });
          var _cryptoClients = require('./cryptoClients');
          Object.defineProperty(exports, 'SECP256K1Client', {
            enumerable: true,
            get: function get() {
              return _cryptoClients.SECP256K1Client;
            }
          });
          Object.defineProperty(exports, 'cryptoClients', {
            enumerable: true,
            get: function get() {
              return _cryptoClients.cryptoClients;
            }
          });
        },
        {
          './cryptoClients': 383,
          './decode': 385,
          './errors': 386,
          './signer': 388,
          './verifier': 389
        }
      ],
      388: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.TokenSigner = undefined;
          var _createClass = (function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          })();
          exports.createUnsecuredToken = createUnsecuredToken;
          var _base64url = require('base64url');
          var _base64url2 = _interopRequireDefault(_base64url);
          var _cryptoClients = require('./cryptoClients');
          var _decode = require('./decode');
          var _decode2 = _interopRequireDefault(_decode);
          var _errors = require('./errors');
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          function createSigningInput(payload, header) {
            var tokenParts = [];
            var encodedHeader = _base64url2.default.encode(
              JSON.stringify(header)
            );
            tokenParts.push(encodedHeader);
            var encodedPayload = _base64url2.default.encode(
              JSON.stringify(payload)
            );
            tokenParts.push(encodedPayload);
            var signingInput = tokenParts.join('.');
            return signingInput;
          }
          function createUnsecuredToken(payload) {
            var header = { typ: 'JWT', alg: 'none' };
            return createSigningInput(payload, header) + '.';
          }
          var TokenSigner = (exports.TokenSigner = (function() {
            function TokenSigner(signingAlgorithm, rawPrivateKey) {
              _classCallCheck(this, TokenSigner);
              if (!(signingAlgorithm && rawPrivateKey)) {
                throw new _errors.MissingParametersError(
                  'a signing algorithm and private key are required'
                );
              }
              if (typeof signingAlgorithm !== 'string') {
                throw 'signing algorithm parameter must be a string';
              }
              signingAlgorithm = signingAlgorithm.toUpperCase();
              if (
                !_cryptoClients.cryptoClients.hasOwnProperty(signingAlgorithm)
              ) {
                throw 'invalid signing algorithm';
              }
              this.tokenType = 'JWT';
              this.cryptoClient =
                _cryptoClients.cryptoClients[signingAlgorithm];
              this.rawPrivateKey = rawPrivateKey;
            }
            _createClass(TokenSigner, [
              {
                key: 'header',
                value: function header() {
                  return {
                    typ: this.tokenType,
                    alg: this.cryptoClient.algorithmName
                  };
                }
              },
              {
                key: 'sign',
                value: function sign(payload) {
                  var expanded =
                    arguments.length > 1 && arguments[1] !== undefined
                      ? arguments[1]
                      : false;
                  var signingInput = createSigningInput(payload, this.header());
                  var signingInputHash = this.cryptoClient.createHash(
                    signingInput
                  );
                  var signature = this.cryptoClient.signHash(
                    signingInputHash,
                    this.rawPrivateKey
                  );
                  if (expanded) {
                    return {
                      header: [
                        _base64url2.default.encode(
                          JSON.stringify(this.header())
                        )
                      ],
                      payload: JSON.stringify(payload),
                      signature: [signature]
                    };
                  } else {
                    return [signingInput, signature].join('.');
                  }
                }
              }
            ]);
            return TokenSigner;
          })());
        },
        {
          './cryptoClients': 383,
          './decode': 385,
          './errors': 386,
          base64url: 70
        }
      ],
      389: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.TokenVerifier = undefined;
          var _typeof =
            typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
              ? function(obj) {
                  return typeof obj;
                }
              : function(obj) {
                  return obj &&
                    typeof Symbol === 'function' &&
                    obj.constructor === Symbol &&
                    obj !== Symbol.prototype
                    ? 'symbol'
                    : typeof obj;
                };
          var _createClass = (function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          })();
          var _base64url = require('base64url');
          var _base64url2 = _interopRequireDefault(_base64url);
          var _cryptoClients = require('./cryptoClients');
          var _decode = require('./decode');
          var _decode2 = _interopRequireDefault(_decode);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          var TokenVerifier = (exports.TokenVerifier = (function() {
            function TokenVerifier(signingAlgorithm, rawPublicKey) {
              _classCallCheck(this, TokenVerifier);
              if (!(signingAlgorithm && rawPublicKey)) {
                throw new MissingParametersError(
                  'a signing algorithm and public key are required'
                );
              }
              if (typeof signingAlgorithm !== 'string') {
                throw 'signing algorithm parameter must be a string';
              }
              signingAlgorithm = signingAlgorithm.toUpperCase();
              if (
                !_cryptoClients.cryptoClients.hasOwnProperty(signingAlgorithm)
              ) {
                throw 'invalid signing algorithm';
              }
              this.tokenType = 'JWT';
              this.cryptoClient =
                _cryptoClients.cryptoClients[signingAlgorithm];
              this.rawPublicKey = rawPublicKey;
            }
            _createClass(TokenVerifier, [
              {
                key: 'verify',
                value: function verify(token) {
                  if (typeof token === 'string') {
                    return this.verifyCompact(token);
                  } else if (
                    (typeof token === 'undefined'
                      ? 'undefined'
                      : _typeof(token)) === 'object'
                  ) {
                    return this.verifyExpanded(token);
                  } else {
                    return false;
                  }
                }
              },
              {
                key: 'verifyCompact',
                value: function verifyCompact(token) {
                  var tokenParts = token.split('.');
                  var signingInput = tokenParts[0] + '.' + tokenParts[1];
                  var signingInputHash = this.cryptoClient.createHash(
                    signingInput
                  );
                  var derSignatureBuffer = this.cryptoClient.loadSignature(
                    tokenParts[2]
                  );
                  return this.cryptoClient.verifyHash(
                    signingInputHash,
                    derSignatureBuffer,
                    this.rawPublicKey
                  );
                }
              },
              {
                key: 'verifyExpanded',
                value: function verifyExpanded(token) {
                  var _this = this;
                  var signingInput = [
                    token['header'].join('.'),
                    _base64url2.default.encode(token['payload'])
                  ].join('.');
                  var signingInputHash = this.cryptoClient.createHash(
                    signingInput
                  );
                  var verified = true;
                  token['signature'].map(function(signature) {
                    var derSignatureBuffer = _this.cryptoClient.loadSignature(
                      signature
                    );
                    var signatureVerified = _this.cryptoClient.verifyHash(
                      signingInputHash,
                      derSignatureBuffer,
                      _this.rawPublicKey
                    );
                    if (!signatureVerified) {
                      verified = false;
                    }
                  });
                  return verified;
                }
              }
            ]);
            return TokenVerifier;
          })());
        },
        { './cryptoClients': 383, './decode': 385, base64url: 70 }
      ],
      390: [
        function(require, module, exports) {
          'use strict';
          module.exports = require('./lib/key-encoder');
        },
        { './lib/key-encoder': 391 }
      ],
      391: [
        function(require, module, exports) {
          (function(Buffer) {
            'use strict';
            var asn1 = require('asn1.js'),
              BN = require('bn.js'),
              EC = require('elliptic').ec;
            var ECPrivateKeyASN = asn1.define('ECPrivateKey', function() {
              this.seq().obj(
                this.key('version').int(),
                this.key('privateKey').octstr(),
                this.key('parameters')
                  .explicit(0)
                  .objid()
                  .optional(),
                this.key('publicKey')
                  .explicit(1)
                  .bitstr()
                  .optional()
              );
            });
            var SubjectPublicKeyInfoASN = asn1.define(
              'SubjectPublicKeyInfo',
              function() {
                this.seq().obj(
                  this.key('algorithm')
                    .seq()
                    .obj(this.key('id').objid(), this.key('curve').objid()),
                  this.key('pub').bitstr()
                );
              }
            );
            var curves = {
              secp256k1: {
                curveParameters: [1, 3, 132, 0, 10],
                privatePEMOptions: { label: 'EC PRIVATE KEY' },
                publicPEMOptions: { label: 'PUBLIC KEY' },
                curve: new EC('secp256k1')
              }
            };
            function assert(val, msg) {
              if (!val) {
                throw new Error(msg || 'Assertion failed');
              }
            }
            function KeyEncoder(options) {
              if (typeof options === 'string') {
                assert(
                  curves.hasOwnProperty(options),
                  'Unknown curve ' + options
                );
                options = curves[options];
              }
              this.options = options;
              this.algorithmID = [1, 2, 840, 10045, 2, 1];
            }
            KeyEncoder.ECPrivateKeyASN = ECPrivateKeyASN;
            KeyEncoder.SubjectPublicKeyInfoASN = SubjectPublicKeyInfoASN;
            KeyEncoder.prototype.privateKeyObject = function(
              rawPrivateKey,
              rawPublicKey
            ) {
              var privateKeyObject = {
                version: new BN(1),
                privateKey: new Buffer(rawPrivateKey, 'hex'),
                parameters: this.options.curveParameters
              };
              if (rawPublicKey) {
                privateKeyObject.publicKey = {
                  unused: 0,
                  data: new Buffer(rawPublicKey, 'hex')
                };
              }
              return privateKeyObject;
            };
            KeyEncoder.prototype.publicKeyObject = function(rawPublicKey) {
              return {
                algorithm: {
                  id: this.algorithmID,
                  curve: this.options.curveParameters
                },
                pub: { unused: 0, data: new Buffer(rawPublicKey, 'hex') }
              };
            };
            KeyEncoder.prototype.encodePrivate = function(
              privateKey,
              originalFormat,
              destinationFormat
            ) {
              var privateKeyObject;
              if (originalFormat === 'raw') {
                if (!typeof privateKey === 'string') {
                  throw 'private key must be a string';
                }
                var privateKeyObject = this.options.curve.keyFromPrivate(
                    privateKey,
                    'hex'
                  ),
                  rawPublicKey = privateKeyObject.getPublic('hex');
                privateKeyObject = this.privateKeyObject(
                  privateKey,
                  rawPublicKey
                );
              } else if (originalFormat === 'der') {
                if (typeof privateKey === 'buffer') {
                } else if (typeof privateKey === 'string') {
                  privateKey = new Buffer(privateKey, 'hex');
                } else {
                  throw 'private key must be a buffer or a string';
                }
                privateKeyObject = ECPrivateKeyASN.decode(privateKey, 'der');
              } else if (originalFormat === 'pem') {
                if (!typeof privateKey === 'string') {
                  throw 'private key must be a string';
                }
                privateKeyObject = ECPrivateKeyASN.decode(
                  privateKey,
                  'pem',
                  this.options.privatePEMOptions
                );
              } else {
                throw 'invalid private key format';
              }
              if (destinationFormat === 'raw') {
                return privateKeyObject.privateKey.toString('hex');
              } else if (destinationFormat === 'der') {
                return ECPrivateKeyASN.encode(privateKeyObject, 'der').toString(
                  'hex'
                );
              } else if (destinationFormat === 'pem') {
                return ECPrivateKeyASN.encode(
                  privateKeyObject,
                  'pem',
                  this.options.privatePEMOptions
                );
              } else {
                throw 'invalid destination format for private key';
              }
            };
            KeyEncoder.prototype.encodePublic = function(
              publicKey,
              originalFormat,
              destinationFormat
            ) {
              var publicKeyObject;
              if (originalFormat === 'raw') {
                if (!typeof publicKey === 'string') {
                  throw 'public key must be a string';
                }
                publicKeyObject = this.publicKeyObject(publicKey);
              } else if (originalFormat === 'der') {
                if (typeof publicKey === 'buffer') {
                } else if (typeof publicKey === 'string') {
                  publicKey = new Buffer(publicKey, 'hex');
                } else {
                  throw 'public key must be a buffer or a string';
                }
                publicKeyObject = SubjectPublicKeyInfoASN.decode(
                  publicKey,
                  'der'
                );
              } else if (originalFormat === 'pem') {
                if (!typeof publicKey === 'string') {
                  throw 'public key must be a string';
                }
                publicKeyObject = SubjectPublicKeyInfoASN.decode(
                  publicKey,
                  'pem',
                  this.options.publicPEMOptions
                );
              } else {
                throw 'invalid public key format';
              }
              if (destinationFormat === 'raw') {
                return publicKeyObject.pub.data.toString('hex');
              } else if (destinationFormat === 'der') {
                return SubjectPublicKeyInfoASN.encode(
                  publicKeyObject,
                  'der'
                ).toString('hex');
              } else if (destinationFormat === 'pem') {
                return SubjectPublicKeyInfoASN.encode(
                  publicKeyObject,
                  'pem',
                  this.options.publicPEMOptions
                );
              } else {
                throw 'invalid destination format for public key';
              }
            };
            module.exports = KeyEncoder;
          }.call(this, require('buffer').Buffer));
        },
        { 'asn1.js': 392, 'bn.js': 407, buffer: 183, elliptic: 408 }
      ],
      392: [
        function(require, module, exports) {
          arguments[4][52][0].apply(exports, arguments);
        },
        {
          './asn1/api': 393,
          './asn1/base': 395,
          './asn1/constants': 399,
          './asn1/decoders': 401,
          './asn1/encoders': 404,
          'bn.js': 406,
          dup: 52
        }
      ],
      393: [
        function(require, module, exports) {
          var asn1 = require('../asn1');
          var inherits = require('inherits');
          var api = exports;
          api.define = function define(name, body) {
            return new Entity(name, body);
          };
          function Entity(name, body) {
            this.name = name;
            this.body = body;
            this.decoders = {};
            this.encoders = {};
          }
          Entity.prototype._createNamed = function createNamed(base) {
            var named;
            try {
              named = require('vm').runInThisContext(
                '(function ' +
                  this.name +
                  '(entity) {\n' +
                  '  this._initNamed(entity);\n' +
                  '})'
              );
            } catch (e) {
              named = function(entity) {
                this._initNamed(entity);
              };
            }
            inherits(named, base);
            named.prototype._initNamed = function initnamed(entity) {
              base.call(this, entity);
            };
            return new named(this);
          };
          Entity.prototype._getDecoder = function _getDecoder(enc) {
            if (!this.decoders.hasOwnProperty(enc))
              this.decoders[enc] = this._createNamed(asn1.decoders[enc]);
            return this.decoders[enc];
          };
          Entity.prototype.decode = function decode(data, enc, options) {
            return this._getDecoder(enc).decode(data, options);
          };
          Entity.prototype._getEncoder = function _getEncoder(enc) {
            if (!this.encoders.hasOwnProperty(enc))
              this.encoders[enc] = this._createNamed(asn1.encoders[enc]);
            return this.encoders[enc];
          };
          Entity.prototype.encode = function encode(data, enc, reporter) {
            return this._getEncoder(enc).encode(data, reporter);
          };
        },
        { '../asn1': 392, inherits: 381, vm: 266 }
      ],
      394: [
        function(require, module, exports) {
          arguments[4][54][0].apply(exports, arguments);
        },
        { '../base': 395, buffer: 183, dup: 54, inherits: 381 }
      ],
      395: [
        function(require, module, exports) {
          arguments[4][55][0].apply(exports, arguments);
        },
        { './buffer': 394, './node': 396, './reporter': 397, dup: 55 }
      ],
      396: [
        function(require, module, exports) {
          var Reporter = require('../base').Reporter;
          var EncoderBuffer = require('../base').EncoderBuffer;
          var assert = require('minimalistic-assert');
          var tags = [
            'seq',
            'seqof',
            'set',
            'setof',
            'octstr',
            'bitstr',
            'objid',
            'bool',
            'gentime',
            'utctime',
            'null_',
            'enum',
            'int',
            'ia5str',
            'utf8str'
          ];
          var methods = [
            'key',
            'obj',
            'use',
            'optional',
            'explicit',
            'implicit',
            'def',
            'choice',
            'any'
          ].concat(tags);
          var overrided = [
            '_peekTag',
            '_decodeTag',
            '_use',
            '_decodeStr',
            '_decodeObjid',
            '_decodeTime',
            '_decodeNull',
            '_decodeInt',
            '_decodeBool',
            '_decodeList',
            '_encodeComposite',
            '_encodeStr',
            '_encodeObjid',
            '_encodeTime',
            '_encodeNull',
            '_encodeInt',
            '_encodeBool'
          ];
          function Node(enc, parent) {
            var state = {};
            this._baseState = state;
            state.enc = enc;
            state.parent = parent || null;
            state.children = null;
            state.tag = null;
            state.args = null;
            state.reverseArgs = null;
            state.choice = null;
            state.optional = false;
            state.any = false;
            state.obj = false;
            state.use = null;
            state.useDecoder = null;
            state.key = null;
            state['default'] = null;
            state.explicit = null;
            state.implicit = null;
            if (!state.parent) {
              state.children = [];
              this._wrap();
            }
          }
          module.exports = Node;
          var stateProps = [
            'enc',
            'parent',
            'children',
            'tag',
            'args',
            'reverseArgs',
            'choice',
            'optional',
            'any',
            'obj',
            'use',
            'alteredUse',
            'key',
            'default',
            'explicit',
            'implicit'
          ];
          Node.prototype.clone = function clone() {
            var state = this._baseState;
            var cstate = {};
            stateProps.forEach(function(prop) {
              cstate[prop] = state[prop];
            });
            var res = new this.constructor(cstate.parent);
            res._baseState = cstate;
            return res;
          };
          Node.prototype._wrap = function wrap() {
            var state = this._baseState;
            methods.forEach(function(method) {
              this[method] = function _wrappedMethod() {
                var clone = new this.constructor(this);
                state.children.push(clone);
                return clone[method].apply(clone, arguments);
              };
            }, this);
          };
          Node.prototype._init = function init(body) {
            var state = this._baseState;
            assert(state.parent === null);
            body.call(this);
            state.children = state.children.filter(function(child) {
              return child._baseState.parent === this;
            }, this);
            assert.equal(
              state.children.length,
              1,
              'Root node can have only one child'
            );
          };
          Node.prototype._useArgs = function useArgs(args) {
            var state = this._baseState;
            var children = args.filter(function(arg) {
              return arg instanceof this.constructor;
            }, this);
            args = args.filter(function(arg) {
              return !(arg instanceof this.constructor);
            }, this);
            if (children.length !== 0) {
              assert(state.children === null);
              state.children = children;
              children.forEach(function(child) {
                child._baseState.parent = this;
              }, this);
            }
            if (args.length !== 0) {
              assert(state.args === null);
              state.args = args;
              state.reverseArgs = args.map(function(arg) {
                if (typeof arg !== 'object' || arg.constructor !== Object)
                  return arg;
                var res = {};
                Object.keys(arg).forEach(function(key) {
                  if (key == (key | 0)) key |= 0;
                  var value = arg[key];
                  res[value] = key;
                });
                return res;
              });
            }
          };
          overrided.forEach(function(method) {
            Node.prototype[method] = function _overrided() {
              var state = this._baseState;
              throw new Error(
                method + ' not implemented for encoding: ' + state.enc
              );
            };
          });
          tags.forEach(function(tag) {
            Node.prototype[tag] = function _tagMethod() {
              var state = this._baseState;
              var args = Array.prototype.slice.call(arguments);
              assert(state.tag === null);
              state.tag = tag;
              this._useArgs(args);
              return this;
            };
          });
          Node.prototype.use = function use(item) {
            var state = this._baseState;
            assert(state.use === null);
            state.use = item;
            return this;
          };
          Node.prototype.optional = function optional() {
            var state = this._baseState;
            state.optional = true;
            return this;
          };
          Node.prototype.def = function def(val) {
            var state = this._baseState;
            assert(state['default'] === null);
            state['default'] = val;
            state.optional = true;
            return this;
          };
          Node.prototype.explicit = function explicit(num) {
            var state = this._baseState;
            assert(state.explicit === null && state.implicit === null);
            state.explicit = num;
            return this;
          };
          Node.prototype.implicit = function implicit(num) {
            var state = this._baseState;
            assert(state.explicit === null && state.implicit === null);
            state.implicit = num;
            return this;
          };
          Node.prototype.obj = function obj() {
            var state = this._baseState;
            var args = Array.prototype.slice.call(arguments);
            state.obj = true;
            if (args.length !== 0) this._useArgs(args);
            return this;
          };
          Node.prototype.key = function key(newKey) {
            var state = this._baseState;
            assert(state.key === null);
            state.key = newKey;
            return this;
          };
          Node.prototype.any = function any() {
            var state = this._baseState;
            state.any = true;
            return this;
          };
          Node.prototype.choice = function choice(obj) {
            var state = this._baseState;
            assert(state.choice === null);
            state.choice = obj;
            this._useArgs(
              Object.keys(obj).map(function(key) {
                return obj[key];
              })
            );
            return this;
          };
          Node.prototype._decode = function decode(input) {
            var state = this._baseState;
            if (state.parent === null)
              return input.wrapResult(state.children[0]._decode(input));
            var result = state['default'];
            var present = true;
            var prevKey;
            if (state.key !== null) prevKey = input.enterKey(state.key);
            if (state.optional) {
              var tag = null;
              if (state.explicit !== null) tag = state.explicit;
              else if (state.implicit !== null) tag = state.implicit;
              else if (state.tag !== null) tag = state.tag;
              if (tag === null && !state.any) {
                var save = input.save();
                try {
                  if (state.choice === null)
                    this._decodeGeneric(state.tag, input);
                  else this._decodeChoice(input);
                  present = true;
                } catch (e) {
                  present = false;
                }
                input.restore(save);
              } else {
                present = this._peekTag(input, tag, state.any);
                if (input.isError(present)) return present;
              }
            }
            var prevObj;
            if (state.obj && present) prevObj = input.enterObject();
            if (present) {
              if (state.explicit !== null) {
                var explicit = this._decodeTag(input, state.explicit);
                if (input.isError(explicit)) return explicit;
                input = explicit;
              }
              if (state.use === null && state.choice === null) {
                if (state.any) var save = input.save();
                var body = this._decodeTag(
                  input,
                  state.implicit !== null ? state.implicit : state.tag,
                  state.any
                );
                if (input.isError(body)) return body;
                if (state.any) result = input.raw(save);
                else input = body;
              }
              if (state.any) result = result;
              else if (state.choice === null)
                result = this._decodeGeneric(state.tag, input);
              else result = this._decodeChoice(input);
              if (input.isError(result)) return result;
              if (
                !state.any &&
                state.choice === null &&
                state.children !== null
              ) {
                var fail = state.children.some(function decodeChildren(child) {
                  child._decode(input);
                });
                if (fail) return err;
              }
            }
            if (state.obj && present) result = input.leaveObject(prevObj);
            if (state.key !== null && (result !== null || present === true))
              input.leaveKey(prevKey, state.key, result);
            return result;
          };
          Node.prototype._decodeGeneric = function decodeGeneric(tag, input) {
            var state = this._baseState;
            if (tag === 'seq' || tag === 'set') return null;
            if (tag === 'seqof' || tag === 'setof')
              return this._decodeList(input, tag, state.args[0]);
            else if (tag === 'octstr' || tag === 'bitstr')
              return this._decodeStr(input, tag);
            else if (tag === 'ia5str' || tag === 'utf8str')
              return this._decodeStr(input, tag);
            else if (tag === 'objid' && state.args)
              return this._decodeObjid(input, state.args[0], state.args[1]);
            else if (tag === 'objid')
              return this._decodeObjid(input, null, null);
            else if (tag === 'gentime' || tag === 'utctime')
              return this._decodeTime(input, tag);
            else if (tag === 'null_') return this._decodeNull(input);
            else if (tag === 'bool') return this._decodeBool(input);
            else if (tag === 'int' || tag === 'enum')
              return this._decodeInt(input, state.args && state.args[0]);
            else if (state.use !== null)
              return this._getUse(state.use, input._reporterState.obj)._decode(
                input
              );
            else return input.error('unknown tag: ' + tag);
            return null;
          };
          Node.prototype._getUse = function _getUse(entity, obj) {
            var state = this._baseState;
            state.useDecoder = this._use(entity, obj);
            assert(state.useDecoder._baseState.parent === null);
            state.useDecoder = state.useDecoder._baseState.children[0];
            if (state.implicit !== state.useDecoder._baseState.implicit) {
              state.useDecoder = state.useDecoder.clone();
              state.useDecoder._baseState.implicit = state.implicit;
            }
            return state.useDecoder;
          };
          Node.prototype._decodeChoice = function decodeChoice(input) {
            var state = this._baseState;
            var result = null;
            var match = false;
            Object.keys(state.choice).some(function(key) {
              var save = input.save();
              var node = state.choice[key];
              try {
                var value = node._decode(input);
                if (input.isError(value)) return false;
                result = { type: key, value: value };
                match = true;
              } catch (e) {
                input.restore(save);
                return false;
              }
              return true;
            }, this);
            if (!match) return input.error('Choice not matched');
            return result;
          };
          Node.prototype._createEncoderBuffer = function createEncoderBuffer(
            data
          ) {
            return new EncoderBuffer(data, this.reporter);
          };
          Node.prototype._encode = function encode(data, reporter, parent) {
            var state = this._baseState;
            if (state['default'] !== null && state['default'] === data) return;
            var result = this._encodeValue(data, reporter, parent);
            if (result === undefined) return;
            if (this._skipDefault(result, reporter, parent)) return;
            return result;
          };
          Node.prototype._encodeValue = function encode(
            data,
            reporter,
            parent
          ) {
            var state = this._baseState;
            if (state.parent === null)
              return state.children[0]._encode(
                data,
                reporter || new Reporter()
              );
            var result = null;
            var present = true;
            this.reporter = reporter;
            if (state.optional && data === undefined) {
              if (state['default'] !== null) data = state['default'];
              else return;
            }
            var prevKey;
            var content = null;
            var primitive = false;
            if (state.any) {
              result = this._createEncoderBuffer(data);
            } else if (state.choice) {
              result = this._encodeChoice(data, reporter);
            } else if (state.children) {
              content = state.children
                .map(function(child) {
                  if (child._baseState.tag === 'null_')
                    return child._encode(null, reporter, data);
                  if (child._baseState.key === null)
                    return reporter.error('Child should have a key');
                  var prevKey = reporter.enterKey(child._baseState.key);
                  if (typeof data !== 'object')
                    return reporter.error(
                      'Child expected, but input is not object'
                    );
                  var res = child._encode(
                    data[child._baseState.key],
                    reporter,
                    data
                  );
                  reporter.leaveKey(prevKey);
                  return res;
                }, this)
                .filter(function(child) {
                  return child;
                });
              content = this._createEncoderBuffer(content);
            } else {
              if (state.tag === 'seqof' || state.tag === 'setof') {
                if (!(state.args && state.args.length === 1))
                  return reporter.error('Too many args for : ' + state.tag);
                if (!Array.isArray(data))
                  return reporter.error('seqof/setof, but data is not Array');
                var child = this.clone();
                child._baseState.implicit = null;
                content = this._createEncoderBuffer(
                  data.map(function(item) {
                    var state = this._baseState;
                    return this._getUse(state.args[0], data)._encode(
                      item,
                      reporter
                    );
                  }, child)
                );
              } else if (state.use !== null) {
                result = this._getUse(state.use, parent)._encode(
                  data,
                  reporter
                );
              } else {
                content = this._encodePrimitive(state.tag, data);
                primitive = true;
              }
            }
            var result;
            if (!state.any && state.choice === null) {
              var tag = state.implicit !== null ? state.implicit : state.tag;
              var cls = state.implicit === null ? 'universal' : 'context';
              if (tag === null) {
                if (state.use === null)
                  reporter.error('Tag could be ommited only for .use()');
              } else {
                if (state.use === null)
                  result = this._encodeComposite(tag, primitive, cls, content);
              }
            }
            if (state.explicit !== null)
              result = this._encodeComposite(
                state.explicit,
                false,
                'context',
                result
              );
            return result;
          };
          Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
            var state = this._baseState;
            var node = state.choice[data.type];
            if (!node) {
              assert(
                false,
                data.type +
                  ' not found in ' +
                  JSON.stringify(Object.keys(state.choice))
              );
            }
            return node._encode(data.value, reporter);
          };
          Node.prototype._encodePrimitive = function encodePrimitive(
            tag,
            data
          ) {
            var state = this._baseState;
            if (tag === 'octstr' || tag === 'bitstr' || tag === 'ia5str')
              return this._encodeStr(data, tag);
            else if (tag === 'utf8str') return this._encodeStr(data, tag);
            else if (tag === 'objid' && state.args)
              return this._encodeObjid(
                data,
                state.reverseArgs[0],
                state.args[1]
              );
            else if (tag === 'objid')
              return this._encodeObjid(data, null, null);
            else if (tag === 'gentime' || tag === 'utctime')
              return this._encodeTime(data, tag);
            else if (tag === 'null_') return this._encodeNull();
            else if (tag === 'int' || tag === 'enum')
              return this._encodeInt(data, state.args && state.reverseArgs[0]);
            else if (tag === 'bool') return this._encodeBool(data);
            else throw new Error('Unsupported tag: ' + tag);
          };
        },
        { '../base': 395, 'minimalistic-assert': 441 }
      ],
      397: [
        function(require, module, exports) {
          var inherits = require('inherits');
          function Reporter(options) {
            this._reporterState = {
              obj: null,
              path: [],
              options: options || {},
              errors: []
            };
          }
          exports.Reporter = Reporter;
          Reporter.prototype.isError = function isError(obj) {
            return obj instanceof ReporterError;
          };
          Reporter.prototype.save = function save() {
            var state = this._reporterState;
            return { obj: state.obj, pathLen: state.path.length };
          };
          Reporter.prototype.restore = function restore(data) {
            var state = this._reporterState;
            state.obj = data.obj;
            state.path = state.path.slice(0, data.pathLen);
          };
          Reporter.prototype.enterKey = function enterKey(key) {
            return this._reporterState.path.push(key);
          };
          Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
            var state = this._reporterState;
            state.path = state.path.slice(0, index - 1);
            if (state.obj !== null) state.obj[key] = value;
          };
          Reporter.prototype.enterObject = function enterObject() {
            var state = this._reporterState;
            var prev = state.obj;
            state.obj = {};
            return prev;
          };
          Reporter.prototype.leaveObject = function leaveObject(prev) {
            var state = this._reporterState;
            var now = state.obj;
            state.obj = prev;
            return now;
          };
          Reporter.prototype.error = function error(msg) {
            var err;
            var state = this._reporterState;
            var inherited = msg instanceof ReporterError;
            if (inherited) {
              err = msg;
            } else {
              err = new ReporterError(
                state.path
                  .map(function(elem) {
                    return '[' + JSON.stringify(elem) + ']';
                  })
                  .join(''),
                msg.message || msg,
                msg.stack
              );
            }
            if (!state.options.partial) throw err;
            if (!inherited) state.errors.push(err);
            return err;
          };
          Reporter.prototype.wrapResult = function wrapResult(result) {
            var state = this._reporterState;
            if (!state.options.partial) return result;
            return {
              result: this.isError(result) ? null : result,
              errors: state.errors
            };
          };
          function ReporterError(path, msg) {
            this.path = path;
            this.rethrow(msg);
          }
          inherits(ReporterError, Error);
          ReporterError.prototype.rethrow = function rethrow(msg) {
            this.message = msg + ' at: ' + (this.path || '(shallow)');
            Error.captureStackTrace(this, ReporterError);
            return this;
          };
        },
        { inherits: 381 }
      ],
      398: [
        function(require, module, exports) {
          arguments[4][58][0].apply(exports, arguments);
        },
        { '../constants': 399, dup: 58 }
      ],
      399: [
        function(require, module, exports) {
          arguments[4][59][0].apply(exports, arguments);
        },
        { './der': 398, dup: 59 }
      ],
      400: [
        function(require, module, exports) {
          var inherits = require('inherits');
          var asn1 = require('../../asn1');
          var base = asn1.base;
          var bignum = asn1.bignum;
          var der = asn1.constants.der;
          function DERDecoder(entity) {
            this.enc = 'der';
            this.name = entity.name;
            this.entity = entity;
            this.tree = new DERNode();
            this.tree._init(entity.body);
          }
          module.exports = DERDecoder;
          DERDecoder.prototype.decode = function decode(data, options) {
            if (!(data instanceof base.DecoderBuffer))
              data = new base.DecoderBuffer(data, options);
            return this.tree._decode(data, options);
          };
          function DERNode(parent) {
            base.Node.call(this, 'der', parent);
          }
          inherits(DERNode, base.Node);
          DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
            if (buffer.isEmpty()) return false;
            var state = buffer.save();
            var decodedTag = derDecodeTag(
              buffer,
              'Failed to peek tag: "' + tag + '"'
            );
            if (buffer.isError(decodedTag)) return decodedTag;
            buffer.restore(state);
            return decodedTag.tag === tag || decodedTag.tagStr === tag || any;
          };
          DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
            var decodedTag = derDecodeTag(
              buffer,
              'Failed to decode tag of "' + tag + '"'
            );
            if (buffer.isError(decodedTag)) return decodedTag;
            var len = derDecodeLen(
              buffer,
              decodedTag.primitive,
              'Failed to get length of "' + tag + '"'
            );
            if (buffer.isError(len)) return len;
            if (
              !any &&
              decodedTag.tag !== tag &&
              decodedTag.tagStr !== tag &&
              decodedTag.tagStr + 'of' !== tag
            ) {
              return buffer.error('Failed to match tag: "' + tag + '"');
            }
            if (decodedTag.primitive || len !== null)
              return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
            var state = buffer.save();
            var res = this._skipUntilEnd(
              buffer,
              'Failed to skip indefinite length body: "' + this.tag + '"'
            );
            if (buffer.isError(res)) return res;
            len = buffer.offset - state.offset;
            buffer.restore(state);
            return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
          };
          DERNode.prototype._skipUntilEnd = function skipUntilEnd(
            buffer,
            fail
          ) {
            while (true) {
              var tag = derDecodeTag(buffer, fail);
              if (buffer.isError(tag)) return tag;
              var len = derDecodeLen(buffer, tag.primitive, fail);
              if (buffer.isError(len)) return len;
              var res;
              if (tag.primitive || len !== null) res = buffer.skip(len);
              else res = this._skipUntilEnd(buffer, fail);
              if (buffer.isError(res)) return res;
              if (tag.tagStr === 'end') break;
            }
          };
          DERNode.prototype._decodeList = function decodeList(
            buffer,
            tag,
            decoder
          ) {
            var result = [];
            while (!buffer.isEmpty()) {
              var possibleEnd = this._peekTag(buffer, 'end');
              if (buffer.isError(possibleEnd)) return possibleEnd;
              var res = decoder.decode(buffer, 'der');
              if (buffer.isError(res) && possibleEnd) break;
              result.push(res);
            }
            return result;
          };
          DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
            if (tag === 'octstr') {
              return buffer.raw();
            } else if (tag === 'bitstr') {
              var unused = buffer.readUInt8();
              if (buffer.isError(unused)) return unused;
              return { unused: unused, data: buffer.raw() };
            } else if (tag === 'ia5str' || tag === 'utf8str') {
              return buffer.raw().toString();
            } else {
              return this.error(
                'Decoding of string type: ' + tag + ' unsupported'
              );
            }
          };
          DERNode.prototype._decodeObjid = function decodeObjid(
            buffer,
            values,
            relative
          ) {
            var identifiers = [];
            var ident = 0;
            while (!buffer.isEmpty()) {
              var subident = buffer.readUInt8();
              ident <<= 7;
              ident |= subident & 127;
              if ((subident & 128) === 0) {
                identifiers.push(ident);
                ident = 0;
              }
            }
            if (subident & 128) identifiers.push(ident);
            var first = (identifiers[0] / 40) | 0;
            var second = identifiers[0] % 40;
            if (relative) result = identifiers;
            else result = [first, second].concat(identifiers.slice(1));
            if (values) result = values[result.join(' ')];
            return result;
          };
          DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
            var str = buffer.raw().toString();
            if (tag === 'gentime') {
              var year = str.slice(0, 4) | 0;
              var mon = str.slice(4, 6) | 0;
              var day = str.slice(6, 8) | 0;
              var hour = str.slice(8, 10) | 0;
              var min = str.slice(10, 12) | 0;
              var sec = str.slice(12, 14) | 0;
            } else if (tag === 'utctime') {
              var year = str.slice(0, 2) | 0;
              var mon = str.slice(2, 4) | 0;
              var day = str.slice(4, 6) | 0;
              var hour = str.slice(6, 8) | 0;
              var min = str.slice(8, 10) | 0;
              var sec = str.slice(10, 12) | 0;
              if (year < 70) year = 2e3 + year;
              else year = 1900 + year;
            } else {
              return this.error(
                'Decoding ' + tag + ' time is not supported yet'
              );
            }
            return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
          };
          DERNode.prototype._decodeNull = function decodeNull(buffer) {
            return null;
          };
          DERNode.prototype._decodeBool = function decodeBool(buffer) {
            var res = buffer.readUInt8();
            if (buffer.isError(res)) return res;
            else return res !== 0;
          };
          DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
            var raw = buffer.raw();
            var res = new bignum(raw);
            if (values) res = values[res.toString(10)] || res;
            return res;
          };
          DERNode.prototype._use = function use(entity, obj) {
            if (typeof entity === 'function') entity = entity(obj);
            return entity._getDecoder('der').tree;
          };
          function derDecodeTag(buf, fail) {
            var tag = buf.readUInt8(fail);
            if (buf.isError(tag)) return tag;
            var cls = der.tagClass[tag >> 6];
            var primitive = (tag & 32) === 0;
            if ((tag & 31) === 31) {
              var oct = tag;
              tag = 0;
              while ((oct & 128) === 128) {
                oct = buf.readUInt8(fail);
                if (buf.isError(oct)) return oct;
                tag <<= 7;
                tag |= oct & 127;
              }
            } else {
              tag &= 31;
            }
            var tagStr = der.tag[tag];
            return { cls: cls, primitive: primitive, tag: tag, tagStr: tagStr };
          }
          function derDecodeLen(buf, primitive, fail) {
            var len = buf.readUInt8(fail);
            if (buf.isError(len)) return len;
            if (!primitive && len === 128) return null;
            if ((len & 128) === 0) {
              return len;
            }
            var num = len & 127;
            if (num >= 4) return buf.error('length octect is too long');
            len = 0;
            for (var i = 0; i < num; i++) {
              len <<= 8;
              var j = buf.readUInt8(fail);
              if (buf.isError(j)) return j;
              len |= j;
            }
            return len;
          }
        },
        { '../../asn1': 392, inherits: 381 }
      ],
      401: [
        function(require, module, exports) {
          arguments[4][61][0].apply(exports, arguments);
        },
        { './der': 400, './pem': 402, dup: 61 }
      ],
      402: [
        function(require, module, exports) {
          var inherits = require('inherits');
          var Buffer = require('buffer').Buffer;
          var asn1 = require('../../asn1');
          var DERDecoder = require('./der');
          function PEMDecoder(entity) {
            DERDecoder.call(this, entity);
            this.enc = 'pem';
          }
          inherits(PEMDecoder, DERDecoder);
          module.exports = PEMDecoder;
          PEMDecoder.prototype.decode = function decode(data, options) {
            var lines = data.toString().split(/[\r\n]+/g);
            var label = options.label.toUpperCase();
            var re = /^-----(BEGIN|END) ([^-]+)-----$/;
            var start = -1;
            var end = -1;
            for (var i = 0; i < lines.length; i++) {
              var match = lines[i].match(re);
              if (match === null) continue;
              if (match[2] !== label) continue;
              if (start === -1) {
                if (match[1] !== 'BEGIN') break;
                start = i;
              } else {
                if (match[1] !== 'END') break;
                end = i;
                break;
              }
            }
            if (start === -1 || end === -1)
              throw new Error('PEM section not found for: ' + label);
            var base64 = lines.slice(start + 1, end).join('');
            base64.replace(/[^a-z0-9\+\/=]+/gi, '');
            var input = new Buffer(base64, 'base64');
            return DERDecoder.prototype.decode.call(this, input, options);
          };
        },
        { '../../asn1': 392, './der': 400, buffer: 183, inherits: 381 }
      ],
      403: [
        function(require, module, exports) {
          var inherits = require('inherits');
          var Buffer = require('buffer').Buffer;
          var asn1 = require('../../asn1');
          var base = asn1.base;
          var bignum = asn1.bignum;
          var der = asn1.constants.der;
          function DEREncoder(entity) {
            this.enc = 'der';
            this.name = entity.name;
            this.entity = entity;
            this.tree = new DERNode();
            this.tree._init(entity.body);
          }
          module.exports = DEREncoder;
          DEREncoder.prototype.encode = function encode(data, reporter) {
            return this.tree._encode(data, reporter).join();
          };
          function DERNode(parent) {
            base.Node.call(this, 'der', parent);
          }
          inherits(DERNode, base.Node);
          DERNode.prototype._encodeComposite = function encodeComposite(
            tag,
            primitive,
            cls,
            content
          ) {
            var encodedTag = encodeTag(tag, primitive, cls, this.reporter);
            if (content.length < 128) {
              var header = new Buffer(2);
              header[0] = encodedTag;
              header[1] = content.length;
              return this._createEncoderBuffer([header, content]);
            }
            var lenOctets = 1;
            for (var i = content.length; i >= 256; i >>= 8) lenOctets++;
            var header = new Buffer(1 + 1 + lenOctets);
            header[0] = encodedTag;
            header[1] = 128 | lenOctets;
            for (var i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
              header[i] = j & 255;
            return this._createEncoderBuffer([header, content]);
          };
          DERNode.prototype._encodeStr = function encodeStr(str, tag) {
            if (tag === 'octstr') return this._createEncoderBuffer(str);
            else if (tag === 'bitstr')
              return this._createEncoderBuffer([str.unused | 0, str.data]);
            else if (tag === 'ia5str' || tag === 'utf8str')
              return this._createEncoderBuffer(str);
            return this.reporter.error(
              'Encoding of string type: ' + tag + ' unsupported'
            );
          };
          DERNode.prototype._encodeObjid = function encodeObjid(
            id,
            values,
            relative
          ) {
            if (typeof id === 'string') {
              if (!values)
                return this.reporter.error(
                  'string objid given, but no values map found'
                );
              if (!values.hasOwnProperty(id))
                return this.reporter.error('objid not found in values map');
              id = values[id].split(/[\s\.]+/g);
              for (var i = 0; i < id.length; i++) id[i] |= 0;
            } else if (Array.isArray(id)) {
              id = id.slice();
              for (var i = 0; i < id.length; i++) id[i] |= 0;
            }
            if (!Array.isArray(id)) {
              return this.reporter.error(
                'objid() should be either array or string, ' +
                  'got: ' +
                  JSON.stringify(id)
              );
            }
            if (!relative) {
              if (id[1] >= 40)
                return this.reporter.error('Second objid identifier OOB');
              id.splice(0, 2, id[0] * 40 + id[1]);
            }
            var size = 0;
            for (var i = 0; i < id.length; i++) {
              var ident = id[i];
              for (size++; ident >= 128; ident >>= 7) size++;
            }
            var objid = new Buffer(size);
            var offset = objid.length - 1;
            for (var i = id.length - 1; i >= 0; i--) {
              var ident = id[i];
              objid[offset--] = ident & 127;
              while ((ident >>= 7) > 0) objid[offset--] = 128 | (ident & 127);
            }
            return this._createEncoderBuffer(objid);
          };
          function two(num) {
            if (num < 10) return '0' + num;
            else return num;
          }
          DERNode.prototype._encodeTime = function encodeTime(time, tag) {
            var str;
            var date = new Date(time);
            if (tag === 'gentime') {
              str = [
                two(date.getFullYear()),
                two(date.getUTCMonth() + 1),
                two(date.getUTCDate()),
                two(date.getUTCHours()),
                two(date.getUTCMinutes()),
                two(date.getUTCSeconds()),
                'Z'
              ].join('');
            } else if (tag === 'utctime') {
              str = [
                two(date.getFullYear() % 100),
                two(date.getUTCMonth() + 1),
                two(date.getUTCDate()),
                two(date.getUTCHours()),
                two(date.getUTCMinutes()),
                two(date.getUTCSeconds()),
                'Z'
              ].join('');
            } else {
              this.reporter.error(
                'Encoding ' + tag + ' time is not supported yet'
              );
            }
            return this._encodeStr(str, 'octstr');
          };
          DERNode.prototype._encodeNull = function encodeNull() {
            return this._createEncoderBuffer('');
          };
          DERNode.prototype._encodeInt = function encodeInt(num, values) {
            if (typeof num === 'string') {
              if (!values)
                return this.reporter.error(
                  'String int or enum given, but no values map'
                );
              if (!values.hasOwnProperty(num)) {
                return this.reporter.error(
                  "Values map doesn't contain: " + JSON.stringify(num)
                );
              }
              num = values[num];
            }
            if (typeof num !== 'number' && !Buffer.isBuffer(num)) {
              var numArray = num.toArray();
              if (num.sign === false && numArray[0] & 128) {
                numArray.unshift(0);
              }
              num = new Buffer(numArray);
            }
            if (Buffer.isBuffer(num)) {
              var size = num.length;
              if (num.length === 0) size++;
              var out = new Buffer(size);
              num.copy(out);
              if (num.length === 0) out[0] = 0;
              return this._createEncoderBuffer(out);
            }
            if (num < 128) return this._createEncoderBuffer(num);
            if (num < 256) return this._createEncoderBuffer([0, num]);
            var size = 1;
            for (var i = num; i >= 256; i >>= 8) size++;
            var out = new Array(size);
            for (var i = out.length - 1; i >= 0; i--) {
              out[i] = num & 255;
              num >>= 8;
            }
            if (out[0] & 128) {
              out.unshift(0);
            }
            return this._createEncoderBuffer(new Buffer(out));
          };
          DERNode.prototype._encodeBool = function encodeBool(value) {
            return this._createEncoderBuffer(value ? 255 : 0);
          };
          DERNode.prototype._use = function use(entity, obj) {
            if (typeof entity === 'function') entity = entity(obj);
            return entity._getEncoder('der').tree;
          };
          DERNode.prototype._skipDefault = function skipDefault(
            dataBuffer,
            reporter,
            parent
          ) {
            var state = this._baseState;
            var i;
            if (state['default'] === null) return false;
            var data = dataBuffer.join();
            if (state.defaultBuffer === undefined)
              state.defaultBuffer = this._encodeValue(
                state['default'],
                reporter,
                parent
              ).join();
            if (data.length !== state.defaultBuffer.length) return false;
            for (i = 0; i < data.length; i++)
              if (data[i] !== state.defaultBuffer[i]) return false;
            return true;
          };
          function encodeTag(tag, primitive, cls, reporter) {
            var res;
            if (tag === 'seqof') tag = 'seq';
            else if (tag === 'setof') tag = 'set';
            if (der.tagByName.hasOwnProperty(tag)) res = der.tagByName[tag];
            else if (typeof tag === 'number' && (tag | 0) === tag) res = tag;
            else return reporter.error('Unknown tag: ' + tag);
            if (res >= 31)
              return reporter.error('Multi-octet tag encoding unsupported');
            if (!primitive) res |= 32;
            res |= der.tagClassByName[cls || 'universal'] << 6;
            return res;
          }
        },
        { '../../asn1': 392, buffer: 183, inherits: 381 }
      ],
      404: [
        function(require, module, exports) {
          arguments[4][64][0].apply(exports, arguments);
        },
        { './der': 403, './pem': 405, dup: 64 }
      ],
      405: [
        function(require, module, exports) {
          var inherits = require('inherits');
          var Buffer = require('buffer').Buffer;
          var asn1 = require('../../asn1');
          var DEREncoder = require('./der');
          function PEMEncoder(entity) {
            DEREncoder.call(this, entity);
            this.enc = 'pem';
          }
          inherits(PEMEncoder, DEREncoder);
          module.exports = PEMEncoder;
          PEMEncoder.prototype.encode = function encode(data, options) {
            var buf = DEREncoder.prototype.encode.call(this, data);
            var p = buf.toString('base64');
            var out = ['-----BEGIN ' + options.label + '-----'];
            for (var i = 0; i < p.length; i += 64) out.push(p.slice(i, i + 64));
            out.push('-----END ' + options.label + '-----');
            return out.join('\n');
          };
        },
        { '../../asn1': 392, './der': 403, buffer: 183, inherits: 381 }
      ],
      406: [
        function(require, module, exports) {
          (function(module, exports) {
            'use strict';
            function assert(val, msg) {
              if (!val) throw new Error(msg || 'Assertion failed');
            }
            function inherits(ctor, superCtor) {
              ctor.super_ = superCtor;
              var TempCtor = function() {};
              TempCtor.prototype = superCtor.prototype;
              ctor.prototype = new TempCtor();
              ctor.prototype.constructor = ctor;
            }
            function BN(number, base, endian) {
              if (
                number !== null &&
                typeof number === 'object' &&
                Array.isArray(number.words)
              ) {
                return number;
              }
              this.sign = false;
              this.words = null;
              this.length = 0;
              this.red = null;
              if (base === 'le' || base === 'be') {
                endian = base;
                base = 10;
              }
              if (number !== null)
                this._init(number || 0, base || 10, endian || 'be');
            }
            if (typeof module === 'object') module.exports = BN;
            else exports.BN = BN;
            BN.BN = BN;
            BN.wordSize = 26;
            BN.prototype._init = function init(number, base, endian) {
              if (typeof number === 'number') {
                return this._initNumber(number, base, endian);
              } else if (typeof number === 'object') {
                return this._initArray(number, base, endian);
              }
              if (base === 'hex') base = 16;
              assert(base === (base | 0) && base >= 2 && base <= 36);
              number = number.toString().replace(/\s+/g, '');
              var start = 0;
              if (number[0] === '-') start++;
              if (base === 16) this._parseHex(number, start);
              else this._parseBase(number, base, start);
              if (number[0] === '-') this.sign = true;
              this.strip();
              if (endian !== 'le') return;
              this._initArray(this.toArray(), base, endian);
            };
            BN.prototype._initNumber = function _initNumber(
              number,
              base,
              endian
            ) {
              if (number < 0) {
                this.sign = true;
                number = -number;
              }
              if (number < 67108864) {
                this.words = [number & 67108863];
                this.length = 1;
              } else if (number < 4503599627370496) {
                this.words = [
                  number & 67108863,
                  (number / 67108864) & 67108863
                ];
                this.length = 2;
              } else {
                assert(number < 9007199254740992);
                this.words = [
                  number & 67108863,
                  (number / 67108864) & 67108863,
                  1
                ];
                this.length = 3;
              }
              if (endian !== 'le') return;
              this._initArray(this.toArray(), base, endian);
            };
            BN.prototype._initArray = function _initArray(
              number,
              base,
              endian
            ) {
              assert(typeof number.length === 'number');
              if (number.length <= 0) {
                this.words = [0];
                this.length = 1;
                return this;
              }
              this.length = Math.ceil(number.length / 3);
              this.words = new Array(this.length);
              for (var i = 0; i < this.length; i++) this.words[i] = 0;
              var off = 0;
              if (endian === 'be') {
                for (var i = number.length - 1, j = 0; i >= 0; i -= 3) {
                  var w =
                    number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
                  this.words[j] |= (w << off) & 67108863;
                  this.words[j + 1] = (w >>> (26 - off)) & 67108863;
                  off += 24;
                  if (off >= 26) {
                    off -= 26;
                    j++;
                  }
                }
              } else if (endian === 'le') {
                for (var i = 0, j = 0; i < number.length; i += 3) {
                  var w =
                    number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
                  this.words[j] |= (w << off) & 67108863;
                  this.words[j + 1] = (w >>> (26 - off)) & 67108863;
                  off += 24;
                  if (off >= 26) {
                    off -= 26;
                    j++;
                  }
                }
              }
              return this.strip();
            };
            function parseHex(str, start, end) {
              var r = 0;
              var len = Math.min(str.length, end);
              for (var i = start; i < len; i++) {
                var c = str.charCodeAt(i) - 48;
                r <<= 4;
                if (c >= 49 && c <= 54) r |= c - 49 + 10;
                else if (c >= 17 && c <= 22) r |= c - 17 + 10;
                else r |= c & 15;
              }
              return r;
            }
            BN.prototype._parseHex = function _parseHex(number, start) {
              this.length = Math.ceil((number.length - start) / 6);
              this.words = new Array(this.length);
              for (var i = 0; i < this.length; i++) this.words[i] = 0;
              var off = 0;
              for (var i = number.length - 6, j = 0; i >= start; i -= 6) {
                var w = parseHex(number, i, i + 6);
                this.words[j] |= (w << off) & 67108863;
                this.words[j + 1] |= (w >>> (26 - off)) & 4194303;
                off += 24;
                if (off >= 26) {
                  off -= 26;
                  j++;
                }
              }
              if (i + 6 !== start) {
                var w = parseHex(number, start, i + 6);
                this.words[j] |= (w << off) & 67108863;
                this.words[j + 1] |= (w >>> (26 - off)) & 4194303;
              }
              this.strip();
            };
            function parseBase(str, start, end, mul) {
              var r = 0;
              var len = Math.min(str.length, end);
              for (var i = start; i < len; i++) {
                var c = str.charCodeAt(i) - 48;
                r *= mul;
                if (c >= 49) r += c - 49 + 10;
                else if (c >= 17) r += c - 17 + 10;
                else r += c;
              }
              return r;
            }
            BN.prototype._parseBase = function _parseBase(number, base, start) {
              this.words = [0];
              this.length = 1;
              for (
                var limbLen = 0, limbPow = 1;
                limbPow <= 67108863;
                limbPow *= base
              )
                limbLen++;
              limbLen--;
              limbPow = (limbPow / base) | 0;
              var total = number.length - start;
              var mod = total % limbLen;
              var end = Math.min(total, total - mod) + start;
              var word = 0;
              for (var i = start; i < end; i += limbLen) {
                word = parseBase(number, i, i + limbLen, base);
                this.imuln(limbPow);
                if (this.words[0] + word < 67108864) this.words[0] += word;
                else this._iaddn(word);
              }
              if (mod !== 0) {
                var pow = 1;
                var word = parseBase(number, i, number.length, base);
                for (var i = 0; i < mod; i++) pow *= base;
                this.imuln(pow);
                if (this.words[0] + word < 67108864) this.words[0] += word;
                else this._iaddn(word);
              }
            };
            BN.prototype.copy = function copy(dest) {
              dest.words = new Array(this.length);
              for (var i = 0; i < this.length; i++)
                dest.words[i] = this.words[i];
              dest.length = this.length;
              dest.sign = this.sign;
              dest.red = this.red;
            };
            BN.prototype.clone = function clone() {
              var r = new BN(null);
              this.copy(r);
              return r;
            };
            BN.prototype.strip = function strip() {
              while (this.length > 1 && this.words[this.length - 1] === 0)
                this.length--;
              return this._normSign();
            };
            BN.prototype._normSign = function _normSign() {
              if (this.length === 1 && this.words[0] === 0) this.sign = false;
              return this;
            };
            BN.prototype.inspect = function inspect() {
              return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
            };
            var zeros = [
              '',
              '0',
              '00',
              '000',
              '0000',
              '00000',
              '000000',
              '0000000',
              '00000000',
              '000000000',
              '0000000000',
              '00000000000',
              '000000000000',
              '0000000000000',
              '00000000000000',
              '000000000000000',
              '0000000000000000',
              '00000000000000000',
              '000000000000000000',
              '0000000000000000000',
              '00000000000000000000',
              '000000000000000000000',
              '0000000000000000000000',
              '00000000000000000000000',
              '000000000000000000000000',
              '0000000000000000000000000'
            ];
            var groupSizes = [
              0,
              0,
              25,
              16,
              12,
              11,
              10,
              9,
              8,
              8,
              7,
              7,
              7,
              7,
              6,
              6,
              6,
              6,
              6,
              6,
              6,
              5,
              5,
              5,
              5,
              5,
              5,
              5,
              5,
              5,
              5,
              5,
              5,
              5,
              5,
              5,
              5
            ];
            var groupBases = [
              0,
              0,
              33554432,
              43046721,
              16777216,
              48828125,
              60466176,
              40353607,
              16777216,
              43046721,
              1e7,
              19487171,
              35831808,
              62748517,
              7529536,
              11390625,
              16777216,
              24137569,
              34012224,
              47045881,
              64e6,
              4084101,
              5153632,
              6436343,
              7962624,
              9765625,
              11881376,
              14348907,
              17210368,
              20511149,
              243e5,
              28629151,
              33554432,
              39135393,
              45435424,
              52521875,
              60466176
            ];
            BN.prototype.toString = function toString(base, padding) {
              base = base || 10;
              if (base === 16 || base === 'hex') {
                var out = '';
                var off = 0;
                var padding = padding | 0 || 1;
                var carry = 0;
                for (var i = 0; i < this.length; i++) {
                  var w = this.words[i];
                  var word = (((w << off) | carry) & 16777215).toString(16);
                  carry = (w >>> (24 - off)) & 16777215;
                  if (carry !== 0 || i !== this.length - 1)
                    out = zeros[6 - word.length] + word + out;
                  else out = word + out;
                  off += 2;
                  if (off >= 26) {
                    off -= 26;
                    i--;
                  }
                }
                if (carry !== 0) out = carry.toString(16) + out;
                while (out.length % padding !== 0) out = '0' + out;
                if (this.sign) out = '-' + out;
                return out;
              } else if (base === (base | 0) && base >= 2 && base <= 36) {
                var groupSize = groupSizes[base];
                var groupBase = groupBases[base];
                var out = '';
                var c = this.clone();
                c.sign = false;
                while (c.cmpn(0) !== 0) {
                  var r = c.modn(groupBase).toString(base);
                  c = c.idivn(groupBase);
                  if (c.cmpn(0) !== 0)
                    out = zeros[groupSize - r.length] + r + out;
                  else out = r + out;
                }
                if (this.cmpn(0) === 0) out = '0' + out;
                if (this.sign) out = '-' + out;
                return out;
              } else {
                assert(false, 'Base should be between 2 and 36');
              }
            };
            BN.prototype.toJSON = function toJSON() {
              return this.toString(16);
            };
            BN.prototype.toArray = function toArray(endian) {
              this.strip();
              var res = new Array(this.byteLength());
              res[0] = 0;
              var q = this.clone();
              if (endian !== 'le') {
                for (var i = 0; q.cmpn(0) !== 0; i++) {
                  var b = q.andln(255);
                  q.ishrn(8);
                  res[res.length - i - 1] = b;
                }
              } else {
                for (var i = 0; q.cmpn(0) !== 0; i++) {
                  var b = q.andln(255);
                  q.ishrn(8);
                  res[i] = b;
                }
              }
              return res;
            };
            if (Math.clz32) {
              BN.prototype._countBits = function _countBits(w) {
                return 32 - Math.clz32(w);
              };
            } else {
              BN.prototype._countBits = function _countBits(w) {
                var t = w;
                var r = 0;
                if (t >= 4096) {
                  r += 13;
                  t >>>= 13;
                }
                if (t >= 64) {
                  r += 7;
                  t >>>= 7;
                }
                if (t >= 8) {
                  r += 4;
                  t >>>= 4;
                }
                if (t >= 2) {
                  r += 2;
                  t >>>= 2;
                }
                return r + t;
              };
            }
            BN.prototype._zeroBits = function _zeroBits(w) {
              if (w === 0) return 26;
              var t = w;
              var r = 0;
              if ((t & 8191) === 0) {
                r += 13;
                t >>>= 13;
              }
              if ((t & 127) === 0) {
                r += 7;
                t >>>= 7;
              }
              if ((t & 15) === 0) {
                r += 4;
                t >>>= 4;
              }
              if ((t & 3) === 0) {
                r += 2;
                t >>>= 2;
              }
              if ((t & 1) === 0) r++;
              return r;
            };
            BN.prototype.bitLength = function bitLength() {
              var hi = 0;
              var w = this.words[this.length - 1];
              var hi = this._countBits(w);
              return (this.length - 1) * 26 + hi;
            };
            BN.prototype.zeroBits = function zeroBits() {
              if (this.cmpn(0) === 0) return 0;
              var r = 0;
              for (var i = 0; i < this.length; i++) {
                var b = this._zeroBits(this.words[i]);
                r += b;
                if (b !== 26) break;
              }
              return r;
            };
            BN.prototype.byteLength = function byteLength() {
              return Math.ceil(this.bitLength() / 8);
            };
            BN.prototype.neg = function neg() {
              if (this.cmpn(0) === 0) return this.clone();
              var r = this.clone();
              r.sign = !this.sign;
              return r;
            };
            BN.prototype.ior = function ior(num) {
              this.sign = this.sign || num.sign;
              while (this.length < num.length) this.words[this.length++] = 0;
              for (var i = 0; i < num.length; i++)
                this.words[i] = this.words[i] | num.words[i];
              return this.strip();
            };
            BN.prototype.or = function or(num) {
              if (this.length > num.length) return this.clone().ior(num);
              else return num.clone().ior(this);
            };
            BN.prototype.iand = function iand(num) {
              this.sign = this.sign && num.sign;
              var b;
              if (this.length > num.length) b = num;
              else b = this;
              for (var i = 0; i < b.length; i++)
                this.words[i] = this.words[i] & num.words[i];
              this.length = b.length;
              return this.strip();
            };
            BN.prototype.and = function and(num) {
              if (this.length > num.length) return this.clone().iand(num);
              else return num.clone().iand(this);
            };
            BN.prototype.ixor = function ixor(num) {
              this.sign = this.sign || num.sign;
              var a;
              var b;
              if (this.length > num.length) {
                a = this;
                b = num;
              } else {
                a = num;
                b = this;
              }
              for (var i = 0; i < b.length; i++)
                this.words[i] = a.words[i] ^ b.words[i];
              if (this !== a)
                for (; i < a.length; i++) this.words[i] = a.words[i];
              this.length = a.length;
              return this.strip();
            };
            BN.prototype.xor = function xor(num) {
              if (this.length > num.length) return this.clone().ixor(num);
              else return num.clone().ixor(this);
            };
            BN.prototype.setn = function setn(bit, val) {
              assert(typeof bit === 'number' && bit >= 0);
              var off = (bit / 26) | 0;
              var wbit = bit % 26;
              while (this.length <= off) this.words[this.length++] = 0;
              if (val) this.words[off] = this.words[off] | (1 << wbit);
              else this.words[off] = this.words[off] & ~(1 << wbit);
              return this.strip();
            };
            BN.prototype.iadd = function iadd(num) {
              if (this.sign && !num.sign) {
                this.sign = false;
                var r = this.isub(num);
                this.sign = !this.sign;
                return this._normSign();
              } else if (!this.sign && num.sign) {
                num.sign = false;
                var r = this.isub(num);
                num.sign = true;
                return r._normSign();
              }
              var a;
              var b;
              if (this.length > num.length) {
                a = this;
                b = num;
              } else {
                a = num;
                b = this;
              }
              var carry = 0;
              for (var i = 0; i < b.length; i++) {
                var r = a.words[i] + b.words[i] + carry;
                this.words[i] = r & 67108863;
                carry = r >>> 26;
              }
              for (; carry !== 0 && i < a.length; i++) {
                var r = a.words[i] + carry;
                this.words[i] = r & 67108863;
                carry = r >>> 26;
              }
              this.length = a.length;
              if (carry !== 0) {
                this.words[this.length] = carry;
                this.length++;
              } else if (a !== this) {
                for (; i < a.length; i++) this.words[i] = a.words[i];
              }
              return this;
            };
            BN.prototype.add = function add(num) {
              if (num.sign && !this.sign) {
                num.sign = false;
                var res = this.sub(num);
                num.sign = true;
                return res;
              } else if (!num.sign && this.sign) {
                this.sign = false;
                var res = num.sub(this);
                this.sign = true;
                return res;
              }
              if (this.length > num.length) return this.clone().iadd(num);
              else return num.clone().iadd(this);
            };
            BN.prototype.isub = function isub(num) {
              if (num.sign) {
                num.sign = false;
                var r = this.iadd(num);
                num.sign = true;
                return r._normSign();
              } else if (this.sign) {
                this.sign = false;
                this.iadd(num);
                this.sign = true;
                return this._normSign();
              }
              var cmp = this.cmp(num);
              if (cmp === 0) {
                this.sign = false;
                this.length = 1;
                this.words[0] = 0;
                return this;
              }
              var a;
              var b;
              if (cmp > 0) {
                a = this;
                b = num;
              } else {
                a = num;
                b = this;
              }
              var carry = 0;
              for (var i = 0; i < b.length; i++) {
                var r = a.words[i] - b.words[i] + carry;
                carry = r >> 26;
                this.words[i] = r & 67108863;
              }
              for (; carry !== 0 && i < a.length; i++) {
                var r = a.words[i] + carry;
                carry = r >> 26;
                this.words[i] = r & 67108863;
              }
              if (carry === 0 && i < a.length && a !== this)
                for (; i < a.length; i++) this.words[i] = a.words[i];
              this.length = Math.max(this.length, i);
              if (a !== this) this.sign = true;
              return this.strip();
            };
            BN.prototype.sub = function sub(num) {
              return this.clone().isub(num);
            };
            BN.prototype._smallMulTo = function _smallMulTo(num, out) {
              out.sign = num.sign !== this.sign;
              out.length = this.length + num.length;
              var carry = 0;
              for (var k = 0; k < out.length - 1; k++) {
                var ncarry = carry >>> 26;
                var rword = carry & 67108863;
                var maxJ = Math.min(k, num.length - 1);
                for (var j = Math.max(0, k - this.length + 1); j <= maxJ; j++) {
                  var i = k - j;
                  var a = this.words[i] | 0;
                  var b = num.words[j] | 0;
                  var r = a * b;
                  var lo = r & 67108863;
                  ncarry = (ncarry + ((r / 67108864) | 0)) | 0;
                  lo = (lo + rword) | 0;
                  rword = lo & 67108863;
                  ncarry = (ncarry + (lo >>> 26)) | 0;
                }
                out.words[k] = rword;
                carry = ncarry;
              }
              if (carry !== 0) {
                out.words[k] = carry;
              } else {
                out.length--;
              }
              return out.strip();
            };
            BN.prototype._bigMulTo = function _bigMulTo(num, out) {
              out.sign = num.sign !== this.sign;
              out.length = this.length + num.length;
              var carry = 0;
              var hncarry = 0;
              for (var k = 0; k < out.length - 1; k++) {
                var ncarry = hncarry;
                hncarry = 0;
                var rword = carry & 67108863;
                var maxJ = Math.min(k, num.length - 1);
                for (var j = Math.max(0, k - this.length + 1); j <= maxJ; j++) {
                  var i = k - j;
                  var a = this.words[i] | 0;
                  var b = num.words[j] | 0;
                  var r = a * b;
                  var lo = r & 67108863;
                  ncarry = (ncarry + ((r / 67108864) | 0)) | 0;
                  lo = (lo + rword) | 0;
                  rword = lo & 67108863;
                  ncarry = (ncarry + (lo >>> 26)) | 0;
                  hncarry += ncarry >>> 26;
                  ncarry &= 67108863;
                }
                out.words[k] = rword;
                carry = ncarry;
                ncarry = hncarry;
              }
              if (carry !== 0) {
                out.words[k] = carry;
              } else {
                out.length--;
              }
              return out.strip();
            };
            BN.prototype.mulTo = function mulTo(num, out) {
              var res;
              if (this.length + num.length < 63)
                res = this._smallMulTo(num, out);
              else res = this._bigMulTo(num, out);
              return res;
            };
            BN.prototype.mul = function mul(num) {
              var out = new BN(null);
              out.words = new Array(this.length + num.length);
              return this.mulTo(num, out);
            };
            BN.prototype.imul = function imul(num) {
              if (this.cmpn(0) === 0 || num.cmpn(0) === 0) {
                this.words[0] = 0;
                this.length = 1;
                return this;
              }
              var tlen = this.length;
              var nlen = num.length;
              this.sign = num.sign !== this.sign;
              this.length = this.length + num.length;
              this.words[this.length - 1] = 0;
              for (var k = this.length - 2; k >= 0; k--) {
                var carry = 0;
                var rword = 0;
                var maxJ = Math.min(k, nlen - 1);
                for (var j = Math.max(0, k - tlen + 1); j <= maxJ; j++) {
                  var i = k - j;
                  var a = this.words[i];
                  var b = num.words[j];
                  var r = a * b;
                  var lo = r & 67108863;
                  carry += (r / 67108864) | 0;
                  lo += rword;
                  rword = lo & 67108863;
                  carry += lo >>> 26;
                }
                this.words[k] = rword;
                this.words[k + 1] += carry;
                carry = 0;
              }
              var carry = 0;
              for (var i = 1; i < this.length; i++) {
                var w = this.words[i] + carry;
                this.words[i] = w & 67108863;
                carry = w >>> 26;
              }
              return this.strip();
            };
            BN.prototype.imuln = function imuln(num) {
              assert(typeof num === 'number');
              var carry = 0;
              for (var i = 0; i < this.length; i++) {
                var w = this.words[i] * num;
                var lo = (w & 67108863) + (carry & 67108863);
                carry >>= 26;
                carry += (w / 67108864) | 0;
                carry += lo >>> 26;
                this.words[i] = lo & 67108863;
              }
              if (carry !== 0) {
                this.words[i] = carry;
                this.length++;
              }
              return this;
            };
            BN.prototype.muln = function muln(num) {
              return this.clone().imuln(num);
            };
            BN.prototype.sqr = function sqr() {
              return this.mul(this);
            };
            BN.prototype.isqr = function isqr() {
              return this.mul(this);
            };
            BN.prototype.ishln = function ishln(bits) {
              assert(typeof bits === 'number' && bits >= 0);
              var r = bits % 26;
              var s = (bits - r) / 26;
              var carryMask = (67108863 >>> (26 - r)) << (26 - r);
              if (r !== 0) {
                var carry = 0;
                for (var i = 0; i < this.length; i++) {
                  var newCarry = this.words[i] & carryMask;
                  var c = (this.words[i] - newCarry) << r;
                  this.words[i] = c | carry;
                  carry = newCarry >>> (26 - r);
                }
                if (carry) {
                  this.words[i] = carry;
                  this.length++;
                }
              }
              if (s !== 0) {
                for (var i = this.length - 1; i >= 0; i--)
                  this.words[i + s] = this.words[i];
                for (var i = 0; i < s; i++) this.words[i] = 0;
                this.length += s;
              }
              return this.strip();
            };
            BN.prototype.ishrn = function ishrn(bits, hint, extended) {
              assert(typeof bits === 'number' && bits >= 0);
              var h;
              if (hint) h = (hint - (hint % 26)) / 26;
              else h = 0;
              var r = bits % 26;
              var s = Math.min((bits - r) / 26, this.length);
              var mask = 67108863 ^ ((67108863 >>> r) << r);
              var maskedWords = extended;
              h -= s;
              h = Math.max(0, h);
              if (maskedWords) {
                for (var i = 0; i < s; i++)
                  maskedWords.words[i] = this.words[i];
                maskedWords.length = s;
              }
              if (s === 0) {
              } else if (this.length > s) {
                this.length -= s;
                for (var i = 0; i < this.length; i++)
                  this.words[i] = this.words[i + s];
              } else {
                this.words[0] = 0;
                this.length = 1;
              }
              var carry = 0;
              for (
                var i = this.length - 1;
                i >= 0 && (carry !== 0 || i >= h);
                i--
              ) {
                var word = this.words[i];
                this.words[i] = (carry << (26 - r)) | (word >>> r);
                carry = word & mask;
              }
              if (maskedWords && carry !== 0)
                maskedWords.words[maskedWords.length++] = carry;
              if (this.length === 0) {
                this.words[0] = 0;
                this.length = 1;
              }
              this.strip();
              return this;
            };
            BN.prototype.shln = function shln(bits) {
              return this.clone().ishln(bits);
            };
            BN.prototype.shrn = function shrn(bits) {
              return this.clone().ishrn(bits);
            };
            BN.prototype.testn = function testn(bit) {
              assert(typeof bit === 'number' && bit >= 0);
              var r = bit % 26;
              var s = (bit - r) / 26;
              var q = 1 << r;
              if (this.length <= s) {
                return false;
              }
              var w = this.words[s];
              return !!(w & q);
            };
            BN.prototype.imaskn = function imaskn(bits) {
              assert(typeof bits === 'number' && bits >= 0);
              var r = bits % 26;
              var s = (bits - r) / 26;
              assert(!this.sign, 'imaskn works only with positive numbers');
              if (r !== 0) s++;
              this.length = Math.min(s, this.length);
              if (r !== 0) {
                var mask = 67108863 ^ ((67108863 >>> r) << r);
                this.words[this.length - 1] &= mask;
              }
              return this.strip();
            };
            BN.prototype.maskn = function maskn(bits) {
              return this.clone().imaskn(bits);
            };
            BN.prototype.iaddn = function iaddn(num) {
              assert(typeof num === 'number');
              if (num < 0) return this.isubn(-num);
              if (this.sign) {
                if (this.length === 1 && this.words[0] < num) {
                  this.words[0] = num - this.words[0];
                  this.sign = false;
                  return this;
                }
                this.sign = false;
                this.isubn(num);
                this.sign = true;
                return this;
              }
              return this._iaddn(num);
            };
            BN.prototype._iaddn = function _iaddn(num) {
              this.words[0] += num;
              for (
                var i = 0;
                i < this.length && this.words[i] >= 67108864;
                i++
              ) {
                this.words[i] -= 67108864;
                if (i === this.length - 1) this.words[i + 1] = 1;
                else this.words[i + 1]++;
              }
              this.length = Math.max(this.length, i + 1);
              return this;
            };
            BN.prototype.isubn = function isubn(num) {
              assert(typeof num === 'number');
              if (num < 0) return this.iaddn(-num);
              if (this.sign) {
                this.sign = false;
                this.iaddn(num);
                this.sign = true;
                return this;
              }
              this.words[0] -= num;
              for (var i = 0; i < this.length && this.words[i] < 0; i++) {
                this.words[i] += 67108864;
                this.words[i + 1] -= 1;
              }
              return this.strip();
            };
            BN.prototype.addn = function addn(num) {
              return this.clone().iaddn(num);
            };
            BN.prototype.subn = function subn(num) {
              return this.clone().isubn(num);
            };
            BN.prototype.iabs = function iabs() {
              this.sign = false;
              return this;
            };
            BN.prototype.abs = function abs() {
              return this.clone().iabs();
            };
            BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
              var len = num.length + shift;
              var i;
              if (this.words.length < len) {
                var t = new Array(len);
                for (var i = 0; i < this.length; i++) t[i] = this.words[i];
                this.words = t;
              } else {
                i = this.length;
              }
              this.length = Math.max(this.length, len);
              for (; i < this.length; i++) this.words[i] = 0;
              var carry = 0;
              for (var i = 0; i < num.length; i++) {
                var w = this.words[i + shift] + carry;
                var right = num.words[i] * mul;
                w -= right & 67108863;
                carry = (w >> 26) - ((right / 67108864) | 0);
                this.words[i + shift] = w & 67108863;
              }
              for (; i < this.length - shift; i++) {
                var w = this.words[i + shift] + carry;
                carry = w >> 26;
                this.words[i + shift] = w & 67108863;
              }
              if (carry === 0) return this.strip();
              assert(carry === -1);
              carry = 0;
              for (var i = 0; i < this.length; i++) {
                var w = -this.words[i] + carry;
                carry = w >> 26;
                this.words[i] = w & 67108863;
              }
              this.sign = true;
              return this.strip();
            };
            BN.prototype._wordDiv = function _wordDiv(num, mode) {
              var shift = this.length - num.length;
              var a = this.clone();
              var b = num;
              var bhi = b.words[b.length - 1];
              var bhiBits = this._countBits(bhi);
              shift = 26 - bhiBits;
              if (shift !== 0) {
                b = b.shln(shift);
                a.ishln(shift);
                bhi = b.words[b.length - 1];
              }
              var m = a.length - b.length;
              var q;
              if (mode !== 'mod') {
                q = new BN(null);
                q.length = m + 1;
                q.words = new Array(q.length);
                for (var i = 0; i < q.length; i++) q.words[i] = 0;
              }
              var diff = a.clone()._ishlnsubmul(b, 1, m);
              if (!diff.sign) {
                a = diff;
                if (q) q.words[m] = 1;
              }
              for (var j = m - 1; j >= 0; j--) {
                var qj =
                  a.words[b.length + j] * 67108864 + a.words[b.length + j - 1];
                qj = Math.min((qj / bhi) | 0, 67108863);
                a._ishlnsubmul(b, qj, j);
                while (a.sign) {
                  qj--;
                  a.sign = false;
                  a._ishlnsubmul(b, 1, j);
                  if (a.cmpn(0) !== 0) a.sign = !a.sign;
                }
                if (q) q.words[j] = qj;
              }
              if (q) q.strip();
              a.strip();
              if (mode !== 'div' && shift !== 0) a.ishrn(shift);
              return { div: q ? q : null, mod: a };
            };
            BN.prototype.divmod = function divmod(num, mode) {
              assert(num.cmpn(0) !== 0);
              if (this.sign && !num.sign) {
                var res = this.neg().divmod(num, mode);
                var div;
                var mod;
                if (mode !== 'mod') div = res.div.neg();
                if (mode !== 'div')
                  mod = res.mod.cmpn(0) === 0 ? res.mod : num.sub(res.mod);
                return { div: div, mod: mod };
              } else if (!this.sign && num.sign) {
                var res = this.divmod(num.neg(), mode);
                var div;
                if (mode !== 'mod') div = res.div.neg();
                return { div: div, mod: res.mod };
              } else if (this.sign && num.sign) {
                return this.neg().divmod(num.neg(), mode);
              }
              if (num.length > this.length || this.cmp(num) < 0)
                return { div: new BN(0), mod: this };
              if (num.length === 1) {
                if (mode === 'div')
                  return { div: this.divn(num.words[0]), mod: null };
                else if (mode === 'mod')
                  return { div: null, mod: new BN(this.modn(num.words[0])) };
                return {
                  div: this.divn(num.words[0]),
                  mod: new BN(this.modn(num.words[0]))
                };
              }
              return this._wordDiv(num, mode);
            };
            BN.prototype.div = function div(num) {
              return this.divmod(num, 'div').div;
            };
            BN.prototype.mod = function mod(num) {
              return this.divmod(num, 'mod').mod;
            };
            BN.prototype.divRound = function divRound(num) {
              var dm = this.divmod(num);
              if (dm.mod.cmpn(0) === 0) return dm.div;
              var mod = dm.div.sign ? dm.mod.isub(num) : dm.mod;
              var half = num.shrn(1);
              var r2 = num.andln(1);
              var cmp = mod.cmp(half);
              if (cmp < 0 || (r2 === 1 && cmp === 0)) return dm.div;
              return dm.div.sign ? dm.div.isubn(1) : dm.div.iaddn(1);
            };
            BN.prototype.modn = function modn(num) {
              assert(num <= 67108863);
              var p = (1 << 26) % num;
              var acc = 0;
              for (var i = this.length - 1; i >= 0; i--)
                acc = (p * acc + this.words[i]) % num;
              return acc;
            };
            BN.prototype.idivn = function idivn(num) {
              assert(num <= 67108863);
              var carry = 0;
              for (var i = this.length - 1; i >= 0; i--) {
                var w = this.words[i] + carry * 67108864;
                this.words[i] = (w / num) | 0;
                carry = w % num;
              }
              return this.strip();
            };
            BN.prototype.divn = function divn(num) {
              return this.clone().idivn(num);
            };
            BN.prototype.egcd = function egcd(p) {
              assert(!p.sign);
              assert(p.cmpn(0) !== 0);
              var x = this;
              var y = p.clone();
              if (x.sign) x = x.mod(p);
              else x = x.clone();
              var A = new BN(1);
              var B = new BN(0);
              var C = new BN(0);
              var D = new BN(1);
              var g = 0;
              while (x.isEven() && y.isEven()) {
                x.ishrn(1);
                y.ishrn(1);
                ++g;
              }
              var yp = y.clone();
              var xp = x.clone();
              while (x.cmpn(0) !== 0) {
                while (x.isEven()) {
                  x.ishrn(1);
                  if (A.isEven() && B.isEven()) {
                    A.ishrn(1);
                    B.ishrn(1);
                  } else {
                    A.iadd(yp).ishrn(1);
                    B.isub(xp).ishrn(1);
                  }
                }
                while (y.isEven()) {
                  y.ishrn(1);
                  if (C.isEven() && D.isEven()) {
                    C.ishrn(1);
                    D.ishrn(1);
                  } else {
                    C.iadd(yp).ishrn(1);
                    D.isub(xp).ishrn(1);
                  }
                }
                if (x.cmp(y) >= 0) {
                  x.isub(y);
                  A.isub(C);
                  B.isub(D);
                } else {
                  y.isub(x);
                  C.isub(A);
                  D.isub(B);
                }
              }
              return { a: C, b: D, gcd: y.ishln(g) };
            };
            BN.prototype._invmp = function _invmp(p) {
              assert(!p.sign);
              assert(p.cmpn(0) !== 0);
              var a = this;
              var b = p.clone();
              if (a.sign) a = a.mod(p);
              else a = a.clone();
              var x1 = new BN(1);
              var x2 = new BN(0);
              var delta = b.clone();
              while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
                while (a.isEven()) {
                  a.ishrn(1);
                  if (x1.isEven()) x1.ishrn(1);
                  else x1.iadd(delta).ishrn(1);
                }
                while (b.isEven()) {
                  b.ishrn(1);
                  if (x2.isEven()) x2.ishrn(1);
                  else x2.iadd(delta).ishrn(1);
                }
                if (a.cmp(b) >= 0) {
                  a.isub(b);
                  x1.isub(x2);
                } else {
                  b.isub(a);
                  x2.isub(x1);
                }
              }
              if (a.cmpn(1) === 0) return x1;
              else return x2;
            };
            BN.prototype.gcd = function gcd(num) {
              if (this.cmpn(0) === 0) return num.clone();
              if (num.cmpn(0) === 0) return this.clone();
              var a = this.clone();
              var b = num.clone();
              a.sign = false;
              b.sign = false;
              for (var shift = 0; a.isEven() && b.isEven(); shift++) {
                a.ishrn(1);
                b.ishrn(1);
              }
              do {
                while (a.isEven()) a.ishrn(1);
                while (b.isEven()) b.ishrn(1);
                var r = a.cmp(b);
                if (r < 0) {
                  var t = a;
                  a = b;
                  b = t;
                } else if (r === 0 || b.cmpn(1) === 0) {
                  break;
                }
                a.isub(b);
              } while (true);
              return b.ishln(shift);
            };
            BN.prototype.invm = function invm(num) {
              return this.egcd(num).a.mod(num);
            };
            BN.prototype.isEven = function isEven() {
              return (this.words[0] & 1) === 0;
            };
            BN.prototype.isOdd = function isOdd() {
              return (this.words[0] & 1) === 1;
            };
            BN.prototype.andln = function andln(num) {
              return this.words[0] & num;
            };
            BN.prototype.bincn = function bincn(bit) {
              assert(typeof bit === 'number');
              var r = bit % 26;
              var s = (bit - r) / 26;
              var q = 1 << r;
              if (this.length <= s) {
                for (var i = this.length; i < s + 1; i++) this.words[i] = 0;
                this.words[s] |= q;
                this.length = s + 1;
                return this;
              }
              var carry = q;
              for (var i = s; carry !== 0 && i < this.length; i++) {
                var w = this.words[i];
                w += carry;
                carry = w >>> 26;
                w &= 67108863;
                this.words[i] = w;
              }
              if (carry !== 0) {
                this.words[i] = carry;
                this.length++;
              }
              return this;
            };
            BN.prototype.cmpn = function cmpn(num) {
              var sign = num < 0;
              if (sign) num = -num;
              if (this.sign && !sign) return -1;
              else if (!this.sign && sign) return 1;
              num &= 67108863;
              this.strip();
              var res;
              if (this.length > 1) {
                res = 1;
              } else {
                var w = this.words[0];
                res = w === num ? 0 : w < num ? -1 : 1;
              }
              if (this.sign) res = -res;
              return res;
            };
            BN.prototype.cmp = function cmp(num) {
              if (this.sign && !num.sign) return -1;
              else if (!this.sign && num.sign) return 1;
              var res = this.ucmp(num);
              if (this.sign) return -res;
              else return res;
            };
            BN.prototype.ucmp = function ucmp(num) {
              if (this.length > num.length) return 1;
              else if (this.length < num.length) return -1;
              var res = 0;
              for (var i = this.length - 1; i >= 0; i--) {
                var a = this.words[i];
                var b = num.words[i];
                if (a === b) continue;
                if (a < b) res = -1;
                else if (a > b) res = 1;
                break;
              }
              return res;
            };
            BN.red = function red(num) {
              return new Red(num);
            };
            BN.prototype.toRed = function toRed(ctx) {
              assert(!this.red, 'Already a number in reduction context');
              assert(!this.sign, 'red works only with positives');
              return ctx.convertTo(this)._forceRed(ctx);
            };
            BN.prototype.fromRed = function fromRed() {
              assert(
                this.red,
                'fromRed works only with numbers in reduction context'
              );
              return this.red.convertFrom(this);
            };
            BN.prototype._forceRed = function _forceRed(ctx) {
              this.red = ctx;
              return this;
            };
            BN.prototype.forceRed = function forceRed(ctx) {
              assert(!this.red, 'Already a number in reduction context');
              return this._forceRed(ctx);
            };
            BN.prototype.redAdd = function redAdd(num) {
              assert(this.red, 'redAdd works only with red numbers');
              return this.red.add(this, num);
            };
            BN.prototype.redIAdd = function redIAdd(num) {
              assert(this.red, 'redIAdd works only with red numbers');
              return this.red.iadd(this, num);
            };
            BN.prototype.redSub = function redSub(num) {
              assert(this.red, 'redSub works only with red numbers');
              return this.red.sub(this, num);
            };
            BN.prototype.redISub = function redISub(num) {
              assert(this.red, 'redISub works only with red numbers');
              return this.red.isub(this, num);
            };
            BN.prototype.redShl = function redShl(num) {
              assert(this.red, 'redShl works only with red numbers');
              return this.red.shl(this, num);
            };
            BN.prototype.redMul = function redMul(num) {
              assert(this.red, 'redMul works only with red numbers');
              this.red._verify2(this, num);
              return this.red.mul(this, num);
            };
            BN.prototype.redIMul = function redIMul(num) {
              assert(this.red, 'redMul works only with red numbers');
              this.red._verify2(this, num);
              return this.red.imul(this, num);
            };
            BN.prototype.redSqr = function redSqr() {
              assert(this.red, 'redSqr works only with red numbers');
              this.red._verify1(this);
              return this.red.sqr(this);
            };
            BN.prototype.redISqr = function redISqr() {
              assert(this.red, 'redISqr works only with red numbers');
              this.red._verify1(this);
              return this.red.isqr(this);
            };
            BN.prototype.redSqrt = function redSqrt() {
              assert(this.red, 'redSqrt works only with red numbers');
              this.red._verify1(this);
              return this.red.sqrt(this);
            };
            BN.prototype.redInvm = function redInvm() {
              assert(this.red, 'redInvm works only with red numbers');
              this.red._verify1(this);
              return this.red.invm(this);
            };
            BN.prototype.redNeg = function redNeg() {
              assert(this.red, 'redNeg works only with red numbers');
              this.red._verify1(this);
              return this.red.neg(this);
            };
            BN.prototype.redPow = function redPow(num) {
              assert(this.red && !num.red, 'redPow(normalNum)');
              this.red._verify1(this);
              return this.red.pow(this, num);
            };
            var primes = { k256: null, p224: null, p192: null, p25519: null };
            function MPrime(name, p) {
              this.name = name;
              this.p = new BN(p, 16);
              this.n = this.p.bitLength();
              this.k = new BN(1).ishln(this.n).isub(this.p);
              this.tmp = this._tmp();
            }
            MPrime.prototype._tmp = function _tmp() {
              var tmp = new BN(null);
              tmp.words = new Array(Math.ceil(this.n / 13));
              return tmp;
            };
            MPrime.prototype.ireduce = function ireduce(num) {
              var r = num;
              var rlen;
              do {
                this.split(r, this.tmp);
                r = this.imulK(r);
                r = r.iadd(this.tmp);
                rlen = r.bitLength();
              } while (rlen > this.n);
              var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
              if (cmp === 0) {
                r.words[0] = 0;
                r.length = 1;
              } else if (cmp > 0) {
                r.isub(this.p);
              } else {
                r.strip();
              }
              return r;
            };
            MPrime.prototype.split = function split(input, out) {
              input.ishrn(this.n, 0, out);
            };
            MPrime.prototype.imulK = function imulK(num) {
              return num.imul(this.k);
            };
            function K256() {
              MPrime.call(
                this,
                'k256',
                'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f'
              );
            }
            inherits(K256, MPrime);
            K256.prototype.split = function split(input, output) {
              var mask = 4194303;
              var outLen = Math.min(input.length, 9);
              for (var i = 0; i < outLen; i++) output.words[i] = input.words[i];
              output.length = outLen;
              if (input.length <= 9) {
                input.words[0] = 0;
                input.length = 1;
                return;
              }
              var prev = input.words[9];
              output.words[output.length++] = prev & mask;
              for (var i = 10; i < input.length; i++) {
                var next = input.words[i];
                input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
                prev = next;
              }
              input.words[i - 10] = prev >>> 22;
              input.length -= 9;
            };
            K256.prototype.imulK = function imulK(num) {
              num.words[num.length] = 0;
              num.words[num.length + 1] = 0;
              num.length += 2;
              var hi;
              var lo = 0;
              for (var i = 0; i < num.length; i++) {
                var w = num.words[i];
                hi = w * 64;
                lo += w * 977;
                hi += (lo / 67108864) | 0;
                lo &= 67108863;
                num.words[i] = lo;
                lo = hi;
              }
              if (num.words[num.length - 1] === 0) {
                num.length--;
                if (num.words[num.length - 1] === 0) num.length--;
              }
              return num;
            };
            function P224() {
              MPrime.call(
                this,
                'p224',
                'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001'
              );
            }
            inherits(P224, MPrime);
            function P192() {
              MPrime.call(
                this,
                'p192',
                'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff'
              );
            }
            inherits(P192, MPrime);
            function P25519() {
              MPrime.call(
                this,
                '25519',
                '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed'
              );
            }
            inherits(P25519, MPrime);
            P25519.prototype.imulK = function imulK(num) {
              var carry = 0;
              for (var i = 0; i < num.length; i++) {
                var hi = num.words[i] * 19 + carry;
                var lo = hi & 67108863;
                hi >>>= 26;
                num.words[i] = lo;
                carry = hi;
              }
              if (carry !== 0) num.words[num.length++] = carry;
              return num;
            };
            BN._prime = function prime(name) {
              if (primes[name]) return primes[name];
              var prime;
              if (name === 'k256') prime = new K256();
              else if (name === 'p224') prime = new P224();
              else if (name === 'p192') prime = new P192();
              else if (name === 'p25519') prime = new P25519();
              else throw new Error('Unknown prime ' + name);
              primes[name] = prime;
              return prime;
            };
            function Red(m) {
              if (typeof m === 'string') {
                var prime = BN._prime(m);
                this.m = prime.p;
                this.prime = prime;
              } else {
                this.m = m;
                this.prime = null;
              }
            }
            Red.prototype._verify1 = function _verify1(a) {
              assert(!a.sign, 'red works only with positives');
              assert(a.red, 'red works only with red numbers');
            };
            Red.prototype._verify2 = function _verify2(a, b) {
              assert(!a.sign && !b.sign, 'red works only with positives');
              assert(
                a.red && a.red === b.red,
                'red works only with red numbers'
              );
            };
            Red.prototype.imod = function imod(a) {
              if (this.prime) return this.prime.ireduce(a)._forceRed(this);
              return a.mod(this.m)._forceRed(this);
            };
            Red.prototype.neg = function neg(a) {
              var r = a.clone();
              r.sign = !r.sign;
              return r.iadd(this.m)._forceRed(this);
            };
            Red.prototype.add = function add(a, b) {
              this._verify2(a, b);
              var res = a.add(b);
              if (res.cmp(this.m) >= 0) res.isub(this.m);
              return res._forceRed(this);
            };
            Red.prototype.iadd = function iadd(a, b) {
              this._verify2(a, b);
              var res = a.iadd(b);
              if (res.cmp(this.m) >= 0) res.isub(this.m);
              return res;
            };
            Red.prototype.sub = function sub(a, b) {
              this._verify2(a, b);
              var res = a.sub(b);
              if (res.cmpn(0) < 0) res.iadd(this.m);
              return res._forceRed(this);
            };
            Red.prototype.isub = function isub(a, b) {
              this._verify2(a, b);
              var res = a.isub(b);
              if (res.cmpn(0) < 0) res.iadd(this.m);
              return res;
            };
            Red.prototype.shl = function shl(a, num) {
              this._verify1(a);
              return this.imod(a.shln(num));
            };
            Red.prototype.imul = function imul(a, b) {
              this._verify2(a, b);
              return this.imod(a.imul(b));
            };
            Red.prototype.mul = function mul(a, b) {
              this._verify2(a, b);
              return this.imod(a.mul(b));
            };
            Red.prototype.isqr = function isqr(a) {
              return this.imul(a, a);
            };
            Red.prototype.sqr = function sqr(a) {
              return this.mul(a, a);
            };
            Red.prototype.sqrt = function sqrt(a) {
              if (a.cmpn(0) === 0) return a.clone();
              var mod3 = this.m.andln(3);
              assert(mod3 % 2 === 1);
              if (mod3 === 3) {
                var pow = this.m.add(new BN(1)).ishrn(2);
                var r = this.pow(a, pow);
                return r;
              }
              var q = this.m.subn(1);
              var s = 0;
              while (q.cmpn(0) !== 0 && q.andln(1) === 0) {
                s++;
                q.ishrn(1);
              }
              assert(q.cmpn(0) !== 0);
              var one = new BN(1).toRed(this);
              var nOne = one.redNeg();
              var lpow = this.m.subn(1).ishrn(1);
              var z = this.m.bitLength();
              z = new BN(2 * z * z).toRed(this);
              while (this.pow(z, lpow).cmp(nOne) !== 0) z.redIAdd(nOne);
              var c = this.pow(z, q);
              var r = this.pow(a, q.addn(1).ishrn(1));
              var t = this.pow(a, q);
              var m = s;
              while (t.cmp(one) !== 0) {
                var tmp = t;
                for (var i = 0; tmp.cmp(one) !== 0; i++) tmp = tmp.redSqr();
                assert(i < m);
                var b = this.pow(c, new BN(1).ishln(m - i - 1));
                r = r.redMul(b);
                c = b.redSqr();
                t = t.redMul(c);
                m = i;
              }
              return r;
            };
            Red.prototype.invm = function invm(a) {
              var inv = a._invmp(this.m);
              if (inv.sign) {
                inv.sign = false;
                return this.imod(inv).redNeg();
              } else {
                return this.imod(inv);
              }
            };
            Red.prototype.pow = function pow(a, num) {
              var w = [];
              if (num.cmpn(0) === 0) return new BN(1);
              var q = num.clone();
              while (q.cmpn(0) !== 0) {
                w.push(q.andln(1));
                q.ishrn(1);
              }
              var res = a;
              for (var i = 0; i < w.length; i++, res = this.sqr(res))
                if (w[i] !== 0) break;
              if (++i < w.length) {
                for (
                  var q = this.sqr(res);
                  i < w.length;
                  i++, q = this.sqr(q)
                ) {
                  if (w[i] === 0) continue;
                  res = this.mul(res, q);
                }
              }
              return res;
            };
            Red.prototype.convertTo = function convertTo(num) {
              var r = num.mod(this.m);
              if (r === num) return r.clone();
              else return r;
            };
            Red.prototype.convertFrom = function convertFrom(num) {
              var res = num.clone();
              res.red = null;
              return res;
            };
            BN.mont = function mont(num) {
              return new Mont(num);
            };
            function Mont(m) {
              Red.call(this, m);
              this.shift = this.m.bitLength();
              if (this.shift % 26 !== 0) this.shift += 26 - (this.shift % 26);
              this.r = new BN(1).ishln(this.shift);
              this.r2 = this.imod(this.r.sqr());
              this.rinv = this.r._invmp(this.m);
              this.minv = this.rinv
                .mul(this.r)
                .isubn(1)
                .div(this.m);
              this.minv.sign = true;
              this.minv = this.minv.mod(this.r);
            }
            inherits(Mont, Red);
            Mont.prototype.convertTo = function convertTo(num) {
              return this.imod(num.shln(this.shift));
            };
            Mont.prototype.convertFrom = function convertFrom(num) {
              var r = this.imod(num.mul(this.rinv));
              r.red = null;
              return r;
            };
            Mont.prototype.imul = function imul(a, b) {
              if (a.cmpn(0) === 0 || b.cmpn(0) === 0) {
                a.words[0] = 0;
                a.length = 1;
                return a;
              }
              var t = a.imul(b);
              var c = t
                .maskn(this.shift)
                .mul(this.minv)
                .imaskn(this.shift)
                .mul(this.m);
              var u = t.isub(c).ishrn(this.shift);
              var res = u;
              if (u.cmp(this.m) >= 0) res = u.isub(this.m);
              else if (u.cmpn(0) < 0) res = u.iadd(this.m);
              return res._forceRed(this);
            };
            Mont.prototype.mul = function mul(a, b) {
              if (a.cmpn(0) === 0 || b.cmpn(0) === 0)
                return new BN(0)._forceRed(this);
              var t = a.mul(b);
              var c = t
                .maskn(this.shift)
                .mul(this.minv)
                .imaskn(this.shift)
                .mul(this.m);
              var u = t.isub(c).ishrn(this.shift);
              var res = u;
              if (u.cmp(this.m) >= 0) res = u.isub(this.m);
              else if (u.cmpn(0) < 0) res = u.iadd(this.m);
              return res._forceRed(this);
            };
            Mont.prototype.invm = function invm(a) {
              var res = this.imod(a._invmp(this.m).mul(this.r2));
              return res._forceRed(this);
            };
          })(typeof module === 'undefined' || module, this);
        },
        {}
      ],
      407: [
        function(require, module, exports) {
          (function(module, exports) {
            'use strict';
            function assert(val, msg) {
              if (!val) throw new Error(msg || 'Assertion failed');
            }
            function inherits(ctor, superCtor) {
              ctor.super_ = superCtor;
              var TempCtor = function() {};
              TempCtor.prototype = superCtor.prototype;
              ctor.prototype = new TempCtor();
              ctor.prototype.constructor = ctor;
            }
            function BN(number, base, endian) {
              if (
                number !== null &&
                typeof number === 'object' &&
                Array.isArray(number.words)
              ) {
                return number;
              }
              this.sign = false;
              this.words = null;
              this.length = 0;
              this.red = null;
              if (base === 'le' || base === 'be') {
                endian = base;
                base = 10;
              }
              if (number !== null)
                this._init(number || 0, base || 10, endian || 'be');
            }
            if (typeof module === 'object') module.exports = BN;
            else exports.BN = BN;
            BN.BN = BN;
            BN.wordSize = 26;
            BN.max = function max(left, right) {
              if (left.cmp(right) > 0) return left;
              else return right;
            };
            BN.min = function min(left, right) {
              if (left.cmp(right) < 0) return left;
              else return right;
            };
            BN.prototype._init = function init(number, base, endian) {
              if (typeof number === 'number') {
                return this._initNumber(number, base, endian);
              } else if (typeof number === 'object') {
                return this._initArray(number, base, endian);
              }
              if (base === 'hex') base = 16;
              assert(base === (base | 0) && base >= 2 && base <= 36);
              number = number.toString().replace(/\s+/g, '');
              var start = 0;
              if (number[0] === '-') start++;
              if (base === 16) this._parseHex(number, start);
              else this._parseBase(number, base, start);
              if (number[0] === '-') this.sign = true;
              this.strip();
              if (endian !== 'le') return;
              this._initArray(this.toArray(), base, endian);
            };
            BN.prototype._initNumber = function _initNumber(
              number,
              base,
              endian
            ) {
              if (number < 0) {
                this.sign = true;
                number = -number;
              }
              if (number < 67108864) {
                this.words = [number & 67108863];
                this.length = 1;
              } else if (number < 4503599627370496) {
                this.words = [
                  number & 67108863,
                  (number / 67108864) & 67108863
                ];
                this.length = 2;
              } else {
                assert(number < 9007199254740992);
                this.words = [
                  number & 67108863,
                  (number / 67108864) & 67108863,
                  1
                ];
                this.length = 3;
              }
              if (endian !== 'le') return;
              this._initArray(this.toArray(), base, endian);
            };
            BN.prototype._initArray = function _initArray(
              number,
              base,
              endian
            ) {
              assert(typeof number.length === 'number');
              if (number.length <= 0) {
                this.words = [0];
                this.length = 1;
                return this;
              }
              this.length = Math.ceil(number.length / 3);
              this.words = new Array(this.length);
              for (var i = 0; i < this.length; i++) this.words[i] = 0;
              var off = 0;
              if (endian === 'be') {
                for (var i = number.length - 1, j = 0; i >= 0; i -= 3) {
                  var w =
                    number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
                  this.words[j] |= (w << off) & 67108863;
                  this.words[j + 1] = (w >>> (26 - off)) & 67108863;
                  off += 24;
                  if (off >= 26) {
                    off -= 26;
                    j++;
                  }
                }
              } else if (endian === 'le') {
                for (var i = 0, j = 0; i < number.length; i += 3) {
                  var w =
                    number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
                  this.words[j] |= (w << off) & 67108863;
                  this.words[j + 1] = (w >>> (26 - off)) & 67108863;
                  off += 24;
                  if (off >= 26) {
                    off -= 26;
                    j++;
                  }
                }
              }
              return this.strip();
            };
            function parseHex(str, start, end) {
              var r = 0;
              var len = Math.min(str.length, end);
              for (var i = start; i < len; i++) {
                var c = str.charCodeAt(i) - 48;
                r <<= 4;
                if (c >= 49 && c <= 54) r |= c - 49 + 10;
                else if (c >= 17 && c <= 22) r |= c - 17 + 10;
                else r |= c & 15;
              }
              return r;
            }
            BN.prototype._parseHex = function _parseHex(number, start) {
              this.length = Math.ceil((number.length - start) / 6);
              this.words = new Array(this.length);
              for (var i = 0; i < this.length; i++) this.words[i] = 0;
              var off = 0;
              for (var i = number.length - 6, j = 0; i >= start; i -= 6) {
                var w = parseHex(number, i, i + 6);
                this.words[j] |= (w << off) & 67108863;
                this.words[j + 1] |= (w >>> (26 - off)) & 4194303;
                off += 24;
                if (off >= 26) {
                  off -= 26;
                  j++;
                }
              }
              if (i + 6 !== start) {
                var w = parseHex(number, start, i + 6);
                this.words[j] |= (w << off) & 67108863;
                this.words[j + 1] |= (w >>> (26 - off)) & 4194303;
              }
              this.strip();
            };
            function parseBase(str, start, end, mul) {
              var r = 0;
              var len = Math.min(str.length, end);
              for (var i = start; i < len; i++) {
                var c = str.charCodeAt(i) - 48;
                r *= mul;
                if (c >= 49) r += c - 49 + 10;
                else if (c >= 17) r += c - 17 + 10;
                else r += c;
              }
              return r;
            }
            BN.prototype._parseBase = function _parseBase(number, base, start) {
              this.words = [0];
              this.length = 1;
              for (
                var limbLen = 0, limbPow = 1;
                limbPow <= 67108863;
                limbPow *= base
              )
                limbLen++;
              limbLen--;
              limbPow = (limbPow / base) | 0;
              var total = number.length - start;
              var mod = total % limbLen;
              var end = Math.min(total, total - mod) + start;
              var word = 0;
              for (var i = start; i < end; i += limbLen) {
                word = parseBase(number, i, i + limbLen, base);
                this.imuln(limbPow);
                if (this.words[0] + word < 67108864) this.words[0] += word;
                else this._iaddn(word);
              }
              if (mod !== 0) {
                var pow = 1;
                var word = parseBase(number, i, number.length, base);
                for (var i = 0; i < mod; i++) pow *= base;
                this.imuln(pow);
                if (this.words[0] + word < 67108864) this.words[0] += word;
                else this._iaddn(word);
              }
            };
            BN.prototype.copy = function copy(dest) {
              dest.words = new Array(this.length);
              for (var i = 0; i < this.length; i++)
                dest.words[i] = this.words[i];
              dest.length = this.length;
              dest.sign = this.sign;
              dest.red = this.red;
            };
            BN.prototype.clone = function clone() {
              var r = new BN(null);
              this.copy(r);
              return r;
            };
            BN.prototype.strip = function strip() {
              while (this.length > 1 && this.words[this.length - 1] === 0)
                this.length--;
              return this._normSign();
            };
            BN.prototype._normSign = function _normSign() {
              if (this.length === 1 && this.words[0] === 0) this.sign = false;
              return this;
            };
            BN.prototype.inspect = function inspect() {
              return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
            };
            var zeros = [
              '',
              '0',
              '00',
              '000',
              '0000',
              '00000',
              '000000',
              '0000000',
              '00000000',
              '000000000',
              '0000000000',
              '00000000000',
              '000000000000',
              '0000000000000',
              '00000000000000',
              '000000000000000',
              '0000000000000000',
              '00000000000000000',
              '000000000000000000',
              '0000000000000000000',
              '00000000000000000000',
              '000000000000000000000',
              '0000000000000000000000',
              '00000000000000000000000',
              '000000000000000000000000',
              '0000000000000000000000000'
            ];
            var groupSizes = [
              0,
              0,
              25,
              16,
              12,
              11,
              10,
              9,
              8,
              8,
              7,
              7,
              7,
              7,
              6,
              6,
              6,
              6,
              6,
              6,
              6,
              5,
              5,
              5,
              5,
              5,
              5,
              5,
              5,
              5,
              5,
              5,
              5,
              5,
              5,
              5,
              5
            ];
            var groupBases = [
              0,
              0,
              33554432,
              43046721,
              16777216,
              48828125,
              60466176,
              40353607,
              16777216,
              43046721,
              1e7,
              19487171,
              35831808,
              62748517,
              7529536,
              11390625,
              16777216,
              24137569,
              34012224,
              47045881,
              64e6,
              4084101,
              5153632,
              6436343,
              7962624,
              9765625,
              11881376,
              14348907,
              17210368,
              20511149,
              243e5,
              28629151,
              33554432,
              39135393,
              45435424,
              52521875,
              60466176
            ];
            BN.prototype.toString = function toString(base, padding) {
              base = base || 10;
              var padding = padding | 0 || 1;
              if (base === 16 || base === 'hex') {
                var out = '';
                var off = 0;
                var carry = 0;
                for (var i = 0; i < this.length; i++) {
                  var w = this.words[i];
                  var word = (((w << off) | carry) & 16777215).toString(16);
                  carry = (w >>> (24 - off)) & 16777215;
                  if (carry !== 0 || i !== this.length - 1)
                    out = zeros[6 - word.length] + word + out;
                  else out = word + out;
                  off += 2;
                  if (off >= 26) {
                    off -= 26;
                    i--;
                  }
                }
                if (carry !== 0) out = carry.toString(16) + out;
                while (out.length % padding !== 0) out = '0' + out;
                if (this.sign) out = '-' + out;
                return out;
              } else if (base === (base | 0) && base >= 2 && base <= 36) {
                var groupSize = groupSizes[base];
                var groupBase = groupBases[base];
                var out = '';
                var c = this.clone();
                c.sign = false;
                while (c.cmpn(0) !== 0) {
                  var r = c.modn(groupBase).toString(base);
                  c = c.idivn(groupBase);
                  if (c.cmpn(0) !== 0)
                    out = zeros[groupSize - r.length] + r + out;
                  else out = r + out;
                }
                if (this.cmpn(0) === 0) out = '0' + out;
                while (out.length % padding !== 0) out = '0' + out;
                if (this.sign) out = '-' + out;
                return out;
              } else {
                assert(false, 'Base should be between 2 and 36');
              }
            };
            BN.prototype.toJSON = function toJSON() {
              return this.toString(16);
            };
            BN.prototype.toArray = function toArray(endian, length) {
              this.strip();
              var littleEndian = endian === 'le';
              var res = new Array(this.byteLength());
              res[0] = 0;
              var q = this.clone();
              if (!littleEndian) {
                for (var i = 0; q.cmpn(0) !== 0; i++) {
                  var b = q.andln(255);
                  q.iushrn(8);
                  res[res.length - i - 1] = b;
                }
              } else {
                for (var i = 0; q.cmpn(0) !== 0; i++) {
                  var b = q.andln(255);
                  q.iushrn(8);
                  res[i] = b;
                }
              }
              if (length) {
                assert(
                  res.length <= length,
                  'byte array longer than desired length'
                );
                while (res.length < length) {
                  if (littleEndian) res.push(0);
                  else res.unshift(0);
                }
              }
              return res;
            };
            if (Math.clz32) {
              BN.prototype._countBits = function _countBits(w) {
                return 32 - Math.clz32(w);
              };
            } else {
              BN.prototype._countBits = function _countBits(w) {
                var t = w;
                var r = 0;
                if (t >= 4096) {
                  r += 13;
                  t >>>= 13;
                }
                if (t >= 64) {
                  r += 7;
                  t >>>= 7;
                }
                if (t >= 8) {
                  r += 4;
                  t >>>= 4;
                }
                if (t >= 2) {
                  r += 2;
                  t >>>= 2;
                }
                return r + t;
              };
            }
            BN.prototype._zeroBits = function _zeroBits(w) {
              if (w === 0) return 26;
              var t = w;
              var r = 0;
              if ((t & 8191) === 0) {
                r += 13;
                t >>>= 13;
              }
              if ((t & 127) === 0) {
                r += 7;
                t >>>= 7;
              }
              if ((t & 15) === 0) {
                r += 4;
                t >>>= 4;
              }
              if ((t & 3) === 0) {
                r += 2;
                t >>>= 2;
              }
              if ((t & 1) === 0) r++;
              return r;
            };
            BN.prototype.bitLength = function bitLength() {
              var hi = 0;
              var w = this.words[this.length - 1];
              var hi = this._countBits(w);
              return (this.length - 1) * 26 + hi;
            };
            function toBitArray(num) {
              var w = new Array(num.bitLength());
              for (var bit = 0; bit < w.length; bit++) {
                var off = (bit / 26) | 0;
                var wbit = bit % 26;
                w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
              }
              return w;
            }
            BN.prototype.zeroBits = function zeroBits() {
              if (this.cmpn(0) === 0) return 0;
              var r = 0;
              for (var i = 0; i < this.length; i++) {
                var b = this._zeroBits(this.words[i]);
                r += b;
                if (b !== 26) break;
              }
              return r;
            };
            BN.prototype.byteLength = function byteLength() {
              return Math.ceil(this.bitLength() / 8);
            };
            BN.prototype.neg = function neg() {
              if (this.cmpn(0) === 0) return this.clone();
              var r = this.clone();
              r.sign = !this.sign;
              return r;
            };
            BN.prototype.iuor = function iuor(num) {
              while (this.length < num.length) this.words[this.length++] = 0;
              for (var i = 0; i < num.length; i++)
                this.words[i] = this.words[i] | num.words[i];
              return this.strip();
            };
            BN.prototype.ior = function ior(num) {
              assert(!this.sign && !num.sign);
              return this.iuor(num);
            };
            BN.prototype.or = function or(num) {
              if (this.length > num.length) return this.clone().ior(num);
              else return num.clone().ior(this);
            };
            BN.prototype.uor = function uor(num) {
              if (this.length > num.length) return this.clone().iuor(num);
              else return num.clone().iuor(this);
            };
            BN.prototype.iuand = function iuand(num) {
              var b;
              if (this.length > num.length) b = num;
              else b = this;
              for (var i = 0; i < b.length; i++)
                this.words[i] = this.words[i] & num.words[i];
              this.length = b.length;
              return this.strip();
            };
            BN.prototype.iand = function iand(num) {
              assert(!this.sign && !num.sign);
              return this.iuand(num);
            };
            BN.prototype.and = function and(num) {
              if (this.length > num.length) return this.clone().iand(num);
              else return num.clone().iand(this);
            };
            BN.prototype.uand = function uand(num) {
              if (this.length > num.length) return this.clone().iuand(num);
              else return num.clone().iuand(this);
            };
            BN.prototype.iuxor = function iuxor(num) {
              var a;
              var b;
              if (this.length > num.length) {
                a = this;
                b = num;
              } else {
                a = num;
                b = this;
              }
              for (var i = 0; i < b.length; i++)
                this.words[i] = a.words[i] ^ b.words[i];
              if (this !== a)
                for (; i < a.length; i++) this.words[i] = a.words[i];
              this.length = a.length;
              return this.strip();
            };
            BN.prototype.ixor = function ixor(num) {
              assert(!this.sign && !num.sign);
              return this.iuxor(num);
            };
            BN.prototype.xor = function xor(num) {
              if (this.length > num.length) return this.clone().ixor(num);
              else return num.clone().ixor(this);
            };
            BN.prototype.uxor = function uxor(num) {
              if (this.length > num.length) return this.clone().iuxor(num);
              else return num.clone().iuxor(this);
            };
            BN.prototype.setn = function setn(bit, val) {
              assert(typeof bit === 'number' && bit >= 0);
              var off = (bit / 26) | 0;
              var wbit = bit % 26;
              while (this.length <= off) this.words[this.length++] = 0;
              if (val) this.words[off] = this.words[off] | (1 << wbit);
              else this.words[off] = this.words[off] & ~(1 << wbit);
              return this.strip();
            };
            BN.prototype.iadd = function iadd(num) {
              if (this.sign && !num.sign) {
                this.sign = false;
                var r = this.isub(num);
                this.sign = !this.sign;
                return this._normSign();
              } else if (!this.sign && num.sign) {
                num.sign = false;
                var r = this.isub(num);
                num.sign = true;
                return r._normSign();
              }
              var a;
              var b;
              if (this.length > num.length) {
                a = this;
                b = num;
              } else {
                a = num;
                b = this;
              }
              var carry = 0;
              for (var i = 0; i < b.length; i++) {
                var r = a.words[i] + b.words[i] + carry;
                this.words[i] = r & 67108863;
                carry = r >>> 26;
              }
              for (; carry !== 0 && i < a.length; i++) {
                var r = a.words[i] + carry;
                this.words[i] = r & 67108863;
                carry = r >>> 26;
              }
              this.length = a.length;
              if (carry !== 0) {
                this.words[this.length] = carry;
                this.length++;
              } else if (a !== this) {
                for (; i < a.length; i++) this.words[i] = a.words[i];
              }
              return this;
            };
            BN.prototype.add = function add(num) {
              if (num.sign && !this.sign) {
                num.sign = false;
                var res = this.sub(num);
                num.sign = true;
                return res;
              } else if (!num.sign && this.sign) {
                this.sign = false;
                var res = num.sub(this);
                this.sign = true;
                return res;
              }
              if (this.length > num.length) return this.clone().iadd(num);
              else return num.clone().iadd(this);
            };
            BN.prototype.isub = function isub(num) {
              if (num.sign) {
                num.sign = false;
                var r = this.iadd(num);
                num.sign = true;
                return r._normSign();
              } else if (this.sign) {
                this.sign = false;
                this.iadd(num);
                this.sign = true;
                return this._normSign();
              }
              var cmp = this.cmp(num);
              if (cmp === 0) {
                this.sign = false;
                this.length = 1;
                this.words[0] = 0;
                return this;
              }
              var a;
              var b;
              if (cmp > 0) {
                a = this;
                b = num;
              } else {
                a = num;
                b = this;
              }
              var carry = 0;
              for (var i = 0; i < b.length; i++) {
                var r = a.words[i] - b.words[i] + carry;
                carry = r >> 26;
                this.words[i] = r & 67108863;
              }
              for (; carry !== 0 && i < a.length; i++) {
                var r = a.words[i] + carry;
                carry = r >> 26;
                this.words[i] = r & 67108863;
              }
              if (carry === 0 && i < a.length && a !== this)
                for (; i < a.length; i++) this.words[i] = a.words[i];
              this.length = Math.max(this.length, i);
              if (a !== this) this.sign = true;
              return this.strip();
            };
            BN.prototype.sub = function sub(num) {
              return this.clone().isub(num);
            };
            BN.prototype._smallMulTo = function _smallMulTo(num, out) {
              out.sign = num.sign !== this.sign;
              out.length = this.length + num.length;
              var carry = 0;
              for (var k = 0; k < out.length - 1; k++) {
                var ncarry = carry >>> 26;
                var rword = carry & 67108863;
                var maxJ = Math.min(k, num.length - 1);
                for (var j = Math.max(0, k - this.length + 1); j <= maxJ; j++) {
                  var i = k - j;
                  var a = this.words[i] | 0;
                  var b = num.words[j] | 0;
                  var r = a * b;
                  var lo = r & 67108863;
                  ncarry = (ncarry + ((r / 67108864) | 0)) | 0;
                  lo = (lo + rword) | 0;
                  rword = lo & 67108863;
                  ncarry = (ncarry + (lo >>> 26)) | 0;
                }
                out.words[k] = rword;
                carry = ncarry;
              }
              if (carry !== 0) {
                out.words[k] = carry;
              } else {
                out.length--;
              }
              return out.strip();
            };
            BN.prototype._bigMulTo = function _bigMulTo(num, out) {
              out.sign = num.sign !== this.sign;
              out.length = this.length + num.length;
              var carry = 0;
              var hncarry = 0;
              for (var k = 0; k < out.length - 1; k++) {
                var ncarry = hncarry;
                hncarry = 0;
                var rword = carry & 67108863;
                var maxJ = Math.min(k, num.length - 1);
                for (var j = Math.max(0, k - this.length + 1); j <= maxJ; j++) {
                  var i = k - j;
                  var a = this.words[i] | 0;
                  var b = num.words[j] | 0;
                  var r = a * b;
                  var lo = r & 67108863;
                  ncarry = (ncarry + ((r / 67108864) | 0)) | 0;
                  lo = (lo + rword) | 0;
                  rword = lo & 67108863;
                  ncarry = (ncarry + (lo >>> 26)) | 0;
                  hncarry += ncarry >>> 26;
                  ncarry &= 67108863;
                }
                out.words[k] = rword;
                carry = ncarry;
                ncarry = hncarry;
              }
              if (carry !== 0) {
                out.words[k] = carry;
              } else {
                out.length--;
              }
              return out.strip();
            };
            BN.prototype.mulTo = function mulTo(num, out) {
              var res;
              if (this.length + num.length < 63)
                res = this._smallMulTo(num, out);
              else res = this._bigMulTo(num, out);
              return res;
            };
            BN.prototype.mul = function mul(num) {
              var out = new BN(null);
              out.words = new Array(this.length + num.length);
              return this.mulTo(num, out);
            };
            BN.prototype.imul = function imul(num) {
              if (this.cmpn(0) === 0 || num.cmpn(0) === 0) {
                this.words[0] = 0;
                this.length = 1;
                return this;
              }
              var tlen = this.length;
              var nlen = num.length;
              this.sign = num.sign !== this.sign;
              this.length = this.length + num.length;
              this.words[this.length - 1] = 0;
              for (var k = this.length - 2; k >= 0; k--) {
                var carry = 0;
                var rword = 0;
                var maxJ = Math.min(k, nlen - 1);
                for (var j = Math.max(0, k - tlen + 1); j <= maxJ; j++) {
                  var i = k - j;
                  var a = this.words[i];
                  var b = num.words[j];
                  var r = a * b;
                  var lo = r & 67108863;
                  carry += (r / 67108864) | 0;
                  lo += rword;
                  rword = lo & 67108863;
                  carry += lo >>> 26;
                }
                this.words[k] = rword;
                this.words[k + 1] += carry;
                carry = 0;
              }
              var carry = 0;
              for (var i = 1; i < this.length; i++) {
                var w = this.words[i] + carry;
                this.words[i] = w & 67108863;
                carry = w >>> 26;
              }
              return this.strip();
            };
            BN.prototype.imuln = function imuln(num) {
              assert(typeof num === 'number');
              var carry = 0;
              for (var i = 0; i < this.length; i++) {
                var w = this.words[i] * num;
                var lo = (w & 67108863) + (carry & 67108863);
                carry >>= 26;
                carry += (w / 67108864) | 0;
                carry += lo >>> 26;
                this.words[i] = lo & 67108863;
              }
              if (carry !== 0) {
                this.words[i] = carry;
                this.length++;
              }
              return this;
            };
            BN.prototype.muln = function muln(num) {
              return this.clone().imuln(num);
            };
            BN.prototype.sqr = function sqr() {
              return this.mul(this);
            };
            BN.prototype.isqr = function isqr() {
              return this.mul(this);
            };
            BN.prototype.pow = function pow(num) {
              var w = toBitArray(num);
              if (w.length === 0) return new BN(1);
              var res = this;
              for (var i = 0; i < w.length; i++, res = res.sqr())
                if (w[i] !== 0) break;
              if (++i < w.length) {
                for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
                  if (w[i] === 0) continue;
                  res = res.mul(q);
                }
              }
              return res;
            };
            BN.prototype.iushln = function iushln(bits) {
              assert(typeof bits === 'number' && bits >= 0);
              var r = bits % 26;
              var s = (bits - r) / 26;
              var carryMask = (67108863 >>> (26 - r)) << (26 - r);
              if (r !== 0) {
                var carry = 0;
                for (var i = 0; i < this.length; i++) {
                  var newCarry = this.words[i] & carryMask;
                  var c = (this.words[i] - newCarry) << r;
                  this.words[i] = c | carry;
                  carry = newCarry >>> (26 - r);
                }
                if (carry) {
                  this.words[i] = carry;
                  this.length++;
                }
              }
              if (s !== 0) {
                for (var i = this.length - 1; i >= 0; i--)
                  this.words[i + s] = this.words[i];
                for (var i = 0; i < s; i++) this.words[i] = 0;
                this.length += s;
              }
              return this.strip();
            };
            BN.prototype.ishln = function ishln(bits) {
              assert(!this.sign);
              return this.iushln(bits);
            };
            BN.prototype.iushrn = function iushrn(bits, hint, extended) {
              assert(typeof bits === 'number' && bits >= 0);
              var h;
              if (hint) h = (hint - (hint % 26)) / 26;
              else h = 0;
              var r = bits % 26;
              var s = Math.min((bits - r) / 26, this.length);
              var mask = 67108863 ^ ((67108863 >>> r) << r);
              var maskedWords = extended;
              h -= s;
              h = Math.max(0, h);
              if (maskedWords) {
                for (var i = 0; i < s; i++)
                  maskedWords.words[i] = this.words[i];
                maskedWords.length = s;
              }
              if (s === 0) {
              } else if (this.length > s) {
                this.length -= s;
                for (var i = 0; i < this.length; i++)
                  this.words[i] = this.words[i + s];
              } else {
                this.words[0] = 0;
                this.length = 1;
              }
              var carry = 0;
              for (
                var i = this.length - 1;
                i >= 0 && (carry !== 0 || i >= h);
                i--
              ) {
                var word = this.words[i];
                this.words[i] = (carry << (26 - r)) | (word >>> r);
                carry = word & mask;
              }
              if (maskedWords && carry !== 0)
                maskedWords.words[maskedWords.length++] = carry;
              if (this.length === 0) {
                this.words[0] = 0;
                this.length = 1;
              }
              this.strip();
              return this;
            };
            BN.prototype.ishrn = function ishrn(bits, hint, extended) {
              assert(!this.sign);
              return this.iushrn(bits, hint, extended);
            };
            BN.prototype.shln = function shln(bits) {
              return this.clone().ishln(bits);
            };
            BN.prototype.ushln = function ushln(bits) {
              return this.clone().iushln(bits);
            };
            BN.prototype.shrn = function shrn(bits) {
              return this.clone().ishrn(bits);
            };
            BN.prototype.ushrn = function ushrn(bits) {
              return this.clone().iushrn(bits);
            };
            BN.prototype.testn = function testn(bit) {
              assert(typeof bit === 'number' && bit >= 0);
              var r = bit % 26;
              var s = (bit - r) / 26;
              var q = 1 << r;
              if (this.length <= s) {
                return false;
              }
              var w = this.words[s];
              return !!(w & q);
            };
            BN.prototype.imaskn = function imaskn(bits) {
              assert(typeof bits === 'number' && bits >= 0);
              var r = bits % 26;
              var s = (bits - r) / 26;
              assert(!this.sign, 'imaskn works only with positive numbers');
              if (r !== 0) s++;
              this.length = Math.min(s, this.length);
              if (r !== 0) {
                var mask = 67108863 ^ ((67108863 >>> r) << r);
                this.words[this.length - 1] &= mask;
              }
              return this.strip();
            };
            BN.prototype.maskn = function maskn(bits) {
              return this.clone().imaskn(bits);
            };
            BN.prototype.iaddn = function iaddn(num) {
              assert(typeof num === 'number');
              if (num < 0) return this.isubn(-num);
              if (this.sign) {
                if (this.length === 1 && this.words[0] < num) {
                  this.words[0] = num - this.words[0];
                  this.sign = false;
                  return this;
                }
                this.sign = false;
                this.isubn(num);
                this.sign = true;
                return this;
              }
              return this._iaddn(num);
            };
            BN.prototype._iaddn = function _iaddn(num) {
              this.words[0] += num;
              for (
                var i = 0;
                i < this.length && this.words[i] >= 67108864;
                i++
              ) {
                this.words[i] -= 67108864;
                if (i === this.length - 1) this.words[i + 1] = 1;
                else this.words[i + 1]++;
              }
              this.length = Math.max(this.length, i + 1);
              return this;
            };
            BN.prototype.isubn = function isubn(num) {
              assert(typeof num === 'number');
              if (num < 0) return this.iaddn(-num);
              if (this.sign) {
                this.sign = false;
                this.iaddn(num);
                this.sign = true;
                return this;
              }
              this.words[0] -= num;
              for (var i = 0; i < this.length && this.words[i] < 0; i++) {
                this.words[i] += 67108864;
                this.words[i + 1] -= 1;
              }
              return this.strip();
            };
            BN.prototype.addn = function addn(num) {
              return this.clone().iaddn(num);
            };
            BN.prototype.subn = function subn(num) {
              return this.clone().isubn(num);
            };
            BN.prototype.iabs = function iabs() {
              this.sign = false;
              return this;
            };
            BN.prototype.abs = function abs() {
              return this.clone().iabs();
            };
            BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
              var len = num.length + shift;
              var i;
              if (this.words.length < len) {
                var t = new Array(len);
                for (var i = 0; i < this.length; i++) t[i] = this.words[i];
                this.words = t;
              } else {
                i = this.length;
              }
              this.length = Math.max(this.length, len);
              for (; i < this.length; i++) this.words[i] = 0;
              var carry = 0;
              for (var i = 0; i < num.length; i++) {
                var w = this.words[i + shift] + carry;
                var right = num.words[i] * mul;
                w -= right & 67108863;
                carry = (w >> 26) - ((right / 67108864) | 0);
                this.words[i + shift] = w & 67108863;
              }
              for (; i < this.length - shift; i++) {
                var w = this.words[i + shift] + carry;
                carry = w >> 26;
                this.words[i + shift] = w & 67108863;
              }
              if (carry === 0) return this.strip();
              assert(carry === -1);
              carry = 0;
              for (var i = 0; i < this.length; i++) {
                var w = -this.words[i] + carry;
                carry = w >> 26;
                this.words[i] = w & 67108863;
              }
              this.sign = true;
              return this.strip();
            };
            BN.prototype._wordDiv = function _wordDiv(num, mode) {
              var shift = this.length - num.length;
              var a = this.clone();
              var b = num;
              var bhi = b.words[b.length - 1];
              var bhiBits = this._countBits(bhi);
              shift = 26 - bhiBits;
              if (shift !== 0) {
                b = b.ushln(shift);
                a.iushln(shift);
                bhi = b.words[b.length - 1];
              }
              var m = a.length - b.length;
              var q;
              if (mode !== 'mod') {
                q = new BN(null);
                q.length = m + 1;
                q.words = new Array(q.length);
                for (var i = 0; i < q.length; i++) q.words[i] = 0;
              }
              var diff = a.clone()._ishlnsubmul(b, 1, m);
              if (!diff.sign) {
                a = diff;
                if (q) q.words[m] = 1;
              }
              for (var j = m - 1; j >= 0; j--) {
                var qj =
                  a.words[b.length + j] * 67108864 + a.words[b.length + j - 1];
                qj = Math.min((qj / bhi) | 0, 67108863);
                a._ishlnsubmul(b, qj, j);
                while (a.sign) {
                  qj--;
                  a.sign = false;
                  a._ishlnsubmul(b, 1, j);
                  if (a.cmpn(0) !== 0) a.sign = !a.sign;
                }
                if (q) q.words[j] = qj;
              }
              if (q) q.strip();
              a.strip();
              if (mode !== 'div' && shift !== 0) a.iushrn(shift);
              return { div: q ? q : null, mod: a };
            };
            BN.prototype.divmod = function divmod(num, mode, positive) {
              assert(num.cmpn(0) !== 0);
              if (this.sign && !num.sign) {
                var res = this.neg().divmod(num, mode);
                var div;
                var mod;
                if (mode !== 'mod') div = res.div.neg();
                if (mode !== 'div') {
                  mod = res.mod.neg();
                  if (positive && mod.neg) mod = mod.add(num);
                }
                return { div: div, mod: mod };
              } else if (!this.sign && num.sign) {
                var res = this.divmod(num.neg(), mode);
                var div;
                if (mode !== 'mod') div = res.div.neg();
                return { div: div, mod: res.mod };
              } else if (this.sign && num.sign) {
                var res = this.neg().divmod(num.neg(), mode);
                var mod;
                if (mode !== 'div') {
                  mod = res.mod.neg();
                  if (positive && mod.neg) mod = mod.isub(num);
                }
                return { div: res.div, mod: mod };
              }
              if (num.length > this.length || this.cmp(num) < 0)
                return { div: new BN(0), mod: this };
              if (num.length === 1) {
                if (mode === 'div')
                  return { div: this.divn(num.words[0]), mod: null };
                else if (mode === 'mod')
                  return { div: null, mod: new BN(this.modn(num.words[0])) };
                return {
                  div: this.divn(num.words[0]),
                  mod: new BN(this.modn(num.words[0]))
                };
              }
              return this._wordDiv(num, mode);
            };
            BN.prototype.div = function div(num) {
              return this.divmod(num, 'div', false).div;
            };
            BN.prototype.mod = function mod(num) {
              return this.divmod(num, 'mod', false).mod;
            };
            BN.prototype.umod = function umod(num) {
              return this.divmod(num, 'mod', true).mod;
            };
            BN.prototype.divRound = function divRound(num) {
              var dm = this.divmod(num);
              if (dm.mod.cmpn(0) === 0) return dm.div;
              var mod = dm.div.sign ? dm.mod.isub(num) : dm.mod;
              var half = num.ushrn(1);
              var r2 = num.andln(1);
              var cmp = mod.cmp(half);
              if (cmp < 0 || (r2 === 1 && cmp === 0)) return dm.div;
              return dm.div.sign ? dm.div.isubn(1) : dm.div.iaddn(1);
            };
            BN.prototype.modn = function modn(num) {
              assert(num <= 67108863);
              var p = (1 << 26) % num;
              var acc = 0;
              for (var i = this.length - 1; i >= 0; i--)
                acc = (p * acc + this.words[i]) % num;
              return acc;
            };
            BN.prototype.idivn = function idivn(num) {
              assert(num <= 67108863);
              var carry = 0;
              for (var i = this.length - 1; i >= 0; i--) {
                var w = this.words[i] + carry * 67108864;
                this.words[i] = (w / num) | 0;
                carry = w % num;
              }
              return this.strip();
            };
            BN.prototype.divn = function divn(num) {
              return this.clone().idivn(num);
            };
            BN.prototype.egcd = function egcd(p) {
              assert(!p.sign);
              assert(p.cmpn(0) !== 0);
              var x = this;
              var y = p.clone();
              if (x.sign) x = x.umod(p);
              else x = x.clone();
              var A = new BN(1);
              var B = new BN(0);
              var C = new BN(0);
              var D = new BN(1);
              var g = 0;
              while (x.isEven() && y.isEven()) {
                x.iushrn(1);
                y.iushrn(1);
                ++g;
              }
              var yp = y.clone();
              var xp = x.clone();
              while (x.cmpn(0) !== 0) {
                while (x.isEven()) {
                  x.iushrn(1);
                  if (A.isEven() && B.isEven()) {
                    A.iushrn(1);
                    B.iushrn(1);
                  } else {
                    A.iadd(yp).iushrn(1);
                    B.isub(xp).iushrn(1);
                  }
                }
                while (y.isEven()) {
                  y.iushrn(1);
                  if (C.isEven() && D.isEven()) {
                    C.iushrn(1);
                    D.iushrn(1);
                  } else {
                    C.iadd(yp).iushrn(1);
                    D.isub(xp).iushrn(1);
                  }
                }
                if (x.cmp(y) >= 0) {
                  x.isub(y);
                  A.isub(C);
                  B.isub(D);
                } else {
                  y.isub(x);
                  C.isub(A);
                  D.isub(B);
                }
              }
              return { a: C, b: D, gcd: y.iushln(g) };
            };
            BN.prototype._invmp = function _invmp(p) {
              assert(!p.sign);
              assert(p.cmpn(0) !== 0);
              var a = this;
              var b = p.clone();
              if (a.sign) a = a.umod(p);
              else a = a.clone();
              var x1 = new BN(1);
              var x2 = new BN(0);
              var delta = b.clone();
              while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
                while (a.isEven()) {
                  a.iushrn(1);
                  if (x1.isEven()) x1.iushrn(1);
                  else x1.iadd(delta).iushrn(1);
                }
                while (b.isEven()) {
                  b.iushrn(1);
                  if (x2.isEven()) x2.iushrn(1);
                  else x2.iadd(delta).iushrn(1);
                }
                if (a.cmp(b) >= 0) {
                  a.isub(b);
                  x1.isub(x2);
                } else {
                  b.isub(a);
                  x2.isub(x1);
                }
              }
              var res;
              if (a.cmpn(1) === 0) res = x1;
              else res = x2;
              if (res.cmpn(0) < 0) res.iadd(p);
              return res;
            };
            BN.prototype.gcd = function gcd(num) {
              if (this.cmpn(0) === 0) return num.clone();
              if (num.cmpn(0) === 0) return this.clone();
              var a = this.clone();
              var b = num.clone();
              a.sign = false;
              b.sign = false;
              for (var shift = 0; a.isEven() && b.isEven(); shift++) {
                a.iushrn(1);
                b.iushrn(1);
              }
              do {
                while (a.isEven()) a.iushrn(1);
                while (b.isEven()) b.iushrn(1);
                var r = a.cmp(b);
                if (r < 0) {
                  var t = a;
                  a = b;
                  b = t;
                } else if (r === 0 || b.cmpn(1) === 0) {
                  break;
                }
                a.isub(b);
              } while (true);
              return b.iushln(shift);
            };
            BN.prototype.invm = function invm(num) {
              return this.egcd(num).a.umod(num);
            };
            BN.prototype.isEven = function isEven() {
              return (this.words[0] & 1) === 0;
            };
            BN.prototype.isOdd = function isOdd() {
              return (this.words[0] & 1) === 1;
            };
            BN.prototype.andln = function andln(num) {
              return this.words[0] & num;
            };
            BN.prototype.bincn = function bincn(bit) {
              assert(typeof bit === 'number');
              var r = bit % 26;
              var s = (bit - r) / 26;
              var q = 1 << r;
              if (this.length <= s) {
                for (var i = this.length; i < s + 1; i++) this.words[i] = 0;
                this.words[s] |= q;
                this.length = s + 1;
                return this;
              }
              var carry = q;
              for (var i = s; carry !== 0 && i < this.length; i++) {
                var w = this.words[i];
                w += carry;
                carry = w >>> 26;
                w &= 67108863;
                this.words[i] = w;
              }
              if (carry !== 0) {
                this.words[i] = carry;
                this.length++;
              }
              return this;
            };
            BN.prototype.cmpn = function cmpn(num) {
              var sign = num < 0;
              if (sign) num = -num;
              if (this.sign && !sign) return -1;
              else if (!this.sign && sign) return 1;
              num &= 67108863;
              this.strip();
              var res;
              if (this.length > 1) {
                res = 1;
              } else {
                var w = this.words[0];
                res = w === num ? 0 : w < num ? -1 : 1;
              }
              if (this.sign) res = -res;
              return res;
            };
            BN.prototype.cmp = function cmp(num) {
              if (this.sign && !num.sign) return -1;
              else if (!this.sign && num.sign) return 1;
              var res = this.ucmp(num);
              if (this.sign) return -res;
              else return res;
            };
            BN.prototype.ucmp = function ucmp(num) {
              if (this.length > num.length) return 1;
              else if (this.length < num.length) return -1;
              var res = 0;
              for (var i = this.length - 1; i >= 0; i--) {
                var a = this.words[i];
                var b = num.words[i];
                if (a === b) continue;
                if (a < b) res = -1;
                else if (a > b) res = 1;
                break;
              }
              return res;
            };
            BN.red = function red(num) {
              return new Red(num);
            };
            BN.prototype.toRed = function toRed(ctx) {
              assert(!this.red, 'Already a number in reduction context');
              assert(!this.sign, 'red works only with positives');
              return ctx.convertTo(this)._forceRed(ctx);
            };
            BN.prototype.fromRed = function fromRed() {
              assert(
                this.red,
                'fromRed works only with numbers in reduction context'
              );
              return this.red.convertFrom(this);
            };
            BN.prototype._forceRed = function _forceRed(ctx) {
              this.red = ctx;
              return this;
            };
            BN.prototype.forceRed = function forceRed(ctx) {
              assert(!this.red, 'Already a number in reduction context');
              return this._forceRed(ctx);
            };
            BN.prototype.redAdd = function redAdd(num) {
              assert(this.red, 'redAdd works only with red numbers');
              return this.red.add(this, num);
            };
            BN.prototype.redIAdd = function redIAdd(num) {
              assert(this.red, 'redIAdd works only with red numbers');
              return this.red.iadd(this, num);
            };
            BN.prototype.redSub = function redSub(num) {
              assert(this.red, 'redSub works only with red numbers');
              return this.red.sub(this, num);
            };
            BN.prototype.redISub = function redISub(num) {
              assert(this.red, 'redISub works only with red numbers');
              return this.red.isub(this, num);
            };
            BN.prototype.redShl = function redShl(num) {
              assert(this.red, 'redShl works only with red numbers');
              return this.red.ushl(this, num);
            };
            BN.prototype.redMul = function redMul(num) {
              assert(this.red, 'redMul works only with red numbers');
              this.red._verify2(this, num);
              return this.red.mul(this, num);
            };
            BN.prototype.redIMul = function redIMul(num) {
              assert(this.red, 'redMul works only with red numbers');
              this.red._verify2(this, num);
              return this.red.imul(this, num);
            };
            BN.prototype.redSqr = function redSqr() {
              assert(this.red, 'redSqr works only with red numbers');
              this.red._verify1(this);
              return this.red.sqr(this);
            };
            BN.prototype.redISqr = function redISqr() {
              assert(this.red, 'redISqr works only with red numbers');
              this.red._verify1(this);
              return this.red.isqr(this);
            };
            BN.prototype.redSqrt = function redSqrt() {
              assert(this.red, 'redSqrt works only with red numbers');
              this.red._verify1(this);
              return this.red.sqrt(this);
            };
            BN.prototype.redInvm = function redInvm() {
              assert(this.red, 'redInvm works only with red numbers');
              this.red._verify1(this);
              return this.red.invm(this);
            };
            BN.prototype.redNeg = function redNeg() {
              assert(this.red, 'redNeg works only with red numbers');
              this.red._verify1(this);
              return this.red.neg(this);
            };
            BN.prototype.redPow = function redPow(num) {
              assert(this.red && !num.red, 'redPow(normalNum)');
              this.red._verify1(this);
              return this.red.pow(this, num);
            };
            var primes = { k256: null, p224: null, p192: null, p25519: null };
            function MPrime(name, p) {
              this.name = name;
              this.p = new BN(p, 16);
              this.n = this.p.bitLength();
              this.k = new BN(1).iushln(this.n).isub(this.p);
              this.tmp = this._tmp();
            }
            MPrime.prototype._tmp = function _tmp() {
              var tmp = new BN(null);
              tmp.words = new Array(Math.ceil(this.n / 13));
              return tmp;
            };
            MPrime.prototype.ireduce = function ireduce(num) {
              var r = num;
              var rlen;
              do {
                this.split(r, this.tmp);
                r = this.imulK(r);
                r = r.iadd(this.tmp);
                rlen = r.bitLength();
              } while (rlen > this.n);
              var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
              if (cmp === 0) {
                r.words[0] = 0;
                r.length = 1;
              } else if (cmp > 0) {
                r.isub(this.p);
              } else {
                r.strip();
              }
              return r;
            };
            MPrime.prototype.split = function split(input, out) {
              input.iushrn(this.n, 0, out);
            };
            MPrime.prototype.imulK = function imulK(num) {
              return num.imul(this.k);
            };
            function K256() {
              MPrime.call(
                this,
                'k256',
                'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f'
              );
            }
            inherits(K256, MPrime);
            K256.prototype.split = function split(input, output) {
              var mask = 4194303;
              var outLen = Math.min(input.length, 9);
              for (var i = 0; i < outLen; i++) output.words[i] = input.words[i];
              output.length = outLen;
              if (input.length <= 9) {
                input.words[0] = 0;
                input.length = 1;
                return;
              }
              var prev = input.words[9];
              output.words[output.length++] = prev & mask;
              for (var i = 10; i < input.length; i++) {
                var next = input.words[i];
                input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
                prev = next;
              }
              input.words[i - 10] = prev >>> 22;
              input.length -= 9;
            };
            K256.prototype.imulK = function imulK(num) {
              num.words[num.length] = 0;
              num.words[num.length + 1] = 0;
              num.length += 2;
              var hi;
              var lo = 0;
              for (var i = 0; i < num.length; i++) {
                var w = num.words[i];
                hi = w * 64;
                lo += w * 977;
                hi += (lo / 67108864) | 0;
                lo &= 67108863;
                num.words[i] = lo;
                lo = hi;
              }
              if (num.words[num.length - 1] === 0) {
                num.length--;
                if (num.words[num.length - 1] === 0) num.length--;
              }
              return num;
            };
            function P224() {
              MPrime.call(
                this,
                'p224',
                'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001'
              );
            }
            inherits(P224, MPrime);
            function P192() {
              MPrime.call(
                this,
                'p192',
                'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff'
              );
            }
            inherits(P192, MPrime);
            function P25519() {
              MPrime.call(
                this,
                '25519',
                '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed'
              );
            }
            inherits(P25519, MPrime);
            P25519.prototype.imulK = function imulK(num) {
              var carry = 0;
              for (var i = 0; i < num.length; i++) {
                var hi = num.words[i] * 19 + carry;
                var lo = hi & 67108863;
                hi >>>= 26;
                num.words[i] = lo;
                carry = hi;
              }
              if (carry !== 0) num.words[num.length++] = carry;
              return num;
            };
            BN._prime = function prime(name) {
              if (primes[name]) return primes[name];
              var prime;
              if (name === 'k256') prime = new K256();
              else if (name === 'p224') prime = new P224();
              else if (name === 'p192') prime = new P192();
              else if (name === 'p25519') prime = new P25519();
              else throw new Error('Unknown prime ' + name);
              primes[name] = prime;
              return prime;
            };
            function Red(m) {
              if (typeof m === 'string') {
                var prime = BN._prime(m);
                this.m = prime.p;
                this.prime = prime;
              } else {
                this.m = m;
                this.prime = null;
              }
            }
            Red.prototype._verify1 = function _verify1(a) {
              assert(!a.sign, 'red works only with positives');
              assert(a.red, 'red works only with red numbers');
            };
            Red.prototype._verify2 = function _verify2(a, b) {
              assert(!a.sign && !b.sign, 'red works only with positives');
              assert(
                a.red && a.red === b.red,
                'red works only with red numbers'
              );
            };
            Red.prototype.imod = function imod(a) {
              if (this.prime) return this.prime.ireduce(a)._forceRed(this);
              return a.umod(this.m)._forceRed(this);
            };
            Red.prototype.neg = function neg(a) {
              var r = a.clone();
              r.sign = !r.sign;
              return r.iadd(this.m)._forceRed(this);
            };
            Red.prototype.add = function add(a, b) {
              this._verify2(a, b);
              var res = a.add(b);
              if (res.cmp(this.m) >= 0) res.isub(this.m);
              return res._forceRed(this);
            };
            Red.prototype.iadd = function iadd(a, b) {
              this._verify2(a, b);
              var res = a.iadd(b);
              if (res.cmp(this.m) >= 0) res.isub(this.m);
              return res;
            };
            Red.prototype.sub = function sub(a, b) {
              this._verify2(a, b);
              var res = a.sub(b);
              if (res.cmpn(0) < 0) res.iadd(this.m);
              return res._forceRed(this);
            };
            Red.prototype.isub = function isub(a, b) {
              this._verify2(a, b);
              var res = a.isub(b);
              if (res.cmpn(0) < 0) res.iadd(this.m);
              return res;
            };
            Red.prototype.shl = function shl(a, num) {
              this._verify1(a);
              return this.imod(a.ushln(num));
            };
            Red.prototype.imul = function imul(a, b) {
              this._verify2(a, b);
              return this.imod(a.imul(b));
            };
            Red.prototype.mul = function mul(a, b) {
              this._verify2(a, b);
              return this.imod(a.mul(b));
            };
            Red.prototype.isqr = function isqr(a) {
              return this.imul(a, a);
            };
            Red.prototype.sqr = function sqr(a) {
              return this.mul(a, a);
            };
            Red.prototype.sqrt = function sqrt(a) {
              if (a.cmpn(0) === 0) return a.clone();
              var mod3 = this.m.andln(3);
              assert(mod3 % 2 === 1);
              if (mod3 === 3) {
                var pow = this.m.add(new BN(1)).iushrn(2);
                var r = this.pow(a, pow);
                return r;
              }
              var q = this.m.subn(1);
              var s = 0;
              while (q.cmpn(0) !== 0 && q.andln(1) === 0) {
                s++;
                q.iushrn(1);
              }
              assert(q.cmpn(0) !== 0);
              var one = new BN(1).toRed(this);
              var nOne = one.redNeg();
              var lpow = this.m.subn(1).iushrn(1);
              var z = this.m.bitLength();
              z = new BN(2 * z * z).toRed(this);
              while (this.pow(z, lpow).cmp(nOne) !== 0) z.redIAdd(nOne);
              var c = this.pow(z, q);
              var r = this.pow(a, q.addn(1).iushrn(1));
              var t = this.pow(a, q);
              var m = s;
              while (t.cmp(one) !== 0) {
                var tmp = t;
                for (var i = 0; tmp.cmp(one) !== 0; i++) tmp = tmp.redSqr();
                assert(i < m);
                var b = this.pow(c, new BN(1).iushln(m - i - 1));
                r = r.redMul(b);
                c = b.redSqr();
                t = t.redMul(c);
                m = i;
              }
              return r;
            };
            Red.prototype.invm = function invm(a) {
              var inv = a._invmp(this.m);
              if (inv.sign) {
                inv.sign = false;
                return this.imod(inv).redNeg();
              } else {
                return this.imod(inv);
              }
            };
            Red.prototype.pow = function pow(a, num) {
              var w = toBitArray(num);
              if (w.length === 0) return new BN(1);
              var res = a;
              for (var i = 0; i < w.length; i++, res = this.sqr(res))
                if (w[i] !== 0) break;
              if (++i < w.length) {
                for (
                  var q = this.sqr(res);
                  i < w.length;
                  i++, q = this.sqr(q)
                ) {
                  if (w[i] === 0) continue;
                  res = this.mul(res, q);
                }
              }
              return res;
            };
            Red.prototype.convertTo = function convertTo(num) {
              var r = num.umod(this.m);
              if (r === num) return r.clone();
              else return r;
            };
            Red.prototype.convertFrom = function convertFrom(num) {
              var res = num.clone();
              res.red = null;
              return res;
            };
            BN.mont = function mont(num) {
              return new Mont(num);
            };
            function Mont(m) {
              Red.call(this, m);
              this.shift = this.m.bitLength();
              if (this.shift % 26 !== 0) this.shift += 26 - (this.shift % 26);
              this.r = new BN(1).iushln(this.shift);
              this.r2 = this.imod(this.r.sqr());
              this.rinv = this.r._invmp(this.m);
              this.minv = this.rinv
                .mul(this.r)
                .isubn(1)
                .div(this.m);
              this.minv = this.minv.umod(this.r);
              this.minv = this.r.sub(this.minv);
            }
            inherits(Mont, Red);
            Mont.prototype.convertTo = function convertTo(num) {
              return this.imod(num.ushln(this.shift));
            };
            Mont.prototype.convertFrom = function convertFrom(num) {
              var r = this.imod(num.mul(this.rinv));
              r.red = null;
              return r;
            };
            Mont.prototype.imul = function imul(a, b) {
              if (a.cmpn(0) === 0 || b.cmpn(0) === 0) {
                a.words[0] = 0;
                a.length = 1;
                return a;
              }
              var t = a.imul(b);
              var c = t
                .maskn(this.shift)
                .mul(this.minv)
                .imaskn(this.shift)
                .mul(this.m);
              var u = t.isub(c).iushrn(this.shift);
              var res = u;
              if (u.cmp(this.m) >= 0) res = u.isub(this.m);
              else if (u.cmpn(0) < 0) res = u.iadd(this.m);
              return res._forceRed(this);
            };
            Mont.prototype.mul = function mul(a, b) {
              if (a.cmpn(0) === 0 || b.cmpn(0) === 0)
                return new BN(0)._forceRed(this);
              var t = a.mul(b);
              var c = t
                .maskn(this.shift)
                .mul(this.minv)
                .imaskn(this.shift)
                .mul(this.m);
              var u = t.isub(c).iushrn(this.shift);
              var res = u;
              if (u.cmp(this.m) >= 0) res = u.isub(this.m);
              else if (u.cmpn(0) < 0) res = u.iadd(this.m);
              return res._forceRed(this);
            };
            Mont.prototype.invm = function invm(a) {
              var res = this.imod(a._invmp(this.m).mul(this.r2));
              return res._forceRed(this);
            };
          })(typeof module === 'undefined' || module, this);
        },
        {}
      ],
      408: [
        function(require, module, exports) {
          'use strict';
          var elliptic = exports;
          elliptic.version = require('../package.json').version;
          elliptic.utils = require('./elliptic/utils');
          elliptic.rand = require('brorand');
          elliptic.hmacDRBG = require('./elliptic/hmac-drbg');
          elliptic.curve = require('./elliptic/curve');
          elliptic.curves = require('./elliptic/curves');
          elliptic.ec = require('./elliptic/ec');
          elliptic.eddsa = require('./elliptic/eddsa');
        },
        {
          '../package.json': 424,
          './elliptic/curve': 411,
          './elliptic/curves': 414,
          './elliptic/ec': 415,
          './elliptic/eddsa': 418,
          './elliptic/hmac-drbg': 421,
          './elliptic/utils': 423,
          brorand: 136
        }
      ],
      409: [
        function(require, module, exports) {
          'use strict';
          var bn = require('bn.js');
          var elliptic = require('../../elliptic');
          var utils = elliptic.utils;
          var getNAF = utils.getNAF;
          var getJSF = utils.getJSF;
          var assert = utils.assert;
          function BaseCurve(type, conf) {
            this.type = type;
            this.p = new bn(conf.p, 16);
            this.red = conf.prime ? bn.red(conf.prime) : bn.mont(this.p);
            this.zero = new bn(0).toRed(this.red);
            this.one = new bn(1).toRed(this.red);
            this.two = new bn(2).toRed(this.red);
            this.n = conf.n && new bn(conf.n, 16);
            this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
            this._wnafT1 = new Array(4);
            this._wnafT2 = new Array(4);
            this._wnafT3 = new Array(4);
            this._wnafT4 = new Array(4);
          }
          module.exports = BaseCurve;
          BaseCurve.prototype.point = function point() {
            throw new Error('Not implemented');
          };
          BaseCurve.prototype.validate = function validate() {
            throw new Error('Not implemented');
          };
          BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
            assert(p.precomputed);
            var doubles = p._getDoubles();
            var naf = getNAF(k, 1);
            var I =
              (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
            I /= 3;
            var repr = [];
            for (var j = 0; j < naf.length; j += doubles.step) {
              var nafW = 0;
              for (var k = j + doubles.step - 1; k >= j; k--)
                nafW = (nafW << 1) + naf[k];
              repr.push(nafW);
            }
            var a = this.jpoint(null, null, null);
            var b = this.jpoint(null, null, null);
            for (var i = I; i > 0; i--) {
              for (var j = 0; j < repr.length; j++) {
                var nafW = repr[j];
                if (nafW === i) b = b.mixedAdd(doubles.points[j]);
                else if (nafW === -i) b = b.mixedAdd(doubles.points[j].neg());
              }
              a = a.add(b);
            }
            return a.toP();
          };
          BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
            var w = 4;
            var nafPoints = p._getNAFPoints(w);
            w = nafPoints.wnd;
            var wnd = nafPoints.points;
            var naf = getNAF(k, w);
            var acc = this.jpoint(null, null, null);
            for (var i = naf.length - 1; i >= 0; i--) {
              for (var k = 0; i >= 0 && naf[i] === 0; i--) k++;
              if (i >= 0) k++;
              acc = acc.dblp(k);
              if (i < 0) break;
              var z = naf[i];
              assert(z !== 0);
              if (p.type === 'affine') {
                if (z > 0) acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
                else acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
              } else {
                if (z > 0) acc = acc.add(wnd[(z - 1) >> 1]);
                else acc = acc.add(wnd[(-z - 1) >> 1].neg());
              }
            }
            return p.type === 'affine' ? acc.toP() : acc;
          };
          BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(
            defW,
            points,
            coeffs,
            len
          ) {
            var wndWidth = this._wnafT1;
            var wnd = this._wnafT2;
            var naf = this._wnafT3;
            var max = 0;
            for (var i = 0; i < len; i++) {
              var p = points[i];
              var nafPoints = p._getNAFPoints(defW);
              wndWidth[i] = nafPoints.wnd;
              wnd[i] = nafPoints.points;
            }
            for (var i = len - 1; i >= 1; i -= 2) {
              var a = i - 1;
              var b = i;
              if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
                naf[a] = getNAF(coeffs[a], wndWidth[a]);
                naf[b] = getNAF(coeffs[b], wndWidth[b]);
                max = Math.max(naf[a].length, max);
                max = Math.max(naf[b].length, max);
                continue;
              }
              var comb = [points[a], null, null, points[b]];
              if (points[a].y.cmp(points[b].y) === 0) {
                comb[1] = points[a].add(points[b]);
                comb[2] = points[a].toJ().mixedAdd(points[b].neg());
              } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
                comb[1] = points[a].toJ().mixedAdd(points[b]);
                comb[2] = points[a].add(points[b].neg());
              } else {
                comb[1] = points[a].toJ().mixedAdd(points[b]);
                comb[2] = points[a].toJ().mixedAdd(points[b].neg());
              }
              var index = [-3, -1, -5, -7, 0, 7, 5, 1, 3];
              var jsf = getJSF(coeffs[a], coeffs[b]);
              max = Math.max(jsf[0].length, max);
              naf[a] = new Array(max);
              naf[b] = new Array(max);
              for (var j = 0; j < max; j++) {
                var ja = jsf[0][j] | 0;
                var jb = jsf[1][j] | 0;
                naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
                naf[b][j] = 0;
                wnd[a] = comb;
              }
            }
            var acc = this.jpoint(null, null, null);
            var tmp = this._wnafT4;
            for (var i = max; i >= 0; i--) {
              var k = 0;
              while (i >= 0) {
                var zero = true;
                for (var j = 0; j < len; j++) {
                  tmp[j] = naf[j][i] | 0;
                  if (tmp[j] !== 0) zero = false;
                }
                if (!zero) break;
                k++;
                i--;
              }
              if (i >= 0) k++;
              acc = acc.dblp(k);
              if (i < 0) break;
              for (var j = 0; j < len; j++) {
                var z = tmp[j];
                var p;
                if (z === 0) continue;
                else if (z > 0) p = wnd[j][(z - 1) >> 1];
                else if (z < 0) p = wnd[j][(-z - 1) >> 1].neg();
                if (p.type === 'affine') acc = acc.mixedAdd(p);
                else acc = acc.add(p);
              }
            }
            for (var i = 0; i < len; i++) wnd[i] = null;
            return acc.toP();
          };
          function BasePoint(curve, type) {
            this.curve = curve;
            this.type = type;
            this.precomputed = null;
          }
          BaseCurve.BasePoint = BasePoint;
          BasePoint.prototype.eq = function eq() {
            throw new Error('Not implemented');
          };
          BasePoint.prototype.validate = function validate() {
            return this.curve.validate(this);
          };
          BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
            bytes = utils.toArray(bytes, enc);
            var len = this.p.byteLength();
            if (bytes[0] === 4 && bytes.length - 1 === 2 * len) {
              return this.point(
                bytes.slice(1, 1 + len),
                bytes.slice(1 + len, 1 + 2 * len)
              );
            } else if (
              (bytes[0] === 2 || bytes[0] === 3) &&
              bytes.length - 1 === len
            ) {
              return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
            }
            throw new Error('Unknown point format');
          };
          BasePoint.prototype.encodeCompressed = function encodeCompressed(
            enc
          ) {
            return this.encode(enc, true);
          };
          BasePoint.prototype._encode = function _encode(compact) {
            var len = this.curve.p.byteLength();
            var x = this.getX().toArray('be', len);
            if (compact) return [this.getY().isEven() ? 2 : 3].concat(x);
            return [4].concat(x, this.getY().toArray('be', len));
          };
          BasePoint.prototype.encode = function encode(enc, compact) {
            return utils.encode(this._encode(compact), enc);
          };
          BasePoint.prototype.precompute = function precompute(power) {
            if (this.precomputed) return this;
            var precomputed = { doubles: null, naf: null, beta: null };
            precomputed.naf = this._getNAFPoints(8);
            precomputed.doubles = this._getDoubles(4, power);
            precomputed.beta = this._getBeta();
            this.precomputed = precomputed;
            return this;
          };
          BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
            if (!this.precomputed) return false;
            var doubles = this.precomputed.doubles;
            if (!doubles) return false;
            return (
              doubles.points.length >=
              Math.ceil((k.bitLength() + 1) / doubles.step)
            );
          };
          BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
            if (this.precomputed && this.precomputed.doubles)
              return this.precomputed.doubles;
            var doubles = [this];
            var acc = this;
            for (var i = 0; i < power; i += step) {
              for (var j = 0; j < step; j++) acc = acc.dbl();
              doubles.push(acc);
            }
            return { step: step, points: doubles };
          };
          BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
            if (this.precomputed && this.precomputed.naf)
              return this.precomputed.naf;
            var res = [this];
            var max = (1 << wnd) - 1;
            var dbl = max === 1 ? null : this.dbl();
            for (var i = 1; i < max; i++) res[i] = res[i - 1].add(dbl);
            return { wnd: wnd, points: res };
          };
          BasePoint.prototype._getBeta = function _getBeta() {
            return null;
          };
          BasePoint.prototype.dblp = function dblp(k) {
            var r = this;
            for (var i = 0; i < k; i++) r = r.dbl();
            return r;
          };
        },
        { '../../elliptic': 408, 'bn.js': 407 }
      ],
      410: [
        function(require, module, exports) {
          'use strict';
          var curve = require('../curve');
          var elliptic = require('../../elliptic');
          var bn = require('bn.js');
          var inherits = require('inherits');
          var Base = curve.base;
          var assert = elliptic.utils.assert;
          function EdwardsCurve(conf) {
            this.twisted = (conf.a | 0) !== 1;
            this.mOneA = this.twisted && (conf.a | 0) === -1;
            this.extended = this.mOneA;
            Base.call(this, 'edwards', conf);
            this.a = new bn(conf.a, 16).umod(this.red.m);
            this.a = this.a.toRed(this.red);
            this.c = new bn(conf.c, 16).toRed(this.red);
            this.c2 = this.c.redSqr();
            this.d = new bn(conf.d, 16).toRed(this.red);
            this.dd = this.d.redAdd(this.d);
            assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
            this.oneC = (conf.c | 0) === 1;
          }
          inherits(EdwardsCurve, Base);
          module.exports = EdwardsCurve;
          EdwardsCurve.prototype._mulA = function _mulA(num) {
            if (this.mOneA) return num.redNeg();
            else return this.a.redMul(num);
          };
          EdwardsCurve.prototype._mulC = function _mulC(num) {
            if (this.oneC) return num;
            else return this.c.redMul(num);
          };
          EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
            return this.point(x, y, z, t);
          };
          EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
            x = new bn(x, 16);
            if (!x.red) x = x.toRed(this.red);
            var x2 = x.redSqr();
            var rhs = this.c2.redSub(this.a.redMul(x2));
            var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
            var y = rhs.redMul(lhs.redInvm()).redSqrt();
            var isOdd = y.fromRed().isOdd();
            if ((odd && !isOdd) || (!odd && isOdd)) y = y.redNeg();
            return this.point(x, y);
          };
          EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
            y = new bn(y, 16);
            if (!y.red) y = y.toRed(this.red);
            var y2 = y.redSqr();
            var lhs = y2.redSub(this.one);
            var rhs = y2.redMul(this.d).redAdd(this.one);
            var x2 = lhs.redMul(rhs.redInvm());
            if (x2.cmp(this.zero) === 0) {
              if (odd) throw new Error('invalid point');
              else return this.point(this.zero, y);
            }
            var x = x2.redSqrt();
            if (
              x
                .redSqr()
                .redSub(x2)
                .cmp(this.zero) !== 0
            )
              throw new Error('invalid point');
            if (x.isOdd() !== odd) x = x.redNeg();
            return this.point(x, y);
          };
          EdwardsCurve.prototype.validate = function validate(point) {
            if (point.isInfinity()) return true;
            point.normalize();
            var x2 = point.x.redSqr();
            var y2 = point.y.redSqr();
            var lhs = x2.redMul(this.a).redAdd(y2);
            var rhs = this.c2.redMul(
              this.one.redAdd(this.d.redMul(x2).redMul(y2))
            );
            return lhs.cmp(rhs) === 0;
          };
          function Point(curve, x, y, z, t) {
            Base.BasePoint.call(this, curve, 'projective');
            if (x === null && y === null && z === null) {
              this.x = this.curve.zero;
              this.y = this.curve.one;
              this.z = this.curve.one;
              this.t = this.curve.zero;
              this.zOne = true;
            } else {
              this.x = new bn(x, 16);
              this.y = new bn(y, 16);
              this.z = z ? new bn(z, 16) : this.curve.one;
              this.t = t && new bn(t, 16);
              if (!this.x.red) this.x = this.x.toRed(this.curve.red);
              if (!this.y.red) this.y = this.y.toRed(this.curve.red);
              if (!this.z.red) this.z = this.z.toRed(this.curve.red);
              if (this.t && !this.t.red) this.t = this.t.toRed(this.curve.red);
              this.zOne = this.z === this.curve.one;
              if (this.curve.extended && !this.t) {
                this.t = this.x.redMul(this.y);
                if (!this.zOne) this.t = this.t.redMul(this.z.redInvm());
              }
            }
          }
          inherits(Point, Base.BasePoint);
          EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
            return Point.fromJSON(this, obj);
          };
          EdwardsCurve.prototype.point = function point(x, y, z, t) {
            return new Point(this, x, y, z, t);
          };
          Point.fromJSON = function fromJSON(curve, obj) {
            return new Point(curve, obj[0], obj[1], obj[2]);
          };
          Point.prototype.inspect = function inspect() {
            if (this.isInfinity()) return '<EC Point Infinity>';
            return (
              '<EC Point x: ' +
              this.x.fromRed().toString(16, 2) +
              ' y: ' +
              this.y.fromRed().toString(16, 2) +
              ' z: ' +
              this.z.fromRed().toString(16, 2) +
              '>'
            );
          };
          Point.prototype.isInfinity = function isInfinity() {
            return this.x.cmpn(0) === 0 && this.y.cmp(this.z) === 0;
          };
          Point.prototype._extDbl = function _extDbl() {
            var a = this.x.redSqr();
            var b = this.y.redSqr();
            var c = this.z.redSqr();
            c = c.redIAdd(c);
            var d = this.curve._mulA(a);
            var e = this.x
              .redAdd(this.y)
              .redSqr()
              .redISub(a)
              .redISub(b);
            var g = d.redAdd(b);
            var f = g.redSub(c);
            var h = d.redSub(b);
            var nx = e.redMul(f);
            var ny = g.redMul(h);
            var nt = e.redMul(h);
            var nz = f.redMul(g);
            return this.curve.point(nx, ny, nz, nt);
          };
          Point.prototype._projDbl = function _projDbl() {
            var b = this.x.redAdd(this.y).redSqr();
            var c = this.x.redSqr();
            var d = this.y.redSqr();
            var nx;
            var ny;
            var nz;
            if (this.curve.twisted) {
              var e = this.curve._mulA(c);
              var f = e.redAdd(d);
              if (this.zOne) {
                nx = b
                  .redSub(c)
                  .redSub(d)
                  .redMul(f.redSub(this.curve.two));
                ny = f.redMul(e.redSub(d));
                nz = f
                  .redSqr()
                  .redSub(f)
                  .redSub(f);
              } else {
                var h = this.z.redSqr();
                var j = f.redSub(h).redISub(h);
                nx = b
                  .redSub(c)
                  .redISub(d)
                  .redMul(j);
                ny = f.redMul(e.redSub(d));
                nz = f.redMul(j);
              }
            } else {
              var e = c.redAdd(d);
              var h = this.curve._mulC(this.c.redMul(this.z)).redSqr();
              var j = e.redSub(h).redSub(h);
              nx = this.curve._mulC(b.redISub(e)).redMul(j);
              ny = this.curve._mulC(e).redMul(c.redISub(d));
              nz = e.redMul(j);
            }
            return this.curve.point(nx, ny, nz);
          };
          Point.prototype.dbl = function dbl() {
            if (this.isInfinity()) return this;
            if (this.curve.extended) return this._extDbl();
            else return this._projDbl();
          };
          Point.prototype._extAdd = function _extAdd(p) {
            var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
            var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
            var c = this.t.redMul(this.curve.dd).redMul(p.t);
            var d = this.z.redMul(p.z.redAdd(p.z));
            var e = b.redSub(a);
            var f = d.redSub(c);
            var g = d.redAdd(c);
            var h = b.redAdd(a);
            var nx = e.redMul(f);
            var ny = g.redMul(h);
            var nt = e.redMul(h);
            var nz = f.redMul(g);
            return this.curve.point(nx, ny, nz, nt);
          };
          Point.prototype._projAdd = function _projAdd(p) {
            var a = this.z.redMul(p.z);
            var b = a.redSqr();
            var c = this.x.redMul(p.x);
            var d = this.y.redMul(p.y);
            var e = this.curve.d.redMul(c).redMul(d);
            var f = b.redSub(e);
            var g = b.redAdd(e);
            var tmp = this.x
              .redAdd(this.y)
              .redMul(p.x.redAdd(p.y))
              .redISub(c)
              .redISub(d);
            var nx = a.redMul(f).redMul(tmp);
            var ny;
            var nz;
            if (this.curve.twisted) {
              ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
              nz = f.redMul(g);
            } else {
              ny = a.redMul(g).redMul(d.redSub(c));
              nz = this.curve._mulC(f).redMul(g);
            }
            return this.curve.point(nx, ny, nz);
          };
          Point.prototype.add = function add(p) {
            if (this.isInfinity()) return p;
            if (p.isInfinity()) return this;
            if (this.curve.extended) return this._extAdd(p);
            else return this._projAdd(p);
          };
          Point.prototype.mul = function mul(k) {
            if (this._hasDoubles(k)) return this.curve._fixedNafMul(this, k);
            else return this.curve._wnafMul(this, k);
          };
          Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
            return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2);
          };
          Point.prototype.normalize = function normalize() {
            if (this.zOne) return this;
            var zi = this.z.redInvm();
            this.x = this.x.redMul(zi);
            this.y = this.y.redMul(zi);
            if (this.t) this.t = this.t.redMul(zi);
            this.z = this.curve.one;
            this.zOne = true;
            return this;
          };
          Point.prototype.neg = function neg() {
            return this.curve.point(
              this.x.redNeg(),
              this.y,
              this.z,
              this.t && this.t.redNeg()
            );
          };
          Point.prototype.getX = function getX() {
            this.normalize();
            return this.x.fromRed();
          };
          Point.prototype.getY = function getY() {
            this.normalize();
            return this.y.fromRed();
          };
          Point.prototype.eq = function eq(other) {
            return (
              this === other ||
              (this.getX().cmp(other.getX()) === 0 &&
                this.getY().cmp(other.getY()) === 0)
            );
          };
          Point.prototype.toP = Point.prototype.normalize;
          Point.prototype.mixedAdd = Point.prototype.add;
        },
        { '../../elliptic': 408, '../curve': 411, 'bn.js': 407, inherits: 381 }
      ],
      411: [
        function(require, module, exports) {
          arguments[4][312][0].apply(exports, arguments);
        },
        {
          './base': 409,
          './edwards': 410,
          './mont': 412,
          './short': 413,
          dup: 312
        }
      ],
      412: [
        function(require, module, exports) {
          'use strict';
          var curve = require('../curve');
          var bn = require('bn.js');
          var inherits = require('inherits');
          var Base = curve.base;
          var elliptic = require('../../elliptic');
          var utils = elliptic.utils;
          function MontCurve(conf) {
            Base.call(this, 'mont', conf);
            this.a = new bn(conf.a, 16).toRed(this.red);
            this.b = new bn(conf.b, 16).toRed(this.red);
            this.i4 = new bn(4).toRed(this.red).redInvm();
            this.two = new bn(2).toRed(this.red);
            this.a24 = this.i4.redMul(this.a.redAdd(this.two));
          }
          inherits(MontCurve, Base);
          module.exports = MontCurve;
          MontCurve.prototype.validate = function validate(point) {
            var x = point.normalize().x;
            var x2 = x.redSqr();
            var rhs = x2
              .redMul(x)
              .redAdd(x2.redMul(this.a))
              .redAdd(x);
            var y = rhs.redSqrt();
            return y.redSqr().cmp(rhs) === 0;
          };
          function Point(curve, x, z) {
            Base.BasePoint.call(this, curve, 'projective');
            if (x === null && z === null) {
              this.x = this.curve.one;
              this.z = this.curve.zero;
            } else {
              this.x = new bn(x, 16);
              this.z = new bn(z, 16);
              if (!this.x.red) this.x = this.x.toRed(this.curve.red);
              if (!this.z.red) this.z = this.z.toRed(this.curve.red);
            }
          }
          inherits(Point, Base.BasePoint);
          MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
            return this.point(utils.toArray(bytes, enc), 1);
          };
          MontCurve.prototype.point = function point(x, z) {
            return new Point(this, x, z);
          };
          MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
            return Point.fromJSON(this, obj);
          };
          Point.prototype.precompute = function precompute() {};
          Point.prototype._encode = function _encode() {
            return this.getX().toArray('be', this.curve.p.byteLength());
          };
          Point.fromJSON = function fromJSON(curve, obj) {
            return new Point(curve, obj[0], obj[1] || curve.one);
          };
          Point.prototype.inspect = function inspect() {
            if (this.isInfinity()) return '<EC Point Infinity>';
            return (
              '<EC Point x: ' +
              this.x.fromRed().toString(16, 2) +
              ' z: ' +
              this.z.fromRed().toString(16, 2) +
              '>'
            );
          };
          Point.prototype.isInfinity = function isInfinity() {
            return this.z.cmpn(0) === 0;
          };
          Point.prototype.dbl = function dbl() {
            var a = this.x.redAdd(this.z);
            var aa = a.redSqr();
            var b = this.x.redSub(this.z);
            var bb = b.redSqr();
            var c = aa.redSub(bb);
            var nx = aa.redMul(bb);
            var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
            return this.curve.point(nx, nz);
          };
          Point.prototype.add = function add() {
            throw new Error('Not supported on Montgomery curve');
          };
          Point.prototype.diffAdd = function diffAdd(p, diff) {
            var a = this.x.redAdd(this.z);
            var b = this.x.redSub(this.z);
            var c = p.x.redAdd(p.z);
            var d = p.x.redSub(p.z);
            var da = d.redMul(a);
            var cb = c.redMul(b);
            var nx = diff.z.redMul(da.redAdd(cb).redSqr());
            var nz = diff.x.redMul(da.redISub(cb).redSqr());
            return this.curve.point(nx, nz);
          };
          Point.prototype.mul = function mul(k) {
            var t = k.clone();
            var a = this;
            var b = this.curve.point(null, null);
            var c = this;
            for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
              bits.push(t.andln(1));
            for (var i = bits.length - 1; i >= 0; i--) {
              if (bits[i] === 0) {
                a = a.diffAdd(b, c);
                b = b.dbl();
              } else {
                b = a.diffAdd(b, c);
                a = a.dbl();
              }
            }
            return b;
          };
          Point.prototype.mulAdd = function mulAdd() {
            throw new Error('Not supported on Montgomery curve');
          };
          Point.prototype.eq = function eq(other) {
            return this.getX().cmp(other.getX()) === 0;
          };
          Point.prototype.normalize = function normalize() {
            this.x = this.x.redMul(this.z.redInvm());
            this.z = this.curve.one;
            return this;
          };
          Point.prototype.getX = function getX() {
            this.normalize();
            return this.x.fromRed();
          };
        },
        { '../../elliptic': 408, '../curve': 411, 'bn.js': 407, inherits: 381 }
      ],
      413: [
        function(require, module, exports) {
          'use strict';
          var curve = require('../curve');
          var elliptic = require('../../elliptic');
          var bn = require('bn.js');
          var inherits = require('inherits');
          var Base = curve.base;
          var assert = elliptic.utils.assert;
          function ShortCurve(conf) {
            Base.call(this, 'short', conf);
            this.a = new bn(conf.a, 16).toRed(this.red);
            this.b = new bn(conf.b, 16).toRed(this.red);
            this.tinv = this.two.redInvm();
            this.zeroA = this.a.fromRed().cmpn(0) === 0;
            this.threeA =
              this.a
                .fromRed()
                .sub(this.p)
                .cmpn(-3) === 0;
            this.endo = this._getEndomorphism(conf);
            this._endoWnafT1 = new Array(4);
            this._endoWnafT2 = new Array(4);
          }
          inherits(ShortCurve, Base);
          module.exports = ShortCurve;
          ShortCurve.prototype._getEndomorphism = function _getEndomorphism(
            conf
          ) {
            if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
              return;
            var beta;
            var lambda;
            if (conf.beta) {
              beta = new bn(conf.beta, 16).toRed(this.red);
            } else {
              var betas = this._getEndoRoots(this.p);
              beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
              beta = beta.toRed(this.red);
            }
            if (conf.lambda) {
              lambda = new bn(conf.lambda, 16);
            } else {
              var lambdas = this._getEndoRoots(this.n);
              if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
                lambda = lambdas[0];
              } else {
                lambda = lambdas[1];
                assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
              }
            }
            var basis;
            if (conf.basis) {
              basis = conf.basis.map(function(vec) {
                return { a: new bn(vec.a, 16), b: new bn(vec.b, 16) };
              });
            } else {
              basis = this._getEndoBasis(lambda);
            }
            return { beta: beta, lambda: lambda, basis: basis };
          };
          ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
            var red = num === this.p ? this.red : bn.mont(num);
            var tinv = new bn(2).toRed(red).redInvm();
            var ntinv = tinv.redNeg();
            var s = new bn(3)
              .toRed(red)
              .redNeg()
              .redSqrt()
              .redMul(tinv);
            var l1 = ntinv.redAdd(s).fromRed();
            var l2 = ntinv.redSub(s).fromRed();
            return [l1, l2];
          };
          ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
            var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
            var u = lambda;
            var v = this.n.clone();
            var x1 = new bn(1);
            var y1 = new bn(0);
            var x2 = new bn(0);
            var y2 = new bn(1);
            var a0;
            var b0;
            var a1;
            var b1;
            var a2;
            var b2;
            var prevR;
            var i = 0;
            var r;
            var x;
            while (u.cmpn(0) !== 0) {
              var q = v.div(u);
              r = v.sub(q.mul(u));
              x = x2.sub(q.mul(x1));
              var y = y2.sub(q.mul(y1));
              if (!a1 && r.cmp(aprxSqrt) < 0) {
                a0 = prevR.neg();
                b0 = x1;
                a1 = r.neg();
                b1 = x;
              } else if (a1 && ++i === 2) {
                break;
              }
              prevR = r;
              v = u;
              u = r;
              x2 = x1;
              x1 = x;
              y2 = y1;
              y1 = y;
            }
            a2 = r.neg();
            b2 = x;
            var len1 = a1.sqr().add(b1.sqr());
            var len2 = a2.sqr().add(b2.sqr());
            if (len2.cmp(len1) >= 0) {
              a2 = a0;
              b2 = b0;
            }
            if (a1.sign) {
              a1 = a1.neg();
              b1 = b1.neg();
            }
            if (a2.sign) {
              a2 = a2.neg();
              b2 = b2.neg();
            }
            return [{ a: a1, b: b1 }, { a: a2, b: b2 }];
          };
          ShortCurve.prototype._endoSplit = function _endoSplit(k) {
            var basis = this.endo.basis;
            var v1 = basis[0];
            var v2 = basis[1];
            var c1 = v2.b.mul(k).divRound(this.n);
            var c2 = v1.b
              .neg()
              .mul(k)
              .divRound(this.n);
            var p1 = c1.mul(v1.a);
            var p2 = c2.mul(v2.a);
            var q1 = c1.mul(v1.b);
            var q2 = c2.mul(v2.b);
            var k1 = k.sub(p1).sub(p2);
            var k2 = q1.add(q2).neg();
            return { k1: k1, k2: k2 };
          };
          ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
            x = new bn(x, 16);
            if (!x.red) x = x.toRed(this.red);
            var y2 = x
              .redSqr()
              .redMul(x)
              .redIAdd(x.redMul(this.a))
              .redIAdd(this.b);
            var y = y2.redSqrt();
            var isOdd = y.fromRed().isOdd();
            if ((odd && !isOdd) || (!odd && isOdd)) y = y.redNeg();
            return this.point(x, y);
          };
          ShortCurve.prototype.validate = function validate(point) {
            if (point.inf) return true;
            var x = point.x;
            var y = point.y;
            var ax = this.a.redMul(x);
            var rhs = x
              .redSqr()
              .redMul(x)
              .redIAdd(ax)
              .redIAdd(this.b);
            return (
              y
                .redSqr()
                .redISub(rhs)
                .cmpn(0) === 0
            );
          };
          ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(
            points,
            coeffs
          ) {
            var npoints = this._endoWnafT1;
            var ncoeffs = this._endoWnafT2;
            for (var i = 0; i < points.length; i++) {
              var split = this._endoSplit(coeffs[i]);
              var p = points[i];
              var beta = p._getBeta();
              if (split.k1.sign) {
                split.k1.sign = !split.k1.sign;
                p = p.neg(true);
              }
              if (split.k2.sign) {
                split.k2.sign = !split.k2.sign;
                beta = beta.neg(true);
              }
              npoints[i * 2] = p;
              npoints[i * 2 + 1] = beta;
              ncoeffs[i * 2] = split.k1;
              ncoeffs[i * 2 + 1] = split.k2;
            }
            var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2);
            for (var j = 0; j < i * 2; j++) {
              npoints[j] = null;
              ncoeffs[j] = null;
            }
            return res;
          };
          function Point(curve, x, y, isRed) {
            Base.BasePoint.call(this, curve, 'affine');
            if (x === null && y === null) {
              this.x = null;
              this.y = null;
              this.inf = true;
            } else {
              this.x = new bn(x, 16);
              this.y = new bn(y, 16);
              if (isRed) {
                this.x.forceRed(this.curve.red);
                this.y.forceRed(this.curve.red);
              }
              if (!this.x.red) this.x = this.x.toRed(this.curve.red);
              if (!this.y.red) this.y = this.y.toRed(this.curve.red);
              this.inf = false;
            }
          }
          inherits(Point, Base.BasePoint);
          ShortCurve.prototype.point = function point(x, y, isRed) {
            return new Point(this, x, y, isRed);
          };
          ShortCurve.prototype.pointFromJSON = function pointFromJSON(
            obj,
            red
          ) {
            return Point.fromJSON(this, obj, red);
          };
          Point.prototype._getBeta = function _getBeta() {
            if (!this.curve.endo) return;
            var pre = this.precomputed;
            if (pre && pre.beta) return pre.beta;
            var beta = this.curve.point(
              this.x.redMul(this.curve.endo.beta),
              this.y
            );
            if (pre) {
              var curve = this.curve;
              var endoMul = function(p) {
                return curve.point(p.x.redMul(curve.endo.beta), p.y);
              };
              pre.beta = beta;
              beta.precomputed = {
                beta: null,
                naf: pre.naf && {
                  wnd: pre.naf.wnd,
                  points: pre.naf.points.map(endoMul)
                },
                doubles: pre.doubles && {
                  step: pre.doubles.step,
                  points: pre.doubles.points.map(endoMul)
                }
              };
            }
            return beta;
          };
          Point.prototype.toJSON = function toJSON() {
            if (!this.precomputed) return [this.x, this.y];
            return [
              this.x,
              this.y,
              this.precomputed && {
                doubles: this.precomputed.doubles && {
                  step: this.precomputed.doubles.step,
                  points: this.precomputed.doubles.points.slice(1)
                },
                naf: this.precomputed.naf && {
                  wnd: this.precomputed.naf.wnd,
                  points: this.precomputed.naf.points.slice(1)
                }
              }
            ];
          };
          Point.fromJSON = function fromJSON(curve, obj, red) {
            if (typeof obj === 'string') obj = JSON.parse(obj);
            var res = curve.point(obj[0], obj[1], red);
            if (!obj[2]) return res;
            function obj2point(obj) {
              return curve.point(obj[0], obj[1], red);
            }
            var pre = obj[2];
            res.precomputed = {
              beta: null,
              doubles: pre.doubles && {
                step: pre.doubles.step,
                points: [res].concat(pre.doubles.points.map(obj2point))
              },
              naf: pre.naf && {
                wnd: pre.naf.wnd,
                points: [res].concat(pre.naf.points.map(obj2point))
              }
            };
            return res;
          };
          Point.prototype.inspect = function inspect() {
            if (this.isInfinity()) return '<EC Point Infinity>';
            return (
              '<EC Point x: ' +
              this.x.fromRed().toString(16, 2) +
              ' y: ' +
              this.y.fromRed().toString(16, 2) +
              '>'
            );
          };
          Point.prototype.isInfinity = function isInfinity() {
            return this.inf;
          };
          Point.prototype.add = function add(p) {
            if (this.inf) return p;
            if (p.inf) return this;
            if (this.eq(p)) return this.dbl();
            if (this.neg().eq(p)) return this.curve.point(null, null);
            if (this.x.cmp(p.x) === 0) return this.curve.point(null, null);
            var c = this.y.redSub(p.y);
            if (c.cmpn(0) !== 0) c = c.redMul(this.x.redSub(p.x).redInvm());
            var nx = c
              .redSqr()
              .redISub(this.x)
              .redISub(p.x);
            var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
            return this.curve.point(nx, ny);
          };
          Point.prototype.dbl = function dbl() {
            if (this.inf) return this;
            var ys1 = this.y.redAdd(this.y);
            if (ys1.cmpn(0) === 0) return this.curve.point(null, null);
            var a = this.curve.a;
            var x2 = this.x.redSqr();
            var dyinv = ys1.redInvm();
            var c = x2
              .redAdd(x2)
              .redIAdd(x2)
              .redIAdd(a)
              .redMul(dyinv);
            var nx = c.redSqr().redISub(this.x.redAdd(this.x));
            var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
            return this.curve.point(nx, ny);
          };
          Point.prototype.getX = function getX() {
            return this.x.fromRed();
          };
          Point.prototype.getY = function getY() {
            return this.y.fromRed();
          };
          Point.prototype.mul = function mul(k) {
            k = new bn(k, 16);
            if (this._hasDoubles(k)) return this.curve._fixedNafMul(this, k);
            else if (this.curve.endo)
              return this.curve._endoWnafMulAdd([this], [k]);
            else return this.curve._wnafMul(this, k);
          };
          Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
            var points = [this, p2];
            var coeffs = [k1, k2];
            if (this.curve.endo)
              return this.curve._endoWnafMulAdd(points, coeffs);
            else return this.curve._wnafMulAdd(1, points, coeffs, 2);
          };
          Point.prototype.eq = function eq(p) {
            return (
              this === p ||
              (this.inf === p.inf &&
                (this.inf || (this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0)))
            );
          };
          Point.prototype.neg = function neg(_precompute) {
            if (this.inf) return this;
            var res = this.curve.point(this.x, this.y.redNeg());
            if (_precompute && this.precomputed) {
              var pre = this.precomputed;
              var negate = function(p) {
                return p.neg();
              };
              res.precomputed = {
                naf: pre.naf && {
                  wnd: pre.naf.wnd,
                  points: pre.naf.points.map(negate)
                },
                doubles: pre.doubles && {
                  step: pre.doubles.step,
                  points: pre.doubles.points.map(negate)
                }
              };
            }
            return res;
          };
          Point.prototype.toJ = function toJ() {
            if (this.inf) return this.curve.jpoint(null, null, null);
            var res = this.curve.jpoint(this.x, this.y, this.curve.one);
            return res;
          };
          function JPoint(curve, x, y, z) {
            Base.BasePoint.call(this, curve, 'jacobian');
            if (x === null && y === null && z === null) {
              this.x = this.curve.one;
              this.y = this.curve.one;
              this.z = new bn(0);
            } else {
              this.x = new bn(x, 16);
              this.y = new bn(y, 16);
              this.z = new bn(z, 16);
            }
            if (!this.x.red) this.x = this.x.toRed(this.curve.red);
            if (!this.y.red) this.y = this.y.toRed(this.curve.red);
            if (!this.z.red) this.z = this.z.toRed(this.curve.red);
            this.zOne = this.z === this.curve.one;
          }
          inherits(JPoint, Base.BasePoint);
          ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
            return new JPoint(this, x, y, z);
          };
          JPoint.prototype.toP = function toP() {
            if (this.isInfinity()) return this.curve.point(null, null);
            var zinv = this.z.redInvm();
            var zinv2 = zinv.redSqr();
            var ax = this.x.redMul(zinv2);
            var ay = this.y.redMul(zinv2).redMul(zinv);
            return this.curve.point(ax, ay);
          };
          JPoint.prototype.neg = function neg() {
            return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
          };
          JPoint.prototype.add = function add(p) {
            if (this.isInfinity()) return p;
            if (p.isInfinity()) return this;
            var pz2 = p.z.redSqr();
            var z2 = this.z.redSqr();
            var u1 = this.x.redMul(pz2);
            var u2 = p.x.redMul(z2);
            var s1 = this.y.redMul(pz2.redMul(p.z));
            var s2 = p.y.redMul(z2.redMul(this.z));
            var h = u1.redSub(u2);
            var r = s1.redSub(s2);
            if (h.cmpn(0) === 0) {
              if (r.cmpn(0) !== 0) return this.curve.jpoint(null, null, null);
              else return this.dbl();
            }
            var h2 = h.redSqr();
            var h3 = h2.redMul(h);
            var v = u1.redMul(h2);
            var nx = r
              .redSqr()
              .redIAdd(h3)
              .redISub(v)
              .redISub(v);
            var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
            var nz = this.z.redMul(p.z).redMul(h);
            return this.curve.jpoint(nx, ny, nz);
          };
          JPoint.prototype.mixedAdd = function mixedAdd(p) {
            if (this.isInfinity()) return p.toJ();
            if (p.isInfinity()) return this;
            var z2 = this.z.redSqr();
            var u1 = this.x;
            var u2 = p.x.redMul(z2);
            var s1 = this.y;
            var s2 = p.y.redMul(z2).redMul(this.z);
            var h = u1.redSub(u2);
            var r = s1.redSub(s2);
            if (h.cmpn(0) === 0) {
              if (r.cmpn(0) !== 0) return this.curve.jpoint(null, null, null);
              else return this.dbl();
            }
            var h2 = h.redSqr();
            var h3 = h2.redMul(h);
            var v = u1.redMul(h2);
            var nx = r
              .redSqr()
              .redIAdd(h3)
              .redISub(v)
              .redISub(v);
            var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
            var nz = this.z.redMul(h);
            return this.curve.jpoint(nx, ny, nz);
          };
          JPoint.prototype.dblp = function dblp(pow) {
            if (pow === 0) return this;
            if (this.isInfinity()) return this;
            if (!pow) return this.dbl();
            if (this.curve.zeroA || this.curve.threeA) {
              var r = this;
              for (var i = 0; i < pow; i++) r = r.dbl();
              return r;
            }
            var a = this.curve.a;
            var tinv = this.curve.tinv;
            var jx = this.x;
            var jy = this.y;
            var jz = this.z;
            var jz4 = jz.redSqr().redSqr();
            var jyd = jy.redAdd(jy);
            for (var i = 0; i < pow; i++) {
              var jx2 = jx.redSqr();
              var jyd2 = jyd.redSqr();
              var jyd4 = jyd2.redSqr();
              var c = jx2
                .redAdd(jx2)
                .redIAdd(jx2)
                .redIAdd(a.redMul(jz4));
              var t1 = jx.redMul(jyd2);
              var nx = c.redSqr().redISub(t1.redAdd(t1));
              var t2 = t1.redISub(nx);
              var dny = c.redMul(t2);
              dny = dny.redIAdd(dny).redISub(jyd4);
              var nz = jyd.redMul(jz);
              if (i + 1 < pow) jz4 = jz4.redMul(jyd4);
              jx = nx;
              jz = nz;
              jyd = dny;
            }
            return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
          };
          JPoint.prototype.dbl = function dbl() {
            if (this.isInfinity()) return this;
            if (this.curve.zeroA) return this._zeroDbl();
            else if (this.curve.threeA) return this._threeDbl();
            else return this._dbl();
          };
          JPoint.prototype._zeroDbl = function _zeroDbl() {
            var nx;
            var ny;
            var nz;
            if (this.zOne) {
              var xx = this.x.redSqr();
              var yy = this.y.redSqr();
              var yyyy = yy.redSqr();
              var s = this.x
                .redAdd(yy)
                .redSqr()
                .redISub(xx)
                .redISub(yyyy);
              s = s.redIAdd(s);
              var m = xx.redAdd(xx).redIAdd(xx);
              var t = m
                .redSqr()
                .redISub(s)
                .redISub(s);
              var yyyy8 = yyyy.redIAdd(yyyy);
              yyyy8 = yyyy8.redIAdd(yyyy8);
              yyyy8 = yyyy8.redIAdd(yyyy8);
              nx = t;
              ny = m.redMul(s.redISub(t)).redISub(yyyy8);
              nz = this.y.redAdd(this.y);
            } else {
              var a = this.x.redSqr();
              var b = this.y.redSqr();
              var c = b.redSqr();
              var d = this.x
                .redAdd(b)
                .redSqr()
                .redISub(a)
                .redISub(c);
              d = d.redIAdd(d);
              var e = a.redAdd(a).redIAdd(a);
              var f = e.redSqr();
              var c8 = c.redIAdd(c);
              c8 = c8.redIAdd(c8);
              c8 = c8.redIAdd(c8);
              nx = f.redISub(d).redISub(d);
              ny = e.redMul(d.redISub(nx)).redISub(c8);
              nz = this.y.redMul(this.z);
              nz = nz.redIAdd(nz);
            }
            return this.curve.jpoint(nx, ny, nz);
          };
          JPoint.prototype._threeDbl = function _threeDbl() {
            var nx;
            var ny;
            var nz;
            if (this.zOne) {
              var xx = this.x.redSqr();
              var yy = this.y.redSqr();
              var yyyy = yy.redSqr();
              var s = this.x
                .redAdd(yy)
                .redSqr()
                .redISub(xx)
                .redISub(yyyy);
              s = s.redIAdd(s);
              var m = xx
                .redAdd(xx)
                .redIAdd(xx)
                .redIAdd(this.curve.a);
              var t = m
                .redSqr()
                .redISub(s)
                .redISub(s);
              nx = t;
              var yyyy8 = yyyy.redIAdd(yyyy);
              yyyy8 = yyyy8.redIAdd(yyyy8);
              yyyy8 = yyyy8.redIAdd(yyyy8);
              ny = m.redMul(s.redISub(t)).redISub(yyyy8);
              nz = this.y.redAdd(this.y);
            } else {
              var delta = this.z.redSqr();
              var gamma = this.y.redSqr();
              var beta = this.x.redMul(gamma);
              var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
              alpha = alpha.redAdd(alpha).redIAdd(alpha);
              var beta4 = beta.redIAdd(beta);
              beta4 = beta4.redIAdd(beta4);
              var beta8 = beta4.redAdd(beta4);
              nx = alpha.redSqr().redISub(beta8);
              nz = this.y
                .redAdd(this.z)
                .redSqr()
                .redISub(gamma)
                .redISub(delta);
              var ggamma8 = gamma.redSqr();
              ggamma8 = ggamma8.redIAdd(ggamma8);
              ggamma8 = ggamma8.redIAdd(ggamma8);
              ggamma8 = ggamma8.redIAdd(ggamma8);
              ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
            }
            return this.curve.jpoint(nx, ny, nz);
          };
          JPoint.prototype._dbl = function _dbl() {
            var a = this.curve.a;
            var jx = this.x;
            var jy = this.y;
            var jz = this.z;
            var jz4 = jz.redSqr().redSqr();
            var jx2 = jx.redSqr();
            var jy2 = jy.redSqr();
            var c = jx2
              .redAdd(jx2)
              .redIAdd(jx2)
              .redIAdd(a.redMul(jz4));
            var jxd4 = jx.redAdd(jx);
            jxd4 = jxd4.redIAdd(jxd4);
            var t1 = jxd4.redMul(jy2);
            var nx = c.redSqr().redISub(t1.redAdd(t1));
            var t2 = t1.redISub(nx);
            var jyd8 = jy2.redSqr();
            jyd8 = jyd8.redIAdd(jyd8);
            jyd8 = jyd8.redIAdd(jyd8);
            jyd8 = jyd8.redIAdd(jyd8);
            var ny = c.redMul(t2).redISub(jyd8);
            var nz = jy.redAdd(jy).redMul(jz);
            return this.curve.jpoint(nx, ny, nz);
          };
          JPoint.prototype.trpl = function trpl() {
            if (!this.curve.zeroA) return this.dbl().add(this);
            var xx = this.x.redSqr();
            var yy = this.y.redSqr();
            var zz = this.z.redSqr();
            var yyyy = yy.redSqr();
            var m = xx.redAdd(xx).redIAdd(xx);
            var mm = m.redSqr();
            var e = this.x
              .redAdd(yy)
              .redSqr()
              .redISub(xx)
              .redISub(yyyy);
            e = e.redIAdd(e);
            e = e.redAdd(e).redIAdd(e);
            e = e.redISub(mm);
            var ee = e.redSqr();
            var t = yyyy.redIAdd(yyyy);
            t = t.redIAdd(t);
            t = t.redIAdd(t);
            t = t.redIAdd(t);
            var u = m
              .redIAdd(e)
              .redSqr()
              .redISub(mm)
              .redISub(ee)
              .redISub(t);
            var yyu4 = yy.redMul(u);
            yyu4 = yyu4.redIAdd(yyu4);
            yyu4 = yyu4.redIAdd(yyu4);
            var nx = this.x.redMul(ee).redISub(yyu4);
            nx = nx.redIAdd(nx);
            nx = nx.redIAdd(nx);
            var ny = this.y.redMul(
              u.redMul(t.redISub(u)).redISub(e.redMul(ee))
            );
            ny = ny.redIAdd(ny);
            ny = ny.redIAdd(ny);
            ny = ny.redIAdd(ny);
            var nz = this.z
              .redAdd(e)
              .redSqr()
              .redISub(zz)
              .redISub(ee);
            return this.curve.jpoint(nx, ny, nz);
          };
          JPoint.prototype.mul = function mul(k, kbase) {
            k = new bn(k, kbase);
            return this.curve._wnafMul(this, k);
          };
          JPoint.prototype.eq = function eq(p) {
            if (p.type === 'affine') return this.eq(p.toJ());
            if (this === p) return true;
            var z2 = this.z.redSqr();
            var pz2 = p.z.redSqr();
            if (
              this.x
                .redMul(pz2)
                .redISub(p.x.redMul(z2))
                .cmpn(0) !== 0
            )
              return false;
            var z3 = z2.redMul(this.z);
            var pz3 = pz2.redMul(p.z);
            return (
              this.y
                .redMul(pz3)
                .redISub(p.y.redMul(z3))
                .cmpn(0) === 0
            );
          };
          JPoint.prototype.inspect = function inspect() {
            if (this.isInfinity()) return '<EC JPoint Infinity>';
            return (
              '<EC JPoint x: ' +
              this.x.toString(16, 2) +
              ' y: ' +
              this.y.toString(16, 2) +
              ' z: ' +
              this.z.toString(16, 2) +
              '>'
            );
          };
          JPoint.prototype.isInfinity = function isInfinity() {
            return this.z.cmpn(0) === 0;
          };
        },
        { '../../elliptic': 408, '../curve': 411, 'bn.js': 407, inherits: 381 }
      ],
      414: [
        function(require, module, exports) {
          'use strict';
          var curves = exports;
          var hash = require('hash.js');
          var elliptic = require('../elliptic');
          var assert = elliptic.utils.assert;
          function PresetCurve(options) {
            if (options.type === 'short')
              this.curve = new elliptic.curve.short(options);
            else if (options.type === 'edwards')
              this.curve = new elliptic.curve.edwards(options);
            else this.curve = new elliptic.curve.mont(options);
            this.g = this.curve.g;
            this.n = this.curve.n;
            this.hash = options.hash;
            assert(this.g.validate(), 'Invalid curve');
            assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
          }
          curves.PresetCurve = PresetCurve;
          function defineCurve(name, options) {
            Object.defineProperty(curves, name, {
              configurable: true,
              enumerable: true,
              get: function() {
                var curve = new PresetCurve(options);
                Object.defineProperty(curves, name, {
                  configurable: true,
                  enumerable: true,
                  value: curve
                });
                return curve;
              }
            });
          }
          defineCurve('p192', {
            type: 'short',
            prime: 'p192',
            p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
            a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
            b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
            n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
            hash: hash.sha256,
            gRed: false,
            g: [
              '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
              '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811'
            ]
          });
          defineCurve('p224', {
            type: 'short',
            prime: 'p224',
            p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
            a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
            b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
            n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
            hash: hash.sha256,
            gRed: false,
            g: [
              'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
              'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34'
            ]
          });
          defineCurve('p256', {
            type: 'short',
            prime: null,
            p:
              'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
            a:
              'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
            b:
              '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
            n:
              'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
            hash: hash.sha256,
            gRed: false,
            g: [
              '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
              '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5'
            ]
          });
          defineCurve('p384', {
            type: 'short',
            prime: null,
            p:
              'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
              'fffffffe ffffffff 00000000 00000000 ffffffff',
            a:
              'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
              'fffffffe ffffffff 00000000 00000000 fffffffc',
            b:
              'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
              '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
            n:
              'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
              'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
            hash: hash.sha384,
            gRed: false,
            g: [
              'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
                '5502f25d bf55296c 3a545e38 72760ab7',
              '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
                '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f'
            ]
          });
          defineCurve('p521', {
            type: 'short',
            prime: null,
            p:
              '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
              'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
              'ffffffff ffffffff ffffffff ffffffff ffffffff',
            a:
              '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
              'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
              'ffffffff ffffffff ffffffff ffffffff fffffffc',
            b:
              '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
              '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
              '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
            n:
              '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
              'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
              'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
            hash: hash.sha512,
            gRed: false,
            g: [
              '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
                '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
                'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
              '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
                '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
                '3fad0761 353c7086 a272c240 88be9476 9fd16650'
            ]
          });
          defineCurve('curve25519', {
            type: 'mont',
            prime: 'p25519',
            p:
              '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
            a: '76d06',
            b: '0',
            n:
              '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
            hash: hash.sha256,
            gRed: false,
            g: ['9']
          });
          defineCurve('ed25519', {
            type: 'edwards',
            prime: 'p25519',
            p:
              '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
            a: '-1',
            c: '1',
            d:
              '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
            n:
              '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
            hash: hash.sha256,
            gRed: false,
            g: [
              '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',
              '6666666666666666666666666666666666666666666666666666666666666658'
            ]
          });
          var pre;
          try {
            pre = require('./precomputed/secp256k1');
          } catch (e) {
            pre = undefined;
          }
          defineCurve('secp256k1', {
            type: 'short',
            prime: 'k256',
            p:
              'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
            a: '0',
            b: '7',
            n:
              'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
            h: '1',
            hash: hash.sha256,
            beta:
              '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
            lambda:
              '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
            basis: [
              {
                a: '3086d221a7d46bcde86c90e49284eb15',
                b: '-e4437ed6010e88286f547fa90abfe4c3'
              },
              {
                a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
                b: '3086d221a7d46bcde86c90e49284eb15'
              }
            ],
            gRed: false,
            g: [
              '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
              '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
              pre
            ]
          });
        },
        { '../elliptic': 408, './precomputed/secp256k1': 422, 'hash.js': 354 }
      ],
      415: [
        function(require, module, exports) {
          'use strict';
          var bn = require('bn.js');
          var elliptic = require('../../elliptic');
          var utils = elliptic.utils;
          var assert = utils.assert;
          var KeyPair = require('./key');
          var Signature = require('./signature');
          function EC(options) {
            if (!(this instanceof EC)) return new EC(options);
            if (typeof options === 'string') {
              assert(
                elliptic.curves.hasOwnProperty(options),
                'Unknown curve ' + options
              );
              options = elliptic.curves[options];
            }
            if (options instanceof elliptic.curves.PresetCurve)
              options = { curve: options };
            this.curve = options.curve.curve;
            this.n = this.curve.n;
            this.nh = this.n.ushrn(1);
            this.g = this.curve.g;
            this.g = options.curve.g;
            this.g.precompute(options.curve.n.bitLength() + 1);
            this.hash = options.hash || options.curve.hash;
          }
          module.exports = EC;
          EC.prototype.keyPair = function keyPair(options) {
            return new KeyPair(this, options);
          };
          EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
            return KeyPair.fromPrivate(this, priv, enc);
          };
          EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
            return KeyPair.fromPublic(this, pub, enc);
          };
          EC.prototype.genKeyPair = function genKeyPair(options) {
            if (!options) options = {};
            var drbg = new elliptic.hmacDRBG({
              hash: this.hash,
              pers: options.pers,
              entropy: options.entropy || elliptic.rand(this.hash.hmacStrength),
              nonce: this.n.toArray()
            });
            var bytes = this.n.byteLength();
            var ns2 = this.n.sub(new bn(2));
            do {
              var priv = new bn(drbg.generate(bytes));
              if (priv.cmp(ns2) > 0) continue;
              priv.iaddn(1);
              return this.keyFromPrivate(priv);
            } while (true);
          };
          EC.prototype._truncateToN = function truncateToN(msg, truncOnly) {
            var delta = msg.byteLength() * 8 - this.n.bitLength();
            if (delta > 0) msg = msg.ushrn(delta);
            if (!truncOnly && msg.cmp(this.n) >= 0) return msg.sub(this.n);
            else return msg;
          };
          EC.prototype.sign = function sign(msg, key, enc, options) {
            if (typeof enc === 'object') {
              options = enc;
              enc = null;
            }
            if (!options) options = {};
            key = this.keyFromPrivate(key, enc);
            msg = this._truncateToN(new bn(msg, 16));
            var bytes = this.n.byteLength();
            var bkey = key.getPrivate().toArray();
            for (var i = bkey.length; i < bytes; i++) bkey.unshift(0);
            var nonce = msg.toArray();
            for (var i = nonce.length; i < bytes; i++) nonce.unshift(0);
            var drbg = new elliptic.hmacDRBG({
              hash: this.hash,
              entropy: bkey,
              nonce: nonce
            });
            var ns1 = this.n.sub(new bn(1));
            do {
              var k = new bn(drbg.generate(this.n.byteLength()));
              k = this._truncateToN(k, true);
              if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0) continue;
              var kp = this.g.mul(k);
              if (kp.isInfinity()) continue;
              var kpX = kp.getX();
              var r = kpX.umod(this.n);
              if (r.cmpn(0) === 0) continue;
              var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
              s = s.umod(this.n);
              if (s.cmpn(0) === 0) continue;
              if (options.canonical && s.cmp(this.nh) > 0) s = this.n.sub(s);
              var recoveryParam =
                (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
              return new Signature({
                r: r,
                s: s,
                recoveryParam: recoveryParam
              });
            } while (true);
          };
          EC.prototype.verify = function verify(msg, signature, key, enc) {
            msg = this._truncateToN(new bn(msg, 16));
            key = this.keyFromPublic(key, enc);
            signature = new Signature(signature, 'hex');
            var r = signature.r;
            var s = signature.s;
            if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0) return false;
            if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0) return false;
            var sinv = s.invm(this.n);
            var u1 = sinv.mul(msg).umod(this.n);
            var u2 = sinv.mul(r).umod(this.n);
            var p = this.g.mulAdd(u1, key.getPublic(), u2);
            if (p.isInfinity()) return false;
            return (
              p
                .getX()
                .umod(this.n)
                .cmp(r) === 0
            );
          };
          EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
            assert((3 & j) === j, 'The recovery param is more than two bits');
            signature = new Signature(signature, enc);
            var n = this.n;
            var e = new bn(msg);
            var r = signature.r;
            var s = signature.s;
            var isYOdd = j & 1;
            var isSecondKey = j >> 1;
            if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
              throw new Error('Unable to find sencond key candinate');
            r = this.curve.pointFromX(r, isYOdd);
            var eNeg = e.neg().umod(n);
            var rInv = signature.r.invm(n);
            return r
              .mul(s)
              .add(this.g.mul(eNeg))
              .mul(rInv);
          };
          EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
            signature = new Signature(signature, enc);
            if (signature.recoveryParam !== null)
              return signature.recoveryParam;
            for (var i = 0; i < 4; i++) {
              var Qprime = this.recoverPubKey(e, signature, i);
              if (Qprime.eq(Q)) return i;
            }
            throw new Error('Unable to find valid recovery factor');
          };
        },
        {
          '../../elliptic': 408,
          './key': 416,
          './signature': 417,
          'bn.js': 407
        }
      ],
      416: [
        function(require, module, exports) {
          'use strict';
          var bn = require('bn.js');
          function KeyPair(ec, options) {
            this.ec = ec;
            this.priv = null;
            this.pub = null;
            if (options.priv)
              this._importPrivate(options.priv, options.privEnc);
            if (options.pub) this._importPublic(options.pub, options.pubEnc);
          }
          module.exports = KeyPair;
          KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
            if (pub instanceof KeyPair) return pub;
            return new KeyPair(ec, { pub: pub, pubEnc: enc });
          };
          KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
            if (priv instanceof KeyPair) return priv;
            return new KeyPair(ec, { priv: priv, privEnc: enc });
          };
          KeyPair.prototype.validate = function validate() {
            var pub = this.getPublic();
            if (pub.isInfinity())
              return { result: false, reason: 'Invalid public key' };
            if (!pub.validate())
              return { result: false, reason: 'Public key is not a point' };
            if (!pub.mul(this.ec.curve.n).isInfinity())
              return { result: false, reason: 'Public key * N != O' };
            return { result: true, reason: null };
          };
          KeyPair.prototype.getPublic = function getPublic(compact, enc) {
            if (typeof compact === 'string') {
              enc = compact;
              compact = null;
            }
            if (!this.pub) this.pub = this.ec.g.mul(this.priv);
            if (!enc) return this.pub;
            return this.pub.encode(enc, compact);
          };
          KeyPair.prototype.getPrivate = function getPrivate(enc) {
            if (enc === 'hex') return this.priv.toString(16, 2);
            else return this.priv;
          };
          KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
            this.priv = new bn(key, enc || 16);
            this.priv = this.priv.umod(this.ec.curve.n);
          };
          KeyPair.prototype._importPublic = function _importPublic(key, enc) {
            if (key.x || key.y) {
              this.pub = this.ec.curve.point(key.x, key.y);
              return;
            }
            this.pub = this.ec.curve.decodePoint(key, enc);
          };
          KeyPair.prototype.derive = function derive(pub) {
            return pub.mul(this.priv).getX();
          };
          KeyPair.prototype.sign = function sign(msg, enc, options) {
            return this.ec.sign(msg, this, enc, options);
          };
          KeyPair.prototype.verify = function verify(msg, signature) {
            return this.ec.verify(msg, signature, this);
          };
          KeyPair.prototype.inspect = function inspect() {
            return (
              '<Key priv: ' +
              (this.priv && this.priv.toString(16, 2)) +
              ' pub: ' +
              (this.pub && this.pub.inspect()) +
              ' >'
            );
          };
        },
        { 'bn.js': 407 }
      ],
      417: [
        function(require, module, exports) {
          'use strict';
          var bn = require('bn.js');
          var elliptic = require('../../elliptic');
          var utils = elliptic.utils;
          var assert = utils.assert;
          function Signature(options, enc) {
            if (options instanceof Signature) return options;
            if (this._importDER(options, enc)) return;
            assert(options.r && options.s, 'Signature without r or s');
            this.r = new bn(options.r, 16);
            this.s = new bn(options.s, 16);
            if (options.recoveryParam !== null)
              this.recoveryParam = options.recoveryParam;
            else this.recoveryParam = null;
          }
          module.exports = Signature;
          function Position() {
            this.place = 0;
          }
          function getLength(buf, p) {
            var initial = buf[p.place++];
            if (!(initial & 128)) {
              return initial;
            }
            var octetLen = initial & 15;
            var val = 0;
            for (var i = 0, off = p.place; i < octetLen; i++, off++) {
              val <<= 8;
              val |= buf[off];
            }
            p.place = off;
            return val;
          }
          function rmPadding(buf) {
            var i = 0;
            var len = buf.length - 1;
            while (!buf[i] && !(buf[i + 1] & 128) && i < len) {
              i++;
            }
            if (i === 0) {
              return buf;
            }
            return buf.slice(i);
          }
          Signature.prototype._importDER = function _importDER(data, enc) {
            data = utils.toArray(data, enc);
            var p = new Position();
            if (data[p.place++] !== 48) {
              return false;
            }
            var len = getLength(data, p);
            if (len + p.place !== data.length) {
              return false;
            }
            if (data[p.place++] !== 2) {
              return false;
            }
            var rlen = getLength(data, p);
            var r = data.slice(p.place, rlen + p.place);
            p.place += rlen;
            if (data[p.place++] !== 2) {
              return false;
            }
            var slen = getLength(data, p);
            if (data.length !== slen + p.place) {
              return false;
            }
            var s = data.slice(p.place, slen + p.place);
            if (r[0] === 0 && r[1] & 128) {
              r = r.slice(1);
            }
            if (s[0] === 0 && s[1] & 128) {
              s = s.slice(1);
            }
            this.r = new bn(r);
            this.s = new bn(s);
            this.recoveryParam = null;
            return true;
          };
          function constructLength(arr, len) {
            if (len < 128) {
              arr.push(len);
              return;
            }
            var octets = 1 + ((Math.log(len) / Math.LN2) >>> 3);
            arr.push(octets | 128);
            while (--octets) {
              arr.push((len >>> (octets << 3)) & 255);
            }
            arr.push(len);
          }
          Signature.prototype.toDER = function toDER(enc) {
            var r = this.r.toArray();
            var s = this.s.toArray();
            if (r[0] & 128) r = [0].concat(r);
            if (s[0] & 128) s = [0].concat(s);
            r = rmPadding(r);
            s = rmPadding(s);
            while (!s[0] && !(s[1] & 128)) {
              s = s.slice(1);
            }
            var arr = [2];
            constructLength(arr, r.length);
            arr = arr.concat(r);
            arr.push(2);
            constructLength(arr, s.length);
            var backHalf = arr.concat(s);
            var res = [48];
            constructLength(res, backHalf.length);
            res = res.concat(backHalf);
            return utils.encode(res, enc);
          };
        },
        { '../../elliptic': 408, 'bn.js': 407 }
      ],
      418: [
        function(require, module, exports) {
          arguments[4][319][0].apply(exports, arguments);
        },
        {
          '../../elliptic': 408,
          './key': 419,
          './signature': 420,
          dup: 319,
          'hash.js': 354
        }
      ],
      419: [
        function(require, module, exports) {
          'use strict';
          var elliptic = require('../../elliptic');
          var utils = elliptic.utils;
          var assert = utils.assert;
          var parseBytes = utils.parseBytes;
          var cachedProperty = utils.cachedProperty;
          function KeyPair(eddsa, params) {
            this.eddsa = eddsa;
            this._secret = parseBytes(params.secret);
            if (eddsa.isPoint(params.pub)) this._pub = params.pub;
            else this._pubBytes = parseBytes(params.pub);
          }
          KeyPair.fromPublic = function fromPublic(eddsa, pub) {
            if (pub instanceof KeyPair) return pub;
            return new KeyPair(eddsa, { pub: pub });
          };
          KeyPair.fromSecret = function fromSecret(eddsa, secret) {
            if (secret instanceof KeyPair) return secret;
            return new KeyPair(eddsa, { secret: secret });
          };
          KeyPair.prototype.secret = function secret() {
            return this._secret;
          };
          cachedProperty(KeyPair, function pubBytes() {
            return this.eddsa.encodePoint(this.pub());
          });
          cachedProperty(KeyPair, function pub() {
            if (this._pubBytes) return this.eddsa.decodePoint(this._pubBytes);
            return this.eddsa.g.mul(this.priv());
          });
          cachedProperty(KeyPair, function privBytes() {
            var eddsa = this.eddsa;
            var hash = this.hash();
            var lastIx = eddsa.encodingLength - 1;
            var a = hash.slice(0, eddsa.encodingLength);
            a[0] &= 248;
            a[lastIx] &= 127;
            a[lastIx] |= 64;
            return a;
          });
          cachedProperty(KeyPair, function priv() {
            return this.eddsa.decodeInt(this.privBytes());
          });
          cachedProperty(KeyPair, function hash() {
            return this.eddsa
              .hash()
              .update(this.secret())
              .digest();
          });
          cachedProperty(KeyPair, function messagePrefix() {
            return this.hash().slice(this.eddsa.encodingLength);
          });
          KeyPair.prototype.sign = function sign(message) {
            assert(this._secret, 'KeyPair can only verify');
            return this.eddsa.sign(message, this);
          };
          KeyPair.prototype.verify = function verify(message, sig) {
            return this.eddsa.verify(message, sig, this);
          };
          KeyPair.prototype.getSecret = function getSecret(enc) {
            assert(this._secret, 'KeyPair is public only');
            return utils.encode(this.secret(), enc);
          };
          KeyPair.prototype.getPublic = function getPublic(enc) {
            return utils.encode(this.pubBytes(), enc);
          };
          module.exports = KeyPair;
        },
        { '../../elliptic': 408 }
      ],
      420: [
        function(require, module, exports) {
          'use strict';
          var bn = require('bn.js');
          var elliptic = require('../../elliptic');
          var utils = elliptic.utils;
          var assert = utils.assert;
          var cachedProperty = utils.cachedProperty;
          var parseBytes = utils.parseBytes;
          function Signature(eddsa, sig) {
            this.eddsa = eddsa;
            if (typeof sig !== 'object') sig = parseBytes(sig);
            if (Array.isArray(sig)) {
              sig = {
                R: sig.slice(0, eddsa.encodingLength),
                S: sig.slice(eddsa.encodingLength)
              };
            }
            assert(sig.R && sig.S, 'Signature without R or S');
            if (eddsa.isPoint(sig.R)) this._R = sig.R;
            if (sig.S instanceof bn) this._S = sig.S;
            this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
            this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
          }
          cachedProperty(Signature, function S() {
            return this.eddsa.decodeInt(this.Sencoded());
          });
          cachedProperty(Signature, function R() {
            return this.eddsa.decodePoint(this.Rencoded());
          });
          cachedProperty(Signature, function Rencoded() {
            return this.eddsa.encodePoint(this.R());
          });
          cachedProperty(Signature, function Sencoded() {
            return this.eddsa.encodeInt(this.S());
          });
          Signature.prototype.toBytes = function toBytes() {
            return this.Rencoded().concat(this.Sencoded());
          };
          Signature.prototype.toHex = function toHex() {
            return utils.encode(this.toBytes(), 'hex').toUpperCase();
          };
          module.exports = Signature;
        },
        { '../../elliptic': 408, 'bn.js': 407 }
      ],
      421: [
        function(require, module, exports) {
          'use strict';
          var hash = require('hash.js');
          var elliptic = require('../elliptic');
          var utils = elliptic.utils;
          var assert = utils.assert;
          function HmacDRBG(options) {
            if (!(this instanceof HmacDRBG)) return new HmacDRBG(options);
            this.hash = options.hash;
            this.predResist = !!options.predResist;
            this.outLen = this.hash.outSize;
            this.minEntropy = options.minEntropy || this.hash.hmacStrength;
            this.reseed = null;
            this.reseedInterval = null;
            this.K = null;
            this.V = null;
            var entropy = utils.toArray(options.entropy, options.entropyEnc);
            var nonce = utils.toArray(options.nonce, options.nonceEnc);
            var pers = utils.toArray(options.pers, options.persEnc);
            assert(
              entropy.length >= this.minEntropy / 8,
              'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits'
            );
            this._init(entropy, nonce, pers);
          }
          module.exports = HmacDRBG;
          HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
            var seed = entropy.concat(nonce).concat(pers);
            this.K = new Array(this.outLen / 8);
            this.V = new Array(this.outLen / 8);
            for (var i = 0; i < this.V.length; i++) {
              this.K[i] = 0;
              this.V[i] = 1;
            }
            this._update(seed);
            this.reseed = 1;
            this.reseedInterval = 281474976710656;
          };
          HmacDRBG.prototype._hmac = function hmac() {
            return new hash.hmac(this.hash, this.K);
          };
          HmacDRBG.prototype._update = function update(seed) {
            var kmac = this._hmac()
              .update(this.V)
              .update([0]);
            if (seed) kmac = kmac.update(seed);
            this.K = kmac.digest();
            this.V = this._hmac()
              .update(this.V)
              .digest();
            if (!seed) return;
            this.K = this._hmac()
              .update(this.V)
              .update([1])
              .update(seed)
              .digest();
            this.V = this._hmac()
              .update(this.V)
              .digest();
          };
          HmacDRBG.prototype.reseed = function reseed(
            entropy,
            entropyEnc,
            add,
            addEnc
          ) {
            if (typeof entropyEnc !== 'string') {
              addEnc = add;
              add = entropyEnc;
              entropyEnc = null;
            }
            entropy = utils.toBuffer(entropy, entropyEnc);
            add = utils.toBuffer(add, addEnc);
            assert(
              entropy.length >= this.minEntropy / 8,
              'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits'
            );
            this._update(entropy.concat(add || []));
            this.reseed = 1;
          };
          HmacDRBG.prototype.generate = function generate(
            len,
            enc,
            add,
            addEnc
          ) {
            if (this.reseed > this.reseedInterval)
              throw new Error('Reseed is required');
            if (typeof enc !== 'string') {
              addEnc = add;
              add = enc;
              enc = null;
            }
            if (add) {
              add = utils.toArray(add, addEnc);
              this._update(add);
            }
            var temp = [];
            while (temp.length < len) {
              this.V = this._hmac()
                .update(this.V)
                .digest();
              temp = temp.concat(this.V);
            }
            var res = temp.slice(0, len);
            this._update(add);
            this.reseed++;
            return utils.encode(res, enc);
          };
        },
        { '../elliptic': 408, 'hash.js': 354 }
      ],
      422: [
        function(require, module, exports) {
          arguments[4][322][0].apply(exports, arguments);
        },
        { dup: 322 }
      ],
      423: [
        function(require, module, exports) {
          'use strict';
          var utils = exports;
          var bn = require('bn.js');
          utils.assert = function assert(val, msg) {
            if (!val) throw new Error(msg || 'Assertion failed');
          };
          function toArray(msg, enc) {
            if (Array.isArray(msg)) return msg.slice();
            if (!msg) return [];
            var res = [];
            if (typeof msg !== 'string') {
              for (var i = 0; i < msg.length; i++) res[i] = msg[i] | 0;
              return res;
            }
            if (!enc) {
              for (var i = 0; i < msg.length; i++) {
                var c = msg.charCodeAt(i);
                var hi = c >> 8;
                var lo = c & 255;
                if (hi) res.push(hi, lo);
                else res.push(lo);
              }
            } else if (enc === 'hex') {
              msg = msg.replace(/[^a-z0-9]+/gi, '');
              if (msg.length % 2 !== 0) msg = '0' + msg;
              for (var i = 0; i < msg.length; i += 2)
                res.push(parseInt(msg[i] + msg[i + 1], 16));
            }
            return res;
          }
          utils.toArray = toArray;
          function zero2(word) {
            if (word.length === 1) return '0' + word;
            else return word;
          }
          utils.zero2 = zero2;
          function toHex(msg) {
            var res = '';
            for (var i = 0; i < msg.length; i++)
              res += zero2(msg[i].toString(16));
            return res;
          }
          utils.toHex = toHex;
          utils.encode = function encode(arr, enc) {
            if (enc === 'hex') return toHex(arr);
            else return arr;
          };
          function getNAF(num, w) {
            var naf = [];
            var ws = 1 << (w + 1);
            var k = num.clone();
            while (k.cmpn(1) >= 0) {
              var z;
              if (k.isOdd()) {
                var mod = k.andln(ws - 1);
                if (mod > (ws >> 1) - 1) z = (ws >> 1) - mod;
                else z = mod;
                k.isubn(z);
              } else {
                z = 0;
              }
              naf.push(z);
              var shift = k.cmpn(0) !== 0 && k.andln(ws - 1) === 0 ? w + 1 : 1;
              for (var i = 1; i < shift; i++) naf.push(0);
              k.iushrn(shift);
            }
            return naf;
          }
          utils.getNAF = getNAF;
          function getJSF(k1, k2) {
            var jsf = [[], []];
            k1 = k1.clone();
            k2 = k2.clone();
            var d1 = 0;
            var d2 = 0;
            while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
              var m14 = (k1.andln(3) + d1) & 3;
              var m24 = (k2.andln(3) + d2) & 3;
              if (m14 === 3) m14 = -1;
              if (m24 === 3) m24 = -1;
              var u1;
              if ((m14 & 1) === 0) {
                u1 = 0;
              } else {
                var m8 = (k1.andln(7) + d1) & 7;
                if ((m8 === 3 || m8 === 5) && m24 === 2) u1 = -m14;
                else u1 = m14;
              }
              jsf[0].push(u1);
              var u2;
              if ((m24 & 1) === 0) {
                u2 = 0;
              } else {
                var m8 = (k2.andln(7) + d2) & 7;
                if ((m8 === 3 || m8 === 5) && m14 === 2) u2 = -m24;
                else u2 = m24;
              }
              jsf[1].push(u2);
              if (2 * d1 === u1 + 1) d1 = 1 - d1;
              if (2 * d2 === u2 + 1) d2 = 1 - d2;
              k1.iushrn(1);
              k2.iushrn(1);
            }
            return jsf;
          }
          utils.getJSF = getJSF;
          function cachedProperty(obj, computer) {
            var name = computer.name;
            var key = '_' + name;
            obj.prototype[name] = function cachedProperty() {
              return this[key] !== undefined
                ? this[key]
                : (this[key] = computer.call(this));
            };
          }
          utils.cachedProperty = cachedProperty;
          function parseBytes(bytes) {
            return typeof bytes === 'string'
              ? utils.toArray(bytes, 'hex')
              : bytes;
          }
          utils.parseBytes = parseBytes;
          function intFromLE(bytes) {
            return new bn(bytes, 'hex', 'le');
          }
          utils.intFromLE = intFromLE;
        },
        { 'bn.js': 407 }
      ],
      424: [
        function(require, module, exports) {
          module.exports = {
            _args: [
              [
                'elliptic@5.2.1',
                '/Users/Yukan/Desktop/work/blockstack/blockstack.js'
              ]
            ],
            _from: 'elliptic@5.2.1',
            _id: 'elliptic@5.2.1',
            _inBundle: false,
            _integrity: 'sha1-+ilLZWPG3bybo9yFlGh66ECFjxA=',
            _location: '/key-encoder/elliptic',
            _phantomChildren: {},
            _requested: {
              type: 'version',
              registry: true,
              raw: 'elliptic@5.2.1',
              name: 'elliptic',
              escapedName: 'elliptic',
              rawSpec: '5.2.1',
              saveSpec: null,
              fetchSpec: '5.2.1'
            },
            _requiredBy: ['/key-encoder'],
            _resolved:
              'https://registry.npmjs.org/elliptic/-/elliptic-5.2.1.tgz',
            _spec: '5.2.1',
            _where: '/Users/Yukan/Desktop/work/blockstack/blockstack.js',
            author: { name: 'Fedor Indutny', email: 'fedor@indutny.com' },
            bugs: { url: 'https://github.com/indutny/elliptic/issues' },
            dependencies: {
              'bn.js': '^3.1.1',
              brorand: '^1.0.1',
              'hash.js': '^1.0.0',
              inherits: '^2.0.1'
            },
            description: 'EC cryptography',
            devDependencies: {
              browserify: '^3.44.2',
              coveralls: '^2.11.3',
              istanbul: '^0.3.17',
              jscs: '^1.11.3',
              jshint: '^2.6.0',
              mocha: '^2.1.0',
              'uglify-js': '^2.4.13'
            },
            homepage: 'https://github.com/indutny/elliptic',
            keywords: ['EC', 'Elliptic', 'curve', 'Cryptography'],
            license: 'MIT',
            main: 'lib/elliptic.js',
            name: 'elliptic',
            repository: {
              type: 'git',
              url: 'git+ssh://git@github.com/indutny/elliptic.git'
            },
            scripts: {
              coveralls: 'cat ./coverage/lcov.info | coveralls',
              test:
                'make lint && istanbul test _mocha --reporter=spec test/*-test.js'
            },
            version: '5.2.1'
          };
        },
        {}
      ],
      425: [
        function(require, module, exports) {
          var MAX_SAFE_INTEGER = 9007199254740991;
          var argsTag = '[object Arguments]',
            funcTag = '[object Function]',
            genTag = '[object GeneratorFunction]';
          var reIsUint = /^(?:0|[1-9]\d*)$/;
          function apply(func, thisArg, args) {
            switch (args.length) {
              case 0:
                return func.call(thisArg);
              case 1:
                return func.call(thisArg, args[0]);
              case 2:
                return func.call(thisArg, args[0], args[1]);
              case 3:
                return func.call(thisArg, args[0], args[1], args[2]);
            }
            return func.apply(thisArg, args);
          }
          function baseTimes(n, iteratee) {
            var index = -1,
              result = Array(n);
            while (++index < n) {
              result[index] = iteratee(index);
            }
            return result;
          }
          var objectProto = Object.prototype;
          var hasOwnProperty = objectProto.hasOwnProperty;
          var objectToString = objectProto.toString;
          var propertyIsEnumerable = objectProto.propertyIsEnumerable;
          var nativeMax = Math.max;
          function arrayLikeKeys(value, inherited) {
            var result =
              isArray(value) || isArguments(value)
                ? baseTimes(value.length, String)
                : [];
            var length = result.length,
              skipIndexes = !!length;
            for (var key in value) {
              if (
                (inherited || hasOwnProperty.call(value, key)) &&
                !(skipIndexes && (key == 'length' || isIndex(key, length)))
              ) {
                result.push(key);
              }
            }
            return result;
          }
          function assignValue(object, key, value) {
            var objValue = object[key];
            if (
              !(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
              (value === undefined && !(key in object))
            ) {
              object[key] = value;
            }
          }
          function baseKeysIn(object) {
            if (!isObject(object)) {
              return nativeKeysIn(object);
            }
            var isProto = isPrototype(object),
              result = [];
            for (var key in object) {
              if (
                !(
                  key == 'constructor' &&
                  (isProto || !hasOwnProperty.call(object, key))
                )
              ) {
                result.push(key);
              }
            }
            return result;
          }
          function baseRest(func, start) {
            start = nativeMax(start === undefined ? func.length - 1 : start, 0);
            return function() {
              var args = arguments,
                index = -1,
                length = nativeMax(args.length - start, 0),
                array = Array(length);
              while (++index < length) {
                array[index] = args[start + index];
              }
              index = -1;
              var otherArgs = Array(start + 1);
              while (++index < start) {
                otherArgs[index] = args[index];
              }
              otherArgs[start] = array;
              return apply(func, this, otherArgs);
            };
          }
          function copyObject(source, props, object, customizer) {
            object || (object = {});
            var index = -1,
              length = props.length;
            while (++index < length) {
              var key = props[index];
              var newValue = customizer
                ? customizer(object[key], source[key], key, object, source)
                : undefined;
              assignValue(
                object,
                key,
                newValue === undefined ? source[key] : newValue
              );
            }
            return object;
          }
          function createAssigner(assigner) {
            return baseRest(function(object, sources) {
              var index = -1,
                length = sources.length,
                customizer = length > 1 ? sources[length - 1] : undefined,
                guard = length > 2 ? sources[2] : undefined;
              customizer =
                assigner.length > 3 && typeof customizer == 'function'
                  ? (length--, customizer)
                  : undefined;
              if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                customizer = length < 3 ? undefined : customizer;
                length = 1;
              }
              object = Object(object);
              while (++index < length) {
                var source = sources[index];
                if (source) {
                  assigner(object, source, index, customizer);
                }
              }
              return object;
            });
          }
          function isIndex(value, length) {
            length = length == null ? MAX_SAFE_INTEGER : length;
            return (
              !!length &&
              (typeof value == 'number' || reIsUint.test(value)) &&
              (value > -1 && value % 1 == 0 && value < length)
            );
          }
          function isIterateeCall(value, index, object) {
            if (!isObject(object)) {
              return false;
            }
            var type = typeof index;
            if (
              type == 'number'
                ? isArrayLike(object) && isIndex(index, object.length)
                : type == 'string' && index in object
            ) {
              return eq(object[index], value);
            }
            return false;
          }
          function isPrototype(value) {
            var Ctor = value && value.constructor,
              proto =
                (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
            return value === proto;
          }
          function nativeKeysIn(object) {
            var result = [];
            if (object != null) {
              for (var key in Object(object)) {
                result.push(key);
              }
            }
            return result;
          }
          function eq(value, other) {
            return value === other || (value !== value && other !== other);
          }
          function isArguments(value) {
            return (
              isArrayLikeObject(value) &&
              hasOwnProperty.call(value, 'callee') &&
              (!propertyIsEnumerable.call(value, 'callee') ||
                objectToString.call(value) == argsTag)
            );
          }
          var isArray = Array.isArray;
          function isArrayLike(value) {
            return (
              value != null && isLength(value.length) && !isFunction(value)
            );
          }
          function isArrayLikeObject(value) {
            return isObjectLike(value) && isArrayLike(value);
          }
          function isFunction(value) {
            var tag = isObject(value) ? objectToString.call(value) : '';
            return tag == funcTag || tag == genTag;
          }
          function isLength(value) {
            return (
              typeof value == 'number' &&
              value > -1 &&
              value % 1 == 0 &&
              value <= MAX_SAFE_INTEGER
            );
          }
          function isObject(value) {
            var type = typeof value;
            return !!value && (type == 'object' || type == 'function');
          }
          function isObjectLike(value) {
            return !!value && typeof value == 'object';
          }
          var assignIn = createAssigner(function(object, source) {
            copyObject(source, keysIn(source), object);
          });
          function keysIn(object) {
            return isArrayLike(object)
              ? arrayLikeKeys(object, true)
              : baseKeysIn(object);
          }
          module.exports = assignIn;
        },
        {}
      ],
      426: [
        function(require, module, exports) {
          (function(global) {
            var FUNC_ERROR_TEXT = 'Expected a function';
            var PLACEHOLDER = '__lodash_placeholder__';
            var BIND_FLAG = 1,
              BIND_KEY_FLAG = 2,
              CURRY_BOUND_FLAG = 4,
              CURRY_FLAG = 8,
              CURRY_RIGHT_FLAG = 16,
              PARTIAL_FLAG = 32,
              PARTIAL_RIGHT_FLAG = 64,
              ARY_FLAG = 128,
              REARG_FLAG = 256,
              FLIP_FLAG = 512;
            var INFINITY = 1 / 0,
              MAX_SAFE_INTEGER = 9007199254740991,
              MAX_INTEGER = 1.7976931348623157e308,
              NAN = 0 / 0;
            var wrapFlags = [
              ['ary', ARY_FLAG],
              ['bind', BIND_FLAG],
              ['bindKey', BIND_KEY_FLAG],
              ['curry', CURRY_FLAG],
              ['curryRight', CURRY_RIGHT_FLAG],
              ['flip', FLIP_FLAG],
              ['partial', PARTIAL_FLAG],
              ['partialRight', PARTIAL_RIGHT_FLAG],
              ['rearg', REARG_FLAG]
            ];
            var funcTag = '[object Function]',
              genTag = '[object GeneratorFunction]',
              symbolTag = '[object Symbol]';
            var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
            var reTrim = /^\s+|\s+$/g;
            var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
              reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
              reSplitDetails = /,? & /;
            var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
            var reIsBinary = /^0b[01]+$/i;
            var reIsHostCtor = /^\[object .+?Constructor\]$/;
            var reIsOctal = /^0o[0-7]+$/i;
            var reIsUint = /^(?:0|[1-9]\d*)$/;
            var freeParseInt = parseInt;
            var freeGlobal =
              typeof global == 'object' &&
              global &&
              global.Object === Object &&
              global;
            var freeSelf =
              typeof self == 'object' && self && self.Object === Object && self;
            var root = freeGlobal || freeSelf || Function('return this')();
            function apply(func, thisArg, args) {
              switch (args.length) {
                case 0:
                  return func.call(thisArg);
                case 1:
                  return func.call(thisArg, args[0]);
                case 2:
                  return func.call(thisArg, args[0], args[1]);
                case 3:
                  return func.call(thisArg, args[0], args[1], args[2]);
              }
              return func.apply(thisArg, args);
            }
            function arrayEach(array, iteratee) {
              var index = -1,
                length = array ? array.length : 0;
              while (++index < length) {
                if (iteratee(array[index], index, array) === false) {
                  break;
                }
              }
              return array;
            }
            function arrayIncludes(array, value) {
              var length = array ? array.length : 0;
              return !!length && baseIndexOf(array, value, 0) > -1;
            }
            function baseFindIndex(array, predicate, fromIndex, fromRight) {
              var length = array.length,
                index = fromIndex + (fromRight ? 1 : -1);
              while (fromRight ? index-- : ++index < length) {
                if (predicate(array[index], index, array)) {
                  return index;
                }
              }
              return -1;
            }
            function baseIndexOf(array, value, fromIndex) {
              if (value !== value) {
                return baseFindIndex(array, baseIsNaN, fromIndex);
              }
              var index = fromIndex - 1,
                length = array.length;
              while (++index < length) {
                if (array[index] === value) {
                  return index;
                }
              }
              return -1;
            }
            function baseIsNaN(value) {
              return value !== value;
            }
            function countHolders(array, placeholder) {
              var length = array.length,
                result = 0;
              while (length--) {
                if (array[length] === placeholder) {
                  result++;
                }
              }
              return result;
            }
            function getValue(object, key) {
              return object == null ? undefined : object[key];
            }
            function isHostObject(value) {
              var result = false;
              if (value != null && typeof value.toString != 'function') {
                try {
                  result = !!(value + '');
                } catch (e) {}
              }
              return result;
            }
            function replaceHolders(array, placeholder) {
              var index = -1,
                length = array.length,
                resIndex = 0,
                result = [];
              while (++index < length) {
                var value = array[index];
                if (value === placeholder || value === PLACEHOLDER) {
                  array[index] = PLACEHOLDER;
                  result[resIndex++] = index;
                }
              }
              return result;
            }
            var funcProto = Function.prototype,
              objectProto = Object.prototype;
            var coreJsData = root['__core-js_shared__'];
            var maskSrcKey = (function() {
              var uid = /[^.]+$/.exec(
                (coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO) ||
                  ''
              );
              return uid ? 'Symbol(src)_1.' + uid : '';
            })();
            var funcToString = funcProto.toString;
            var hasOwnProperty = objectProto.hasOwnProperty;
            var objectToString = objectProto.toString;
            var reIsNative = RegExp(
              '^' +
                funcToString
                  .call(hasOwnProperty)
                  .replace(reRegExpChar, '\\$&')
                  .replace(
                    /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                    '$1.*?'
                  ) +
                '$'
            );
            var objectCreate = Object.create;
            var nativeMax = Math.max,
              nativeMin = Math.min;
            var defineProperty = (function() {
              var func = getNative(Object, 'defineProperty'),
                name = getNative.name;
              return name && name.length > 2 ? func : undefined;
            })();
            function baseCreate(proto) {
              return isObject(proto) ? objectCreate(proto) : {};
            }
            function baseIsNative(value) {
              if (!isObject(value) || isMasked(value)) {
                return false;
              }
              var pattern =
                isFunction(value) || isHostObject(value)
                  ? reIsNative
                  : reIsHostCtor;
              return pattern.test(toSource(value));
            }
            function baseRest(func, start) {
              start = nativeMax(
                start === undefined ? func.length - 1 : start,
                0
              );
              return function() {
                var args = arguments,
                  index = -1,
                  length = nativeMax(args.length - start, 0),
                  array = Array(length);
                while (++index < length) {
                  array[index] = args[start + index];
                }
                index = -1;
                var otherArgs = Array(start + 1);
                while (++index < start) {
                  otherArgs[index] = args[index];
                }
                otherArgs[start] = array;
                return apply(func, this, otherArgs);
              };
            }
            function composeArgs(args, partials, holders, isCurried) {
              var argsIndex = -1,
                argsLength = args.length,
                holdersLength = holders.length,
                leftIndex = -1,
                leftLength = partials.length,
                rangeLength = nativeMax(argsLength - holdersLength, 0),
                result = Array(leftLength + rangeLength),
                isUncurried = !isCurried;
              while (++leftIndex < leftLength) {
                result[leftIndex] = partials[leftIndex];
              }
              while (++argsIndex < holdersLength) {
                if (isUncurried || argsIndex < argsLength) {
                  result[holders[argsIndex]] = args[argsIndex];
                }
              }
              while (rangeLength--) {
                result[leftIndex++] = args[argsIndex++];
              }
              return result;
            }
            function composeArgsRight(args, partials, holders, isCurried) {
              var argsIndex = -1,
                argsLength = args.length,
                holdersIndex = -1,
                holdersLength = holders.length,
                rightIndex = -1,
                rightLength = partials.length,
                rangeLength = nativeMax(argsLength - holdersLength, 0),
                result = Array(rangeLength + rightLength),
                isUncurried = !isCurried;
              while (++argsIndex < rangeLength) {
                result[argsIndex] = args[argsIndex];
              }
              var offset = argsIndex;
              while (++rightIndex < rightLength) {
                result[offset + rightIndex] = partials[rightIndex];
              }
              while (++holdersIndex < holdersLength) {
                if (isUncurried || argsIndex < argsLength) {
                  result[offset + holders[holdersIndex]] = args[argsIndex++];
                }
              }
              return result;
            }
            function copyArray(source, array) {
              var index = -1,
                length = source.length;
              array || (array = Array(length));
              while (++index < length) {
                array[index] = source[index];
              }
              return array;
            }
            function createBind(func, bitmask, thisArg) {
              var isBind = bitmask & BIND_FLAG,
                Ctor = createCtor(func);
              function wrapper() {
                var fn =
                  this && this !== root && this instanceof wrapper
                    ? Ctor
                    : func;
                return fn.apply(isBind ? thisArg : this, arguments);
              }
              return wrapper;
            }
            function createCtor(Ctor) {
              return function() {
                var args = arguments;
                switch (args.length) {
                  case 0:
                    return new Ctor();
                  case 1:
                    return new Ctor(args[0]);
                  case 2:
                    return new Ctor(args[0], args[1]);
                  case 3:
                    return new Ctor(args[0], args[1], args[2]);
                  case 4:
                    return new Ctor(args[0], args[1], args[2], args[3]);
                  case 5:
                    return new Ctor(
                      args[0],
                      args[1],
                      args[2],
                      args[3],
                      args[4]
                    );
                  case 6:
                    return new Ctor(
                      args[0],
                      args[1],
                      args[2],
                      args[3],
                      args[4],
                      args[5]
                    );
                  case 7:
                    return new Ctor(
                      args[0],
                      args[1],
                      args[2],
                      args[3],
                      args[4],
                      args[5],
                      args[6]
                    );
                }
                var thisBinding = baseCreate(Ctor.prototype),
                  result = Ctor.apply(thisBinding, args);
                return isObject(result) ? result : thisBinding;
              };
            }
            function createCurry(func, bitmask, arity) {
              var Ctor = createCtor(func);
              function wrapper() {
                var length = arguments.length,
                  args = Array(length),
                  index = length,
                  placeholder = getHolder(wrapper);
                while (index--) {
                  args[index] = arguments[index];
                }
                var holders =
                  length < 3 &&
                  args[0] !== placeholder &&
                  args[length - 1] !== placeholder
                    ? []
                    : replaceHolders(args, placeholder);
                length -= holders.length;
                if (length < arity) {
                  return createRecurry(
                    func,
                    bitmask,
                    createHybrid,
                    wrapper.placeholder,
                    undefined,
                    args,
                    holders,
                    undefined,
                    undefined,
                    arity - length
                  );
                }
                var fn =
                  this && this !== root && this instanceof wrapper
                    ? Ctor
                    : func;
                return apply(fn, this, args);
              }
              return wrapper;
            }
            function createHybrid(
              func,
              bitmask,
              thisArg,
              partials,
              holders,
              partialsRight,
              holdersRight,
              argPos,
              ary,
              arity
            ) {
              var isAry = bitmask & ARY_FLAG,
                isBind = bitmask & BIND_FLAG,
                isBindKey = bitmask & BIND_KEY_FLAG,
                isCurried = bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG),
                isFlip = bitmask & FLIP_FLAG,
                Ctor = isBindKey ? undefined : createCtor(func);
              function wrapper() {
                var length = arguments.length,
                  args = Array(length),
                  index = length;
                while (index--) {
                  args[index] = arguments[index];
                }
                if (isCurried) {
                  var placeholder = getHolder(wrapper),
                    holdersCount = countHolders(args, placeholder);
                }
                if (partials) {
                  args = composeArgs(args, partials, holders, isCurried);
                }
                if (partialsRight) {
                  args = composeArgsRight(
                    args,
                    partialsRight,
                    holdersRight,
                    isCurried
                  );
                }
                length -= holdersCount;
                if (isCurried && length < arity) {
                  var newHolders = replaceHolders(args, placeholder);
                  return createRecurry(
                    func,
                    bitmask,
                    createHybrid,
                    wrapper.placeholder,
                    thisArg,
                    args,
                    newHolders,
                    argPos,
                    ary,
                    arity - length
                  );
                }
                var thisBinding = isBind ? thisArg : this,
                  fn = isBindKey ? thisBinding[func] : func;
                length = args.length;
                if (argPos) {
                  args = reorder(args, argPos);
                } else if (isFlip && length > 1) {
                  args.reverse();
                }
                if (isAry && ary < length) {
                  args.length = ary;
                }
                if (this && this !== root && this instanceof wrapper) {
                  fn = Ctor || createCtor(fn);
                }
                return fn.apply(thisBinding, args);
              }
              return wrapper;
            }
            function createPartial(func, bitmask, thisArg, partials) {
              var isBind = bitmask & BIND_FLAG,
                Ctor = createCtor(func);
              function wrapper() {
                var argsIndex = -1,
                  argsLength = arguments.length,
                  leftIndex = -1,
                  leftLength = partials.length,
                  args = Array(leftLength + argsLength),
                  fn =
                    this && this !== root && this instanceof wrapper
                      ? Ctor
                      : func;
                while (++leftIndex < leftLength) {
                  args[leftIndex] = partials[leftIndex];
                }
                while (argsLength--) {
                  args[leftIndex++] = arguments[++argsIndex];
                }
                return apply(fn, isBind ? thisArg : this, args);
              }
              return wrapper;
            }
            function createRecurry(
              func,
              bitmask,
              wrapFunc,
              placeholder,
              thisArg,
              partials,
              holders,
              argPos,
              ary,
              arity
            ) {
              var isCurry = bitmask & CURRY_FLAG,
                newHolders = isCurry ? holders : undefined,
                newHoldersRight = isCurry ? undefined : holders,
                newPartials = isCurry ? partials : undefined,
                newPartialsRight = isCurry ? undefined : partials;
              bitmask |= isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG;
              bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);
              if (!(bitmask & CURRY_BOUND_FLAG)) {
                bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
              }
              var result = wrapFunc(
                func,
                bitmask,
                thisArg,
                newPartials,
                newHolders,
                newPartialsRight,
                newHoldersRight,
                argPos,
                ary,
                arity
              );
              result.placeholder = placeholder;
              return setWrapToString(result, func, bitmask);
            }
            function createWrap(
              func,
              bitmask,
              thisArg,
              partials,
              holders,
              argPos,
              ary,
              arity
            ) {
              var isBindKey = bitmask & BIND_KEY_FLAG;
              if (!isBindKey && typeof func != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
              }
              var length = partials ? partials.length : 0;
              if (!length) {
                bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
                partials = holders = undefined;
              }
              ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
              arity = arity === undefined ? arity : toInteger(arity);
              length -= holders ? holders.length : 0;
              if (bitmask & PARTIAL_RIGHT_FLAG) {
                var partialsRight = partials,
                  holdersRight = holders;
                partials = holders = undefined;
              }
              var newData = [
                func,
                bitmask,
                thisArg,
                partials,
                holders,
                partialsRight,
                holdersRight,
                argPos,
                ary,
                arity
              ];
              func = newData[0];
              bitmask = newData[1];
              thisArg = newData[2];
              partials = newData[3];
              holders = newData[4];
              arity = newData[9] =
                newData[9] == null
                  ? isBindKey
                    ? 0
                    : func.length
                  : nativeMax(newData[9] - length, 0);
              if (!arity && bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG)) {
                bitmask &= ~(CURRY_FLAG | CURRY_RIGHT_FLAG);
              }
              if (!bitmask || bitmask == BIND_FLAG) {
                var result = createBind(func, bitmask, thisArg);
              } else if (bitmask == CURRY_FLAG || bitmask == CURRY_RIGHT_FLAG) {
                result = createCurry(func, bitmask, arity);
              } else if (
                (bitmask == PARTIAL_FLAG ||
                  bitmask == (BIND_FLAG | PARTIAL_FLAG)) &&
                !holders.length
              ) {
                result = createPartial(func, bitmask, thisArg, partials);
              } else {
                result = createHybrid.apply(undefined, newData);
              }
              return setWrapToString(result, func, bitmask);
            }
            function getHolder(func) {
              var object = func;
              return object.placeholder;
            }
            function getNative(object, key) {
              var value = getValue(object, key);
              return baseIsNative(value) ? value : undefined;
            }
            function getWrapDetails(source) {
              var match = source.match(reWrapDetails);
              return match ? match[1].split(reSplitDetails) : [];
            }
            function insertWrapDetails(source, details) {
              var length = details.length,
                lastIndex = length - 1;
              details[lastIndex] =
                (length > 1 ? '& ' : '') + details[lastIndex];
              details = details.join(length > 2 ? ', ' : ' ');
              return source.replace(
                reWrapComment,
                '{\n/* [wrapped with ' + details + '] */\n'
              );
            }
            function isIndex(value, length) {
              length = length == null ? MAX_SAFE_INTEGER : length;
              return (
                !!length &&
                (typeof value == 'number' || reIsUint.test(value)) &&
                (value > -1 && value % 1 == 0 && value < length)
              );
            }
            function isMasked(func) {
              return !!maskSrcKey && maskSrcKey in func;
            }
            function reorder(array, indexes) {
              var arrLength = array.length,
                length = nativeMin(indexes.length, arrLength),
                oldArray = copyArray(array);
              while (length--) {
                var index = indexes[length];
                array[length] = isIndex(index, arrLength)
                  ? oldArray[index]
                  : undefined;
              }
              return array;
            }
            var setWrapToString = !defineProperty
              ? identity
              : function(wrapper, reference, bitmask) {
                  var source = reference + '';
                  return defineProperty(wrapper, 'toString', {
                    configurable: true,
                    enumerable: false,
                    value: constant(
                      insertWrapDetails(
                        source,
                        updateWrapDetails(getWrapDetails(source), bitmask)
                      )
                    )
                  });
                };
            function toSource(func) {
              if (func != null) {
                try {
                  return funcToString.call(func);
                } catch (e) {}
                try {
                  return func + '';
                } catch (e) {}
              }
              return '';
            }
            function updateWrapDetails(details, bitmask) {
              arrayEach(wrapFlags, function(pair) {
                var value = '_.' + pair[0];
                if (bitmask & pair[1] && !arrayIncludes(details, value)) {
                  details.push(value);
                }
              });
              return details.sort();
            }
            var bind = baseRest(function(func, thisArg, partials) {
              var bitmask = BIND_FLAG;
              if (partials.length) {
                var holders = replaceHolders(partials, getHolder(bind));
                bitmask |= PARTIAL_FLAG;
              }
              return createWrap(func, bitmask, thisArg, partials, holders);
            });
            function isFunction(value) {
              var tag = isObject(value) ? objectToString.call(value) : '';
              return tag == funcTag || tag == genTag;
            }
            function isObject(value) {
              var type = typeof value;
              return !!value && (type == 'object' || type == 'function');
            }
            function isObjectLike(value) {
              return !!value && typeof value == 'object';
            }
            function isSymbol(value) {
              return (
                typeof value == 'symbol' ||
                (isObjectLike(value) && objectToString.call(value) == symbolTag)
              );
            }
            function toFinite(value) {
              if (!value) {
                return value === 0 ? value : 0;
              }
              value = toNumber(value);
              if (value === INFINITY || value === -INFINITY) {
                var sign = value < 0 ? -1 : 1;
                return sign * MAX_INTEGER;
              }
              return value === value ? value : 0;
            }
            function toInteger(value) {
              var result = toFinite(value),
                remainder = result % 1;
              return result === result
                ? remainder
                  ? result - remainder
                  : result
                : 0;
            }
            function toNumber(value) {
              if (typeof value == 'number') {
                return value;
              }
              if (isSymbol(value)) {
                return NAN;
              }
              if (isObject(value)) {
                var other =
                  typeof value.valueOf == 'function' ? value.valueOf() : value;
                value = isObject(other) ? other + '' : other;
              }
              if (typeof value != 'string') {
                return value === 0 ? value : +value;
              }
              value = value.replace(reTrim, '');
              var isBinary = reIsBinary.test(value);
              return isBinary || reIsOctal.test(value)
                ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
                : reIsBadHex.test(value)
                ? NAN
                : +value;
            }
            function constant(value) {
              return function() {
                return value;
              };
            }
            function identity(value) {
              return value;
            }
            bind.placeholder = {};
            module.exports = bind;
          }.call(
            this,
            typeof global !== 'undefined'
              ? global
              : typeof self !== 'undefined'
              ? self
              : typeof window !== 'undefined'
              ? window
              : {}
          ));
        },
        {}
      ],
      427: [
        function(require, module, exports) {
          var MAX_SAFE_INTEGER = 9007199254740991;
          var argsTag = '[object Arguments]',
            funcTag = '[object Function]',
            genTag = '[object GeneratorFunction]';
          var reIsUint = /^(?:0|[1-9]\d*)$/;
          function apply(func, thisArg, args) {
            switch (args.length) {
              case 0:
                return func.call(thisArg);
              case 1:
                return func.call(thisArg, args[0]);
              case 2:
                return func.call(thisArg, args[0], args[1]);
              case 3:
                return func.call(thisArg, args[0], args[1], args[2]);
            }
            return func.apply(thisArg, args);
          }
          function baseTimes(n, iteratee) {
            var index = -1,
              result = Array(n);
            while (++index < n) {
              result[index] = iteratee(index);
            }
            return result;
          }
          var objectProto = Object.prototype;
          var hasOwnProperty = objectProto.hasOwnProperty;
          var objectToString = objectProto.toString;
          var propertyIsEnumerable = objectProto.propertyIsEnumerable;
          var nativeMax = Math.max;
          function arrayLikeKeys(value, inherited) {
            var result =
              isArray(value) || isArguments(value)
                ? baseTimes(value.length, String)
                : [];
            var length = result.length,
              skipIndexes = !!length;
            for (var key in value) {
              if (
                (inherited || hasOwnProperty.call(value, key)) &&
                !(skipIndexes && (key == 'length' || isIndex(key, length)))
              ) {
                result.push(key);
              }
            }
            return result;
          }
          function assignInDefaults(objValue, srcValue, key, object) {
            if (
              objValue === undefined ||
              (eq(objValue, objectProto[key]) &&
                !hasOwnProperty.call(object, key))
            ) {
              return srcValue;
            }
            return objValue;
          }
          function assignValue(object, key, value) {
            var objValue = object[key];
            if (
              !(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
              (value === undefined && !(key in object))
            ) {
              object[key] = value;
            }
          }
          function baseKeysIn(object) {
            if (!isObject(object)) {
              return nativeKeysIn(object);
            }
            var isProto = isPrototype(object),
              result = [];
            for (var key in object) {
              if (
                !(
                  key == 'constructor' &&
                  (isProto || !hasOwnProperty.call(object, key))
                )
              ) {
                result.push(key);
              }
            }
            return result;
          }
          function baseRest(func, start) {
            start = nativeMax(start === undefined ? func.length - 1 : start, 0);
            return function() {
              var args = arguments,
                index = -1,
                length = nativeMax(args.length - start, 0),
                array = Array(length);
              while (++index < length) {
                array[index] = args[start + index];
              }
              index = -1;
              var otherArgs = Array(start + 1);
              while (++index < start) {
                otherArgs[index] = args[index];
              }
              otherArgs[start] = array;
              return apply(func, this, otherArgs);
            };
          }
          function copyObject(source, props, object, customizer) {
            object || (object = {});
            var index = -1,
              length = props.length;
            while (++index < length) {
              var key = props[index];
              var newValue = customizer
                ? customizer(object[key], source[key], key, object, source)
                : undefined;
              assignValue(
                object,
                key,
                newValue === undefined ? source[key] : newValue
              );
            }
            return object;
          }
          function createAssigner(assigner) {
            return baseRest(function(object, sources) {
              var index = -1,
                length = sources.length,
                customizer = length > 1 ? sources[length - 1] : undefined,
                guard = length > 2 ? sources[2] : undefined;
              customizer =
                assigner.length > 3 && typeof customizer == 'function'
                  ? (length--, customizer)
                  : undefined;
              if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                customizer = length < 3 ? undefined : customizer;
                length = 1;
              }
              object = Object(object);
              while (++index < length) {
                var source = sources[index];
                if (source) {
                  assigner(object, source, index, customizer);
                }
              }
              return object;
            });
          }
          function isIndex(value, length) {
            length = length == null ? MAX_SAFE_INTEGER : length;
            return (
              !!length &&
              (typeof value == 'number' || reIsUint.test(value)) &&
              (value > -1 && value % 1 == 0 && value < length)
            );
          }
          function isIterateeCall(value, index, object) {
            if (!isObject(object)) {
              return false;
            }
            var type = typeof index;
            if (
              type == 'number'
                ? isArrayLike(object) && isIndex(index, object.length)
                : type == 'string' && index in object
            ) {
              return eq(object[index], value);
            }
            return false;
          }
          function isPrototype(value) {
            var Ctor = value && value.constructor,
              proto =
                (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
            return value === proto;
          }
          function nativeKeysIn(object) {
            var result = [];
            if (object != null) {
              for (var key in Object(object)) {
                result.push(key);
              }
            }
            return result;
          }
          function eq(value, other) {
            return value === other || (value !== value && other !== other);
          }
          function isArguments(value) {
            return (
              isArrayLikeObject(value) &&
              hasOwnProperty.call(value, 'callee') &&
              (!propertyIsEnumerable.call(value, 'callee') ||
                objectToString.call(value) == argsTag)
            );
          }
          var isArray = Array.isArray;
          function isArrayLike(value) {
            return (
              value != null && isLength(value.length) && !isFunction(value)
            );
          }
          function isArrayLikeObject(value) {
            return isObjectLike(value) && isArrayLike(value);
          }
          function isFunction(value) {
            var tag = isObject(value) ? objectToString.call(value) : '';
            return tag == funcTag || tag == genTag;
          }
          function isLength(value) {
            return (
              typeof value == 'number' &&
              value > -1 &&
              value % 1 == 0 &&
              value <= MAX_SAFE_INTEGER
            );
          }
          function isObject(value) {
            var type = typeof value;
            return !!value && (type == 'object' || type == 'function');
          }
          function isObjectLike(value) {
            return !!value && typeof value == 'object';
          }
          var assignInWith = createAssigner(function(
            object,
            source,
            srcIndex,
            customizer
          ) {
            copyObject(source, keysIn(source), object, customizer);
          });
          var defaults = baseRest(function(args) {
            args.push(undefined, assignInDefaults);
            return apply(assignInWith, undefined, args);
          });
          function keysIn(object) {
            return isArrayLike(object)
              ? arrayLikeKeys(object, true)
              : baseKeysIn(object);
          }
          module.exports = defaults;
        },
        {}
      ],
      428: [
        function(require, module, exports) {
          (function(global) {
            var LARGE_ARRAY_SIZE = 200;
            var FUNC_ERROR_TEXT = 'Expected a function';
            var HASH_UNDEFINED = '__lodash_hash_undefined__';
            var UNORDERED_COMPARE_FLAG = 1,
              PARTIAL_COMPARE_FLAG = 2;
            var INFINITY = 1 / 0,
              MAX_SAFE_INTEGER = 9007199254740991;
            var argsTag = '[object Arguments]',
              arrayTag = '[object Array]',
              boolTag = '[object Boolean]',
              dateTag = '[object Date]',
              errorTag = '[object Error]',
              funcTag = '[object Function]',
              genTag = '[object GeneratorFunction]',
              mapTag = '[object Map]',
              numberTag = '[object Number]',
              objectTag = '[object Object]',
              promiseTag = '[object Promise]',
              regexpTag = '[object RegExp]',
              setTag = '[object Set]',
              stringTag = '[object String]',
              symbolTag = '[object Symbol]',
              weakMapTag = '[object WeakMap]';
            var arrayBufferTag = '[object ArrayBuffer]',
              dataViewTag = '[object DataView]',
              float32Tag = '[object Float32Array]',
              float64Tag = '[object Float64Array]',
              int8Tag = '[object Int8Array]',
              int16Tag = '[object Int16Array]',
              int32Tag = '[object Int32Array]',
              uint8Tag = '[object Uint8Array]',
              uint8ClampedTag = '[object Uint8ClampedArray]',
              uint16Tag = '[object Uint16Array]',
              uint32Tag = '[object Uint32Array]';
            var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
              reIsPlainProp = /^\w*$/,
              reLeadingDot = /^\./,
              rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
            var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
            var reEscapeChar = /\\(\\)?/g;
            var reIsHostCtor = /^\[object .+?Constructor\]$/;
            var reIsUint = /^(?:0|[1-9]\d*)$/;
            var typedArrayTags = {};
            typedArrayTags[float32Tag] = typedArrayTags[
              float64Tag
            ] = typedArrayTags[int8Tag] = typedArrayTags[
              int16Tag
            ] = typedArrayTags[int32Tag] = typedArrayTags[
              uint8Tag
            ] = typedArrayTags[uint8ClampedTag] = typedArrayTags[
              uint16Tag
            ] = typedArrayTags[uint32Tag] = true;
            typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[
              arrayBufferTag
            ] = typedArrayTags[boolTag] = typedArrayTags[
              dataViewTag
            ] = typedArrayTags[dateTag] = typedArrayTags[
              errorTag
            ] = typedArrayTags[funcTag] = typedArrayTags[
              mapTag
            ] = typedArrayTags[numberTag] = typedArrayTags[
              objectTag
            ] = typedArrayTags[regexpTag] = typedArrayTags[
              setTag
            ] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
            var freeGlobal =
              typeof global == 'object' &&
              global &&
              global.Object === Object &&
              global;
            var freeSelf =
              typeof self == 'object' && self && self.Object === Object && self;
            var root = freeGlobal || freeSelf || Function('return this')();
            var freeExports =
              typeof exports == 'object' &&
              exports &&
              !exports.nodeType &&
              exports;
            var freeModule =
              freeExports &&
              typeof module == 'object' &&
              module &&
              !module.nodeType &&
              module;
            var moduleExports =
              freeModule && freeModule.exports === freeExports;
            var freeProcess = moduleExports && freeGlobal.process;
            var nodeUtil = (function() {
              try {
                return freeProcess && freeProcess.binding('util');
              } catch (e) {}
            })();
            var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
            function arrayFilter(array, predicate) {
              var index = -1,
                length = array ? array.length : 0,
                resIndex = 0,
                result = [];
              while (++index < length) {
                var value = array[index];
                if (predicate(value, index, array)) {
                  result[resIndex++] = value;
                }
              }
              return result;
            }
            function arraySome(array, predicate) {
              var index = -1,
                length = array ? array.length : 0;
              while (++index < length) {
                if (predicate(array[index], index, array)) {
                  return true;
                }
              }
              return false;
            }
            function baseProperty(key) {
              return function(object) {
                return object == null ? undefined : object[key];
              };
            }
            function baseTimes(n, iteratee) {
              var index = -1,
                result = Array(n);
              while (++index < n) {
                result[index] = iteratee(index);
              }
              return result;
            }
            function baseUnary(func) {
              return function(value) {
                return func(value);
              };
            }
            function getValue(object, key) {
              return object == null ? undefined : object[key];
            }
            function isHostObject(value) {
              var result = false;
              if (value != null && typeof value.toString != 'function') {
                try {
                  result = !!(value + '');
                } catch (e) {}
              }
              return result;
            }
            function mapToArray(map) {
              var index = -1,
                result = Array(map.size);
              map.forEach(function(value, key) {
                result[++index] = [key, value];
              });
              return result;
            }
            function overArg(func, transform) {
              return function(arg) {
                return func(transform(arg));
              };
            }
            function setToArray(set) {
              var index = -1,
                result = Array(set.size);
              set.forEach(function(value) {
                result[++index] = value;
              });
              return result;
            }
            var arrayProto = Array.prototype,
              funcProto = Function.prototype,
              objectProto = Object.prototype;
            var coreJsData = root['__core-js_shared__'];
            var maskSrcKey = (function() {
              var uid = /[^.]+$/.exec(
                (coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO) ||
                  ''
              );
              return uid ? 'Symbol(src)_1.' + uid : '';
            })();
            var funcToString = funcProto.toString;
            var hasOwnProperty = objectProto.hasOwnProperty;
            var objectToString = objectProto.toString;
            var reIsNative = RegExp(
              '^' +
                funcToString
                  .call(hasOwnProperty)
                  .replace(reRegExpChar, '\\$&')
                  .replace(
                    /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                    '$1.*?'
                  ) +
                '$'
            );
            var Symbol = root.Symbol,
              Uint8Array = root.Uint8Array,
              propertyIsEnumerable = objectProto.propertyIsEnumerable,
              splice = arrayProto.splice;
            var nativeKeys = overArg(Object.keys, Object);
            var DataView = getNative(root, 'DataView'),
              Map = getNative(root, 'Map'),
              Promise = getNative(root, 'Promise'),
              Set = getNative(root, 'Set'),
              WeakMap = getNative(root, 'WeakMap'),
              nativeCreate = getNative(Object, 'create');
            var dataViewCtorString = toSource(DataView),
              mapCtorString = toSource(Map),
              promiseCtorString = toSource(Promise),
              setCtorString = toSource(Set),
              weakMapCtorString = toSource(WeakMap);
            var symbolProto = Symbol ? Symbol.prototype : undefined,
              symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
              symbolToString = symbolProto ? symbolProto.toString : undefined;
            function Hash(entries) {
              var index = -1,
                length = entries ? entries.length : 0;
              this.clear();
              while (++index < length) {
                var entry = entries[index];
                this.set(entry[0], entry[1]);
              }
            }
            function hashClear() {
              this.__data__ = nativeCreate ? nativeCreate(null) : {};
            }
            function hashDelete(key) {
              return this.has(key) && delete this.__data__[key];
            }
            function hashGet(key) {
              var data = this.__data__;
              if (nativeCreate) {
                var result = data[key];
                return result === HASH_UNDEFINED ? undefined : result;
              }
              return hasOwnProperty.call(data, key) ? data[key] : undefined;
            }
            function hashHas(key) {
              var data = this.__data__;
              return nativeCreate
                ? data[key] !== undefined
                : hasOwnProperty.call(data, key);
            }
            function hashSet(key, value) {
              var data = this.__data__;
              data[key] =
                nativeCreate && value === undefined ? HASH_UNDEFINED : value;
              return this;
            }
            Hash.prototype.clear = hashClear;
            Hash.prototype['delete'] = hashDelete;
            Hash.prototype.get = hashGet;
            Hash.prototype.has = hashHas;
            Hash.prototype.set = hashSet;
            function ListCache(entries) {
              var index = -1,
                length = entries ? entries.length : 0;
              this.clear();
              while (++index < length) {
                var entry = entries[index];
                this.set(entry[0], entry[1]);
              }
            }
            function listCacheClear() {
              this.__data__ = [];
            }
            function listCacheDelete(key) {
              var data = this.__data__,
                index = assocIndexOf(data, key);
              if (index < 0) {
                return false;
              }
              var lastIndex = data.length - 1;
              if (index == lastIndex) {
                data.pop();
              } else {
                splice.call(data, index, 1);
              }
              return true;
            }
            function listCacheGet(key) {
              var data = this.__data__,
                index = assocIndexOf(data, key);
              return index < 0 ? undefined : data[index][1];
            }
            function listCacheHas(key) {
              return assocIndexOf(this.__data__, key) > -1;
            }
            function listCacheSet(key, value) {
              var data = this.__data__,
                index = assocIndexOf(data, key);
              if (index < 0) {
                data.push([key, value]);
              } else {
                data[index][1] = value;
              }
              return this;
            }
            ListCache.prototype.clear = listCacheClear;
            ListCache.prototype['delete'] = listCacheDelete;
            ListCache.prototype.get = listCacheGet;
            ListCache.prototype.has = listCacheHas;
            ListCache.prototype.set = listCacheSet;
            function MapCache(entries) {
              var index = -1,
                length = entries ? entries.length : 0;
              this.clear();
              while (++index < length) {
                var entry = entries[index];
                this.set(entry[0], entry[1]);
              }
            }
            function mapCacheClear() {
              this.__data__ = {
                hash: new Hash(),
                map: new (Map || ListCache)(),
                string: new Hash()
              };
            }
            function mapCacheDelete(key) {
              return getMapData(this, key)['delete'](key);
            }
            function mapCacheGet(key) {
              return getMapData(this, key).get(key);
            }
            function mapCacheHas(key) {
              return getMapData(this, key).has(key);
            }
            function mapCacheSet(key, value) {
              getMapData(this, key).set(key, value);
              return this;
            }
            MapCache.prototype.clear = mapCacheClear;
            MapCache.prototype['delete'] = mapCacheDelete;
            MapCache.prototype.get = mapCacheGet;
            MapCache.prototype.has = mapCacheHas;
            MapCache.prototype.set = mapCacheSet;
            function SetCache(values) {
              var index = -1,
                length = values ? values.length : 0;
              this.__data__ = new MapCache();
              while (++index < length) {
                this.add(values[index]);
              }
            }
            function setCacheAdd(value) {
              this.__data__.set(value, HASH_UNDEFINED);
              return this;
            }
            function setCacheHas(value) {
              return this.__data__.has(value);
            }
            SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
            SetCache.prototype.has = setCacheHas;
            function Stack(entries) {
              this.__data__ = new ListCache(entries);
            }
            function stackClear() {
              this.__data__ = new ListCache();
            }
            function stackDelete(key) {
              return this.__data__['delete'](key);
            }
            function stackGet(key) {
              return this.__data__.get(key);
            }
            function stackHas(key) {
              return this.__data__.has(key);
            }
            function stackSet(key, value) {
              var cache = this.__data__;
              if (cache instanceof ListCache) {
                var pairs = cache.__data__;
                if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
                  pairs.push([key, value]);
                  return this;
                }
                cache = this.__data__ = new MapCache(pairs);
              }
              cache.set(key, value);
              return this;
            }
            Stack.prototype.clear = stackClear;
            Stack.prototype['delete'] = stackDelete;
            Stack.prototype.get = stackGet;
            Stack.prototype.has = stackHas;
            Stack.prototype.set = stackSet;
            function arrayLikeKeys(value, inherited) {
              var result =
                isArray(value) || isArguments(value)
                  ? baseTimes(value.length, String)
                  : [];
              var length = result.length,
                skipIndexes = !!length;
              for (var key in value) {
                if (
                  (inherited || hasOwnProperty.call(value, key)) &&
                  !(skipIndexes && (key == 'length' || isIndex(key, length)))
                ) {
                  result.push(key);
                }
              }
              return result;
            }
            function assocIndexOf(array, key) {
              var length = array.length;
              while (length--) {
                if (eq(array[length][0], key)) {
                  return length;
                }
              }
              return -1;
            }
            var baseEach = createBaseEach(baseForOwn);
            function baseFilter(collection, predicate) {
              var result = [];
              baseEach(collection, function(value, index, collection) {
                if (predicate(value, index, collection)) {
                  result.push(value);
                }
              });
              return result;
            }
            var baseFor = createBaseFor();
            function baseForOwn(object, iteratee) {
              return object && baseFor(object, iteratee, keys);
            }
            function baseGet(object, path) {
              path = isKey(path, object) ? [path] : castPath(path);
              var index = 0,
                length = path.length;
              while (object != null && index < length) {
                object = object[toKey(path[index++])];
              }
              return index && index == length ? object : undefined;
            }
            function baseGetTag(value) {
              return objectToString.call(value);
            }
            function baseHasIn(object, key) {
              return object != null && key in Object(object);
            }
            function baseIsEqual(value, other, customizer, bitmask, stack) {
              if (value === other) {
                return true;
              }
              if (
                value == null ||
                other == null ||
                (!isObject(value) && !isObjectLike(other))
              ) {
                return value !== value && other !== other;
              }
              return baseIsEqualDeep(
                value,
                other,
                baseIsEqual,
                customizer,
                bitmask,
                stack
              );
            }
            function baseIsEqualDeep(
              object,
              other,
              equalFunc,
              customizer,
              bitmask,
              stack
            ) {
              var objIsArr = isArray(object),
                othIsArr = isArray(other),
                objTag = arrayTag,
                othTag = arrayTag;
              if (!objIsArr) {
                objTag = getTag(object);
                objTag = objTag == argsTag ? objectTag : objTag;
              }
              if (!othIsArr) {
                othTag = getTag(other);
                othTag = othTag == argsTag ? objectTag : othTag;
              }
              var objIsObj = objTag == objectTag && !isHostObject(object),
                othIsObj = othTag == objectTag && !isHostObject(other),
                isSameTag = objTag == othTag;
              if (isSameTag && !objIsObj) {
                stack || (stack = new Stack());
                return objIsArr || isTypedArray(object)
                  ? equalArrays(
                      object,
                      other,
                      equalFunc,
                      customizer,
                      bitmask,
                      stack
                    )
                  : equalByTag(
                      object,
                      other,
                      objTag,
                      equalFunc,
                      customizer,
                      bitmask,
                      stack
                    );
              }
              if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
                var objIsWrapped =
                    objIsObj && hasOwnProperty.call(object, '__wrapped__'),
                  othIsWrapped =
                    othIsObj && hasOwnProperty.call(other, '__wrapped__');
                if (objIsWrapped || othIsWrapped) {
                  var objUnwrapped = objIsWrapped ? object.value() : object,
                    othUnwrapped = othIsWrapped ? other.value() : other;
                  stack || (stack = new Stack());
                  return equalFunc(
                    objUnwrapped,
                    othUnwrapped,
                    customizer,
                    bitmask,
                    stack
                  );
                }
              }
              if (!isSameTag) {
                return false;
              }
              stack || (stack = new Stack());
              return equalObjects(
                object,
                other,
                equalFunc,
                customizer,
                bitmask,
                stack
              );
            }
            function baseIsMatch(object, source, matchData, customizer) {
              var index = matchData.length,
                length = index,
                noCustomizer = !customizer;
              if (object == null) {
                return !length;
              }
              object = Object(object);
              while (index--) {
                var data = matchData[index];
                if (
                  noCustomizer && data[2]
                    ? data[1] !== object[data[0]]
                    : !(data[0] in object)
                ) {
                  return false;
                }
              }
              while (++index < length) {
                data = matchData[index];
                var key = data[0],
                  objValue = object[key],
                  srcValue = data[1];
                if (noCustomizer && data[2]) {
                  if (objValue === undefined && !(key in object)) {
                    return false;
                  }
                } else {
                  var stack = new Stack();
                  if (customizer) {
                    var result = customizer(
                      objValue,
                      srcValue,
                      key,
                      object,
                      source,
                      stack
                    );
                  }
                  if (
                    !(result === undefined
                      ? baseIsEqual(
                          srcValue,
                          objValue,
                          customizer,
                          UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG,
                          stack
                        )
                      : result)
                  ) {
                    return false;
                  }
                }
              }
              return true;
            }
            function baseIsNative(value) {
              if (!isObject(value) || isMasked(value)) {
                return false;
              }
              var pattern =
                isFunction(value) || isHostObject(value)
                  ? reIsNative
                  : reIsHostCtor;
              return pattern.test(toSource(value));
            }
            function baseIsTypedArray(value) {
              return (
                isObjectLike(value) &&
                isLength(value.length) &&
                !!typedArrayTags[objectToString.call(value)]
              );
            }
            function baseIteratee(value) {
              if (typeof value == 'function') {
                return value;
              }
              if (value == null) {
                return identity;
              }
              if (typeof value == 'object') {
                return isArray(value)
                  ? baseMatchesProperty(value[0], value[1])
                  : baseMatches(value);
              }
              return property(value);
            }
            function baseKeys(object) {
              if (!isPrototype(object)) {
                return nativeKeys(object);
              }
              var result = [];
              for (var key in Object(object)) {
                if (hasOwnProperty.call(object, key) && key != 'constructor') {
                  result.push(key);
                }
              }
              return result;
            }
            function baseMatches(source) {
              var matchData = getMatchData(source);
              if (matchData.length == 1 && matchData[0][2]) {
                return matchesStrictComparable(
                  matchData[0][0],
                  matchData[0][1]
                );
              }
              return function(object) {
                return (
                  object === source || baseIsMatch(object, source, matchData)
                );
              };
            }
            function baseMatchesProperty(path, srcValue) {
              if (isKey(path) && isStrictComparable(srcValue)) {
                return matchesStrictComparable(toKey(path), srcValue);
              }
              return function(object) {
                var objValue = get(object, path);
                return objValue === undefined && objValue === srcValue
                  ? hasIn(object, path)
                  : baseIsEqual(
                      srcValue,
                      objValue,
                      undefined,
                      UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG
                    );
              };
            }
            function basePropertyDeep(path) {
              return function(object) {
                return baseGet(object, path);
              };
            }
            function baseToString(value) {
              if (typeof value == 'string') {
                return value;
              }
              if (isSymbol(value)) {
                return symbolToString ? symbolToString.call(value) : '';
              }
              var result = value + '';
              return result == '0' && 1 / value == -INFINITY ? '-0' : result;
            }
            function castPath(value) {
              return isArray(value) ? value : stringToPath(value);
            }
            function createBaseEach(eachFunc, fromRight) {
              return function(collection, iteratee) {
                if (collection == null) {
                  return collection;
                }
                if (!isArrayLike(collection)) {
                  return eachFunc(collection, iteratee);
                }
                var length = collection.length,
                  index = fromRight ? length : -1,
                  iterable = Object(collection);
                while (fromRight ? index-- : ++index < length) {
                  if (iteratee(iterable[index], index, iterable) === false) {
                    break;
                  }
                }
                return collection;
              };
            }
            function createBaseFor(fromRight) {
              return function(object, iteratee, keysFunc) {
                var index = -1,
                  iterable = Object(object),
                  props = keysFunc(object),
                  length = props.length;
                while (length--) {
                  var key = props[fromRight ? length : ++index];
                  if (iteratee(iterable[key], key, iterable) === false) {
                    break;
                  }
                }
                return object;
              };
            }
            function equalArrays(
              array,
              other,
              equalFunc,
              customizer,
              bitmask,
              stack
            ) {
              var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
                arrLength = array.length,
                othLength = other.length;
              if (
                arrLength != othLength &&
                !(isPartial && othLength > arrLength)
              ) {
                return false;
              }
              var stacked = stack.get(array);
              if (stacked && stack.get(other)) {
                return stacked == other;
              }
              var index = -1,
                result = true,
                seen =
                  bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : undefined;
              stack.set(array, other);
              stack.set(other, array);
              while (++index < arrLength) {
                var arrValue = array[index],
                  othValue = other[index];
                if (customizer) {
                  var compared = isPartial
                    ? customizer(othValue, arrValue, index, other, array, stack)
                    : customizer(
                        arrValue,
                        othValue,
                        index,
                        array,
                        other,
                        stack
                      );
                }
                if (compared !== undefined) {
                  if (compared) {
                    continue;
                  }
                  result = false;
                  break;
                }
                if (seen) {
                  if (
                    !arraySome(other, function(othValue, othIndex) {
                      if (
                        !seen.has(othIndex) &&
                        (arrValue === othValue ||
                          equalFunc(
                            arrValue,
                            othValue,
                            customizer,
                            bitmask,
                            stack
                          ))
                      ) {
                        return seen.add(othIndex);
                      }
                    })
                  ) {
                    result = false;
                    break;
                  }
                } else if (
                  !(
                    arrValue === othValue ||
                    equalFunc(arrValue, othValue, customizer, bitmask, stack)
                  )
                ) {
                  result = false;
                  break;
                }
              }
              stack['delete'](array);
              stack['delete'](other);
              return result;
            }
            function equalByTag(
              object,
              other,
              tag,
              equalFunc,
              customizer,
              bitmask,
              stack
            ) {
              switch (tag) {
                case dataViewTag:
                  if (
                    object.byteLength != other.byteLength ||
                    object.byteOffset != other.byteOffset
                  ) {
                    return false;
                  }
                  object = object.buffer;
                  other = other.buffer;
                case arrayBufferTag:
                  if (
                    object.byteLength != other.byteLength ||
                    !equalFunc(new Uint8Array(object), new Uint8Array(other))
                  ) {
                    return false;
                  }
                  return true;
                case boolTag:
                case dateTag:
                case numberTag:
                  return eq(+object, +other);
                case errorTag:
                  return (
                    object.name == other.name && object.message == other.message
                  );
                case regexpTag:
                case stringTag:
                  return object == other + '';
                case mapTag:
                  var convert = mapToArray;
                case setTag:
                  var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
                  convert || (convert = setToArray);
                  if (object.size != other.size && !isPartial) {
                    return false;
                  }
                  var stacked = stack.get(object);
                  if (stacked) {
                    return stacked == other;
                  }
                  bitmask |= UNORDERED_COMPARE_FLAG;
                  stack.set(object, other);
                  var result = equalArrays(
                    convert(object),
                    convert(other),
                    equalFunc,
                    customizer,
                    bitmask,
                    stack
                  );
                  stack['delete'](object);
                  return result;
                case symbolTag:
                  if (symbolValueOf) {
                    return (
                      symbolValueOf.call(object) == symbolValueOf.call(other)
                    );
                  }
              }
              return false;
            }
            function equalObjects(
              object,
              other,
              equalFunc,
              customizer,
              bitmask,
              stack
            ) {
              var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
                objProps = keys(object),
                objLength = objProps.length,
                othProps = keys(other),
                othLength = othProps.length;
              if (objLength != othLength && !isPartial) {
                return false;
              }
              var index = objLength;
              while (index--) {
                var key = objProps[index];
                if (
                  !(isPartial ? key in other : hasOwnProperty.call(other, key))
                ) {
                  return false;
                }
              }
              var stacked = stack.get(object);
              if (stacked && stack.get(other)) {
                return stacked == other;
              }
              var result = true;
              stack.set(object, other);
              stack.set(other, object);
              var skipCtor = isPartial;
              while (++index < objLength) {
                key = objProps[index];
                var objValue = object[key],
                  othValue = other[key];
                if (customizer) {
                  var compared = isPartial
                    ? customizer(othValue, objValue, key, other, object, stack)
                    : customizer(objValue, othValue, key, object, other, stack);
                }
                if (
                  !(compared === undefined
                    ? objValue === othValue ||
                      equalFunc(objValue, othValue, customizer, bitmask, stack)
                    : compared)
                ) {
                  result = false;
                  break;
                }
                skipCtor || (skipCtor = key == 'constructor');
              }
              if (result && !skipCtor) {
                var objCtor = object.constructor,
                  othCtor = other.constructor;
                if (
                  objCtor != othCtor &&
                  ('constructor' in object && 'constructor' in other) &&
                  !(
                    typeof objCtor == 'function' &&
                    objCtor instanceof objCtor &&
                    typeof othCtor == 'function' &&
                    othCtor instanceof othCtor
                  )
                ) {
                  result = false;
                }
              }
              stack['delete'](object);
              stack['delete'](other);
              return result;
            }
            function getMapData(map, key) {
              var data = map.__data__;
              return isKeyable(key)
                ? data[typeof key == 'string' ? 'string' : 'hash']
                : data.map;
            }
            function getMatchData(object) {
              var result = keys(object),
                length = result.length;
              while (length--) {
                var key = result[length],
                  value = object[key];
                result[length] = [key, value, isStrictComparable(value)];
              }
              return result;
            }
            function getNative(object, key) {
              var value = getValue(object, key);
              return baseIsNative(value) ? value : undefined;
            }
            var getTag = baseGetTag;
            if (
              (DataView &&
                getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
              (Map && getTag(new Map()) != mapTag) ||
              (Promise && getTag(Promise.resolve()) != promiseTag) ||
              (Set && getTag(new Set()) != setTag) ||
              (WeakMap && getTag(new WeakMap()) != weakMapTag)
            ) {
              getTag = function(value) {
                var result = objectToString.call(value),
                  Ctor = result == objectTag ? value.constructor : undefined,
                  ctorString = Ctor ? toSource(Ctor) : undefined;
                if (ctorString) {
                  switch (ctorString) {
                    case dataViewCtorString:
                      return dataViewTag;
                    case mapCtorString:
                      return mapTag;
                    case promiseCtorString:
                      return promiseTag;
                    case setCtorString:
                      return setTag;
                    case weakMapCtorString:
                      return weakMapTag;
                  }
                }
                return result;
              };
            }
            function hasPath(object, path, hasFunc) {
              path = isKey(path, object) ? [path] : castPath(path);
              var result,
                index = -1,
                length = path.length;
              while (++index < length) {
                var key = toKey(path[index]);
                if (!(result = object != null && hasFunc(object, key))) {
                  break;
                }
                object = object[key];
              }
              if (result) {
                return result;
              }
              var length = object ? object.length : 0;
              return (
                !!length &&
                isLength(length) &&
                isIndex(key, length) &&
                (isArray(object) || isArguments(object))
              );
            }
            function isIndex(value, length) {
              length = length == null ? MAX_SAFE_INTEGER : length;
              return (
                !!length &&
                (typeof value == 'number' || reIsUint.test(value)) &&
                (value > -1 && value % 1 == 0 && value < length)
              );
            }
            function isKey(value, object) {
              if (isArray(value)) {
                return false;
              }
              var type = typeof value;
              if (
                type == 'number' ||
                type == 'symbol' ||
                type == 'boolean' ||
                value == null ||
                isSymbol(value)
              ) {
                return true;
              }
              return (
                reIsPlainProp.test(value) ||
                !reIsDeepProp.test(value) ||
                (object != null && value in Object(object))
              );
            }
            function isKeyable(value) {
              var type = typeof value;
              return type == 'string' ||
                type == 'number' ||
                type == 'symbol' ||
                type == 'boolean'
                ? value !== '__proto__'
                : value === null;
            }
            function isMasked(func) {
              return !!maskSrcKey && maskSrcKey in func;
            }
            function isPrototype(value) {
              var Ctor = value && value.constructor,
                proto =
                  (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
              return value === proto;
            }
            function isStrictComparable(value) {
              return value === value && !isObject(value);
            }
            function matchesStrictComparable(key, srcValue) {
              return function(object) {
                if (object == null) {
                  return false;
                }
                return (
                  object[key] === srcValue &&
                  (srcValue !== undefined || key in Object(object))
                );
              };
            }
            var stringToPath = memoize(function(string) {
              string = toString(string);
              var result = [];
              if (reLeadingDot.test(string)) {
                result.push('');
              }
              string.replace(rePropName, function(
                match,
                number,
                quote,
                string
              ) {
                result.push(
                  quote ? string.replace(reEscapeChar, '$1') : number || match
                );
              });
              return result;
            });
            function toKey(value) {
              if (typeof value == 'string' || isSymbol(value)) {
                return value;
              }
              var result = value + '';
              return result == '0' && 1 / value == -INFINITY ? '-0' : result;
            }
            function toSource(func) {
              if (func != null) {
                try {
                  return funcToString.call(func);
                } catch (e) {}
                try {
                  return func + '';
                } catch (e) {}
              }
              return '';
            }
            function filter(collection, predicate) {
              var func = isArray(collection) ? arrayFilter : baseFilter;
              return func(collection, baseIteratee(predicate, 3));
            }
            function memoize(func, resolver) {
              if (
                typeof func != 'function' ||
                (resolver && typeof resolver != 'function')
              ) {
                throw new TypeError(FUNC_ERROR_TEXT);
              }
              var memoized = function() {
                var args = arguments,
                  key = resolver ? resolver.apply(this, args) : args[0],
                  cache = memoized.cache;
                if (cache.has(key)) {
                  return cache.get(key);
                }
                var result = func.apply(this, args);
                memoized.cache = cache.set(key, result);
                return result;
              };
              memoized.cache = new (memoize.Cache || MapCache)();
              return memoized;
            }
            memoize.Cache = MapCache;
            function eq(value, other) {
              return value === other || (value !== value && other !== other);
            }
            function isArguments(value) {
              return (
                isArrayLikeObject(value) &&
                hasOwnProperty.call(value, 'callee') &&
                (!propertyIsEnumerable.call(value, 'callee') ||
                  objectToString.call(value) == argsTag)
              );
            }
            var isArray = Array.isArray;
            function isArrayLike(value) {
              return (
                value != null && isLength(value.length) && !isFunction(value)
              );
            }
            function isArrayLikeObject(value) {
              return isObjectLike(value) && isArrayLike(value);
            }
            function isFunction(value) {
              var tag = isObject(value) ? objectToString.call(value) : '';
              return tag == funcTag || tag == genTag;
            }
            function isLength(value) {
              return (
                typeof value == 'number' &&
                value > -1 &&
                value % 1 == 0 &&
                value <= MAX_SAFE_INTEGER
              );
            }
            function isObject(value) {
              var type = typeof value;
              return !!value && (type == 'object' || type == 'function');
            }
            function isObjectLike(value) {
              return !!value && typeof value == 'object';
            }
            function isSymbol(value) {
              return (
                typeof value == 'symbol' ||
                (isObjectLike(value) && objectToString.call(value) == symbolTag)
              );
            }
            var isTypedArray = nodeIsTypedArray
              ? baseUnary(nodeIsTypedArray)
              : baseIsTypedArray;
            function toString(value) {
              return value == null ? '' : baseToString(value);
            }
            function get(object, path, defaultValue) {
              var result = object == null ? undefined : baseGet(object, path);
              return result === undefined ? defaultValue : result;
            }
            function hasIn(object, path) {
              return object != null && hasPath(object, path, baseHasIn);
            }
            function keys(object) {
              return isArrayLike(object)
                ? arrayLikeKeys(object)
                : baseKeys(object);
            }
            function identity(value) {
              return value;
            }
            function property(path) {
              return isKey(path)
                ? baseProperty(toKey(path))
                : basePropertyDeep(path);
            }
            module.exports = filter;
          }.call(
            this,
            typeof global !== 'undefined'
              ? global
              : typeof self !== 'undefined'
              ? self
              : typeof window !== 'undefined'
              ? window
              : {}
          ));
        },
        {}
      ],
      429: [
        function(require, module, exports) {
          (function(global) {
            var MAX_SAFE_INTEGER = 9007199254740991;
            var argsTag = '[object Arguments]',
              funcTag = '[object Function]',
              genTag = '[object GeneratorFunction]';
            var freeGlobal =
              typeof global == 'object' &&
              global &&
              global.Object === Object &&
              global;
            var freeSelf =
              typeof self == 'object' && self && self.Object === Object && self;
            var root = freeGlobal || freeSelf || Function('return this')();
            function arrayPush(array, values) {
              var index = -1,
                length = values.length,
                offset = array.length;
              while (++index < length) {
                array[offset + index] = values[index];
              }
              return array;
            }
            var objectProto = Object.prototype;
            var hasOwnProperty = objectProto.hasOwnProperty;
            var objectToString = objectProto.toString;
            var Symbol = root.Symbol,
              propertyIsEnumerable = objectProto.propertyIsEnumerable,
              spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;
            function baseFlatten(array, depth, predicate, isStrict, result) {
              var index = -1,
                length = array.length;
              predicate || (predicate = isFlattenable);
              result || (result = []);
              while (++index < length) {
                var value = array[index];
                if (depth > 0 && predicate(value)) {
                  if (depth > 1) {
                    baseFlatten(value, depth - 1, predicate, isStrict, result);
                  } else {
                    arrayPush(result, value);
                  }
                } else if (!isStrict) {
                  result[result.length] = value;
                }
              }
              return result;
            }
            function isFlattenable(value) {
              return (
                isArray(value) ||
                isArguments(value) ||
                !!(spreadableSymbol && value && value[spreadableSymbol])
              );
            }
            function flatten(array) {
              var length = array ? array.length : 0;
              return length ? baseFlatten(array, 1) : [];
            }
            function isArguments(value) {
              return (
                isArrayLikeObject(value) &&
                hasOwnProperty.call(value, 'callee') &&
                (!propertyIsEnumerable.call(value, 'callee') ||
                  objectToString.call(value) == argsTag)
              );
            }
            var isArray = Array.isArray;
            function isArrayLike(value) {
              return (
                value != null && isLength(value.length) && !isFunction(value)
              );
            }
            function isArrayLikeObject(value) {
              return isObjectLike(value) && isArrayLike(value);
            }
            function isFunction(value) {
              var tag = isObject(value) ? objectToString.call(value) : '';
              return tag == funcTag || tag == genTag;
            }
            function isLength(value) {
              return (
                typeof value == 'number' &&
                value > -1 &&
                value % 1 == 0 &&
                value <= MAX_SAFE_INTEGER
              );
            }
            function isObject(value) {
              var type = typeof value;
              return !!value && (type == 'object' || type == 'function');
            }
            function isObjectLike(value) {
              return !!value && typeof value == 'object';
            }
            module.exports = flatten;
          }.call(
            this,
            typeof global !== 'undefined'
              ? global
              : typeof self !== 'undefined'
              ? self
              : typeof window !== 'undefined'
              ? window
              : {}
          ));
        },
        {}
      ],
      430: [
        function(require, module, exports) {
          var MAX_SAFE_INTEGER = 9007199254740991;
          var argsTag = '[object Arguments]',
            funcTag = '[object Function]',
            genTag = '[object GeneratorFunction]';
          var reIsUint = /^(?:0|[1-9]\d*)$/;
          function arrayEach(array, iteratee) {
            var index = -1,
              length = array ? array.length : 0;
            while (++index < length) {
              if (iteratee(array[index], index, array) === false) {
                break;
              }
            }
            return array;
          }
          function baseTimes(n, iteratee) {
            var index = -1,
              result = Array(n);
            while (++index < n) {
              result[index] = iteratee(index);
            }
            return result;
          }
          function overArg(func, transform) {
            return function(arg) {
              return func(transform(arg));
            };
          }
          var objectProto = Object.prototype;
          var hasOwnProperty = objectProto.hasOwnProperty;
          var objectToString = objectProto.toString;
          var propertyIsEnumerable = objectProto.propertyIsEnumerable;
          var nativeKeys = overArg(Object.keys, Object);
          function arrayLikeKeys(value, inherited) {
            var result =
              isArray(value) || isArguments(value)
                ? baseTimes(value.length, String)
                : [];
            var length = result.length,
              skipIndexes = !!length;
            for (var key in value) {
              if (
                (inherited || hasOwnProperty.call(value, key)) &&
                !(skipIndexes && (key == 'length' || isIndex(key, length)))
              ) {
                result.push(key);
              }
            }
            return result;
          }
          var baseEach = createBaseEach(baseForOwn);
          var baseFor = createBaseFor();
          function baseForOwn(object, iteratee) {
            return object && baseFor(object, iteratee, keys);
          }
          function baseKeys(object) {
            if (!isPrototype(object)) {
              return nativeKeys(object);
            }
            var result = [];
            for (var key in Object(object)) {
              if (hasOwnProperty.call(object, key) && key != 'constructor') {
                result.push(key);
              }
            }
            return result;
          }
          function createBaseEach(eachFunc, fromRight) {
            return function(collection, iteratee) {
              if (collection == null) {
                return collection;
              }
              if (!isArrayLike(collection)) {
                return eachFunc(collection, iteratee);
              }
              var length = collection.length,
                index = fromRight ? length : -1,
                iterable = Object(collection);
              while (fromRight ? index-- : ++index < length) {
                if (iteratee(iterable[index], index, iterable) === false) {
                  break;
                }
              }
              return collection;
            };
          }
          function createBaseFor(fromRight) {
            return function(object, iteratee, keysFunc) {
              var index = -1,
                iterable = Object(object),
                props = keysFunc(object),
                length = props.length;
              while (length--) {
                var key = props[fromRight ? length : ++index];
                if (iteratee(iterable[key], key, iterable) === false) {
                  break;
                }
              }
              return object;
            };
          }
          function isIndex(value, length) {
            length = length == null ? MAX_SAFE_INTEGER : length;
            return (
              !!length &&
              (typeof value == 'number' || reIsUint.test(value)) &&
              (value > -1 && value % 1 == 0 && value < length)
            );
          }
          function isPrototype(value) {
            var Ctor = value && value.constructor,
              proto =
                (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
            return value === proto;
          }
          function forEach(collection, iteratee) {
            var func = isArray(collection) ? arrayEach : baseEach;
            return func(
              collection,
              typeof iteratee == 'function' ? iteratee : identity
            );
          }
          function isArguments(value) {
            return (
              isArrayLikeObject(value) &&
              hasOwnProperty.call(value, 'callee') &&
              (!propertyIsEnumerable.call(value, 'callee') ||
                objectToString.call(value) == argsTag)
            );
          }
          var isArray = Array.isArray;
          function isArrayLike(value) {
            return (
              value != null && isLength(value.length) && !isFunction(value)
            );
          }
          function isArrayLikeObject(value) {
            return isObjectLike(value) && isArrayLike(value);
          }
          function isFunction(value) {
            var tag = isObject(value) ? objectToString.call(value) : '';
            return tag == funcTag || tag == genTag;
          }
          function isLength(value) {
            return (
              typeof value == 'number' &&
              value > -1 &&
              value % 1 == 0 &&
              value <= MAX_SAFE_INTEGER
            );
          }
          function isObject(value) {
            var type = typeof value;
            return !!value && (type == 'object' || type == 'function');
          }
          function isObjectLike(value) {
            return !!value && typeof value == 'object';
          }
          function keys(object) {
            return isArrayLike(object)
              ? arrayLikeKeys(object)
              : baseKeys(object);
          }
          function identity(value) {
            return value;
          }
          module.exports = forEach;
        },
        {}
      ],
      431: [
        function(require, module, exports) {
          (function(global) {
            var LARGE_ARRAY_SIZE = 200;
            var FUNC_ERROR_TEXT = 'Expected a function';
            var HASH_UNDEFINED = '__lodash_hash_undefined__';
            var UNORDERED_COMPARE_FLAG = 1,
              PARTIAL_COMPARE_FLAG = 2;
            var INFINITY = 1 / 0,
              MAX_SAFE_INTEGER = 9007199254740991;
            var argsTag = '[object Arguments]',
              arrayTag = '[object Array]',
              boolTag = '[object Boolean]',
              dateTag = '[object Date]',
              errorTag = '[object Error]',
              funcTag = '[object Function]',
              genTag = '[object GeneratorFunction]',
              mapTag = '[object Map]',
              numberTag = '[object Number]',
              objectTag = '[object Object]',
              promiseTag = '[object Promise]',
              regexpTag = '[object RegExp]',
              setTag = '[object Set]',
              stringTag = '[object String]',
              symbolTag = '[object Symbol]',
              weakMapTag = '[object WeakMap]';
            var arrayBufferTag = '[object ArrayBuffer]',
              dataViewTag = '[object DataView]',
              float32Tag = '[object Float32Array]',
              float64Tag = '[object Float64Array]',
              int8Tag = '[object Int8Array]',
              int16Tag = '[object Int16Array]',
              int32Tag = '[object Int32Array]',
              uint8Tag = '[object Uint8Array]',
              uint8ClampedTag = '[object Uint8ClampedArray]',
              uint16Tag = '[object Uint16Array]',
              uint32Tag = '[object Uint32Array]';
            var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
              reIsPlainProp = /^\w*$/,
              reLeadingDot = /^\./,
              rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
            var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
            var reEscapeChar = /\\(\\)?/g;
            var reIsHostCtor = /^\[object .+?Constructor\]$/;
            var reIsUint = /^(?:0|[1-9]\d*)$/;
            var typedArrayTags = {};
            typedArrayTags[float32Tag] = typedArrayTags[
              float64Tag
            ] = typedArrayTags[int8Tag] = typedArrayTags[
              int16Tag
            ] = typedArrayTags[int32Tag] = typedArrayTags[
              uint8Tag
            ] = typedArrayTags[uint8ClampedTag] = typedArrayTags[
              uint16Tag
            ] = typedArrayTags[uint32Tag] = true;
            typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[
              arrayBufferTag
            ] = typedArrayTags[boolTag] = typedArrayTags[
              dataViewTag
            ] = typedArrayTags[dateTag] = typedArrayTags[
              errorTag
            ] = typedArrayTags[funcTag] = typedArrayTags[
              mapTag
            ] = typedArrayTags[numberTag] = typedArrayTags[
              objectTag
            ] = typedArrayTags[regexpTag] = typedArrayTags[
              setTag
            ] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
            var freeGlobal =
              typeof global == 'object' &&
              global &&
              global.Object === Object &&
              global;
            var freeSelf =
              typeof self == 'object' && self && self.Object === Object && self;
            var root = freeGlobal || freeSelf || Function('return this')();
            var freeExports =
              typeof exports == 'object' &&
              exports &&
              !exports.nodeType &&
              exports;
            var freeModule =
              freeExports &&
              typeof module == 'object' &&
              module &&
              !module.nodeType &&
              module;
            var moduleExports =
              freeModule && freeModule.exports === freeExports;
            var freeProcess = moduleExports && freeGlobal.process;
            var nodeUtil = (function() {
              try {
                return freeProcess && freeProcess.binding('util');
              } catch (e) {}
            })();
            var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
            function arrayMap(array, iteratee) {
              var index = -1,
                length = array ? array.length : 0,
                result = Array(length);
              while (++index < length) {
                result[index] = iteratee(array[index], index, array);
              }
              return result;
            }
            function arraySome(array, predicate) {
              var index = -1,
                length = array ? array.length : 0;
              while (++index < length) {
                if (predicate(array[index], index, array)) {
                  return true;
                }
              }
              return false;
            }
            function baseProperty(key) {
              return function(object) {
                return object == null ? undefined : object[key];
              };
            }
            function baseTimes(n, iteratee) {
              var index = -1,
                result = Array(n);
              while (++index < n) {
                result[index] = iteratee(index);
              }
              return result;
            }
            function baseUnary(func) {
              return function(value) {
                return func(value);
              };
            }
            function getValue(object, key) {
              return object == null ? undefined : object[key];
            }
            function isHostObject(value) {
              var result = false;
              if (value != null && typeof value.toString != 'function') {
                try {
                  result = !!(value + '');
                } catch (e) {}
              }
              return result;
            }
            function mapToArray(map) {
              var index = -1,
                result = Array(map.size);
              map.forEach(function(value, key) {
                result[++index] = [key, value];
              });
              return result;
            }
            function overArg(func, transform) {
              return function(arg) {
                return func(transform(arg));
              };
            }
            function setToArray(set) {
              var index = -1,
                result = Array(set.size);
              set.forEach(function(value) {
                result[++index] = value;
              });
              return result;
            }
            var arrayProto = Array.prototype,
              funcProto = Function.prototype,
              objectProto = Object.prototype;
            var coreJsData = root['__core-js_shared__'];
            var maskSrcKey = (function() {
              var uid = /[^.]+$/.exec(
                (coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO) ||
                  ''
              );
              return uid ? 'Symbol(src)_1.' + uid : '';
            })();
            var funcToString = funcProto.toString;
            var hasOwnProperty = objectProto.hasOwnProperty;
            var objectToString = objectProto.toString;
            var reIsNative = RegExp(
              '^' +
                funcToString
                  .call(hasOwnProperty)
                  .replace(reRegExpChar, '\\$&')
                  .replace(
                    /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                    '$1.*?'
                  ) +
                '$'
            );
            var Symbol = root.Symbol,
              Uint8Array = root.Uint8Array,
              propertyIsEnumerable = objectProto.propertyIsEnumerable,
              splice = arrayProto.splice;
            var nativeKeys = overArg(Object.keys, Object);
            var DataView = getNative(root, 'DataView'),
              Map = getNative(root, 'Map'),
              Promise = getNative(root, 'Promise'),
              Set = getNative(root, 'Set'),
              WeakMap = getNative(root, 'WeakMap'),
              nativeCreate = getNative(Object, 'create');
            var dataViewCtorString = toSource(DataView),
              mapCtorString = toSource(Map),
              promiseCtorString = toSource(Promise),
              setCtorString = toSource(Set),
              weakMapCtorString = toSource(WeakMap);
            var symbolProto = Symbol ? Symbol.prototype : undefined,
              symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
              symbolToString = symbolProto ? symbolProto.toString : undefined;
            function Hash(entries) {
              var index = -1,
                length = entries ? entries.length : 0;
              this.clear();
              while (++index < length) {
                var entry = entries[index];
                this.set(entry[0], entry[1]);
              }
            }
            function hashClear() {
              this.__data__ = nativeCreate ? nativeCreate(null) : {};
            }
            function hashDelete(key) {
              return this.has(key) && delete this.__data__[key];
            }
            function hashGet(key) {
              var data = this.__data__;
              if (nativeCreate) {
                var result = data[key];
                return result === HASH_UNDEFINED ? undefined : result;
              }
              return hasOwnProperty.call(data, key) ? data[key] : undefined;
            }
            function hashHas(key) {
              var data = this.__data__;
              return nativeCreate
                ? data[key] !== undefined
                : hasOwnProperty.call(data, key);
            }
            function hashSet(key, value) {
              var data = this.__data__;
              data[key] =
                nativeCreate && value === undefined ? HASH_UNDEFINED : value;
              return this;
            }
            Hash.prototype.clear = hashClear;
            Hash.prototype['delete'] = hashDelete;
            Hash.prototype.get = hashGet;
            Hash.prototype.has = hashHas;
            Hash.prototype.set = hashSet;
            function ListCache(entries) {
              var index = -1,
                length = entries ? entries.length : 0;
              this.clear();
              while (++index < length) {
                var entry = entries[index];
                this.set(entry[0], entry[1]);
              }
            }
            function listCacheClear() {
              this.__data__ = [];
            }
            function listCacheDelete(key) {
              var data = this.__data__,
                index = assocIndexOf(data, key);
              if (index < 0) {
                return false;
              }
              var lastIndex = data.length - 1;
              if (index == lastIndex) {
                data.pop();
              } else {
                splice.call(data, index, 1);
              }
              return true;
            }
            function listCacheGet(key) {
              var data = this.__data__,
                index = assocIndexOf(data, key);
              return index < 0 ? undefined : data[index][1];
            }
            function listCacheHas(key) {
              return assocIndexOf(this.__data__, key) > -1;
            }
            function listCacheSet(key, value) {
              var data = this.__data__,
                index = assocIndexOf(data, key);
              if (index < 0) {
                data.push([key, value]);
              } else {
                data[index][1] = value;
              }
              return this;
            }
            ListCache.prototype.clear = listCacheClear;
            ListCache.prototype['delete'] = listCacheDelete;
            ListCache.prototype.get = listCacheGet;
            ListCache.prototype.has = listCacheHas;
            ListCache.prototype.set = listCacheSet;
            function MapCache(entries) {
              var index = -1,
                length = entries ? entries.length : 0;
              this.clear();
              while (++index < length) {
                var entry = entries[index];
                this.set(entry[0], entry[1]);
              }
            }
            function mapCacheClear() {
              this.__data__ = {
                hash: new Hash(),
                map: new (Map || ListCache)(),
                string: new Hash()
              };
            }
            function mapCacheDelete(key) {
              return getMapData(this, key)['delete'](key);
            }
            function mapCacheGet(key) {
              return getMapData(this, key).get(key);
            }
            function mapCacheHas(key) {
              return getMapData(this, key).has(key);
            }
            function mapCacheSet(key, value) {
              getMapData(this, key).set(key, value);
              return this;
            }
            MapCache.prototype.clear = mapCacheClear;
            MapCache.prototype['delete'] = mapCacheDelete;
            MapCache.prototype.get = mapCacheGet;
            MapCache.prototype.has = mapCacheHas;
            MapCache.prototype.set = mapCacheSet;
            function SetCache(values) {
              var index = -1,
                length = values ? values.length : 0;
              this.__data__ = new MapCache();
              while (++index < length) {
                this.add(values[index]);
              }
            }
            function setCacheAdd(value) {
              this.__data__.set(value, HASH_UNDEFINED);
              return this;
            }
            function setCacheHas(value) {
              return this.__data__.has(value);
            }
            SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
            SetCache.prototype.has = setCacheHas;
            function Stack(entries) {
              this.__data__ = new ListCache(entries);
            }
            function stackClear() {
              this.__data__ = new ListCache();
            }
            function stackDelete(key) {
              return this.__data__['delete'](key);
            }
            function stackGet(key) {
              return this.__data__.get(key);
            }
            function stackHas(key) {
              return this.__data__.has(key);
            }
            function stackSet(key, value) {
              var cache = this.__data__;
              if (cache instanceof ListCache) {
                var pairs = cache.__data__;
                if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
                  pairs.push([key, value]);
                  return this;
                }
                cache = this.__data__ = new MapCache(pairs);
              }
              cache.set(key, value);
              return this;
            }
            Stack.prototype.clear = stackClear;
            Stack.prototype['delete'] = stackDelete;
            Stack.prototype.get = stackGet;
            Stack.prototype.has = stackHas;
            Stack.prototype.set = stackSet;
            function arrayLikeKeys(value, inherited) {
              var result =
                isArray(value) || isArguments(value)
                  ? baseTimes(value.length, String)
                  : [];
              var length = result.length,
                skipIndexes = !!length;
              for (var key in value) {
                if (
                  (inherited || hasOwnProperty.call(value, key)) &&
                  !(skipIndexes && (key == 'length' || isIndex(key, length)))
                ) {
                  result.push(key);
                }
              }
              return result;
            }
            function assocIndexOf(array, key) {
              var length = array.length;
              while (length--) {
                if (eq(array[length][0], key)) {
                  return length;
                }
              }
              return -1;
            }
            var baseEach = createBaseEach(baseForOwn);
            var baseFor = createBaseFor();
            function baseForOwn(object, iteratee) {
              return object && baseFor(object, iteratee, keys);
            }
            function baseGet(object, path) {
              path = isKey(path, object) ? [path] : castPath(path);
              var index = 0,
                length = path.length;
              while (object != null && index < length) {
                object = object[toKey(path[index++])];
              }
              return index && index == length ? object : undefined;
            }
            function baseGetTag(value) {
              return objectToString.call(value);
            }
            function baseHasIn(object, key) {
              return object != null && key in Object(object);
            }
            function baseIsEqual(value, other, customizer, bitmask, stack) {
              if (value === other) {
                return true;
              }
              if (
                value == null ||
                other == null ||
                (!isObject(value) && !isObjectLike(other))
              ) {
                return value !== value && other !== other;
              }
              return baseIsEqualDeep(
                value,
                other,
                baseIsEqual,
                customizer,
                bitmask,
                stack
              );
            }
            function baseIsEqualDeep(
              object,
              other,
              equalFunc,
              customizer,
              bitmask,
              stack
            ) {
              var objIsArr = isArray(object),
                othIsArr = isArray(other),
                objTag = arrayTag,
                othTag = arrayTag;
              if (!objIsArr) {
                objTag = getTag(object);
                objTag = objTag == argsTag ? objectTag : objTag;
              }
              if (!othIsArr) {
                othTag = getTag(other);
                othTag = othTag == argsTag ? objectTag : othTag;
              }
              var objIsObj = objTag == objectTag && !isHostObject(object),
                othIsObj = othTag == objectTag && !isHostObject(other),
                isSameTag = objTag == othTag;
              if (isSameTag && !objIsObj) {
                stack || (stack = new Stack());
                return objIsArr || isTypedArray(object)
                  ? equalArrays(
                      object,
                      other,
                      equalFunc,
                      customizer,
                      bitmask,
                      stack
                    )
                  : equalByTag(
                      object,
                      other,
                      objTag,
                      equalFunc,
                      customizer,
                      bitmask,
                      stack
                    );
              }
              if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
                var objIsWrapped =
                    objIsObj && hasOwnProperty.call(object, '__wrapped__'),
                  othIsWrapped =
                    othIsObj && hasOwnProperty.call(other, '__wrapped__');
                if (objIsWrapped || othIsWrapped) {
                  var objUnwrapped = objIsWrapped ? object.value() : object,
                    othUnwrapped = othIsWrapped ? other.value() : other;
                  stack || (stack = new Stack());
                  return equalFunc(
                    objUnwrapped,
                    othUnwrapped,
                    customizer,
                    bitmask,
                    stack
                  );
                }
              }
              if (!isSameTag) {
                return false;
              }
              stack || (stack = new Stack());
              return equalObjects(
                object,
                other,
                equalFunc,
                customizer,
                bitmask,
                stack
              );
            }
            function baseIsMatch(object, source, matchData, customizer) {
              var index = matchData.length,
                length = index,
                noCustomizer = !customizer;
              if (object == null) {
                return !length;
              }
              object = Object(object);
              while (index--) {
                var data = matchData[index];
                if (
                  noCustomizer && data[2]
                    ? data[1] !== object[data[0]]
                    : !(data[0] in object)
                ) {
                  return false;
                }
              }
              while (++index < length) {
                data = matchData[index];
                var key = data[0],
                  objValue = object[key],
                  srcValue = data[1];
                if (noCustomizer && data[2]) {
                  if (objValue === undefined && !(key in object)) {
                    return false;
                  }
                } else {
                  var stack = new Stack();
                  if (customizer) {
                    var result = customizer(
                      objValue,
                      srcValue,
                      key,
                      object,
                      source,
                      stack
                    );
                  }
                  if (
                    !(result === undefined
                      ? baseIsEqual(
                          srcValue,
                          objValue,
                          customizer,
                          UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG,
                          stack
                        )
                      : result)
                  ) {
                    return false;
                  }
                }
              }
              return true;
            }
            function baseIsNative(value) {
              if (!isObject(value) || isMasked(value)) {
                return false;
              }
              var pattern =
                isFunction(value) || isHostObject(value)
                  ? reIsNative
                  : reIsHostCtor;
              return pattern.test(toSource(value));
            }
            function baseIsTypedArray(value) {
              return (
                isObjectLike(value) &&
                isLength(value.length) &&
                !!typedArrayTags[objectToString.call(value)]
              );
            }
            function baseIteratee(value) {
              if (typeof value == 'function') {
                return value;
              }
              if (value == null) {
                return identity;
              }
              if (typeof value == 'object') {
                return isArray(value)
                  ? baseMatchesProperty(value[0], value[1])
                  : baseMatches(value);
              }
              return property(value);
            }
            function baseKeys(object) {
              if (!isPrototype(object)) {
                return nativeKeys(object);
              }
              var result = [];
              for (var key in Object(object)) {
                if (hasOwnProperty.call(object, key) && key != 'constructor') {
                  result.push(key);
                }
              }
              return result;
            }
            function baseMap(collection, iteratee) {
              var index = -1,
                result = isArrayLike(collection)
                  ? Array(collection.length)
                  : [];
              baseEach(collection, function(value, key, collection) {
                result[++index] = iteratee(value, key, collection);
              });
              return result;
            }
            function baseMatches(source) {
              var matchData = getMatchData(source);
              if (matchData.length == 1 && matchData[0][2]) {
                return matchesStrictComparable(
                  matchData[0][0],
                  matchData[0][1]
                );
              }
              return function(object) {
                return (
                  object === source || baseIsMatch(object, source, matchData)
                );
              };
            }
            function baseMatchesProperty(path, srcValue) {
              if (isKey(path) && isStrictComparable(srcValue)) {
                return matchesStrictComparable(toKey(path), srcValue);
              }
              return function(object) {
                var objValue = get(object, path);
                return objValue === undefined && objValue === srcValue
                  ? hasIn(object, path)
                  : baseIsEqual(
                      srcValue,
                      objValue,
                      undefined,
                      UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG
                    );
              };
            }
            function basePropertyDeep(path) {
              return function(object) {
                return baseGet(object, path);
              };
            }
            function baseToString(value) {
              if (typeof value == 'string') {
                return value;
              }
              if (isSymbol(value)) {
                return symbolToString ? symbolToString.call(value) : '';
              }
              var result = value + '';
              return result == '0' && 1 / value == -INFINITY ? '-0' : result;
            }
            function castPath(value) {
              return isArray(value) ? value : stringToPath(value);
            }
            function createBaseEach(eachFunc, fromRight) {
              return function(collection, iteratee) {
                if (collection == null) {
                  return collection;
                }
                if (!isArrayLike(collection)) {
                  return eachFunc(collection, iteratee);
                }
                var length = collection.length,
                  index = fromRight ? length : -1,
                  iterable = Object(collection);
                while (fromRight ? index-- : ++index < length) {
                  if (iteratee(iterable[index], index, iterable) === false) {
                    break;
                  }
                }
                return collection;
              };
            }
            function createBaseFor(fromRight) {
              return function(object, iteratee, keysFunc) {
                var index = -1,
                  iterable = Object(object),
                  props = keysFunc(object),
                  length = props.length;
                while (length--) {
                  var key = props[fromRight ? length : ++index];
                  if (iteratee(iterable[key], key, iterable) === false) {
                    break;
                  }
                }
                return object;
              };
            }
            function equalArrays(
              array,
              other,
              equalFunc,
              customizer,
              bitmask,
              stack
            ) {
              var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
                arrLength = array.length,
                othLength = other.length;
              if (
                arrLength != othLength &&
                !(isPartial && othLength > arrLength)
              ) {
                return false;
              }
              var stacked = stack.get(array);
              if (stacked && stack.get(other)) {
                return stacked == other;
              }
              var index = -1,
                result = true,
                seen =
                  bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : undefined;
              stack.set(array, other);
              stack.set(other, array);
              while (++index < arrLength) {
                var arrValue = array[index],
                  othValue = other[index];
                if (customizer) {
                  var compared = isPartial
                    ? customizer(othValue, arrValue, index, other, array, stack)
                    : customizer(
                        arrValue,
                        othValue,
                        index,
                        array,
                        other,
                        stack
                      );
                }
                if (compared !== undefined) {
                  if (compared) {
                    continue;
                  }
                  result = false;
                  break;
                }
                if (seen) {
                  if (
                    !arraySome(other, function(othValue, othIndex) {
                      if (
                        !seen.has(othIndex) &&
                        (arrValue === othValue ||
                          equalFunc(
                            arrValue,
                            othValue,
                            customizer,
                            bitmask,
                            stack
                          ))
                      ) {
                        return seen.add(othIndex);
                      }
                    })
                  ) {
                    result = false;
                    break;
                  }
                } else if (
                  !(
                    arrValue === othValue ||
                    equalFunc(arrValue, othValue, customizer, bitmask, stack)
                  )
                ) {
                  result = false;
                  break;
                }
              }
              stack['delete'](array);
              stack['delete'](other);
              return result;
            }
            function equalByTag(
              object,
              other,
              tag,
              equalFunc,
              customizer,
              bitmask,
              stack
            ) {
              switch (tag) {
                case dataViewTag:
                  if (
                    object.byteLength != other.byteLength ||
                    object.byteOffset != other.byteOffset
                  ) {
                    return false;
                  }
                  object = object.buffer;
                  other = other.buffer;
                case arrayBufferTag:
                  if (
                    object.byteLength != other.byteLength ||
                    !equalFunc(new Uint8Array(object), new Uint8Array(other))
                  ) {
                    return false;
                  }
                  return true;
                case boolTag:
                case dateTag:
                case numberTag:
                  return eq(+object, +other);
                case errorTag:
                  return (
                    object.name == other.name && object.message == other.message
                  );
                case regexpTag:
                case stringTag:
                  return object == other + '';
                case mapTag:
                  var convert = mapToArray;
                case setTag:
                  var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
                  convert || (convert = setToArray);
                  if (object.size != other.size && !isPartial) {
                    return false;
                  }
                  var stacked = stack.get(object);
                  if (stacked) {
                    return stacked == other;
                  }
                  bitmask |= UNORDERED_COMPARE_FLAG;
                  stack.set(object, other);
                  var result = equalArrays(
                    convert(object),
                    convert(other),
                    equalFunc,
                    customizer,
                    bitmask,
                    stack
                  );
                  stack['delete'](object);
                  return result;
                case symbolTag:
                  if (symbolValueOf) {
                    return (
                      symbolValueOf.call(object) == symbolValueOf.call(other)
                    );
                  }
              }
              return false;
            }
            function equalObjects(
              object,
              other,
              equalFunc,
              customizer,
              bitmask,
              stack
            ) {
              var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
                objProps = keys(object),
                objLength = objProps.length,
                othProps = keys(other),
                othLength = othProps.length;
              if (objLength != othLength && !isPartial) {
                return false;
              }
              var index = objLength;
              while (index--) {
                var key = objProps[index];
                if (
                  !(isPartial ? key in other : hasOwnProperty.call(other, key))
                ) {
                  return false;
                }
              }
              var stacked = stack.get(object);
              if (stacked && stack.get(other)) {
                return stacked == other;
              }
              var result = true;
              stack.set(object, other);
              stack.set(other, object);
              var skipCtor = isPartial;
              while (++index < objLength) {
                key = objProps[index];
                var objValue = object[key],
                  othValue = other[key];
                if (customizer) {
                  var compared = isPartial
                    ? customizer(othValue, objValue, key, other, object, stack)
                    : customizer(objValue, othValue, key, object, other, stack);
                }
                if (
                  !(compared === undefined
                    ? objValue === othValue ||
                      equalFunc(objValue, othValue, customizer, bitmask, stack)
                    : compared)
                ) {
                  result = false;
                  break;
                }
                skipCtor || (skipCtor = key == 'constructor');
              }
              if (result && !skipCtor) {
                var objCtor = object.constructor,
                  othCtor = other.constructor;
                if (
                  objCtor != othCtor &&
                  ('constructor' in object && 'constructor' in other) &&
                  !(
                    typeof objCtor == 'function' &&
                    objCtor instanceof objCtor &&
                    typeof othCtor == 'function' &&
                    othCtor instanceof othCtor
                  )
                ) {
                  result = false;
                }
              }
              stack['delete'](object);
              stack['delete'](other);
              return result;
            }
            function getMapData(map, key) {
              var data = map.__data__;
              return isKeyable(key)
                ? data[typeof key == 'string' ? 'string' : 'hash']
                : data.map;
            }
            function getMatchData(object) {
              var result = keys(object),
                length = result.length;
              while (length--) {
                var key = result[length],
                  value = object[key];
                result[length] = [key, value, isStrictComparable(value)];
              }
              return result;
            }
            function getNative(object, key) {
              var value = getValue(object, key);
              return baseIsNative(value) ? value : undefined;
            }
            var getTag = baseGetTag;
            if (
              (DataView &&
                getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
              (Map && getTag(new Map()) != mapTag) ||
              (Promise && getTag(Promise.resolve()) != promiseTag) ||
              (Set && getTag(new Set()) != setTag) ||
              (WeakMap && getTag(new WeakMap()) != weakMapTag)
            ) {
              getTag = function(value) {
                var result = objectToString.call(value),
                  Ctor = result == objectTag ? value.constructor : undefined,
                  ctorString = Ctor ? toSource(Ctor) : undefined;
                if (ctorString) {
                  switch (ctorString) {
                    case dataViewCtorString:
                      return dataViewTag;
                    case mapCtorString:
                      return mapTag;
                    case promiseCtorString:
                      return promiseTag;
                    case setCtorString:
                      return setTag;
                    case weakMapCtorString:
                      return weakMapTag;
                  }
                }
                return result;
              };
            }
            function hasPath(object, path, hasFunc) {
              path = isKey(path, object) ? [path] : castPath(path);
              var result,
                index = -1,
                length = path.length;
              while (++index < length) {
                var key = toKey(path[index]);
                if (!(result = object != null && hasFunc(object, key))) {
                  break;
                }
                object = object[key];
              }
              if (result) {
                return result;
              }
              var length = object ? object.length : 0;
              return (
                !!length &&
                isLength(length) &&
                isIndex(key, length) &&
                (isArray(object) || isArguments(object))
              );
            }
            function isIndex(value, length) {
              length = length == null ? MAX_SAFE_INTEGER : length;
              return (
                !!length &&
                (typeof value == 'number' || reIsUint.test(value)) &&
                (value > -1 && value % 1 == 0 && value < length)
              );
            }
            function isKey(value, object) {
              if (isArray(value)) {
                return false;
              }
              var type = typeof value;
              if (
                type == 'number' ||
                type == 'symbol' ||
                type == 'boolean' ||
                value == null ||
                isSymbol(value)
              ) {
                return true;
              }
              return (
                reIsPlainProp.test(value) ||
                !reIsDeepProp.test(value) ||
                (object != null && value in Object(object))
              );
            }
            function isKeyable(value) {
              var type = typeof value;
              return type == 'string' ||
                type == 'number' ||
                type == 'symbol' ||
                type == 'boolean'
                ? value !== '__proto__'
                : value === null;
            }
            function isMasked(func) {
              return !!maskSrcKey && maskSrcKey in func;
            }
            function isPrototype(value) {
              var Ctor = value && value.constructor,
                proto =
                  (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
              return value === proto;
            }
            function isStrictComparable(value) {
              return value === value && !isObject(value);
            }
            function matchesStrictComparable(key, srcValue) {
              return function(object) {
                if (object == null) {
                  return false;
                }
                return (
                  object[key] === srcValue &&
                  (srcValue !== undefined || key in Object(object))
                );
              };
            }
            var stringToPath = memoize(function(string) {
              string = toString(string);
              var result = [];
              if (reLeadingDot.test(string)) {
                result.push('');
              }
              string.replace(rePropName, function(
                match,
                number,
                quote,
                string
              ) {
                result.push(
                  quote ? string.replace(reEscapeChar, '$1') : number || match
                );
              });
              return result;
            });
            function toKey(value) {
              if (typeof value == 'string' || isSymbol(value)) {
                return value;
              }
              var result = value + '';
              return result == '0' && 1 / value == -INFINITY ? '-0' : result;
            }
            function toSource(func) {
              if (func != null) {
                try {
                  return funcToString.call(func);
                } catch (e) {}
                try {
                  return func + '';
                } catch (e) {}
              }
              return '';
            }
            function map(collection, iteratee) {
              var func = isArray(collection) ? arrayMap : baseMap;
              return func(collection, baseIteratee(iteratee, 3));
            }
            function memoize(func, resolver) {
              if (
                typeof func != 'function' ||
                (resolver && typeof resolver != 'function')
              ) {
                throw new TypeError(FUNC_ERROR_TEXT);
              }
              var memoized = function() {
                var args = arguments,
                  key = resolver ? resolver.apply(this, args) : args[0],
                  cache = memoized.cache;
                if (cache.has(key)) {
                  return cache.get(key);
                }
                var result = func.apply(this, args);
                memoized.cache = cache.set(key, result);
                return result;
              };
              memoized.cache = new (memoize.Cache || MapCache)();
              return memoized;
            }
            memoize.Cache = MapCache;
            function eq(value, other) {
              return value === other || (value !== value && other !== other);
            }
            function isArguments(value) {
              return (
                isArrayLikeObject(value) &&
                hasOwnProperty.call(value, 'callee') &&
                (!propertyIsEnumerable.call(value, 'callee') ||
                  objectToString.call(value) == argsTag)
              );
            }
            var isArray = Array.isArray;
            function isArrayLike(value) {
              return (
                value != null && isLength(value.length) && !isFunction(value)
              );
            }
            function isArrayLikeObject(value) {
              return isObjectLike(value) && isArrayLike(value);
            }
            function isFunction(value) {
              var tag = isObject(value) ? objectToString.call(value) : '';
              return tag == funcTag || tag == genTag;
            }
            function isLength(value) {
              return (
                typeof value == 'number' &&
                value > -1 &&
                value % 1 == 0 &&
                value <= MAX_SAFE_INTEGER
              );
            }
            function isObject(value) {
              var type = typeof value;
              return !!value && (type == 'object' || type == 'function');
            }
            function isObjectLike(value) {
              return !!value && typeof value == 'object';
            }
            function isSymbol(value) {
              return (
                typeof value == 'symbol' ||
                (isObjectLike(value) && objectToString.call(value) == symbolTag)
              );
            }
            var isTypedArray = nodeIsTypedArray
              ? baseUnary(nodeIsTypedArray)
              : baseIsTypedArray;
            function toString(value) {
              return value == null ? '' : baseToString(value);
            }
            function get(object, path, defaultValue) {
              var result = object == null ? undefined : baseGet(object, path);
              return result === undefined ? defaultValue : result;
            }
            function hasIn(object, path) {
              return object != null && hasPath(object, path, baseHasIn);
            }
            function keys(object) {
              return isArrayLike(object)
                ? arrayLikeKeys(object)
                : baseKeys(object);
            }
            function identity(value) {
              return value;
            }
            function property(path) {
              return isKey(path)
                ? baseProperty(toKey(path))
                : basePropertyDeep(path);
            }
            module.exports = map;
          }.call(
            this,
            typeof global !== 'undefined'
              ? global
              : typeof self !== 'undefined'
              ? self
              : typeof window !== 'undefined'
              ? window
              : {}
          ));
        },
        {}
      ],
      432: [
        function(require, module, exports) {
          (function(global) {
            var LARGE_ARRAY_SIZE = 200;
            var HASH_UNDEFINED = '__lodash_hash_undefined__';
            var MAX_SAFE_INTEGER = 9007199254740991;
            var argsTag = '[object Arguments]',
              arrayTag = '[object Array]',
              boolTag = '[object Boolean]',
              dateTag = '[object Date]',
              errorTag = '[object Error]',
              funcTag = '[object Function]',
              genTag = '[object GeneratorFunction]',
              mapTag = '[object Map]',
              numberTag = '[object Number]',
              objectTag = '[object Object]',
              promiseTag = '[object Promise]',
              regexpTag = '[object RegExp]',
              setTag = '[object Set]',
              stringTag = '[object String]',
              symbolTag = '[object Symbol]',
              weakMapTag = '[object WeakMap]';
            var arrayBufferTag = '[object ArrayBuffer]',
              dataViewTag = '[object DataView]',
              float32Tag = '[object Float32Array]',
              float64Tag = '[object Float64Array]',
              int8Tag = '[object Int8Array]',
              int16Tag = '[object Int16Array]',
              int32Tag = '[object Int32Array]',
              uint8Tag = '[object Uint8Array]',
              uint8ClampedTag = '[object Uint8ClampedArray]',
              uint16Tag = '[object Uint16Array]',
              uint32Tag = '[object Uint32Array]';
            var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
            var reFlags = /\w*$/;
            var reIsHostCtor = /^\[object .+?Constructor\]$/;
            var reIsUint = /^(?:0|[1-9]\d*)$/;
            var typedArrayTags = {};
            typedArrayTags[float32Tag] = typedArrayTags[
              float64Tag
            ] = typedArrayTags[int8Tag] = typedArrayTags[
              int16Tag
            ] = typedArrayTags[int32Tag] = typedArrayTags[
              uint8Tag
            ] = typedArrayTags[uint8ClampedTag] = typedArrayTags[
              uint16Tag
            ] = typedArrayTags[uint32Tag] = true;
            typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[
              arrayBufferTag
            ] = typedArrayTags[boolTag] = typedArrayTags[
              dataViewTag
            ] = typedArrayTags[dateTag] = typedArrayTags[
              errorTag
            ] = typedArrayTags[funcTag] = typedArrayTags[
              mapTag
            ] = typedArrayTags[numberTag] = typedArrayTags[
              objectTag
            ] = typedArrayTags[regexpTag] = typedArrayTags[
              setTag
            ] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
            var cloneableTags = {};
            cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[
              arrayBufferTag
            ] = cloneableTags[dataViewTag] = cloneableTags[
              boolTag
            ] = cloneableTags[dateTag] = cloneableTags[
              float32Tag
            ] = cloneableTags[float64Tag] = cloneableTags[
              int8Tag
            ] = cloneableTags[int16Tag] = cloneableTags[
              int32Tag
            ] = cloneableTags[mapTag] = cloneableTags[
              numberTag
            ] = cloneableTags[objectTag] = cloneableTags[
              regexpTag
            ] = cloneableTags[setTag] = cloneableTags[
              stringTag
            ] = cloneableTags[symbolTag] = cloneableTags[
              uint8Tag
            ] = cloneableTags[uint8ClampedTag] = cloneableTags[
              uint16Tag
            ] = cloneableTags[uint32Tag] = true;
            cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[
              weakMapTag
            ] = false;
            var freeGlobal =
              typeof global == 'object' &&
              global &&
              global.Object === Object &&
              global;
            var freeSelf =
              typeof self == 'object' && self && self.Object === Object && self;
            var root = freeGlobal || freeSelf || Function('return this')();
            var freeExports =
              typeof exports == 'object' &&
              exports &&
              !exports.nodeType &&
              exports;
            var freeModule =
              freeExports &&
              typeof module == 'object' &&
              module &&
              !module.nodeType &&
              module;
            var moduleExports =
              freeModule && freeModule.exports === freeExports;
            var freeProcess = moduleExports && freeGlobal.process;
            var nodeUtil = (function() {
              try {
                return freeProcess && freeProcess.binding('util');
              } catch (e) {}
            })();
            var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
            function addMapEntry(map, pair) {
              map.set(pair[0], pair[1]);
              return map;
            }
            function addSetEntry(set, value) {
              set.add(value);
              return set;
            }
            function apply(func, thisArg, args) {
              switch (args.length) {
                case 0:
                  return func.call(thisArg);
                case 1:
                  return func.call(thisArg, args[0]);
                case 2:
                  return func.call(thisArg, args[0], args[1]);
                case 3:
                  return func.call(thisArg, args[0], args[1], args[2]);
              }
              return func.apply(thisArg, args);
            }
            function arrayEach(array, iteratee) {
              var index = -1,
                length = array ? array.length : 0;
              while (++index < length) {
                if (iteratee(array[index], index, array) === false) {
                  break;
                }
              }
              return array;
            }
            function arrayPush(array, values) {
              var index = -1,
                length = values.length,
                offset = array.length;
              while (++index < length) {
                array[offset + index] = values[index];
              }
              return array;
            }
            function arrayReduce(array, iteratee, accumulator, initAccum) {
              var index = -1,
                length = array ? array.length : 0;
              if (initAccum && length) {
                accumulator = array[++index];
              }
              while (++index < length) {
                accumulator = iteratee(accumulator, array[index], index, array);
              }
              return accumulator;
            }
            function baseTimes(n, iteratee) {
              var index = -1,
                result = Array(n);
              while (++index < n) {
                result[index] = iteratee(index);
              }
              return result;
            }
            function baseUnary(func) {
              return function(value) {
                return func(value);
              };
            }
            function getValue(object, key) {
              return object == null ? undefined : object[key];
            }
            function isHostObject(value) {
              var result = false;
              if (value != null && typeof value.toString != 'function') {
                try {
                  result = !!(value + '');
                } catch (e) {}
              }
              return result;
            }
            function mapToArray(map) {
              var index = -1,
                result = Array(map.size);
              map.forEach(function(value, key) {
                result[++index] = [key, value];
              });
              return result;
            }
            function overArg(func, transform) {
              return function(arg) {
                return func(transform(arg));
              };
            }
            function setToArray(set) {
              var index = -1,
                result = Array(set.size);
              set.forEach(function(value) {
                result[++index] = value;
              });
              return result;
            }
            var arrayProto = Array.prototype,
              funcProto = Function.prototype,
              objectProto = Object.prototype;
            var coreJsData = root['__core-js_shared__'];
            var maskSrcKey = (function() {
              var uid = /[^.]+$/.exec(
                (coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO) ||
                  ''
              );
              return uid ? 'Symbol(src)_1.' + uid : '';
            })();
            var funcToString = funcProto.toString;
            var hasOwnProperty = objectProto.hasOwnProperty;
            var objectCtorString = funcToString.call(Object);
            var objectToString = objectProto.toString;
            var reIsNative = RegExp(
              '^' +
                funcToString
                  .call(hasOwnProperty)
                  .replace(reRegExpChar, '\\$&')
                  .replace(
                    /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                    '$1.*?'
                  ) +
                '$'
            );
            var Buffer = moduleExports ? root.Buffer : undefined,
              Symbol = root.Symbol,
              Uint8Array = root.Uint8Array,
              getPrototype = overArg(Object.getPrototypeOf, Object),
              objectCreate = Object.create,
              propertyIsEnumerable = objectProto.propertyIsEnumerable,
              splice = arrayProto.splice;
            var nativeGetSymbols = Object.getOwnPropertySymbols,
              nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
              nativeKeys = overArg(Object.keys, Object),
              nativeMax = Math.max;
            var DataView = getNative(root, 'DataView'),
              Map = getNative(root, 'Map'),
              Promise = getNative(root, 'Promise'),
              Set = getNative(root, 'Set'),
              WeakMap = getNative(root, 'WeakMap'),
              nativeCreate = getNative(Object, 'create');
            var dataViewCtorString = toSource(DataView),
              mapCtorString = toSource(Map),
              promiseCtorString = toSource(Promise),
              setCtorString = toSource(Set),
              weakMapCtorString = toSource(WeakMap);
            var symbolProto = Symbol ? Symbol.prototype : undefined,
              symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
            function Hash(entries) {
              var index = -1,
                length = entries ? entries.length : 0;
              this.clear();
              while (++index < length) {
                var entry = entries[index];
                this.set(entry[0], entry[1]);
              }
            }
            function hashClear() {
              this.__data__ = nativeCreate ? nativeCreate(null) : {};
            }
            function hashDelete(key) {
              return this.has(key) && delete this.__data__[key];
            }
            function hashGet(key) {
              var data = this.__data__;
              if (nativeCreate) {
                var result = data[key];
                return result === HASH_UNDEFINED ? undefined : result;
              }
              return hasOwnProperty.call(data, key) ? data[key] : undefined;
            }
            function hashHas(key) {
              var data = this.__data__;
              return nativeCreate
                ? data[key] !== undefined
                : hasOwnProperty.call(data, key);
            }
            function hashSet(key, value) {
              var data = this.__data__;
              data[key] =
                nativeCreate && value === undefined ? HASH_UNDEFINED : value;
              return this;
            }
            Hash.prototype.clear = hashClear;
            Hash.prototype['delete'] = hashDelete;
            Hash.prototype.get = hashGet;
            Hash.prototype.has = hashHas;
            Hash.prototype.set = hashSet;
            function ListCache(entries) {
              var index = -1,
                length = entries ? entries.length : 0;
              this.clear();
              while (++index < length) {
                var entry = entries[index];
                this.set(entry[0], entry[1]);
              }
            }
            function listCacheClear() {
              this.__data__ = [];
            }
            function listCacheDelete(key) {
              var data = this.__data__,
                index = assocIndexOf(data, key);
              if (index < 0) {
                return false;
              }
              var lastIndex = data.length - 1;
              if (index == lastIndex) {
                data.pop();
              } else {
                splice.call(data, index, 1);
              }
              return true;
            }
            function listCacheGet(key) {
              var data = this.__data__,
                index = assocIndexOf(data, key);
              return index < 0 ? undefined : data[index][1];
            }
            function listCacheHas(key) {
              return assocIndexOf(this.__data__, key) > -1;
            }
            function listCacheSet(key, value) {
              var data = this.__data__,
                index = assocIndexOf(data, key);
              if (index < 0) {
                data.push([key, value]);
              } else {
                data[index][1] = value;
              }
              return this;
            }
            ListCache.prototype.clear = listCacheClear;
            ListCache.prototype['delete'] = listCacheDelete;
            ListCache.prototype.get = listCacheGet;
            ListCache.prototype.has = listCacheHas;
            ListCache.prototype.set = listCacheSet;
            function MapCache(entries) {
              var index = -1,
                length = entries ? entries.length : 0;
              this.clear();
              while (++index < length) {
                var entry = entries[index];
                this.set(entry[0], entry[1]);
              }
            }
            function mapCacheClear() {
              this.__data__ = {
                hash: new Hash(),
                map: new (Map || ListCache)(),
                string: new Hash()
              };
            }
            function mapCacheDelete(key) {
              return getMapData(this, key)['delete'](key);
            }
            function mapCacheGet(key) {
              return getMapData(this, key).get(key);
            }
            function mapCacheHas(key) {
              return getMapData(this, key).has(key);
            }
            function mapCacheSet(key, value) {
              getMapData(this, key).set(key, value);
              return this;
            }
            MapCache.prototype.clear = mapCacheClear;
            MapCache.prototype['delete'] = mapCacheDelete;
            MapCache.prototype.get = mapCacheGet;
            MapCache.prototype.has = mapCacheHas;
            MapCache.prototype.set = mapCacheSet;
            function Stack(entries) {
              this.__data__ = new ListCache(entries);
            }
            function stackClear() {
              this.__data__ = new ListCache();
            }
            function stackDelete(key) {
              return this.__data__['delete'](key);
            }
            function stackGet(key) {
              return this.__data__.get(key);
            }
            function stackHas(key) {
              return this.__data__.has(key);
            }
            function stackSet(key, value) {
              var cache = this.__data__;
              if (cache instanceof ListCache) {
                var pairs = cache.__data__;
                if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
                  pairs.push([key, value]);
                  return this;
                }
                cache = this.__data__ = new MapCache(pairs);
              }
              cache.set(key, value);
              return this;
            }
            Stack.prototype.clear = stackClear;
            Stack.prototype['delete'] = stackDelete;
            Stack.prototype.get = stackGet;
            Stack.prototype.has = stackHas;
            Stack.prototype.set = stackSet;
            function arrayLikeKeys(value, inherited) {
              var result =
                isArray(value) || isArguments(value)
                  ? baseTimes(value.length, String)
                  : [];
              var length = result.length,
                skipIndexes = !!length;
              for (var key in value) {
                if (
                  (inherited || hasOwnProperty.call(value, key)) &&
                  !(skipIndexes && (key == 'length' || isIndex(key, length)))
                ) {
                  result.push(key);
                }
              }
              return result;
            }
            function assignMergeValue(object, key, value) {
              if (
                (value !== undefined && !eq(object[key], value)) ||
                (typeof key == 'number' &&
                  value === undefined &&
                  !(key in object))
              ) {
                object[key] = value;
              }
            }
            function assignValue(object, key, value) {
              var objValue = object[key];
              if (
                !(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
                (value === undefined && !(key in object))
              ) {
                object[key] = value;
              }
            }
            function assocIndexOf(array, key) {
              var length = array.length;
              while (length--) {
                if (eq(array[length][0], key)) {
                  return length;
                }
              }
              return -1;
            }
            function baseAssign(object, source) {
              return object && copyObject(source, keys(source), object);
            }
            function baseClone(
              value,
              isDeep,
              isFull,
              customizer,
              key,
              object,
              stack
            ) {
              var result;
              if (customizer) {
                result = object
                  ? customizer(value, key, object, stack)
                  : customizer(value);
              }
              if (result !== undefined) {
                return result;
              }
              if (!isObject(value)) {
                return value;
              }
              var isArr = isArray(value);
              if (isArr) {
                result = initCloneArray(value);
                if (!isDeep) {
                  return copyArray(value, result);
                }
              } else {
                var tag = getTag(value),
                  isFunc = tag == funcTag || tag == genTag;
                if (isBuffer(value)) {
                  return cloneBuffer(value, isDeep);
                }
                if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
                  if (isHostObject(value)) {
                    return object ? value : {};
                  }
                  result = initCloneObject(isFunc ? {} : value);
                  if (!isDeep) {
                    return copySymbols(value, baseAssign(result, value));
                  }
                } else {
                  if (!cloneableTags[tag]) {
                    return object ? value : {};
                  }
                  result = initCloneByTag(value, tag, baseClone, isDeep);
                }
              }
              stack || (stack = new Stack());
              var stacked = stack.get(value);
              if (stacked) {
                return stacked;
              }
              stack.set(value, result);
              if (!isArr) {
                var props = isFull ? getAllKeys(value) : keys(value);
              }
              arrayEach(props || value, function(subValue, key) {
                if (props) {
                  key = subValue;
                  subValue = value[key];
                }
                assignValue(
                  result,
                  key,
                  baseClone(
                    subValue,
                    isDeep,
                    isFull,
                    customizer,
                    key,
                    value,
                    stack
                  )
                );
              });
              return result;
            }
            function baseCreate(proto) {
              return isObject(proto) ? objectCreate(proto) : {};
            }
            function baseGetAllKeys(object, keysFunc, symbolsFunc) {
              var result = keysFunc(object);
              return isArray(object)
                ? result
                : arrayPush(result, symbolsFunc(object));
            }
            function baseGetTag(value) {
              return objectToString.call(value);
            }
            function baseIsNative(value) {
              if (!isObject(value) || isMasked(value)) {
                return false;
              }
              var pattern =
                isFunction(value) || isHostObject(value)
                  ? reIsNative
                  : reIsHostCtor;
              return pattern.test(toSource(value));
            }
            function baseIsTypedArray(value) {
              return (
                isObjectLike(value) &&
                isLength(value.length) &&
                !!typedArrayTags[objectToString.call(value)]
              );
            }
            function baseKeys(object) {
              if (!isPrototype(object)) {
                return nativeKeys(object);
              }
              var result = [];
              for (var key in Object(object)) {
                if (hasOwnProperty.call(object, key) && key != 'constructor') {
                  result.push(key);
                }
              }
              return result;
            }
            function baseKeysIn(object) {
              if (!isObject(object)) {
                return nativeKeysIn(object);
              }
              var isProto = isPrototype(object),
                result = [];
              for (var key in object) {
                if (
                  !(
                    key == 'constructor' &&
                    (isProto || !hasOwnProperty.call(object, key))
                  )
                ) {
                  result.push(key);
                }
              }
              return result;
            }
            function baseMerge(object, source, srcIndex, customizer, stack) {
              if (object === source) {
                return;
              }
              if (!(isArray(source) || isTypedArray(source))) {
                var props = baseKeysIn(source);
              }
              arrayEach(props || source, function(srcValue, key) {
                if (props) {
                  key = srcValue;
                  srcValue = source[key];
                }
                if (isObject(srcValue)) {
                  stack || (stack = new Stack());
                  baseMergeDeep(
                    object,
                    source,
                    key,
                    srcIndex,
                    baseMerge,
                    customizer,
                    stack
                  );
                } else {
                  var newValue = customizer
                    ? customizer(
                        object[key],
                        srcValue,
                        key + '',
                        object,
                        source,
                        stack
                      )
                    : undefined;
                  if (newValue === undefined) {
                    newValue = srcValue;
                  }
                  assignMergeValue(object, key, newValue);
                }
              });
            }
            function baseMergeDeep(
              object,
              source,
              key,
              srcIndex,
              mergeFunc,
              customizer,
              stack
            ) {
              var objValue = object[key],
                srcValue = source[key],
                stacked = stack.get(srcValue);
              if (stacked) {
                assignMergeValue(object, key, stacked);
                return;
              }
              var newValue = customizer
                ? customizer(
                    objValue,
                    srcValue,
                    key + '',
                    object,
                    source,
                    stack
                  )
                : undefined;
              var isCommon = newValue === undefined;
              if (isCommon) {
                newValue = srcValue;
                if (isArray(srcValue) || isTypedArray(srcValue)) {
                  if (isArray(objValue)) {
                    newValue = objValue;
                  } else if (isArrayLikeObject(objValue)) {
                    newValue = copyArray(objValue);
                  } else {
                    isCommon = false;
                    newValue = baseClone(srcValue, true);
                  }
                } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                  if (isArguments(objValue)) {
                    newValue = toPlainObject(objValue);
                  } else if (
                    !isObject(objValue) ||
                    (srcIndex && isFunction(objValue))
                  ) {
                    isCommon = false;
                    newValue = baseClone(srcValue, true);
                  } else {
                    newValue = objValue;
                  }
                } else {
                  isCommon = false;
                }
              }
              if (isCommon) {
                stack.set(srcValue, newValue);
                mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
                stack['delete'](srcValue);
              }
              assignMergeValue(object, key, newValue);
            }
            function baseRest(func, start) {
              start = nativeMax(
                start === undefined ? func.length - 1 : start,
                0
              );
              return function() {
                var args = arguments,
                  index = -1,
                  length = nativeMax(args.length - start, 0),
                  array = Array(length);
                while (++index < length) {
                  array[index] = args[start + index];
                }
                index = -1;
                var otherArgs = Array(start + 1);
                while (++index < start) {
                  otherArgs[index] = args[index];
                }
                otherArgs[start] = array;
                return apply(func, this, otherArgs);
              };
            }
            function cloneBuffer(buffer, isDeep) {
              if (isDeep) {
                return buffer.slice();
              }
              var result = new buffer.constructor(buffer.length);
              buffer.copy(result);
              return result;
            }
            function cloneArrayBuffer(arrayBuffer) {
              var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
              new Uint8Array(result).set(new Uint8Array(arrayBuffer));
              return result;
            }
            function cloneDataView(dataView, isDeep) {
              var buffer = isDeep
                ? cloneArrayBuffer(dataView.buffer)
                : dataView.buffer;
              return new dataView.constructor(
                buffer,
                dataView.byteOffset,
                dataView.byteLength
              );
            }
            function cloneMap(map, isDeep, cloneFunc) {
              var array = isDeep
                ? cloneFunc(mapToArray(map), true)
                : mapToArray(map);
              return arrayReduce(array, addMapEntry, new map.constructor());
            }
            function cloneRegExp(regexp) {
              var result = new regexp.constructor(
                regexp.source,
                reFlags.exec(regexp)
              );
              result.lastIndex = regexp.lastIndex;
              return result;
            }
            function cloneSet(set, isDeep, cloneFunc) {
              var array = isDeep
                ? cloneFunc(setToArray(set), true)
                : setToArray(set);
              return arrayReduce(array, addSetEntry, new set.constructor());
            }
            function cloneSymbol(symbol) {
              return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
            }
            function cloneTypedArray(typedArray, isDeep) {
              var buffer = isDeep
                ? cloneArrayBuffer(typedArray.buffer)
                : typedArray.buffer;
              return new typedArray.constructor(
                buffer,
                typedArray.byteOffset,
                typedArray.length
              );
            }
            function copyArray(source, array) {
              var index = -1,
                length = source.length;
              array || (array = Array(length));
              while (++index < length) {
                array[index] = source[index];
              }
              return array;
            }
            function copyObject(source, props, object, customizer) {
              object || (object = {});
              var index = -1,
                length = props.length;
              while (++index < length) {
                var key = props[index];
                var newValue = customizer
                  ? customizer(object[key], source[key], key, object, source)
                  : undefined;
                assignValue(
                  object,
                  key,
                  newValue === undefined ? source[key] : newValue
                );
              }
              return object;
            }
            function copySymbols(source, object) {
              return copyObject(source, getSymbols(source), object);
            }
            function createAssigner(assigner) {
              return baseRest(function(object, sources) {
                var index = -1,
                  length = sources.length,
                  customizer = length > 1 ? sources[length - 1] : undefined,
                  guard = length > 2 ? sources[2] : undefined;
                customizer =
                  assigner.length > 3 && typeof customizer == 'function'
                    ? (length--, customizer)
                    : undefined;
                if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                  customizer = length < 3 ? undefined : customizer;
                  length = 1;
                }
                object = Object(object);
                while (++index < length) {
                  var source = sources[index];
                  if (source) {
                    assigner(object, source, index, customizer);
                  }
                }
                return object;
              });
            }
            function getAllKeys(object) {
              return baseGetAllKeys(object, keys, getSymbols);
            }
            function getMapData(map, key) {
              var data = map.__data__;
              return isKeyable(key)
                ? data[typeof key == 'string' ? 'string' : 'hash']
                : data.map;
            }
            function getNative(object, key) {
              var value = getValue(object, key);
              return baseIsNative(value) ? value : undefined;
            }
            var getSymbols = nativeGetSymbols
              ? overArg(nativeGetSymbols, Object)
              : stubArray;
            var getTag = baseGetTag;
            if (
              (DataView &&
                getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
              (Map && getTag(new Map()) != mapTag) ||
              (Promise && getTag(Promise.resolve()) != promiseTag) ||
              (Set && getTag(new Set()) != setTag) ||
              (WeakMap && getTag(new WeakMap()) != weakMapTag)
            ) {
              getTag = function(value) {
                var result = objectToString.call(value),
                  Ctor = result == objectTag ? value.constructor : undefined,
                  ctorString = Ctor ? toSource(Ctor) : undefined;
                if (ctorString) {
                  switch (ctorString) {
                    case dataViewCtorString:
                      return dataViewTag;
                    case mapCtorString:
                      return mapTag;
                    case promiseCtorString:
                      return promiseTag;
                    case setCtorString:
                      return setTag;
                    case weakMapCtorString:
                      return weakMapTag;
                  }
                }
                return result;
              };
            }
            function initCloneArray(array) {
              var length = array.length,
                result = array.constructor(length);
              if (
                length &&
                typeof array[0] == 'string' &&
                hasOwnProperty.call(array, 'index')
              ) {
                result.index = array.index;
                result.input = array.input;
              }
              return result;
            }
            function initCloneObject(object) {
              return typeof object.constructor == 'function' &&
                !isPrototype(object)
                ? baseCreate(getPrototype(object))
                : {};
            }
            function initCloneByTag(object, tag, cloneFunc, isDeep) {
              var Ctor = object.constructor;
              switch (tag) {
                case arrayBufferTag:
                  return cloneArrayBuffer(object);
                case boolTag:
                case dateTag:
                  return new Ctor(+object);
                case dataViewTag:
                  return cloneDataView(object, isDeep);
                case float32Tag:
                case float64Tag:
                case int8Tag:
                case int16Tag:
                case int32Tag:
                case uint8Tag:
                case uint8ClampedTag:
                case uint16Tag:
                case uint32Tag:
                  return cloneTypedArray(object, isDeep);
                case mapTag:
                  return cloneMap(object, isDeep, cloneFunc);
                case numberTag:
                case stringTag:
                  return new Ctor(object);
                case regexpTag:
                  return cloneRegExp(object);
                case setTag:
                  return cloneSet(object, isDeep, cloneFunc);
                case symbolTag:
                  return cloneSymbol(object);
              }
            }
            function isIndex(value, length) {
              length = length == null ? MAX_SAFE_INTEGER : length;
              return (
                !!length &&
                (typeof value == 'number' || reIsUint.test(value)) &&
                (value > -1 && value % 1 == 0 && value < length)
              );
            }
            function isIterateeCall(value, index, object) {
              if (!isObject(object)) {
                return false;
              }
              var type = typeof index;
              if (
                type == 'number'
                  ? isArrayLike(object) && isIndex(index, object.length)
                  : type == 'string' && index in object
              ) {
                return eq(object[index], value);
              }
              return false;
            }
            function isKeyable(value) {
              var type = typeof value;
              return type == 'string' ||
                type == 'number' ||
                type == 'symbol' ||
                type == 'boolean'
                ? value !== '__proto__'
                : value === null;
            }
            function isMasked(func) {
              return !!maskSrcKey && maskSrcKey in func;
            }
            function isPrototype(value) {
              var Ctor = value && value.constructor,
                proto =
                  (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
              return value === proto;
            }
            function nativeKeysIn(object) {
              var result = [];
              if (object != null) {
                for (var key in Object(object)) {
                  result.push(key);
                }
              }
              return result;
            }
            function toSource(func) {
              if (func != null) {
                try {
                  return funcToString.call(func);
                } catch (e) {}
                try {
                  return func + '';
                } catch (e) {}
              }
              return '';
            }
            function eq(value, other) {
              return value === other || (value !== value && other !== other);
            }
            function isArguments(value) {
              return (
                isArrayLikeObject(value) &&
                hasOwnProperty.call(value, 'callee') &&
                (!propertyIsEnumerable.call(value, 'callee') ||
                  objectToString.call(value) == argsTag)
              );
            }
            var isArray = Array.isArray;
            function isArrayLike(value) {
              return (
                value != null && isLength(value.length) && !isFunction(value)
              );
            }
            function isArrayLikeObject(value) {
              return isObjectLike(value) && isArrayLike(value);
            }
            var isBuffer = nativeIsBuffer || stubFalse;
            function isFunction(value) {
              var tag = isObject(value) ? objectToString.call(value) : '';
              return tag == funcTag || tag == genTag;
            }
            function isLength(value) {
              return (
                typeof value == 'number' &&
                value > -1 &&
                value % 1 == 0 &&
                value <= MAX_SAFE_INTEGER
              );
            }
            function isObject(value) {
              var type = typeof value;
              return !!value && (type == 'object' || type == 'function');
            }
            function isObjectLike(value) {
              return !!value && typeof value == 'object';
            }
            function isPlainObject(value) {
              if (
                !isObjectLike(value) ||
                objectToString.call(value) != objectTag ||
                isHostObject(value)
              ) {
                return false;
              }
              var proto = getPrototype(value);
              if (proto === null) {
                return true;
              }
              var Ctor =
                hasOwnProperty.call(proto, 'constructor') && proto.constructor;
              return (
                typeof Ctor == 'function' &&
                Ctor instanceof Ctor &&
                funcToString.call(Ctor) == objectCtorString
              );
            }
            var isTypedArray = nodeIsTypedArray
              ? baseUnary(nodeIsTypedArray)
              : baseIsTypedArray;
            function toPlainObject(value) {
              return copyObject(value, keysIn(value));
            }
            function keys(object) {
              return isArrayLike(object)
                ? arrayLikeKeys(object)
                : baseKeys(object);
            }
            function keysIn(object) {
              return isArrayLike(object)
                ? arrayLikeKeys(object, true)
                : baseKeysIn(object);
            }
            var merge = createAssigner(function(object, source, srcIndex) {
              baseMerge(object, source, srcIndex);
            });
            function stubArray() {
              return [];
            }
            function stubFalse() {
              return false;
            }
            module.exports = merge;
          }.call(
            this,
            typeof global !== 'undefined'
              ? global
              : typeof self !== 'undefined'
              ? self
              : typeof window !== 'undefined'
              ? window
              : {}
          ));
        },
        {}
      ],
      433: [
        function(require, module, exports) {
          (function(global) {
            var INFINITY = 1 / 0,
              MAX_SAFE_INTEGER = 9007199254740991;
            var argsTag = '[object Arguments]',
              funcTag = '[object Function]',
              genTag = '[object GeneratorFunction]',
              symbolTag = '[object Symbol]';
            var freeGlobal =
              typeof global == 'object' &&
              global &&
              global.Object === Object &&
              global;
            var freeSelf =
              typeof self == 'object' && self && self.Object === Object && self;
            var root = freeGlobal || freeSelf || Function('return this')();
            function apply(func, thisArg, args) {
              switch (args.length) {
                case 0:
                  return func.call(thisArg);
                case 1:
                  return func.call(thisArg, args[0]);
                case 2:
                  return func.call(thisArg, args[0], args[1]);
                case 3:
                  return func.call(thisArg, args[0], args[1], args[2]);
              }
              return func.apply(thisArg, args);
            }
            function arrayMap(array, iteratee) {
              var index = -1,
                length = array ? array.length : 0,
                result = Array(length);
              while (++index < length) {
                result[index] = iteratee(array[index], index, array);
              }
              return result;
            }
            function arrayPush(array, values) {
              var index = -1,
                length = values.length,
                offset = array.length;
              while (++index < length) {
                array[offset + index] = values[index];
              }
              return array;
            }
            var objectProto = Object.prototype;
            var hasOwnProperty = objectProto.hasOwnProperty;
            var objectToString = objectProto.toString;
            var Symbol = root.Symbol,
              propertyIsEnumerable = objectProto.propertyIsEnumerable,
              spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;
            var nativeMax = Math.max;
            function baseFlatten(array, depth, predicate, isStrict, result) {
              var index = -1,
                length = array.length;
              predicate || (predicate = isFlattenable);
              result || (result = []);
              while (++index < length) {
                var value = array[index];
                if (depth > 0 && predicate(value)) {
                  if (depth > 1) {
                    baseFlatten(value, depth - 1, predicate, isStrict, result);
                  } else {
                    arrayPush(result, value);
                  }
                } else if (!isStrict) {
                  result[result.length] = value;
                }
              }
              return result;
            }
            function basePick(object, props) {
              object = Object(object);
              return basePickBy(object, props, function(value, key) {
                return key in object;
              });
            }
            function basePickBy(object, props, predicate) {
              var index = -1,
                length = props.length,
                result = {};
              while (++index < length) {
                var key = props[index],
                  value = object[key];
                if (predicate(value, key)) {
                  result[key] = value;
                }
              }
              return result;
            }
            function baseRest(func, start) {
              start = nativeMax(
                start === undefined ? func.length - 1 : start,
                0
              );
              return function() {
                var args = arguments,
                  index = -1,
                  length = nativeMax(args.length - start, 0),
                  array = Array(length);
                while (++index < length) {
                  array[index] = args[start + index];
                }
                index = -1;
                var otherArgs = Array(start + 1);
                while (++index < start) {
                  otherArgs[index] = args[index];
                }
                otherArgs[start] = array;
                return apply(func, this, otherArgs);
              };
            }
            function isFlattenable(value) {
              return (
                isArray(value) ||
                isArguments(value) ||
                !!(spreadableSymbol && value && value[spreadableSymbol])
              );
            }
            function toKey(value) {
              if (typeof value == 'string' || isSymbol(value)) {
                return value;
              }
              var result = value + '';
              return result == '0' && 1 / value == -INFINITY ? '-0' : result;
            }
            function isArguments(value) {
              return (
                isArrayLikeObject(value) &&
                hasOwnProperty.call(value, 'callee') &&
                (!propertyIsEnumerable.call(value, 'callee') ||
                  objectToString.call(value) == argsTag)
              );
            }
            var isArray = Array.isArray;
            function isArrayLike(value) {
              return (
                value != null && isLength(value.length) && !isFunction(value)
              );
            }
            function isArrayLikeObject(value) {
              return isObjectLike(value) && isArrayLike(value);
            }
            function isFunction(value) {
              var tag = isObject(value) ? objectToString.call(value) : '';
              return tag == funcTag || tag == genTag;
            }
            function isLength(value) {
              return (
                typeof value == 'number' &&
                value > -1 &&
                value % 1 == 0 &&
                value <= MAX_SAFE_INTEGER
              );
            }
            function isObject(value) {
              var type = typeof value;
              return !!value && (type == 'object' || type == 'function');
            }
            function isObjectLike(value) {
              return !!value && typeof value == 'object';
            }
            function isSymbol(value) {
              return (
                typeof value == 'symbol' ||
                (isObjectLike(value) && objectToString.call(value) == symbolTag)
              );
            }
            var pick = baseRest(function(object, props) {
              return object == null
                ? {}
                : basePick(object, arrayMap(baseFlatten(props, 1), toKey));
            });
            module.exports = pick;
          }.call(
            this,
            typeof global !== 'undefined'
              ? global
              : typeof self !== 'undefined'
              ? self
              : typeof window !== 'undefined'
              ? window
              : {}
          ));
        },
        {}
      ],
      434: [
        function(require, module, exports) {
          (function(global) {
            var LARGE_ARRAY_SIZE = 200;
            var FUNC_ERROR_TEXT = 'Expected a function';
            var HASH_UNDEFINED = '__lodash_hash_undefined__';
            var UNORDERED_COMPARE_FLAG = 1,
              PARTIAL_COMPARE_FLAG = 2;
            var INFINITY = 1 / 0,
              MAX_SAFE_INTEGER = 9007199254740991;
            var argsTag = '[object Arguments]',
              arrayTag = '[object Array]',
              boolTag = '[object Boolean]',
              dateTag = '[object Date]',
              errorTag = '[object Error]',
              funcTag = '[object Function]',
              genTag = '[object GeneratorFunction]',
              mapTag = '[object Map]',
              numberTag = '[object Number]',
              objectTag = '[object Object]',
              promiseTag = '[object Promise]',
              regexpTag = '[object RegExp]',
              setTag = '[object Set]',
              stringTag = '[object String]',
              symbolTag = '[object Symbol]',
              weakMapTag = '[object WeakMap]';
            var arrayBufferTag = '[object ArrayBuffer]',
              dataViewTag = '[object DataView]',
              float32Tag = '[object Float32Array]',
              float64Tag = '[object Float64Array]',
              int8Tag = '[object Int8Array]',
              int16Tag = '[object Int16Array]',
              int32Tag = '[object Int32Array]',
              uint8Tag = '[object Uint8Array]',
              uint8ClampedTag = '[object Uint8ClampedArray]',
              uint16Tag = '[object Uint16Array]',
              uint32Tag = '[object Uint32Array]';
            var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
              reIsPlainProp = /^\w*$/,
              reLeadingDot = /^\./,
              rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
            var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
            var reEscapeChar = /\\(\\)?/g;
            var reIsHostCtor = /^\[object .+?Constructor\]$/;
            var reIsUint = /^(?:0|[1-9]\d*)$/;
            var typedArrayTags = {};
            typedArrayTags[float32Tag] = typedArrayTags[
              float64Tag
            ] = typedArrayTags[int8Tag] = typedArrayTags[
              int16Tag
            ] = typedArrayTags[int32Tag] = typedArrayTags[
              uint8Tag
            ] = typedArrayTags[uint8ClampedTag] = typedArrayTags[
              uint16Tag
            ] = typedArrayTags[uint32Tag] = true;
            typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[
              arrayBufferTag
            ] = typedArrayTags[boolTag] = typedArrayTags[
              dataViewTag
            ] = typedArrayTags[dateTag] = typedArrayTags[
              errorTag
            ] = typedArrayTags[funcTag] = typedArrayTags[
              mapTag
            ] = typedArrayTags[numberTag] = typedArrayTags[
              objectTag
            ] = typedArrayTags[regexpTag] = typedArrayTags[
              setTag
            ] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
            var freeGlobal =
              typeof global == 'object' &&
              global &&
              global.Object === Object &&
              global;
            var freeSelf =
              typeof self == 'object' && self && self.Object === Object && self;
            var root = freeGlobal || freeSelf || Function('return this')();
            var freeExports =
              typeof exports == 'object' &&
              exports &&
              !exports.nodeType &&
              exports;
            var freeModule =
              freeExports &&
              typeof module == 'object' &&
              module &&
              !module.nodeType &&
              module;
            var moduleExports =
              freeModule && freeModule.exports === freeExports;
            var freeProcess = moduleExports && freeGlobal.process;
            var nodeUtil = (function() {
              try {
                return freeProcess && freeProcess.binding('util');
              } catch (e) {}
            })();
            var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
            function arrayReduce(array, iteratee, accumulator, initAccum) {
              var index = -1,
                length = array ? array.length : 0;
              if (initAccum && length) {
                accumulator = array[++index];
              }
              while (++index < length) {
                accumulator = iteratee(accumulator, array[index], index, array);
              }
              return accumulator;
            }
            function arraySome(array, predicate) {
              var index = -1,
                length = array ? array.length : 0;
              while (++index < length) {
                if (predicate(array[index], index, array)) {
                  return true;
                }
              }
              return false;
            }
            function baseProperty(key) {
              return function(object) {
                return object == null ? undefined : object[key];
              };
            }
            function baseReduce(
              collection,
              iteratee,
              accumulator,
              initAccum,
              eachFunc
            ) {
              eachFunc(collection, function(value, index, collection) {
                accumulator = initAccum
                  ? ((initAccum = false), value)
                  : iteratee(accumulator, value, index, collection);
              });
              return accumulator;
            }
            function baseTimes(n, iteratee) {
              var index = -1,
                result = Array(n);
              while (++index < n) {
                result[index] = iteratee(index);
              }
              return result;
            }
            function baseUnary(func) {
              return function(value) {
                return func(value);
              };
            }
            function getValue(object, key) {
              return object == null ? undefined : object[key];
            }
            function isHostObject(value) {
              var result = false;
              if (value != null && typeof value.toString != 'function') {
                try {
                  result = !!(value + '');
                } catch (e) {}
              }
              return result;
            }
            function mapToArray(map) {
              var index = -1,
                result = Array(map.size);
              map.forEach(function(value, key) {
                result[++index] = [key, value];
              });
              return result;
            }
            function overArg(func, transform) {
              return function(arg) {
                return func(transform(arg));
              };
            }
            function setToArray(set) {
              var index = -1,
                result = Array(set.size);
              set.forEach(function(value) {
                result[++index] = value;
              });
              return result;
            }
            var arrayProto = Array.prototype,
              funcProto = Function.prototype,
              objectProto = Object.prototype;
            var coreJsData = root['__core-js_shared__'];
            var maskSrcKey = (function() {
              var uid = /[^.]+$/.exec(
                (coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO) ||
                  ''
              );
              return uid ? 'Symbol(src)_1.' + uid : '';
            })();
            var funcToString = funcProto.toString;
            var hasOwnProperty = objectProto.hasOwnProperty;
            var objectToString = objectProto.toString;
            var reIsNative = RegExp(
              '^' +
                funcToString
                  .call(hasOwnProperty)
                  .replace(reRegExpChar, '\\$&')
                  .replace(
                    /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                    '$1.*?'
                  ) +
                '$'
            );
            var Symbol = root.Symbol,
              Uint8Array = root.Uint8Array,
              propertyIsEnumerable = objectProto.propertyIsEnumerable,
              splice = arrayProto.splice;
            var nativeKeys = overArg(Object.keys, Object);
            var DataView = getNative(root, 'DataView'),
              Map = getNative(root, 'Map'),
              Promise = getNative(root, 'Promise'),
              Set = getNative(root, 'Set'),
              WeakMap = getNative(root, 'WeakMap'),
              nativeCreate = getNative(Object, 'create');
            var dataViewCtorString = toSource(DataView),
              mapCtorString = toSource(Map),
              promiseCtorString = toSource(Promise),
              setCtorString = toSource(Set),
              weakMapCtorString = toSource(WeakMap);
            var symbolProto = Symbol ? Symbol.prototype : undefined,
              symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
              symbolToString = symbolProto ? symbolProto.toString : undefined;
            function Hash(entries) {
              var index = -1,
                length = entries ? entries.length : 0;
              this.clear();
              while (++index < length) {
                var entry = entries[index];
                this.set(entry[0], entry[1]);
              }
            }
            function hashClear() {
              this.__data__ = nativeCreate ? nativeCreate(null) : {};
            }
            function hashDelete(key) {
              return this.has(key) && delete this.__data__[key];
            }
            function hashGet(key) {
              var data = this.__data__;
              if (nativeCreate) {
                var result = data[key];
                return result === HASH_UNDEFINED ? undefined : result;
              }
              return hasOwnProperty.call(data, key) ? data[key] : undefined;
            }
            function hashHas(key) {
              var data = this.__data__;
              return nativeCreate
                ? data[key] !== undefined
                : hasOwnProperty.call(data, key);
            }
            function hashSet(key, value) {
              var data = this.__data__;
              data[key] =
                nativeCreate && value === undefined ? HASH_UNDEFINED : value;
              return this;
            }
            Hash.prototype.clear = hashClear;
            Hash.prototype['delete'] = hashDelete;
            Hash.prototype.get = hashGet;
            Hash.prototype.has = hashHas;
            Hash.prototype.set = hashSet;
            function ListCache(entries) {
              var index = -1,
                length = entries ? entries.length : 0;
              this.clear();
              while (++index < length) {
                var entry = entries[index];
                this.set(entry[0], entry[1]);
              }
            }
            function listCacheClear() {
              this.__data__ = [];
            }
            function listCacheDelete(key) {
              var data = this.__data__,
                index = assocIndexOf(data, key);
              if (index < 0) {
                return false;
              }
              var lastIndex = data.length - 1;
              if (index == lastIndex) {
                data.pop();
              } else {
                splice.call(data, index, 1);
              }
              return true;
            }
            function listCacheGet(key) {
              var data = this.__data__,
                index = assocIndexOf(data, key);
              return index < 0 ? undefined : data[index][1];
            }
            function listCacheHas(key) {
              return assocIndexOf(this.__data__, key) > -1;
            }
            function listCacheSet(key, value) {
              var data = this.__data__,
                index = assocIndexOf(data, key);
              if (index < 0) {
                data.push([key, value]);
              } else {
                data[index][1] = value;
              }
              return this;
            }
            ListCache.prototype.clear = listCacheClear;
            ListCache.prototype['delete'] = listCacheDelete;
            ListCache.prototype.get = listCacheGet;
            ListCache.prototype.has = listCacheHas;
            ListCache.prototype.set = listCacheSet;
            function MapCache(entries) {
              var index = -1,
                length = entries ? entries.length : 0;
              this.clear();
              while (++index < length) {
                var entry = entries[index];
                this.set(entry[0], entry[1]);
              }
            }
            function mapCacheClear() {
              this.__data__ = {
                hash: new Hash(),
                map: new (Map || ListCache)(),
                string: new Hash()
              };
            }
            function mapCacheDelete(key) {
              return getMapData(this, key)['delete'](key);
            }
            function mapCacheGet(key) {
              return getMapData(this, key).get(key);
            }
            function mapCacheHas(key) {
              return getMapData(this, key).has(key);
            }
            function mapCacheSet(key, value) {
              getMapData(this, key).set(key, value);
              return this;
            }
            MapCache.prototype.clear = mapCacheClear;
            MapCache.prototype['delete'] = mapCacheDelete;
            MapCache.prototype.get = mapCacheGet;
            MapCache.prototype.has = mapCacheHas;
            MapCache.prototype.set = mapCacheSet;
            function SetCache(values) {
              var index = -1,
                length = values ? values.length : 0;
              this.__data__ = new MapCache();
              while (++index < length) {
                this.add(values[index]);
              }
            }
            function setCacheAdd(value) {
              this.__data__.set(value, HASH_UNDEFINED);
              return this;
            }
            function setCacheHas(value) {
              return this.__data__.has(value);
            }
            SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
            SetCache.prototype.has = setCacheHas;
            function Stack(entries) {
              this.__data__ = new ListCache(entries);
            }
            function stackClear() {
              this.__data__ = new ListCache();
            }
            function stackDelete(key) {
              return this.__data__['delete'](key);
            }
            function stackGet(key) {
              return this.__data__.get(key);
            }
            function stackHas(key) {
              return this.__data__.has(key);
            }
            function stackSet(key, value) {
              var cache = this.__data__;
              if (cache instanceof ListCache) {
                var pairs = cache.__data__;
                if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
                  pairs.push([key, value]);
                  return this;
                }
                cache = this.__data__ = new MapCache(pairs);
              }
              cache.set(key, value);
              return this;
            }
            Stack.prototype.clear = stackClear;
            Stack.prototype['delete'] = stackDelete;
            Stack.prototype.get = stackGet;
            Stack.prototype.has = stackHas;
            Stack.prototype.set = stackSet;
            function arrayLikeKeys(value, inherited) {
              var result =
                isArray(value) || isArguments(value)
                  ? baseTimes(value.length, String)
                  : [];
              var length = result.length,
                skipIndexes = !!length;
              for (var key in value) {
                if (
                  (inherited || hasOwnProperty.call(value, key)) &&
                  !(skipIndexes && (key == 'length' || isIndex(key, length)))
                ) {
                  result.push(key);
                }
              }
              return result;
            }
            function assocIndexOf(array, key) {
              var length = array.length;
              while (length--) {
                if (eq(array[length][0], key)) {
                  return length;
                }
              }
              return -1;
            }
            var baseEach = createBaseEach(baseForOwn);
            var baseFor = createBaseFor();
            function baseForOwn(object, iteratee) {
              return object && baseFor(object, iteratee, keys);
            }
            function baseGet(object, path) {
              path = isKey(path, object) ? [path] : castPath(path);
              var index = 0,
                length = path.length;
              while (object != null && index < length) {
                object = object[toKey(path[index++])];
              }
              return index && index == length ? object : undefined;
            }
            function baseGetTag(value) {
              return objectToString.call(value);
            }
            function baseHasIn(object, key) {
              return object != null && key in Object(object);
            }
            function baseIsEqual(value, other, customizer, bitmask, stack) {
              if (value === other) {
                return true;
              }
              if (
                value == null ||
                other == null ||
                (!isObject(value) && !isObjectLike(other))
              ) {
                return value !== value && other !== other;
              }
              return baseIsEqualDeep(
                value,
                other,
                baseIsEqual,
                customizer,
                bitmask,
                stack
              );
            }
            function baseIsEqualDeep(
              object,
              other,
              equalFunc,
              customizer,
              bitmask,
              stack
            ) {
              var objIsArr = isArray(object),
                othIsArr = isArray(other),
                objTag = arrayTag,
                othTag = arrayTag;
              if (!objIsArr) {
                objTag = getTag(object);
                objTag = objTag == argsTag ? objectTag : objTag;
              }
              if (!othIsArr) {
                othTag = getTag(other);
                othTag = othTag == argsTag ? objectTag : othTag;
              }
              var objIsObj = objTag == objectTag && !isHostObject(object),
                othIsObj = othTag == objectTag && !isHostObject(other),
                isSameTag = objTag == othTag;
              if (isSameTag && !objIsObj) {
                stack || (stack = new Stack());
                return objIsArr || isTypedArray(object)
                  ? equalArrays(
                      object,
                      other,
                      equalFunc,
                      customizer,
                      bitmask,
                      stack
                    )
                  : equalByTag(
                      object,
                      other,
                      objTag,
                      equalFunc,
                      customizer,
                      bitmask,
                      stack
                    );
              }
              if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
                var objIsWrapped =
                    objIsObj && hasOwnProperty.call(object, '__wrapped__'),
                  othIsWrapped =
                    othIsObj && hasOwnProperty.call(other, '__wrapped__');
                if (objIsWrapped || othIsWrapped) {
                  var objUnwrapped = objIsWrapped ? object.value() : object,
                    othUnwrapped = othIsWrapped ? other.value() : other;
                  stack || (stack = new Stack());
                  return equalFunc(
                    objUnwrapped,
                    othUnwrapped,
                    customizer,
                    bitmask,
                    stack
                  );
                }
              }
              if (!isSameTag) {
                return false;
              }
              stack || (stack = new Stack());
              return equalObjects(
                object,
                other,
                equalFunc,
                customizer,
                bitmask,
                stack
              );
            }
            function baseIsMatch(object, source, matchData, customizer) {
              var index = matchData.length,
                length = index,
                noCustomizer = !customizer;
              if (object == null) {
                return !length;
              }
              object = Object(object);
              while (index--) {
                var data = matchData[index];
                if (
                  noCustomizer && data[2]
                    ? data[1] !== object[data[0]]
                    : !(data[0] in object)
                ) {
                  return false;
                }
              }
              while (++index < length) {
                data = matchData[index];
                var key = data[0],
                  objValue = object[key],
                  srcValue = data[1];
                if (noCustomizer && data[2]) {
                  if (objValue === undefined && !(key in object)) {
                    return false;
                  }
                } else {
                  var stack = new Stack();
                  if (customizer) {
                    var result = customizer(
                      objValue,
                      srcValue,
                      key,
                      object,
                      source,
                      stack
                    );
                  }
                  if (
                    !(result === undefined
                      ? baseIsEqual(
                          srcValue,
                          objValue,
                          customizer,
                          UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG,
                          stack
                        )
                      : result)
                  ) {
                    return false;
                  }
                }
              }
              return true;
            }
            function baseIsNative(value) {
              if (!isObject(value) || isMasked(value)) {
                return false;
              }
              var pattern =
                isFunction(value) || isHostObject(value)
                  ? reIsNative
                  : reIsHostCtor;
              return pattern.test(toSource(value));
            }
            function baseIsTypedArray(value) {
              return (
                isObjectLike(value) &&
                isLength(value.length) &&
                !!typedArrayTags[objectToString.call(value)]
              );
            }
            function baseIteratee(value) {
              if (typeof value == 'function') {
                return value;
              }
              if (value == null) {
                return identity;
              }
              if (typeof value == 'object') {
                return isArray(value)
                  ? baseMatchesProperty(value[0], value[1])
                  : baseMatches(value);
              }
              return property(value);
            }
            function baseKeys(object) {
              if (!isPrototype(object)) {
                return nativeKeys(object);
              }
              var result = [];
              for (var key in Object(object)) {
                if (hasOwnProperty.call(object, key) && key != 'constructor') {
                  result.push(key);
                }
              }
              return result;
            }
            function baseMatches(source) {
              var matchData = getMatchData(source);
              if (matchData.length == 1 && matchData[0][2]) {
                return matchesStrictComparable(
                  matchData[0][0],
                  matchData[0][1]
                );
              }
              return function(object) {
                return (
                  object === source || baseIsMatch(object, source, matchData)
                );
              };
            }
            function baseMatchesProperty(path, srcValue) {
              if (isKey(path) && isStrictComparable(srcValue)) {
                return matchesStrictComparable(toKey(path), srcValue);
              }
              return function(object) {
                var objValue = get(object, path);
                return objValue === undefined && objValue === srcValue
                  ? hasIn(object, path)
                  : baseIsEqual(
                      srcValue,
                      objValue,
                      undefined,
                      UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG
                    );
              };
            }
            function basePropertyDeep(path) {
              return function(object) {
                return baseGet(object, path);
              };
            }
            function baseToString(value) {
              if (typeof value == 'string') {
                return value;
              }
              if (isSymbol(value)) {
                return symbolToString ? symbolToString.call(value) : '';
              }
              var result = value + '';
              return result == '0' && 1 / value == -INFINITY ? '-0' : result;
            }
            function castPath(value) {
              return isArray(value) ? value : stringToPath(value);
            }
            function createBaseEach(eachFunc, fromRight) {
              return function(collection, iteratee) {
                if (collection == null) {
                  return collection;
                }
                if (!isArrayLike(collection)) {
                  return eachFunc(collection, iteratee);
                }
                var length = collection.length,
                  index = fromRight ? length : -1,
                  iterable = Object(collection);
                while (fromRight ? index-- : ++index < length) {
                  if (iteratee(iterable[index], index, iterable) === false) {
                    break;
                  }
                }
                return collection;
              };
            }
            function createBaseFor(fromRight) {
              return function(object, iteratee, keysFunc) {
                var index = -1,
                  iterable = Object(object),
                  props = keysFunc(object),
                  length = props.length;
                while (length--) {
                  var key = props[fromRight ? length : ++index];
                  if (iteratee(iterable[key], key, iterable) === false) {
                    break;
                  }
                }
                return object;
              };
            }
            function equalArrays(
              array,
              other,
              equalFunc,
              customizer,
              bitmask,
              stack
            ) {
              var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
                arrLength = array.length,
                othLength = other.length;
              if (
                arrLength != othLength &&
                !(isPartial && othLength > arrLength)
              ) {
                return false;
              }
              var stacked = stack.get(array);
              if (stacked && stack.get(other)) {
                return stacked == other;
              }
              var index = -1,
                result = true,
                seen =
                  bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : undefined;
              stack.set(array, other);
              stack.set(other, array);
              while (++index < arrLength) {
                var arrValue = array[index],
                  othValue = other[index];
                if (customizer) {
                  var compared = isPartial
                    ? customizer(othValue, arrValue, index, other, array, stack)
                    : customizer(
                        arrValue,
                        othValue,
                        index,
                        array,
                        other,
                        stack
                      );
                }
                if (compared !== undefined) {
                  if (compared) {
                    continue;
                  }
                  result = false;
                  break;
                }
                if (seen) {
                  if (
                    !arraySome(other, function(othValue, othIndex) {
                      if (
                        !seen.has(othIndex) &&
                        (arrValue === othValue ||
                          equalFunc(
                            arrValue,
                            othValue,
                            customizer,
                            bitmask,
                            stack
                          ))
                      ) {
                        return seen.add(othIndex);
                      }
                    })
                  ) {
                    result = false;
                    break;
                  }
                } else if (
                  !(
                    arrValue === othValue ||
                    equalFunc(arrValue, othValue, customizer, bitmask, stack)
                  )
                ) {
                  result = false;
                  break;
                }
              }
              stack['delete'](array);
              stack['delete'](other);
              return result;
            }
            function equalByTag(
              object,
              other,
              tag,
              equalFunc,
              customizer,
              bitmask,
              stack
            ) {
              switch (tag) {
                case dataViewTag:
                  if (
                    object.byteLength != other.byteLength ||
                    object.byteOffset != other.byteOffset
                  ) {
                    return false;
                  }
                  object = object.buffer;
                  other = other.buffer;
                case arrayBufferTag:
                  if (
                    object.byteLength != other.byteLength ||
                    !equalFunc(new Uint8Array(object), new Uint8Array(other))
                  ) {
                    return false;
                  }
                  return true;
                case boolTag:
                case dateTag:
                case numberTag:
                  return eq(+object, +other);
                case errorTag:
                  return (
                    object.name == other.name && object.message == other.message
                  );
                case regexpTag:
                case stringTag:
                  return object == other + '';
                case mapTag:
                  var convert = mapToArray;
                case setTag:
                  var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
                  convert || (convert = setToArray);
                  if (object.size != other.size && !isPartial) {
                    return false;
                  }
                  var stacked = stack.get(object);
                  if (stacked) {
                    return stacked == other;
                  }
                  bitmask |= UNORDERED_COMPARE_FLAG;
                  stack.set(object, other);
                  var result = equalArrays(
                    convert(object),
                    convert(other),
                    equalFunc,
                    customizer,
                    bitmask,
                    stack
                  );
                  stack['delete'](object);
                  return result;
                case symbolTag:
                  if (symbolValueOf) {
                    return (
                      symbolValueOf.call(object) == symbolValueOf.call(other)
                    );
                  }
              }
              return false;
            }
            function equalObjects(
              object,
              other,
              equalFunc,
              customizer,
              bitmask,
              stack
            ) {
              var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
                objProps = keys(object),
                objLength = objProps.length,
                othProps = keys(other),
                othLength = othProps.length;
              if (objLength != othLength && !isPartial) {
                return false;
              }
              var index = objLength;
              while (index--) {
                var key = objProps[index];
                if (
                  !(isPartial ? key in other : hasOwnProperty.call(other, key))
                ) {
                  return false;
                }
              }
              var stacked = stack.get(object);
              if (stacked && stack.get(other)) {
                return stacked == other;
              }
              var result = true;
              stack.set(object, other);
              stack.set(other, object);
              var skipCtor = isPartial;
              while (++index < objLength) {
                key = objProps[index];
                var objValue = object[key],
                  othValue = other[key];
                if (customizer) {
                  var compared = isPartial
                    ? customizer(othValue, objValue, key, other, object, stack)
                    : customizer(objValue, othValue, key, object, other, stack);
                }
                if (
                  !(compared === undefined
                    ? objValue === othValue ||
                      equalFunc(objValue, othValue, customizer, bitmask, stack)
                    : compared)
                ) {
                  result = false;
                  break;
                }
                skipCtor || (skipCtor = key == 'constructor');
              }
              if (result && !skipCtor) {
                var objCtor = object.constructor,
                  othCtor = other.constructor;
                if (
                  objCtor != othCtor &&
                  ('constructor' in object && 'constructor' in other) &&
                  !(
                    typeof objCtor == 'function' &&
                    objCtor instanceof objCtor &&
                    typeof othCtor == 'function' &&
                    othCtor instanceof othCtor
                  )
                ) {
                  result = false;
                }
              }
              stack['delete'](object);
              stack['delete'](other);
              return result;
            }
            function getMapData(map, key) {
              var data = map.__data__;
              return isKeyable(key)
                ? data[typeof key == 'string' ? 'string' : 'hash']
                : data.map;
            }
            function getMatchData(object) {
              var result = keys(object),
                length = result.length;
              while (length--) {
                var key = result[length],
                  value = object[key];
                result[length] = [key, value, isStrictComparable(value)];
              }
              return result;
            }
            function getNative(object, key) {
              var value = getValue(object, key);
              return baseIsNative(value) ? value : undefined;
            }
            var getTag = baseGetTag;
            if (
              (DataView &&
                getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
              (Map && getTag(new Map()) != mapTag) ||
              (Promise && getTag(Promise.resolve()) != promiseTag) ||
              (Set && getTag(new Set()) != setTag) ||
              (WeakMap && getTag(new WeakMap()) != weakMapTag)
            ) {
              getTag = function(value) {
                var result = objectToString.call(value),
                  Ctor = result == objectTag ? value.constructor : undefined,
                  ctorString = Ctor ? toSource(Ctor) : undefined;
                if (ctorString) {
                  switch (ctorString) {
                    case dataViewCtorString:
                      return dataViewTag;
                    case mapCtorString:
                      return mapTag;
                    case promiseCtorString:
                      return promiseTag;
                    case setCtorString:
                      return setTag;
                    case weakMapCtorString:
                      return weakMapTag;
                  }
                }
                return result;
              };
            }
            function hasPath(object, path, hasFunc) {
              path = isKey(path, object) ? [path] : castPath(path);
              var result,
                index = -1,
                length = path.length;
              while (++index < length) {
                var key = toKey(path[index]);
                if (!(result = object != null && hasFunc(object, key))) {
                  break;
                }
                object = object[key];
              }
              if (result) {
                return result;
              }
              var length = object ? object.length : 0;
              return (
                !!length &&
                isLength(length) &&
                isIndex(key, length) &&
                (isArray(object) || isArguments(object))
              );
            }
            function isIndex(value, length) {
              length = length == null ? MAX_SAFE_INTEGER : length;
              return (
                !!length &&
                (typeof value == 'number' || reIsUint.test(value)) &&
                (value > -1 && value % 1 == 0 && value < length)
              );
            }
            function isKey(value, object) {
              if (isArray(value)) {
                return false;
              }
              var type = typeof value;
              if (
                type == 'number' ||
                type == 'symbol' ||
                type == 'boolean' ||
                value == null ||
                isSymbol(value)
              ) {
                return true;
              }
              return (
                reIsPlainProp.test(value) ||
                !reIsDeepProp.test(value) ||
                (object != null && value in Object(object))
              );
            }
            function isKeyable(value) {
              var type = typeof value;
              return type == 'string' ||
                type == 'number' ||
                type == 'symbol' ||
                type == 'boolean'
                ? value !== '__proto__'
                : value === null;
            }
            function isMasked(func) {
              return !!maskSrcKey && maskSrcKey in func;
            }
            function isPrototype(value) {
              var Ctor = value && value.constructor,
                proto =
                  (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
              return value === proto;
            }
            function isStrictComparable(value) {
              return value === value && !isObject(value);
            }
            function matchesStrictComparable(key, srcValue) {
              return function(object) {
                if (object == null) {
                  return false;
                }
                return (
                  object[key] === srcValue &&
                  (srcValue !== undefined || key in Object(object))
                );
              };
            }
            var stringToPath = memoize(function(string) {
              string = toString(string);
              var result = [];
              if (reLeadingDot.test(string)) {
                result.push('');
              }
              string.replace(rePropName, function(
                match,
                number,
                quote,
                string
              ) {
                result.push(
                  quote ? string.replace(reEscapeChar, '$1') : number || match
                );
              });
              return result;
            });
            function toKey(value) {
              if (typeof value == 'string' || isSymbol(value)) {
                return value;
              }
              var result = value + '';
              return result == '0' && 1 / value == -INFINITY ? '-0' : result;
            }
            function toSource(func) {
              if (func != null) {
                try {
                  return funcToString.call(func);
                } catch (e) {}
                try {
                  return func + '';
                } catch (e) {}
              }
              return '';
            }
            function reduce(collection, iteratee, accumulator) {
              var func = isArray(collection) ? arrayReduce : baseReduce,
                initAccum = arguments.length < 3;
              return func(
                collection,
                baseIteratee(iteratee, 4),
                accumulator,
                initAccum,
                baseEach
              );
            }
            function memoize(func, resolver) {
              if (
                typeof func != 'function' ||
                (resolver && typeof resolver != 'function')
              ) {
                throw new TypeError(FUNC_ERROR_TEXT);
              }
              var memoized = function() {
                var args = arguments,
                  key = resolver ? resolver.apply(this, args) : args[0],
                  cache = memoized.cache;
                if (cache.has(key)) {
                  return cache.get(key);
                }
                var result = func.apply(this, args);
                memoized.cache = cache.set(key, result);
                return result;
              };
              memoized.cache = new (memoize.Cache || MapCache)();
              return memoized;
            }
            memoize.Cache = MapCache;
            function eq(value, other) {
              return value === other || (value !== value && other !== other);
            }
            function isArguments(value) {
              return (
                isArrayLikeObject(value) &&
                hasOwnProperty.call(value, 'callee') &&
                (!propertyIsEnumerable.call(value, 'callee') ||
                  objectToString.call(value) == argsTag)
              );
            }
            var isArray = Array.isArray;
            function isArrayLike(value) {
              return (
                value != null && isLength(value.length) && !isFunction(value)
              );
            }
            function isArrayLikeObject(value) {
              return isObjectLike(value) && isArrayLike(value);
            }
            function isFunction(value) {
              var tag = isObject(value) ? objectToString.call(value) : '';
              return tag == funcTag || tag == genTag;
            }
            function isLength(value) {
              return (
                typeof value == 'number' &&
                value > -1 &&
                value % 1 == 0 &&
                value <= MAX_SAFE_INTEGER
              );
            }
            function isObject(value) {
              var type = typeof value;
              return !!value && (type == 'object' || type == 'function');
            }
            function isObjectLike(value) {
              return !!value && typeof value == 'object';
            }
            function isSymbol(value) {
              return (
                typeof value == 'symbol' ||
                (isObjectLike(value) && objectToString.call(value) == symbolTag)
              );
            }
            var isTypedArray = nodeIsTypedArray
              ? baseUnary(nodeIsTypedArray)
              : baseIsTypedArray;
            function toString(value) {
              return value == null ? '' : baseToString(value);
            }
            function get(object, path, defaultValue) {
              var result = object == null ? undefined : baseGet(object, path);
              return result === undefined ? defaultValue : result;
            }
            function hasIn(object, path) {
              return object != null && hasPath(object, path, baseHasIn);
            }
            function keys(object) {
              return isArrayLike(object)
                ? arrayLikeKeys(object)
                : baseKeys(object);
            }
            function identity(value) {
              return value;
            }
            function property(path) {
              return isKey(path)
                ? baseProperty(toKey(path))
                : basePropertyDeep(path);
            }
            module.exports = reduce;
          }.call(
            this,
            typeof global !== 'undefined'
              ? global
              : typeof self !== 'undefined'
              ? self
              : typeof window !== 'undefined'
              ? window
              : {}
          ));
        },
        {}
      ],
      435: [
        function(require, module, exports) {
          (function(global) {
            var LARGE_ARRAY_SIZE = 200;
            var FUNC_ERROR_TEXT = 'Expected a function';
            var HASH_UNDEFINED = '__lodash_hash_undefined__';
            var UNORDERED_COMPARE_FLAG = 1,
              PARTIAL_COMPARE_FLAG = 2;
            var INFINITY = 1 / 0,
              MAX_SAFE_INTEGER = 9007199254740991;
            var argsTag = '[object Arguments]',
              arrayTag = '[object Array]',
              boolTag = '[object Boolean]',
              dateTag = '[object Date]',
              errorTag = '[object Error]',
              funcTag = '[object Function]',
              genTag = '[object GeneratorFunction]',
              mapTag = '[object Map]',
              numberTag = '[object Number]',
              objectTag = '[object Object]',
              promiseTag = '[object Promise]',
              regexpTag = '[object RegExp]',
              setTag = '[object Set]',
              stringTag = '[object String]',
              symbolTag = '[object Symbol]',
              weakMapTag = '[object WeakMap]';
            var arrayBufferTag = '[object ArrayBuffer]',
              dataViewTag = '[object DataView]',
              float32Tag = '[object Float32Array]',
              float64Tag = '[object Float64Array]',
              int8Tag = '[object Int8Array]',
              int16Tag = '[object Int16Array]',
              int32Tag = '[object Int32Array]',
              uint8Tag = '[object Uint8Array]',
              uint8ClampedTag = '[object Uint8ClampedArray]',
              uint16Tag = '[object Uint16Array]',
              uint32Tag = '[object Uint32Array]';
            var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
              reIsPlainProp = /^\w*$/,
              reLeadingDot = /^\./,
              rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
            var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
            var reEscapeChar = /\\(\\)?/g;
            var reIsHostCtor = /^\[object .+?Constructor\]$/;
            var reIsUint = /^(?:0|[1-9]\d*)$/;
            var typedArrayTags = {};
            typedArrayTags[float32Tag] = typedArrayTags[
              float64Tag
            ] = typedArrayTags[int8Tag] = typedArrayTags[
              int16Tag
            ] = typedArrayTags[int32Tag] = typedArrayTags[
              uint8Tag
            ] = typedArrayTags[uint8ClampedTag] = typedArrayTags[
              uint16Tag
            ] = typedArrayTags[uint32Tag] = true;
            typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[
              arrayBufferTag
            ] = typedArrayTags[boolTag] = typedArrayTags[
              dataViewTag
            ] = typedArrayTags[dateTag] = typedArrayTags[
              errorTag
            ] = typedArrayTags[funcTag] = typedArrayTags[
              mapTag
            ] = typedArrayTags[numberTag] = typedArrayTags[
              objectTag
            ] = typedArrayTags[regexpTag] = typedArrayTags[
              setTag
            ] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
            var freeGlobal =
              typeof global == 'object' &&
              global &&
              global.Object === Object &&
              global;
            var freeSelf =
              typeof self == 'object' && self && self.Object === Object && self;
            var root = freeGlobal || freeSelf || Function('return this')();
            var freeExports =
              typeof exports == 'object' &&
              exports &&
              !exports.nodeType &&
              exports;
            var freeModule =
              freeExports &&
              typeof module == 'object' &&
              module &&
              !module.nodeType &&
              module;
            var moduleExports =
              freeModule && freeModule.exports === freeExports;
            var freeProcess = moduleExports && freeGlobal.process;
            var nodeUtil = (function() {
              try {
                return freeProcess && freeProcess.binding('util');
              } catch (e) {}
            })();
            var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
            function arrayFilter(array, predicate) {
              var index = -1,
                length = array ? array.length : 0,
                resIndex = 0,
                result = [];
              while (++index < length) {
                var value = array[index];
                if (predicate(value, index, array)) {
                  result[resIndex++] = value;
                }
              }
              return result;
            }
            function arraySome(array, predicate) {
              var index = -1,
                length = array ? array.length : 0;
              while (++index < length) {
                if (predicate(array[index], index, array)) {
                  return true;
                }
              }
              return false;
            }
            function baseProperty(key) {
              return function(object) {
                return object == null ? undefined : object[key];
              };
            }
            function baseTimes(n, iteratee) {
              var index = -1,
                result = Array(n);
              while (++index < n) {
                result[index] = iteratee(index);
              }
              return result;
            }
            function baseUnary(func) {
              return function(value) {
                return func(value);
              };
            }
            function getValue(object, key) {
              return object == null ? undefined : object[key];
            }
            function isHostObject(value) {
              var result = false;
              if (value != null && typeof value.toString != 'function') {
                try {
                  result = !!(value + '');
                } catch (e) {}
              }
              return result;
            }
            function mapToArray(map) {
              var index = -1,
                result = Array(map.size);
              map.forEach(function(value, key) {
                result[++index] = [key, value];
              });
              return result;
            }
            function overArg(func, transform) {
              return function(arg) {
                return func(transform(arg));
              };
            }
            function setToArray(set) {
              var index = -1,
                result = Array(set.size);
              set.forEach(function(value) {
                result[++index] = value;
              });
              return result;
            }
            var arrayProto = Array.prototype,
              funcProto = Function.prototype,
              objectProto = Object.prototype;
            var coreJsData = root['__core-js_shared__'];
            var maskSrcKey = (function() {
              var uid = /[^.]+$/.exec(
                (coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO) ||
                  ''
              );
              return uid ? 'Symbol(src)_1.' + uid : '';
            })();
            var funcToString = funcProto.toString;
            var hasOwnProperty = objectProto.hasOwnProperty;
            var objectToString = objectProto.toString;
            var reIsNative = RegExp(
              '^' +
                funcToString
                  .call(hasOwnProperty)
                  .replace(reRegExpChar, '\\$&')
                  .replace(
                    /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                    '$1.*?'
                  ) +
                '$'
            );
            var Symbol = root.Symbol,
              Uint8Array = root.Uint8Array,
              propertyIsEnumerable = objectProto.propertyIsEnumerable,
              splice = arrayProto.splice;
            var nativeKeys = overArg(Object.keys, Object);
            var DataView = getNative(root, 'DataView'),
              Map = getNative(root, 'Map'),
              Promise = getNative(root, 'Promise'),
              Set = getNative(root, 'Set'),
              WeakMap = getNative(root, 'WeakMap'),
              nativeCreate = getNative(Object, 'create');
            var dataViewCtorString = toSource(DataView),
              mapCtorString = toSource(Map),
              promiseCtorString = toSource(Promise),
              setCtorString = toSource(Set),
              weakMapCtorString = toSource(WeakMap);
            var symbolProto = Symbol ? Symbol.prototype : undefined,
              symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
              symbolToString = symbolProto ? symbolProto.toString : undefined;
            function Hash(entries) {
              var index = -1,
                length = entries ? entries.length : 0;
              this.clear();
              while (++index < length) {
                var entry = entries[index];
                this.set(entry[0], entry[1]);
              }
            }
            function hashClear() {
              this.__data__ = nativeCreate ? nativeCreate(null) : {};
            }
            function hashDelete(key) {
              return this.has(key) && delete this.__data__[key];
            }
            function hashGet(key) {
              var data = this.__data__;
              if (nativeCreate) {
                var result = data[key];
                return result === HASH_UNDEFINED ? undefined : result;
              }
              return hasOwnProperty.call(data, key) ? data[key] : undefined;
            }
            function hashHas(key) {
              var data = this.__data__;
              return nativeCreate
                ? data[key] !== undefined
                : hasOwnProperty.call(data, key);
            }
            function hashSet(key, value) {
              var data = this.__data__;
              data[key] =
                nativeCreate && value === undefined ? HASH_UNDEFINED : value;
              return this;
            }
            Hash.prototype.clear = hashClear;
            Hash.prototype['delete'] = hashDelete;
            Hash.prototype.get = hashGet;
            Hash.prototype.has = hashHas;
            Hash.prototype.set = hashSet;
            function ListCache(entries) {
              var index = -1,
                length = entries ? entries.length : 0;
              this.clear();
              while (++index < length) {
                var entry = entries[index];
                this.set(entry[0], entry[1]);
              }
            }
            function listCacheClear() {
              this.__data__ = [];
            }
            function listCacheDelete(key) {
              var data = this.__data__,
                index = assocIndexOf(data, key);
              if (index < 0) {
                return false;
              }
              var lastIndex = data.length - 1;
              if (index == lastIndex) {
                data.pop();
              } else {
                splice.call(data, index, 1);
              }
              return true;
            }
            function listCacheGet(key) {
              var data = this.__data__,
                index = assocIndexOf(data, key);
              return index < 0 ? undefined : data[index][1];
            }
            function listCacheHas(key) {
              return assocIndexOf(this.__data__, key) > -1;
            }
            function listCacheSet(key, value) {
              var data = this.__data__,
                index = assocIndexOf(data, key);
              if (index < 0) {
                data.push([key, value]);
              } else {
                data[index][1] = value;
              }
              return this;
            }
            ListCache.prototype.clear = listCacheClear;
            ListCache.prototype['delete'] = listCacheDelete;
            ListCache.prototype.get = listCacheGet;
            ListCache.prototype.has = listCacheHas;
            ListCache.prototype.set = listCacheSet;
            function MapCache(entries) {
              var index = -1,
                length = entries ? entries.length : 0;
              this.clear();
              while (++index < length) {
                var entry = entries[index];
                this.set(entry[0], entry[1]);
              }
            }
            function mapCacheClear() {
              this.__data__ = {
                hash: new Hash(),
                map: new (Map || ListCache)(),
                string: new Hash()
              };
            }
            function mapCacheDelete(key) {
              return getMapData(this, key)['delete'](key);
            }
            function mapCacheGet(key) {
              return getMapData(this, key).get(key);
            }
            function mapCacheHas(key) {
              return getMapData(this, key).has(key);
            }
            function mapCacheSet(key, value) {
              getMapData(this, key).set(key, value);
              return this;
            }
            MapCache.prototype.clear = mapCacheClear;
            MapCache.prototype['delete'] = mapCacheDelete;
            MapCache.prototype.get = mapCacheGet;
            MapCache.prototype.has = mapCacheHas;
            MapCache.prototype.set = mapCacheSet;
            function SetCache(values) {
              var index = -1,
                length = values ? values.length : 0;
              this.__data__ = new MapCache();
              while (++index < length) {
                this.add(values[index]);
              }
            }
            function setCacheAdd(value) {
              this.__data__.set(value, HASH_UNDEFINED);
              return this;
            }
            function setCacheHas(value) {
              return this.__data__.has(value);
            }
            SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
            SetCache.prototype.has = setCacheHas;
            function Stack(entries) {
              this.__data__ = new ListCache(entries);
            }
            function stackClear() {
              this.__data__ = new ListCache();
            }
            function stackDelete(key) {
              return this.__data__['delete'](key);
            }
            function stackGet(key) {
              return this.__data__.get(key);
            }
            function stackHas(key) {
              return this.__data__.has(key);
            }
            function stackSet(key, value) {
              var cache = this.__data__;
              if (cache instanceof ListCache) {
                var pairs = cache.__data__;
                if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
                  pairs.push([key, value]);
                  return this;
                }
                cache = this.__data__ = new MapCache(pairs);
              }
              cache.set(key, value);
              return this;
            }
            Stack.prototype.clear = stackClear;
            Stack.prototype['delete'] = stackDelete;
            Stack.prototype.get = stackGet;
            Stack.prototype.has = stackHas;
            Stack.prototype.set = stackSet;
            function arrayLikeKeys(value, inherited) {
              var result =
                isArray(value) || isArguments(value)
                  ? baseTimes(value.length, String)
                  : [];
              var length = result.length,
                skipIndexes = !!length;
              for (var key in value) {
                if (
                  (inherited || hasOwnProperty.call(value, key)) &&
                  !(skipIndexes && (key == 'length' || isIndex(key, length)))
                ) {
                  result.push(key);
                }
              }
              return result;
            }
            function assocIndexOf(array, key) {
              var length = array.length;
              while (length--) {
                if (eq(array[length][0], key)) {
                  return length;
                }
              }
              return -1;
            }
            var baseEach = createBaseEach(baseForOwn);
            function baseFilter(collection, predicate) {
              var result = [];
              baseEach(collection, function(value, index, collection) {
                if (predicate(value, index, collection)) {
                  result.push(value);
                }
              });
              return result;
            }
            var baseFor = createBaseFor();
            function baseForOwn(object, iteratee) {
              return object && baseFor(object, iteratee, keys);
            }
            function baseGet(object, path) {
              path = isKey(path, object) ? [path] : castPath(path);
              var index = 0,
                length = path.length;
              while (object != null && index < length) {
                object = object[toKey(path[index++])];
              }
              return index && index == length ? object : undefined;
            }
            function baseGetTag(value) {
              return objectToString.call(value);
            }
            function baseHasIn(object, key) {
              return object != null && key in Object(object);
            }
            function baseIsEqual(value, other, customizer, bitmask, stack) {
              if (value === other) {
                return true;
              }
              if (
                value == null ||
                other == null ||
                (!isObject(value) && !isObjectLike(other))
              ) {
                return value !== value && other !== other;
              }
              return baseIsEqualDeep(
                value,
                other,
                baseIsEqual,
                customizer,
                bitmask,
                stack
              );
            }
            function baseIsEqualDeep(
              object,
              other,
              equalFunc,
              customizer,
              bitmask,
              stack
            ) {
              var objIsArr = isArray(object),
                othIsArr = isArray(other),
                objTag = arrayTag,
                othTag = arrayTag;
              if (!objIsArr) {
                objTag = getTag(object);
                objTag = objTag == argsTag ? objectTag : objTag;
              }
              if (!othIsArr) {
                othTag = getTag(other);
                othTag = othTag == argsTag ? objectTag : othTag;
              }
              var objIsObj = objTag == objectTag && !isHostObject(object),
                othIsObj = othTag == objectTag && !isHostObject(other),
                isSameTag = objTag == othTag;
              if (isSameTag && !objIsObj) {
                stack || (stack = new Stack());
                return objIsArr || isTypedArray(object)
                  ? equalArrays(
                      object,
                      other,
                      equalFunc,
                      customizer,
                      bitmask,
                      stack
                    )
                  : equalByTag(
                      object,
                      other,
                      objTag,
                      equalFunc,
                      customizer,
                      bitmask,
                      stack
                    );
              }
              if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
                var objIsWrapped =
                    objIsObj && hasOwnProperty.call(object, '__wrapped__'),
                  othIsWrapped =
                    othIsObj && hasOwnProperty.call(other, '__wrapped__');
                if (objIsWrapped || othIsWrapped) {
                  var objUnwrapped = objIsWrapped ? object.value() : object,
                    othUnwrapped = othIsWrapped ? other.value() : other;
                  stack || (stack = new Stack());
                  return equalFunc(
                    objUnwrapped,
                    othUnwrapped,
                    customizer,
                    bitmask,
                    stack
                  );
                }
              }
              if (!isSameTag) {
                return false;
              }
              stack || (stack = new Stack());
              return equalObjects(
                object,
                other,
                equalFunc,
                customizer,
                bitmask,
                stack
              );
            }
            function baseIsMatch(object, source, matchData, customizer) {
              var index = matchData.length,
                length = index,
                noCustomizer = !customizer;
              if (object == null) {
                return !length;
              }
              object = Object(object);
              while (index--) {
                var data = matchData[index];
                if (
                  noCustomizer && data[2]
                    ? data[1] !== object[data[0]]
                    : !(data[0] in object)
                ) {
                  return false;
                }
              }
              while (++index < length) {
                data = matchData[index];
                var key = data[0],
                  objValue = object[key],
                  srcValue = data[1];
                if (noCustomizer && data[2]) {
                  if (objValue === undefined && !(key in object)) {
                    return false;
                  }
                } else {
                  var stack = new Stack();
                  if (customizer) {
                    var result = customizer(
                      objValue,
                      srcValue,
                      key,
                      object,
                      source,
                      stack
                    );
                  }
                  if (
                    !(result === undefined
                      ? baseIsEqual(
                          srcValue,
                          objValue,
                          customizer,
                          UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG,
                          stack
                        )
                      : result)
                  ) {
                    return false;
                  }
                }
              }
              return true;
            }
            function baseIsNative(value) {
              if (!isObject(value) || isMasked(value)) {
                return false;
              }
              var pattern =
                isFunction(value) || isHostObject(value)
                  ? reIsNative
                  : reIsHostCtor;
              return pattern.test(toSource(value));
            }
            function baseIsTypedArray(value) {
              return (
                isObjectLike(value) &&
                isLength(value.length) &&
                !!typedArrayTags[objectToString.call(value)]
              );
            }
            function baseIteratee(value) {
              if (typeof value == 'function') {
                return value;
              }
              if (value == null) {
                return identity;
              }
              if (typeof value == 'object') {
                return isArray(value)
                  ? baseMatchesProperty(value[0], value[1])
                  : baseMatches(value);
              }
              return property(value);
            }
            function baseKeys(object) {
              if (!isPrototype(object)) {
                return nativeKeys(object);
              }
              var result = [];
              for (var key in Object(object)) {
                if (hasOwnProperty.call(object, key) && key != 'constructor') {
                  result.push(key);
                }
              }
              return result;
            }
            function baseMatches(source) {
              var matchData = getMatchData(source);
              if (matchData.length == 1 && matchData[0][2]) {
                return matchesStrictComparable(
                  matchData[0][0],
                  matchData[0][1]
                );
              }
              return function(object) {
                return (
                  object === source || baseIsMatch(object, source, matchData)
                );
              };
            }
            function baseMatchesProperty(path, srcValue) {
              if (isKey(path) && isStrictComparable(srcValue)) {
                return matchesStrictComparable(toKey(path), srcValue);
              }
              return function(object) {
                var objValue = get(object, path);
                return objValue === undefined && objValue === srcValue
                  ? hasIn(object, path)
                  : baseIsEqual(
                      srcValue,
                      objValue,
                      undefined,
                      UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG
                    );
              };
            }
            function basePropertyDeep(path) {
              return function(object) {
                return baseGet(object, path);
              };
            }
            function baseToString(value) {
              if (typeof value == 'string') {
                return value;
              }
              if (isSymbol(value)) {
                return symbolToString ? symbolToString.call(value) : '';
              }
              var result = value + '';
              return result == '0' && 1 / value == -INFINITY ? '-0' : result;
            }
            function castPath(value) {
              return isArray(value) ? value : stringToPath(value);
            }
            function createBaseEach(eachFunc, fromRight) {
              return function(collection, iteratee) {
                if (collection == null) {
                  return collection;
                }
                if (!isArrayLike(collection)) {
                  return eachFunc(collection, iteratee);
                }
                var length = collection.length,
                  index = fromRight ? length : -1,
                  iterable = Object(collection);
                while (fromRight ? index-- : ++index < length) {
                  if (iteratee(iterable[index], index, iterable) === false) {
                    break;
                  }
                }
                return collection;
              };
            }
            function createBaseFor(fromRight) {
              return function(object, iteratee, keysFunc) {
                var index = -1,
                  iterable = Object(object),
                  props = keysFunc(object),
                  length = props.length;
                while (length--) {
                  var key = props[fromRight ? length : ++index];
                  if (iteratee(iterable[key], key, iterable) === false) {
                    break;
                  }
                }
                return object;
              };
            }
            function equalArrays(
              array,
              other,
              equalFunc,
              customizer,
              bitmask,
              stack
            ) {
              var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
                arrLength = array.length,
                othLength = other.length;
              if (
                arrLength != othLength &&
                !(isPartial && othLength > arrLength)
              ) {
                return false;
              }
              var stacked = stack.get(array);
              if (stacked && stack.get(other)) {
                return stacked == other;
              }
              var index = -1,
                result = true,
                seen =
                  bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : undefined;
              stack.set(array, other);
              stack.set(other, array);
              while (++index < arrLength) {
                var arrValue = array[index],
                  othValue = other[index];
                if (customizer) {
                  var compared = isPartial
                    ? customizer(othValue, arrValue, index, other, array, stack)
                    : customizer(
                        arrValue,
                        othValue,
                        index,
                        array,
                        other,
                        stack
                      );
                }
                if (compared !== undefined) {
                  if (compared) {
                    continue;
                  }
                  result = false;
                  break;
                }
                if (seen) {
                  if (
                    !arraySome(other, function(othValue, othIndex) {
                      if (
                        !seen.has(othIndex) &&
                        (arrValue === othValue ||
                          equalFunc(
                            arrValue,
                            othValue,
                            customizer,
                            bitmask,
                            stack
                          ))
                      ) {
                        return seen.add(othIndex);
                      }
                    })
                  ) {
                    result = false;
                    break;
                  }
                } else if (
                  !(
                    arrValue === othValue ||
                    equalFunc(arrValue, othValue, customizer, bitmask, stack)
                  )
                ) {
                  result = false;
                  break;
                }
              }
              stack['delete'](array);
              stack['delete'](other);
              return result;
            }
            function equalByTag(
              object,
              other,
              tag,
              equalFunc,
              customizer,
              bitmask,
              stack
            ) {
              switch (tag) {
                case dataViewTag:
                  if (
                    object.byteLength != other.byteLength ||
                    object.byteOffset != other.byteOffset
                  ) {
                    return false;
                  }
                  object = object.buffer;
                  other = other.buffer;
                case arrayBufferTag:
                  if (
                    object.byteLength != other.byteLength ||
                    !equalFunc(new Uint8Array(object), new Uint8Array(other))
                  ) {
                    return false;
                  }
                  return true;
                case boolTag:
                case dateTag:
                case numberTag:
                  return eq(+object, +other);
                case errorTag:
                  return (
                    object.name == other.name && object.message == other.message
                  );
                case regexpTag:
                case stringTag:
                  return object == other + '';
                case mapTag:
                  var convert = mapToArray;
                case setTag:
                  var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
                  convert || (convert = setToArray);
                  if (object.size != other.size && !isPartial) {
                    return false;
                  }
                  var stacked = stack.get(object);
                  if (stacked) {
                    return stacked == other;
                  }
                  bitmask |= UNORDERED_COMPARE_FLAG;
                  stack.set(object, other);
                  var result = equalArrays(
                    convert(object),
                    convert(other),
                    equalFunc,
                    customizer,
                    bitmask,
                    stack
                  );
                  stack['delete'](object);
                  return result;
                case symbolTag:
                  if (symbolValueOf) {
                    return (
                      symbolValueOf.call(object) == symbolValueOf.call(other)
                    );
                  }
              }
              return false;
            }
            function equalObjects(
              object,
              other,
              equalFunc,
              customizer,
              bitmask,
              stack
            ) {
              var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
                objProps = keys(object),
                objLength = objProps.length,
                othProps = keys(other),
                othLength = othProps.length;
              if (objLength != othLength && !isPartial) {
                return false;
              }
              var index = objLength;
              while (index--) {
                var key = objProps[index];
                if (
                  !(isPartial ? key in other : hasOwnProperty.call(other, key))
                ) {
                  return false;
                }
              }
              var stacked = stack.get(object);
              if (stacked && stack.get(other)) {
                return stacked == other;
              }
              var result = true;
              stack.set(object, other);
              stack.set(other, object);
              var skipCtor = isPartial;
              while (++index < objLength) {
                key = objProps[index];
                var objValue = object[key],
                  othValue = other[key];
                if (customizer) {
                  var compared = isPartial
                    ? customizer(othValue, objValue, key, other, object, stack)
                    : customizer(objValue, othValue, key, object, other, stack);
                }
                if (
                  !(compared === undefined
                    ? objValue === othValue ||
                      equalFunc(objValue, othValue, customizer, bitmask, stack)
                    : compared)
                ) {
                  result = false;
                  break;
                }
                skipCtor || (skipCtor = key == 'constructor');
              }
              if (result && !skipCtor) {
                var objCtor = object.constructor,
                  othCtor = other.constructor;
                if (
                  objCtor != othCtor &&
                  ('constructor' in object && 'constructor' in other) &&
                  !(
                    typeof objCtor == 'function' &&
                    objCtor instanceof objCtor &&
                    typeof othCtor == 'function' &&
                    othCtor instanceof othCtor
                  )
                ) {
                  result = false;
                }
              }
              stack['delete'](object);
              stack['delete'](other);
              return result;
            }
            function getMapData(map, key) {
              var data = map.__data__;
              return isKeyable(key)
                ? data[typeof key == 'string' ? 'string' : 'hash']
                : data.map;
            }
            function getMatchData(object) {
              var result = keys(object),
                length = result.length;
              while (length--) {
                var key = result[length],
                  value = object[key];
                result[length] = [key, value, isStrictComparable(value)];
              }
              return result;
            }
            function getNative(object, key) {
              var value = getValue(object, key);
              return baseIsNative(value) ? value : undefined;
            }
            var getTag = baseGetTag;
            if (
              (DataView &&
                getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
              (Map && getTag(new Map()) != mapTag) ||
              (Promise && getTag(Promise.resolve()) != promiseTag) ||
              (Set && getTag(new Set()) != setTag) ||
              (WeakMap && getTag(new WeakMap()) != weakMapTag)
            ) {
              getTag = function(value) {
                var result = objectToString.call(value),
                  Ctor = result == objectTag ? value.constructor : undefined,
                  ctorString = Ctor ? toSource(Ctor) : undefined;
                if (ctorString) {
                  switch (ctorString) {
                    case dataViewCtorString:
                      return dataViewTag;
                    case mapCtorString:
                      return mapTag;
                    case promiseCtorString:
                      return promiseTag;
                    case setCtorString:
                      return setTag;
                    case weakMapCtorString:
                      return weakMapTag;
                  }
                }
                return result;
              };
            }
            function hasPath(object, path, hasFunc) {
              path = isKey(path, object) ? [path] : castPath(path);
              var result,
                index = -1,
                length = path.length;
              while (++index < length) {
                var key = toKey(path[index]);
                if (!(result = object != null && hasFunc(object, key))) {
                  break;
                }
                object = object[key];
              }
              if (result) {
                return result;
              }
              var length = object ? object.length : 0;
              return (
                !!length &&
                isLength(length) &&
                isIndex(key, length) &&
                (isArray(object) || isArguments(object))
              );
            }
            function isIndex(value, length) {
              length = length == null ? MAX_SAFE_INTEGER : length;
              return (
                !!length &&
                (typeof value == 'number' || reIsUint.test(value)) &&
                (value > -1 && value % 1 == 0 && value < length)
              );
            }
            function isKey(value, object) {
              if (isArray(value)) {
                return false;
              }
              var type = typeof value;
              if (
                type == 'number' ||
                type == 'symbol' ||
                type == 'boolean' ||
                value == null ||
                isSymbol(value)
              ) {
                return true;
              }
              return (
                reIsPlainProp.test(value) ||
                !reIsDeepProp.test(value) ||
                (object != null && value in Object(object))
              );
            }
            function isKeyable(value) {
              var type = typeof value;
              return type == 'string' ||
                type == 'number' ||
                type == 'symbol' ||
                type == 'boolean'
                ? value !== '__proto__'
                : value === null;
            }
            function isMasked(func) {
              return !!maskSrcKey && maskSrcKey in func;
            }
            function isPrototype(value) {
              var Ctor = value && value.constructor,
                proto =
                  (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
              return value === proto;
            }
            function isStrictComparable(value) {
              return value === value && !isObject(value);
            }
            function matchesStrictComparable(key, srcValue) {
              return function(object) {
                if (object == null) {
                  return false;
                }
                return (
                  object[key] === srcValue &&
                  (srcValue !== undefined || key in Object(object))
                );
              };
            }
            var stringToPath = memoize(function(string) {
              string = toString(string);
              var result = [];
              if (reLeadingDot.test(string)) {
                result.push('');
              }
              string.replace(rePropName, function(
                match,
                number,
                quote,
                string
              ) {
                result.push(
                  quote ? string.replace(reEscapeChar, '$1') : number || match
                );
              });
              return result;
            });
            function toKey(value) {
              if (typeof value == 'string' || isSymbol(value)) {
                return value;
              }
              var result = value + '';
              return result == '0' && 1 / value == -INFINITY ? '-0' : result;
            }
            function toSource(func) {
              if (func != null) {
                try {
                  return funcToString.call(func);
                } catch (e) {}
                try {
                  return func + '';
                } catch (e) {}
              }
              return '';
            }
            function reject(collection, predicate) {
              var func = isArray(collection) ? arrayFilter : baseFilter;
              return func(collection, negate(baseIteratee(predicate, 3)));
            }
            function memoize(func, resolver) {
              if (
                typeof func != 'function' ||
                (resolver && typeof resolver != 'function')
              ) {
                throw new TypeError(FUNC_ERROR_TEXT);
              }
              var memoized = function() {
                var args = arguments,
                  key = resolver ? resolver.apply(this, args) : args[0],
                  cache = memoized.cache;
                if (cache.has(key)) {
                  return cache.get(key);
                }
                var result = func.apply(this, args);
                memoized.cache = cache.set(key, result);
                return result;
              };
              memoized.cache = new (memoize.Cache || MapCache)();
              return memoized;
            }
            memoize.Cache = MapCache;
            function negate(predicate) {
              if (typeof predicate != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
              }
              return function() {
                var args = arguments;
                switch (args.length) {
                  case 0:
                    return !predicate.call(this);
                  case 1:
                    return !predicate.call(this, args[0]);
                  case 2:
                    return !predicate.call(this, args[0], args[1]);
                  case 3:
                    return !predicate.call(this, args[0], args[1], args[2]);
                }
                return !predicate.apply(this, args);
              };
            }
            function eq(value, other) {
              return value === other || (value !== value && other !== other);
            }
            function isArguments(value) {
              return (
                isArrayLikeObject(value) &&
                hasOwnProperty.call(value, 'callee') &&
                (!propertyIsEnumerable.call(value, 'callee') ||
                  objectToString.call(value) == argsTag)
              );
            }
            var isArray = Array.isArray;
            function isArrayLike(value) {
              return (
                value != null && isLength(value.length) && !isFunction(value)
              );
            }
            function isArrayLikeObject(value) {
              return isObjectLike(value) && isArrayLike(value);
            }
            function isFunction(value) {
              var tag = isObject(value) ? objectToString.call(value) : '';
              return tag == funcTag || tag == genTag;
            }
            function isLength(value) {
              return (
                typeof value == 'number' &&
                value > -1 &&
                value % 1 == 0 &&
                value <= MAX_SAFE_INTEGER
              );
            }
            function isObject(value) {
              var type = typeof value;
              return !!value && (type == 'object' || type == 'function');
            }
            function isObjectLike(value) {
              return !!value && typeof value == 'object';
            }
            function isSymbol(value) {
              return (
                typeof value == 'symbol' ||
                (isObjectLike(value) && objectToString.call(value) == symbolTag)
              );
            }
            var isTypedArray = nodeIsTypedArray
              ? baseUnary(nodeIsTypedArray)
              : baseIsTypedArray;
            function toString(value) {
              return value == null ? '' : baseToString(value);
            }
            function get(object, path, defaultValue) {
              var result = object == null ? undefined : baseGet(object, path);
              return result === undefined ? defaultValue : result;
            }
            function hasIn(object, path) {
              return object != null && hasPath(object, path, baseHasIn);
            }
            function keys(object) {
              return isArrayLike(object)
                ? arrayLikeKeys(object)
                : baseKeys(object);
            }
            function identity(value) {
              return value;
            }
            function property(path) {
              return isKey(path)
                ? baseProperty(toKey(path))
                : basePropertyDeep(path);
            }
            module.exports = reject;
          }.call(
            this,
            typeof global !== 'undefined'
              ? global
              : typeof self !== 'undefined'
              ? self
              : typeof window !== 'undefined'
              ? window
              : {}
          ));
        },
        {}
      ],
      436: [
        function(require, module, exports) {
          (function(global) {
            var LARGE_ARRAY_SIZE = 200;
            var FUNC_ERROR_TEXT = 'Expected a function';
            var HASH_UNDEFINED = '__lodash_hash_undefined__';
            var UNORDERED_COMPARE_FLAG = 1,
              PARTIAL_COMPARE_FLAG = 2;
            var INFINITY = 1 / 0,
              MAX_SAFE_INTEGER = 9007199254740991;
            var argsTag = '[object Arguments]',
              arrayTag = '[object Array]',
              boolTag = '[object Boolean]',
              dateTag = '[object Date]',
              errorTag = '[object Error]',
              funcTag = '[object Function]',
              genTag = '[object GeneratorFunction]',
              mapTag = '[object Map]',
              numberTag = '[object Number]',
              objectTag = '[object Object]',
              promiseTag = '[object Promise]',
              regexpTag = '[object RegExp]',
              setTag = '[object Set]',
              stringTag = '[object String]',
              symbolTag = '[object Symbol]',
              weakMapTag = '[object WeakMap]';
            var arrayBufferTag = '[object ArrayBuffer]',
              dataViewTag = '[object DataView]',
              float32Tag = '[object Float32Array]',
              float64Tag = '[object Float64Array]',
              int8Tag = '[object Int8Array]',
              int16Tag = '[object Int16Array]',
              int32Tag = '[object Int32Array]',
              uint8Tag = '[object Uint8Array]',
              uint8ClampedTag = '[object Uint8ClampedArray]',
              uint16Tag = '[object Uint16Array]',
              uint32Tag = '[object Uint32Array]';
            var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
              reIsPlainProp = /^\w*$/,
              reLeadingDot = /^\./,
              rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
            var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
            var reEscapeChar = /\\(\\)?/g;
            var reIsHostCtor = /^\[object .+?Constructor\]$/;
            var reIsUint = /^(?:0|[1-9]\d*)$/;
            var typedArrayTags = {};
            typedArrayTags[float32Tag] = typedArrayTags[
              float64Tag
            ] = typedArrayTags[int8Tag] = typedArrayTags[
              int16Tag
            ] = typedArrayTags[int32Tag] = typedArrayTags[
              uint8Tag
            ] = typedArrayTags[uint8ClampedTag] = typedArrayTags[
              uint16Tag
            ] = typedArrayTags[uint32Tag] = true;
            typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[
              arrayBufferTag
            ] = typedArrayTags[boolTag] = typedArrayTags[
              dataViewTag
            ] = typedArrayTags[dateTag] = typedArrayTags[
              errorTag
            ] = typedArrayTags[funcTag] = typedArrayTags[
              mapTag
            ] = typedArrayTags[numberTag] = typedArrayTags[
              objectTag
            ] = typedArrayTags[regexpTag] = typedArrayTags[
              setTag
            ] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
            var freeGlobal =
              typeof global == 'object' &&
              global &&
              global.Object === Object &&
              global;
            var freeSelf =
              typeof self == 'object' && self && self.Object === Object && self;
            var root = freeGlobal || freeSelf || Function('return this')();
            var freeExports =
              typeof exports == 'object' &&
              exports &&
              !exports.nodeType &&
              exports;
            var freeModule =
              freeExports &&
              typeof module == 'object' &&
              module &&
              !module.nodeType &&
              module;
            var moduleExports =
              freeModule && freeModule.exports === freeExports;
            var freeProcess = moduleExports && freeGlobal.process;
            var nodeUtil = (function() {
              try {
                return freeProcess && freeProcess.binding('util');
              } catch (e) {}
            })();
            var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
            function arraySome(array, predicate) {
              var index = -1,
                length = array ? array.length : 0;
              while (++index < length) {
                if (predicate(array[index], index, array)) {
                  return true;
                }
              }
              return false;
            }
            function baseProperty(key) {
              return function(object) {
                return object == null ? undefined : object[key];
              };
            }
            function baseTimes(n, iteratee) {
              var index = -1,
                result = Array(n);
              while (++index < n) {
                result[index] = iteratee(index);
              }
              return result;
            }
            function baseUnary(func) {
              return function(value) {
                return func(value);
              };
            }
            function getValue(object, key) {
              return object == null ? undefined : object[key];
            }
            function isHostObject(value) {
              var result = false;
              if (value != null && typeof value.toString != 'function') {
                try {
                  result = !!(value + '');
                } catch (e) {}
              }
              return result;
            }
            function mapToArray(map) {
              var index = -1,
                result = Array(map.size);
              map.forEach(function(value, key) {
                result[++index] = [key, value];
              });
              return result;
            }
            function overArg(func, transform) {
              return function(arg) {
                return func(transform(arg));
              };
            }
            function setToArray(set) {
              var index = -1,
                result = Array(set.size);
              set.forEach(function(value) {
                result[++index] = value;
              });
              return result;
            }
            var arrayProto = Array.prototype,
              funcProto = Function.prototype,
              objectProto = Object.prototype;
            var coreJsData = root['__core-js_shared__'];
            var maskSrcKey = (function() {
              var uid = /[^.]+$/.exec(
                (coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO) ||
                  ''
              );
              return uid ? 'Symbol(src)_1.' + uid : '';
            })();
            var funcToString = funcProto.toString;
            var hasOwnProperty = objectProto.hasOwnProperty;
            var objectToString = objectProto.toString;
            var reIsNative = RegExp(
              '^' +
                funcToString
                  .call(hasOwnProperty)
                  .replace(reRegExpChar, '\\$&')
                  .replace(
                    /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                    '$1.*?'
                  ) +
                '$'
            );
            var Symbol = root.Symbol,
              Uint8Array = root.Uint8Array,
              propertyIsEnumerable = objectProto.propertyIsEnumerable,
              splice = arrayProto.splice;
            var nativeKeys = overArg(Object.keys, Object);
            var DataView = getNative(root, 'DataView'),
              Map = getNative(root, 'Map'),
              Promise = getNative(root, 'Promise'),
              Set = getNative(root, 'Set'),
              WeakMap = getNative(root, 'WeakMap'),
              nativeCreate = getNative(Object, 'create');
            var dataViewCtorString = toSource(DataView),
              mapCtorString = toSource(Map),
              promiseCtorString = toSource(Promise),
              setCtorString = toSource(Set),
              weakMapCtorString = toSource(WeakMap);
            var symbolProto = Symbol ? Symbol.prototype : undefined,
              symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
              symbolToString = symbolProto ? symbolProto.toString : undefined;
            function Hash(entries) {
              var index = -1,
                length = entries ? entries.length : 0;
              this.clear();
              while (++index < length) {
                var entry = entries[index];
                this.set(entry[0], entry[1]);
              }
            }
            function hashClear() {
              this.__data__ = nativeCreate ? nativeCreate(null) : {};
            }
            function hashDelete(key) {
              return this.has(key) && delete this.__data__[key];
            }
            function hashGet(key) {
              var data = this.__data__;
              if (nativeCreate) {
                var result = data[key];
                return result === HASH_UNDEFINED ? undefined : result;
              }
              return hasOwnProperty.call(data, key) ? data[key] : undefined;
            }
            function hashHas(key) {
              var data = this.__data__;
              return nativeCreate
                ? data[key] !== undefined
                : hasOwnProperty.call(data, key);
            }
            function hashSet(key, value) {
              var data = this.__data__;
              data[key] =
                nativeCreate && value === undefined ? HASH_UNDEFINED : value;
              return this;
            }
            Hash.prototype.clear = hashClear;
            Hash.prototype['delete'] = hashDelete;
            Hash.prototype.get = hashGet;
            Hash.prototype.has = hashHas;
            Hash.prototype.set = hashSet;
            function ListCache(entries) {
              var index = -1,
                length = entries ? entries.length : 0;
              this.clear();
              while (++index < length) {
                var entry = entries[index];
                this.set(entry[0], entry[1]);
              }
            }
            function listCacheClear() {
              this.__data__ = [];
            }
            function listCacheDelete(key) {
              var data = this.__data__,
                index = assocIndexOf(data, key);
              if (index < 0) {
                return false;
              }
              var lastIndex = data.length - 1;
              if (index == lastIndex) {
                data.pop();
              } else {
                splice.call(data, index, 1);
              }
              return true;
            }
            function listCacheGet(key) {
              var data = this.__data__,
                index = assocIndexOf(data, key);
              return index < 0 ? undefined : data[index][1];
            }
            function listCacheHas(key) {
              return assocIndexOf(this.__data__, key) > -1;
            }
            function listCacheSet(key, value) {
              var data = this.__data__,
                index = assocIndexOf(data, key);
              if (index < 0) {
                data.push([key, value]);
              } else {
                data[index][1] = value;
              }
              return this;
            }
            ListCache.prototype.clear = listCacheClear;
            ListCache.prototype['delete'] = listCacheDelete;
            ListCache.prototype.get = listCacheGet;
            ListCache.prototype.has = listCacheHas;
            ListCache.prototype.set = listCacheSet;
            function MapCache(entries) {
              var index = -1,
                length = entries ? entries.length : 0;
              this.clear();
              while (++index < length) {
                var entry = entries[index];
                this.set(entry[0], entry[1]);
              }
            }
            function mapCacheClear() {
              this.__data__ = {
                hash: new Hash(),
                map: new (Map || ListCache)(),
                string: new Hash()
              };
            }
            function mapCacheDelete(key) {
              return getMapData(this, key)['delete'](key);
            }
            function mapCacheGet(key) {
              return getMapData(this, key).get(key);
            }
            function mapCacheHas(key) {
              return getMapData(this, key).has(key);
            }
            function mapCacheSet(key, value) {
              getMapData(this, key).set(key, value);
              return this;
            }
            MapCache.prototype.clear = mapCacheClear;
            MapCache.prototype['delete'] = mapCacheDelete;
            MapCache.prototype.get = mapCacheGet;
            MapCache.prototype.has = mapCacheHas;
            MapCache.prototype.set = mapCacheSet;
            function SetCache(values) {
              var index = -1,
                length = values ? values.length : 0;
              this.__data__ = new MapCache();
              while (++index < length) {
                this.add(values[index]);
              }
            }
            function setCacheAdd(value) {
              this.__data__.set(value, HASH_UNDEFINED);
              return this;
            }
            function setCacheHas(value) {
              return this.__data__.has(value);
            }
            SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
            SetCache.prototype.has = setCacheHas;
            function Stack(entries) {
              this.__data__ = new ListCache(entries);
            }
            function stackClear() {
              this.__data__ = new ListCache();
            }
            function stackDelete(key) {
              return this.__data__['delete'](key);
            }
            function stackGet(key) {
              return this.__data__.get(key);
            }
            function stackHas(key) {
              return this.__data__.has(key);
            }
            function stackSet(key, value) {
              var cache = this.__data__;
              if (cache instanceof ListCache) {
                var pairs = cache.__data__;
                if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
                  pairs.push([key, value]);
                  return this;
                }
                cache = this.__data__ = new MapCache(pairs);
              }
              cache.set(key, value);
              return this;
            }
            Stack.prototype.clear = stackClear;
            Stack.prototype['delete'] = stackDelete;
            Stack.prototype.get = stackGet;
            Stack.prototype.has = stackHas;
            Stack.prototype.set = stackSet;
            function arrayLikeKeys(value, inherited) {
              var result =
                isArray(value) || isArguments(value)
                  ? baseTimes(value.length, String)
                  : [];
              var length = result.length,
                skipIndexes = !!length;
              for (var key in value) {
                if (
                  (inherited || hasOwnProperty.call(value, key)) &&
                  !(skipIndexes && (key == 'length' || isIndex(key, length)))
                ) {
                  result.push(key);
                }
              }
              return result;
            }
            function assocIndexOf(array, key) {
              var length = array.length;
              while (length--) {
                if (eq(array[length][0], key)) {
                  return length;
                }
              }
              return -1;
            }
            var baseEach = createBaseEach(baseForOwn);
            var baseFor = createBaseFor();
            function baseForOwn(object, iteratee) {
              return object && baseFor(object, iteratee, keys);
            }
            function baseGet(object, path) {
              path = isKey(path, object) ? [path] : castPath(path);
              var index = 0,
                length = path.length;
              while (object != null && index < length) {
                object = object[toKey(path[index++])];
              }
              return index && index == length ? object : undefined;
            }
            function baseGetTag(value) {
              return objectToString.call(value);
            }
            function baseHasIn(object, key) {
              return object != null && key in Object(object);
            }
            function baseIsEqual(value, other, customizer, bitmask, stack) {
              if (value === other) {
                return true;
              }
              if (
                value == null ||
                other == null ||
                (!isObject(value) && !isObjectLike(other))
              ) {
                return value !== value && other !== other;
              }
              return baseIsEqualDeep(
                value,
                other,
                baseIsEqual,
                customizer,
                bitmask,
                stack
              );
            }
            function baseIsEqualDeep(
              object,
              other,
              equalFunc,
              customizer,
              bitmask,
              stack
            ) {
              var objIsArr = isArray(object),
                othIsArr = isArray(other),
                objTag = arrayTag,
                othTag = arrayTag;
              if (!objIsArr) {
                objTag = getTag(object);
                objTag = objTag == argsTag ? objectTag : objTag;
              }
              if (!othIsArr) {
                othTag = getTag(other);
                othTag = othTag == argsTag ? objectTag : othTag;
              }
              var objIsObj = objTag == objectTag && !isHostObject(object),
                othIsObj = othTag == objectTag && !isHostObject(other),
                isSameTag = objTag == othTag;
              if (isSameTag && !objIsObj) {
                stack || (stack = new Stack());
                return objIsArr || isTypedArray(object)
                  ? equalArrays(
                      object,
                      other,
                      equalFunc,
                      customizer,
                      bitmask,
                      stack
                    )
                  : equalByTag(
                      object,
                      other,
                      objTag,
                      equalFunc,
                      customizer,
                      bitmask,
                      stack
                    );
              }
              if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
                var objIsWrapped =
                    objIsObj && hasOwnProperty.call(object, '__wrapped__'),
                  othIsWrapped =
                    othIsObj && hasOwnProperty.call(other, '__wrapped__');
                if (objIsWrapped || othIsWrapped) {
                  var objUnwrapped = objIsWrapped ? object.value() : object,
                    othUnwrapped = othIsWrapped ? other.value() : other;
                  stack || (stack = new Stack());
                  return equalFunc(
                    objUnwrapped,
                    othUnwrapped,
                    customizer,
                    bitmask,
                    stack
                  );
                }
              }
              if (!isSameTag) {
                return false;
              }
              stack || (stack = new Stack());
              return equalObjects(
                object,
                other,
                equalFunc,
                customizer,
                bitmask,
                stack
              );
            }
            function baseIsMatch(object, source, matchData, customizer) {
              var index = matchData.length,
                length = index,
                noCustomizer = !customizer;
              if (object == null) {
                return !length;
              }
              object = Object(object);
              while (index--) {
                var data = matchData[index];
                if (
                  noCustomizer && data[2]
                    ? data[1] !== object[data[0]]
                    : !(data[0] in object)
                ) {
                  return false;
                }
              }
              while (++index < length) {
                data = matchData[index];
                var key = data[0],
                  objValue = object[key],
                  srcValue = data[1];
                if (noCustomizer && data[2]) {
                  if (objValue === undefined && !(key in object)) {
                    return false;
                  }
                } else {
                  var stack = new Stack();
                  if (customizer) {
                    var result = customizer(
                      objValue,
                      srcValue,
                      key,
                      object,
                      source,
                      stack
                    );
                  }
                  if (
                    !(result === undefined
                      ? baseIsEqual(
                          srcValue,
                          objValue,
                          customizer,
                          UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG,
                          stack
                        )
                      : result)
                  ) {
                    return false;
                  }
                }
              }
              return true;
            }
            function baseIsNative(value) {
              if (!isObject(value) || isMasked(value)) {
                return false;
              }
              var pattern =
                isFunction(value) || isHostObject(value)
                  ? reIsNative
                  : reIsHostCtor;
              return pattern.test(toSource(value));
            }
            function baseIsTypedArray(value) {
              return (
                isObjectLike(value) &&
                isLength(value.length) &&
                !!typedArrayTags[objectToString.call(value)]
              );
            }
            function baseIteratee(value) {
              if (typeof value == 'function') {
                return value;
              }
              if (value == null) {
                return identity;
              }
              if (typeof value == 'object') {
                return isArray(value)
                  ? baseMatchesProperty(value[0], value[1])
                  : baseMatches(value);
              }
              return property(value);
            }
            function baseKeys(object) {
              if (!isPrototype(object)) {
                return nativeKeys(object);
              }
              var result = [];
              for (var key in Object(object)) {
                if (hasOwnProperty.call(object, key) && key != 'constructor') {
                  result.push(key);
                }
              }
              return result;
            }
            function baseMatches(source) {
              var matchData = getMatchData(source);
              if (matchData.length == 1 && matchData[0][2]) {
                return matchesStrictComparable(
                  matchData[0][0],
                  matchData[0][1]
                );
              }
              return function(object) {
                return (
                  object === source || baseIsMatch(object, source, matchData)
                );
              };
            }
            function baseMatchesProperty(path, srcValue) {
              if (isKey(path) && isStrictComparable(srcValue)) {
                return matchesStrictComparable(toKey(path), srcValue);
              }
              return function(object) {
                var objValue = get(object, path);
                return objValue === undefined && objValue === srcValue
                  ? hasIn(object, path)
                  : baseIsEqual(
                      srcValue,
                      objValue,
                      undefined,
                      UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG
                    );
              };
            }
            function basePropertyDeep(path) {
              return function(object) {
                return baseGet(object, path);
              };
            }
            function baseSome(collection, predicate) {
              var result;
              baseEach(collection, function(value, index, collection) {
                result = predicate(value, index, collection);
                return !result;
              });
              return !!result;
            }
            function baseToString(value) {
              if (typeof value == 'string') {
                return value;
              }
              if (isSymbol(value)) {
                return symbolToString ? symbolToString.call(value) : '';
              }
              var result = value + '';
              return result == '0' && 1 / value == -INFINITY ? '-0' : result;
            }
            function castPath(value) {
              return isArray(value) ? value : stringToPath(value);
            }
            function createBaseEach(eachFunc, fromRight) {
              return function(collection, iteratee) {
                if (collection == null) {
                  return collection;
                }
                if (!isArrayLike(collection)) {
                  return eachFunc(collection, iteratee);
                }
                var length = collection.length,
                  index = fromRight ? length : -1,
                  iterable = Object(collection);
                while (fromRight ? index-- : ++index < length) {
                  if (iteratee(iterable[index], index, iterable) === false) {
                    break;
                  }
                }
                return collection;
              };
            }
            function createBaseFor(fromRight) {
              return function(object, iteratee, keysFunc) {
                var index = -1,
                  iterable = Object(object),
                  props = keysFunc(object),
                  length = props.length;
                while (length--) {
                  var key = props[fromRight ? length : ++index];
                  if (iteratee(iterable[key], key, iterable) === false) {
                    break;
                  }
                }
                return object;
              };
            }
            function equalArrays(
              array,
              other,
              equalFunc,
              customizer,
              bitmask,
              stack
            ) {
              var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
                arrLength = array.length,
                othLength = other.length;
              if (
                arrLength != othLength &&
                !(isPartial && othLength > arrLength)
              ) {
                return false;
              }
              var stacked = stack.get(array);
              if (stacked && stack.get(other)) {
                return stacked == other;
              }
              var index = -1,
                result = true,
                seen =
                  bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : undefined;
              stack.set(array, other);
              stack.set(other, array);
              while (++index < arrLength) {
                var arrValue = array[index],
                  othValue = other[index];
                if (customizer) {
                  var compared = isPartial
                    ? customizer(othValue, arrValue, index, other, array, stack)
                    : customizer(
                        arrValue,
                        othValue,
                        index,
                        array,
                        other,
                        stack
                      );
                }
                if (compared !== undefined) {
                  if (compared) {
                    continue;
                  }
                  result = false;
                  break;
                }
                if (seen) {
                  if (
                    !arraySome(other, function(othValue, othIndex) {
                      if (
                        !seen.has(othIndex) &&
                        (arrValue === othValue ||
                          equalFunc(
                            arrValue,
                            othValue,
                            customizer,
                            bitmask,
                            stack
                          ))
                      ) {
                        return seen.add(othIndex);
                      }
                    })
                  ) {
                    result = false;
                    break;
                  }
                } else if (
                  !(
                    arrValue === othValue ||
                    equalFunc(arrValue, othValue, customizer, bitmask, stack)
                  )
                ) {
                  result = false;
                  break;
                }
              }
              stack['delete'](array);
              stack['delete'](other);
              return result;
            }
            function equalByTag(
              object,
              other,
              tag,
              equalFunc,
              customizer,
              bitmask,
              stack
            ) {
              switch (tag) {
                case dataViewTag:
                  if (
                    object.byteLength != other.byteLength ||
                    object.byteOffset != other.byteOffset
                  ) {
                    return false;
                  }
                  object = object.buffer;
                  other = other.buffer;
                case arrayBufferTag:
                  if (
                    object.byteLength != other.byteLength ||
                    !equalFunc(new Uint8Array(object), new Uint8Array(other))
                  ) {
                    return false;
                  }
                  return true;
                case boolTag:
                case dateTag:
                case numberTag:
                  return eq(+object, +other);
                case errorTag:
                  return (
                    object.name == other.name && object.message == other.message
                  );
                case regexpTag:
                case stringTag:
                  return object == other + '';
                case mapTag:
                  var convert = mapToArray;
                case setTag:
                  var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
                  convert || (convert = setToArray);
                  if (object.size != other.size && !isPartial) {
                    return false;
                  }
                  var stacked = stack.get(object);
                  if (stacked) {
                    return stacked == other;
                  }
                  bitmask |= UNORDERED_COMPARE_FLAG;
                  stack.set(object, other);
                  var result = equalArrays(
                    convert(object),
                    convert(other),
                    equalFunc,
                    customizer,
                    bitmask,
                    stack
                  );
                  stack['delete'](object);
                  return result;
                case symbolTag:
                  if (symbolValueOf) {
                    return (
                      symbolValueOf.call(object) == symbolValueOf.call(other)
                    );
                  }
              }
              return false;
            }
            function equalObjects(
              object,
              other,
              equalFunc,
              customizer,
              bitmask,
              stack
            ) {
              var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
                objProps = keys(object),
                objLength = objProps.length,
                othProps = keys(other),
                othLength = othProps.length;
              if (objLength != othLength && !isPartial) {
                return false;
              }
              var index = objLength;
              while (index--) {
                var key = objProps[index];
                if (
                  !(isPartial ? key in other : hasOwnProperty.call(other, key))
                ) {
                  return false;
                }
              }
              var stacked = stack.get(object);
              if (stacked && stack.get(other)) {
                return stacked == other;
              }
              var result = true;
              stack.set(object, other);
              stack.set(other, object);
              var skipCtor = isPartial;
              while (++index < objLength) {
                key = objProps[index];
                var objValue = object[key],
                  othValue = other[key];
                if (customizer) {
                  var compared = isPartial
                    ? customizer(othValue, objValue, key, other, object, stack)
                    : customizer(objValue, othValue, key, object, other, stack);
                }
                if (
                  !(compared === undefined
                    ? objValue === othValue ||
                      equalFunc(objValue, othValue, customizer, bitmask, stack)
                    : compared)
                ) {
                  result = false;
                  break;
                }
                skipCtor || (skipCtor = key == 'constructor');
              }
              if (result && !skipCtor) {
                var objCtor = object.constructor,
                  othCtor = other.constructor;
                if (
                  objCtor != othCtor &&
                  ('constructor' in object && 'constructor' in other) &&
                  !(
                    typeof objCtor == 'function' &&
                    objCtor instanceof objCtor &&
                    typeof othCtor == 'function' &&
                    othCtor instanceof othCtor
                  )
                ) {
                  result = false;
                }
              }
              stack['delete'](object);
              stack['delete'](other);
              return result;
            }
            function getMapData(map, key) {
              var data = map.__data__;
              return isKeyable(key)
                ? data[typeof key == 'string' ? 'string' : 'hash']
                : data.map;
            }
            function getMatchData(object) {
              var result = keys(object),
                length = result.length;
              while (length--) {
                var key = result[length],
                  value = object[key];
                result[length] = [key, value, isStrictComparable(value)];
              }
              return result;
            }
            function getNative(object, key) {
              var value = getValue(object, key);
              return baseIsNative(value) ? value : undefined;
            }
            var getTag = baseGetTag;
            if (
              (DataView &&
                getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
              (Map && getTag(new Map()) != mapTag) ||
              (Promise && getTag(Promise.resolve()) != promiseTag) ||
              (Set && getTag(new Set()) != setTag) ||
              (WeakMap && getTag(new WeakMap()) != weakMapTag)
            ) {
              getTag = function(value) {
                var result = objectToString.call(value),
                  Ctor = result == objectTag ? value.constructor : undefined,
                  ctorString = Ctor ? toSource(Ctor) : undefined;
                if (ctorString) {
                  switch (ctorString) {
                    case dataViewCtorString:
                      return dataViewTag;
                    case mapCtorString:
                      return mapTag;
                    case promiseCtorString:
                      return promiseTag;
                    case setCtorString:
                      return setTag;
                    case weakMapCtorString:
                      return weakMapTag;
                  }
                }
                return result;
              };
            }
            function hasPath(object, path, hasFunc) {
              path = isKey(path, object) ? [path] : castPath(path);
              var result,
                index = -1,
                length = path.length;
              while (++index < length) {
                var key = toKey(path[index]);
                if (!(result = object != null && hasFunc(object, key))) {
                  break;
                }
                object = object[key];
              }
              if (result) {
                return result;
              }
              var length = object ? object.length : 0;
              return (
                !!length &&
                isLength(length) &&
                isIndex(key, length) &&
                (isArray(object) || isArguments(object))
              );
            }
            function isIndex(value, length) {
              length = length == null ? MAX_SAFE_INTEGER : length;
              return (
                !!length &&
                (typeof value == 'number' || reIsUint.test(value)) &&
                (value > -1 && value % 1 == 0 && value < length)
              );
            }
            function isIterateeCall(value, index, object) {
              if (!isObject(object)) {
                return false;
              }
              var type = typeof index;
              if (
                type == 'number'
                  ? isArrayLike(object) && isIndex(index, object.length)
                  : type == 'string' && index in object
              ) {
                return eq(object[index], value);
              }
              return false;
            }
            function isKey(value, object) {
              if (isArray(value)) {
                return false;
              }
              var type = typeof value;
              if (
                type == 'number' ||
                type == 'symbol' ||
                type == 'boolean' ||
                value == null ||
                isSymbol(value)
              ) {
                return true;
              }
              return (
                reIsPlainProp.test(value) ||
                !reIsDeepProp.test(value) ||
                (object != null && value in Object(object))
              );
            }
            function isKeyable(value) {
              var type = typeof value;
              return type == 'string' ||
                type == 'number' ||
                type == 'symbol' ||
                type == 'boolean'
                ? value !== '__proto__'
                : value === null;
            }
            function isMasked(func) {
              return !!maskSrcKey && maskSrcKey in func;
            }
            function isPrototype(value) {
              var Ctor = value && value.constructor,
                proto =
                  (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
              return value === proto;
            }
            function isStrictComparable(value) {
              return value === value && !isObject(value);
            }
            function matchesStrictComparable(key, srcValue) {
              return function(object) {
                if (object == null) {
                  return false;
                }
                return (
                  object[key] === srcValue &&
                  (srcValue !== undefined || key in Object(object))
                );
              };
            }
            var stringToPath = memoize(function(string) {
              string = toString(string);
              var result = [];
              if (reLeadingDot.test(string)) {
                result.push('');
              }
              string.replace(rePropName, function(
                match,
                number,
                quote,
                string
              ) {
                result.push(
                  quote ? string.replace(reEscapeChar, '$1') : number || match
                );
              });
              return result;
            });
            function toKey(value) {
              if (typeof value == 'string' || isSymbol(value)) {
                return value;
              }
              var result = value + '';
              return result == '0' && 1 / value == -INFINITY ? '-0' : result;
            }
            function toSource(func) {
              if (func != null) {
                try {
                  return funcToString.call(func);
                } catch (e) {}
                try {
                  return func + '';
                } catch (e) {}
              }
              return '';
            }
            function some(collection, predicate, guard) {
              var func = isArray(collection) ? arraySome : baseSome;
              if (guard && isIterateeCall(collection, predicate, guard)) {
                predicate = undefined;
              }
              return func(collection, baseIteratee(predicate, 3));
            }
            function memoize(func, resolver) {
              if (
                typeof func != 'function' ||
                (resolver && typeof resolver != 'function')
              ) {
                throw new TypeError(FUNC_ERROR_TEXT);
              }
              var memoized = function() {
                var args = arguments,
                  key = resolver ? resolver.apply(this, args) : args[0],
                  cache = memoized.cache;
                if (cache.has(key)) {
                  return cache.get(key);
                }
                var result = func.apply(this, args);
                memoized.cache = cache.set(key, result);
                return result;
              };
              memoized.cache = new (memoize.Cache || MapCache)();
              return memoized;
            }
            memoize.Cache = MapCache;
            function eq(value, other) {
              return value === other || (value !== value && other !== other);
            }
            function isArguments(value) {
              return (
                isArrayLikeObject(value) &&
                hasOwnProperty.call(value, 'callee') &&
                (!propertyIsEnumerable.call(value, 'callee') ||
                  objectToString.call(value) == argsTag)
              );
            }
            var isArray = Array.isArray;
            function isArrayLike(value) {
              return (
                value != null && isLength(value.length) && !isFunction(value)
              );
            }
            function isArrayLikeObject(value) {
              return isObjectLike(value) && isArrayLike(value);
            }
            function isFunction(value) {
              var tag = isObject(value) ? objectToString.call(value) : '';
              return tag == funcTag || tag == genTag;
            }
            function isLength(value) {
              return (
                typeof value == 'number' &&
                value > -1 &&
                value % 1 == 0 &&
                value <= MAX_SAFE_INTEGER
              );
            }
            function isObject(value) {
              var type = typeof value;
              return !!value && (type == 'object' || type == 'function');
            }
            function isObjectLike(value) {
              return !!value && typeof value == 'object';
            }
            function isSymbol(value) {
              return (
                typeof value == 'symbol' ||
                (isObjectLike(value) && objectToString.call(value) == symbolTag)
              );
            }
            var isTypedArray = nodeIsTypedArray
              ? baseUnary(nodeIsTypedArray)
              : baseIsTypedArray;
            function toString(value) {
              return value == null ? '' : baseToString(value);
            }
            function get(object, path, defaultValue) {
              var result = object == null ? undefined : baseGet(object, path);
              return result === undefined ? defaultValue : result;
            }
            function hasIn(object, path) {
              return object != null && hasPath(object, path, baseHasIn);
            }
            function keys(object) {
              return isArrayLike(object)
                ? arrayLikeKeys(object)
                : baseKeys(object);
            }
            function identity(value) {
              return value;
            }
            function property(path) {
              return isKey(path)
                ? baseProperty(toKey(path))
                : basePropertyDeep(path);
            }
            module.exports = some;
          }.call(
            this,
            typeof global !== 'undefined'
              ? global
              : typeof self !== 'undefined'
              ? self
              : typeof window !== 'undefined'
              ? window
              : {}
          ));
        },
        {}
      ],
      437: [
        function(require, module, exports) {
          (function(Buffer) {
            'use strict';
            var inherits = require('inherits');
            var HashBase = require('hash-base');
            var ARRAY16 = new Array(16);
            function MD5() {
              HashBase.call(this, 64);
              this._a = 1732584193;
              this._b = 4023233417;
              this._c = 2562383102;
              this._d = 271733878;
            }
            inherits(MD5, HashBase);
            MD5.prototype._update = function() {
              var M = ARRAY16;
              for (var i = 0; i < 16; ++i)
                M[i] = this._block.readInt32LE(i * 4);
              var a = this._a;
              var b = this._b;
              var c = this._c;
              var d = this._d;
              a = fnF(a, b, c, d, M[0], 3614090360, 7);
              d = fnF(d, a, b, c, M[1], 3905402710, 12);
              c = fnF(c, d, a, b, M[2], 606105819, 17);
              b = fnF(b, c, d, a, M[3], 3250441966, 22);
              a = fnF(a, b, c, d, M[4], 4118548399, 7);
              d = fnF(d, a, b, c, M[5], 1200080426, 12);
              c = fnF(c, d, a, b, M[6], 2821735955, 17);
              b = fnF(b, c, d, a, M[7], 4249261313, 22);
              a = fnF(a, b, c, d, M[8], 1770035416, 7);
              d = fnF(d, a, b, c, M[9], 2336552879, 12);
              c = fnF(c, d, a, b, M[10], 4294925233, 17);
              b = fnF(b, c, d, a, M[11], 2304563134, 22);
              a = fnF(a, b, c, d, M[12], 1804603682, 7);
              d = fnF(d, a, b, c, M[13], 4254626195, 12);
              c = fnF(c, d, a, b, M[14], 2792965006, 17);
              b = fnF(b, c, d, a, M[15], 1236535329, 22);
              a = fnG(a, b, c, d, M[1], 4129170786, 5);
              d = fnG(d, a, b, c, M[6], 3225465664, 9);
              c = fnG(c, d, a, b, M[11], 643717713, 14);
              b = fnG(b, c, d, a, M[0], 3921069994, 20);
              a = fnG(a, b, c, d, M[5], 3593408605, 5);
              d = fnG(d, a, b, c, M[10], 38016083, 9);
              c = fnG(c, d, a, b, M[15], 3634488961, 14);
              b = fnG(b, c, d, a, M[4], 3889429448, 20);
              a = fnG(a, b, c, d, M[9], 568446438, 5);
              d = fnG(d, a, b, c, M[14], 3275163606, 9);
              c = fnG(c, d, a, b, M[3], 4107603335, 14);
              b = fnG(b, c, d, a, M[8], 1163531501, 20);
              a = fnG(a, b, c, d, M[13], 2850285829, 5);
              d = fnG(d, a, b, c, M[2], 4243563512, 9);
              c = fnG(c, d, a, b, M[7], 1735328473, 14);
              b = fnG(b, c, d, a, M[12], 2368359562, 20);
              a = fnH(a, b, c, d, M[5], 4294588738, 4);
              d = fnH(d, a, b, c, M[8], 2272392833, 11);
              c = fnH(c, d, a, b, M[11], 1839030562, 16);
              b = fnH(b, c, d, a, M[14], 4259657740, 23);
              a = fnH(a, b, c, d, M[1], 2763975236, 4);
              d = fnH(d, a, b, c, M[4], 1272893353, 11);
              c = fnH(c, d, a, b, M[7], 4139469664, 16);
              b = fnH(b, c, d, a, M[10], 3200236656, 23);
              a = fnH(a, b, c, d, M[13], 681279174, 4);
              d = fnH(d, a, b, c, M[0], 3936430074, 11);
              c = fnH(c, d, a, b, M[3], 3572445317, 16);
              b = fnH(b, c, d, a, M[6], 76029189, 23);
              a = fnH(a, b, c, d, M[9], 3654602809, 4);
              d = fnH(d, a, b, c, M[12], 3873151461, 11);
              c = fnH(c, d, a, b, M[15], 530742520, 16);
              b = fnH(b, c, d, a, M[2], 3299628645, 23);
              a = fnI(a, b, c, d, M[0], 4096336452, 6);
              d = fnI(d, a, b, c, M[7], 1126891415, 10);
              c = fnI(c, d, a, b, M[14], 2878612391, 15);
              b = fnI(b, c, d, a, M[5], 4237533241, 21);
              a = fnI(a, b, c, d, M[12], 1700485571, 6);
              d = fnI(d, a, b, c, M[3], 2399980690, 10);
              c = fnI(c, d, a, b, M[10], 4293915773, 15);
              b = fnI(b, c, d, a, M[1], 2240044497, 21);
              a = fnI(a, b, c, d, M[8], 1873313359, 6);
              d = fnI(d, a, b, c, M[15], 4264355552, 10);
              c = fnI(c, d, a, b, M[6], 2734768916, 15);
              b = fnI(b, c, d, a, M[13], 1309151649, 21);
              a = fnI(a, b, c, d, M[4], 4149444226, 6);
              d = fnI(d, a, b, c, M[11], 3174756917, 10);
              c = fnI(c, d, a, b, M[2], 718787259, 15);
              b = fnI(b, c, d, a, M[9], 3951481745, 21);
              this._a = (this._a + a) | 0;
              this._b = (this._b + b) | 0;
              this._c = (this._c + c) | 0;
              this._d = (this._d + d) | 0;
            };
            MD5.prototype._digest = function() {
              this._block[this._blockOffset++] = 128;
              if (this._blockOffset > 56) {
                this._block.fill(0, this._blockOffset, 64);
                this._update();
                this._blockOffset = 0;
              }
              this._block.fill(0, this._blockOffset, 56);
              this._block.writeUInt32LE(this._length[0], 56);
              this._block.writeUInt32LE(this._length[1], 60);
              this._update();
              var buffer = new Buffer(16);
              buffer.writeInt32LE(this._a, 0);
              buffer.writeInt32LE(this._b, 4);
              buffer.writeInt32LE(this._c, 8);
              buffer.writeInt32LE(this._d, 12);
              return buffer;
            };
            function rotl(x, n) {
              return (x << n) | (x >>> (32 - n));
            }
            function fnF(a, b, c, d, m, k, s) {
              return (rotl((a + ((b & c) | (~b & d)) + m + k) | 0, s) + b) | 0;
            }
            function fnG(a, b, c, d, m, k, s) {
              return (rotl((a + ((b & d) | (c & ~d)) + m + k) | 0, s) + b) | 0;
            }
            function fnH(a, b, c, d, m, k, s) {
              return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + b) | 0;
            }
            function fnI(a, b, c, d, m, k, s) {
              return (rotl((a + (c ^ (b | ~d)) + m + k) | 0, s) + b) | 0;
            }
            module.exports = MD5;
          }.call(this, require('buffer').Buffer));
        },
        { buffer: 183, 'hash-base': 438, inherits: 439 }
      ],
      438: [
        function(require, module, exports) {
          'use strict';
          var Buffer = require('safe-buffer').Buffer;
          var Transform = require('stream').Transform;
          var inherits = require('inherits');
          function throwIfNotStringOrBuffer(val, prefix) {
            if (!Buffer.isBuffer(val) && typeof val !== 'string') {
              throw new TypeError(prefix + ' must be a string or a buffer');
            }
          }
          function HashBase(blockSize) {
            Transform.call(this);
            this._block = Buffer.allocUnsafe(blockSize);
            this._blockSize = blockSize;
            this._blockOffset = 0;
            this._length = [0, 0, 0, 0];
            this._finalized = false;
          }
          inherits(HashBase, Transform);
          HashBase.prototype._transform = function(chunk, encoding, callback) {
            var error = null;
            try {
              this.update(chunk, encoding);
            } catch (err) {
              error = err;
            }
            callback(error);
          };
          HashBase.prototype._flush = function(callback) {
            var error = null;
            try {
              this.push(this.digest());
            } catch (err) {
              error = err;
            }
            callback(error);
          };
          HashBase.prototype.update = function(data, encoding) {
            throwIfNotStringOrBuffer(data, 'Data');
            if (this._finalized) throw new Error('Digest already called');
            if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding);
            var block = this._block;
            var offset = 0;
            while (
              this._blockOffset + data.length - offset >=
              this._blockSize
            ) {
              for (var i = this._blockOffset; i < this._blockSize; )
                block[i++] = data[offset++];
              this._update();
              this._blockOffset = 0;
            }
            while (offset < data.length)
              block[this._blockOffset++] = data[offset++];
            for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
              this._length[j] += carry;
              carry = (this._length[j] / 4294967296) | 0;
              if (carry > 0) this._length[j] -= 4294967296 * carry;
            }
            return this;
          };
          HashBase.prototype._update = function() {
            throw new Error('_update is not implemented');
          };
          HashBase.prototype.digest = function(encoding) {
            if (this._finalized) throw new Error('Digest already called');
            this._finalized = true;
            var digest = this._digest();
            if (encoding !== undefined) digest = digest.toString(encoding);
            this._block.fill(0);
            this._blockOffset = 0;
            for (var i = 0; i < 4; ++i) this._length[i] = 0;
            return digest;
          };
          HashBase.prototype._digest = function() {
            throw new Error('_digest is not implemented');
          };
          module.exports = HashBase;
        },
        { inherits: 439, 'safe-buffer': 460, stream: 258 }
      ],
      439: [
        function(require, module, exports) {
          arguments[4][207][0].apply(exports, arguments);
        },
        { dup: 207 }
      ],
      440: [
        function(require, module, exports) {
          (function(Buffer) {
            module.exports = function fastRoot(values, digestFn) {
              if (!Array.isArray(values))
                throw TypeError('Expected values Array');
              if (typeof digestFn !== 'function')
                throw TypeError('Expected digest Function');
              var length = values.length;
              var results = values.concat();
              while (length > 1) {
                var j = 0;
                for (var i = 0; i < length; i += 2, ++j) {
                  var left = results[i];
                  var right = i + 1 === length ? left : results[i + 1];
                  var data = Buffer.concat([left, right]);
                  results[j] = digestFn(data);
                }
                length = j;
              }
              return results[0];
            };
          }.call(this, require('buffer').Buffer));
        },
        { buffer: 183 }
      ],
      441: [
        function(require, module, exports) {
          arguments[4][211][0].apply(exports, arguments);
        },
        { dup: 211 }
      ],
      442: [
        function(require, module, exports) {
          (function() {
            var Generator, iced, __iced_k, __iced_k_noop;
            iced = require('iced-runtime');
            __iced_k = __iced_k_noop = function() {};
            Generator = Generator = (function() {
              function Generator(opts) {
                opts = opts || {};
                this.lazy_loop_delay = opts.lazy_loop_delay || 30;
                this.loop_delay = opts.loop_delay || 5;
                this.work_min = opts.work_min || 1;
                this.auto_stop_bits = opts.auto_stop_bits || 4096;
                this.max_bits_per_delta = opts.max_bits_per_delta || 4;
                this.auto_stop = opts.auto_stop ? opts.auto_stop : true;
                this.entropies = [];
                this.running = true;
                this.is_generating = false;
                this.timer_race_loop();
              }
              Generator.prototype.generate = function(bits_wanted, cb) {
                var e,
                  harvested_bits,
                  res,
                  ___iced_passed_deferral,
                  __iced_deferrals,
                  __iced_k;
                __iced_k = __iced_k_noop;
                ___iced_passed_deferral = iced.findDeferral(arguments);
                this.is_generating = true;
                if (!this.running) {
                  this.resume();
                }
                harvested_bits = 0;
                res = [];
                (function(_this) {
                  return function(__iced_k) {
                    var _results, _while;
                    _results = [];
                    _while = function(__iced_k) {
                      var _break, _continue, _next;
                      _break = function() {
                        return __iced_k(_results);
                      };
                      _continue = function() {
                        return iced.trampoline(function() {
                          return _while(__iced_k);
                        });
                      };
                      _next = function(__iced_next_arg) {
                        _results.push(__iced_next_arg);
                        return _continue();
                      };
                      if (!(harvested_bits < bits_wanted)) {
                        return _break();
                      } else {
                        (function(__iced_k) {
                          if (_this.entropies.length) {
                            e = _this.entropies.splice(0, 1)[0];
                            harvested_bits += e[1];
                            return __iced_k(res.push(e[0]));
                          } else {
                            (function(__iced_k) {
                              __iced_deferrals = new iced.Deferrals(__iced_k, {
                                parent: ___iced_passed_deferral,
                                filename:
                                  '/Users/chris/git/more-entropy/src/generator.iced',
                                funcname: 'Generator.generate'
                              });
                              _this.delay(
                                __iced_deferrals.defer({ lineno: 28 })
                              );
                              __iced_deferrals._fulfill();
                            })(__iced_k);
                          }
                        })(_next);
                      }
                    };
                    _while(__iced_k);
                  };
                })(this)(
                  (function(_this) {
                    return function() {
                      if (_this.auto_stop) {
                        _this.stop();
                      }
                      _this.is_generating = false;
                      return cb(res);
                    };
                  })(this)
                );
              };
              Generator.prototype.stop = function() {
                return (this.running = false);
              };
              Generator.prototype.resume = function() {
                this.running = true;
                return this.timer_race_loop();
              };
              Generator.prototype.reset = function() {
                this.entropies = [];
                return (this.total_bits = 0);
              };
              Generator.prototype.count_unused_bits = function() {
                var bits, e, _i, _len, _ref;
                bits = 0;
                _ref = this.entropies;
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                  e = _ref[_i];
                  bits += e[1];
                }
                return bits;
              };
              Generator.prototype.delay = function(cb) {
                var delay, ___iced_passed_deferral, __iced_deferrals, __iced_k;
                __iced_k = __iced_k_noop;
                ___iced_passed_deferral = iced.findDeferral(arguments);
                delay = this.is_generating
                  ? this.loop_delay
                  : this.lazy_loop_delay;
                (function(_this) {
                  return function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename:
                        '/Users/chris/git/more-entropy/src/generator.iced',
                      funcname: 'Generator.delay'
                    });
                    setTimeout(__iced_deferrals.defer({ lineno: 50 }), delay);
                    __iced_deferrals._fulfill();
                  };
                })(this)(
                  (function(_this) {
                    return function() {
                      return cb();
                    };
                  })(this)
                );
              };
              Generator.prototype.timer_race_loop = function() {
                var ___iced_passed_deferral, __iced_k, _results, _while;
                __iced_k = __iced_k_noop;
                ___iced_passed_deferral = iced.findDeferral(arguments);
                this._last_count = null;
                _results = [];
                _while = (function(_this) {
                  var count, delta, entropy, v, __iced_deferrals;
                  return function(__iced_k) {
                    var _break, _continue, _next;
                    _break = function() {
                      return __iced_k(_results);
                    };
                    _continue = function() {
                      return iced.trampoline(function() {
                        return _while(__iced_k);
                      });
                    };
                    _next = function(__iced_next_arg) {
                      _results.push(__iced_next_arg);
                      return _continue();
                    };
                    if (!_this.running) {
                      return _break();
                    } else {
                      if (_this.count_unused_bits() < _this.auto_stop_bits) {
                        count = _this.millisecond_count();
                        if (
                          _this._last_count != null &&
                          (delta = count - _this._last_count)
                        ) {
                          entropy = Math.floor(_this.log_2(Math.abs(delta)));
                          entropy = Math.min(_this.max_bits_per_delta, entropy);
                          v = [delta, entropy];
                          _this.entropies.push(v);
                        }
                        _this._last_count = count;
                      }
                      (function(__iced_k) {
                        __iced_deferrals = new iced.Deferrals(__iced_k, {
                          parent: ___iced_passed_deferral,
                          filename:
                            '/Users/chris/git/more-entropy/src/generator.iced',
                          funcname: 'Generator.timer_race_loop'
                        });
                        _this.delay(__iced_deferrals.defer({ lineno: 64 }));
                        __iced_deferrals._fulfill();
                      })(_next);
                    }
                  };
                })(this);
                _while(__iced_k);
              };
              Generator.prototype.log_2 = function(x) {
                return Math.log(x) / Math.LN2;
              };
              Generator.prototype.millisecond_count = function() {
                var d, i, x;
                d = Date.now();
                i = x = 0;
                while (Date.now() < d + this.work_min + 1) {
                  i++;
                  x = Math.sin(Math.sqrt(Math.log(i + x)));
                }
                return i;
              };
              return Generator;
            })();
            if (typeof window !== 'undefined' && window !== null) {
              window.Generator = Generator;
            }
            if (typeof exports !== 'undefined' && exports !== null) {
              exports.Generator = Generator;
            }
          }.call(this));
        },
        { 'iced-runtime': 379 }
      ],
      443: [
        function(require, module, exports) {
          (function() {
            exports.Generator = require('../lib/generator').Generator;
          }.call(this));
        },
        { '../lib/generator': 442 }
      ],
      444: [
        function(require, module, exports) {
          module.exports = compile;
          var BaseFuncs = require('boolbase'),
            trueFunc = BaseFuncs.trueFunc,
            falseFunc = BaseFuncs.falseFunc;
          function compile(parsed) {
            var a = parsed[0],
              b = parsed[1] - 1;
            if (b < 0 && a <= 0) return falseFunc;
            if (a === -1)
              return function(pos) {
                return pos <= b;
              };
            if (a === 0)
              return function(pos) {
                return pos === b;
              };
            if (a === 1)
              return b < 0
                ? trueFunc
                : function(pos) {
                    return pos >= b;
                  };
            var bMod = b % a;
            if (bMod < 0) bMod += a;
            if (a > 1) {
              return function(pos) {
                return pos >= b && pos % a === bMod;
              };
            }
            a *= -1;
            return function(pos) {
              return pos <= b && pos % a === bMod;
            };
          }
        },
        { boolbase: 135 }
      ],
      445: [
        function(require, module, exports) {
          var parse = require('./parse.js'),
            compile = require('./compile.js');
          module.exports = function nthCheck(formula) {
            return compile(parse(formula));
          };
          module.exports.parse = parse;
          module.exports.compile = compile;
        },
        { './compile.js': 444, './parse.js': 446 }
      ],
      446: [
        function(require, module, exports) {
          module.exports = parse;
          var re_nthElement = /^([+\-]?\d*n)?\s*(?:([+\-]?)\s*(\d+))?$/;
          function parse(formula) {
            formula = formula.trim().toLowerCase();
            if (formula === 'even') {
              return [2, 0];
            } else if (formula === 'odd') {
              return [2, 1];
            } else {
              var parsed = formula.match(re_nthElement);
              if (!parsed) {
                throw new SyntaxError(
                  "n-th rule couldn't be parsed ('" + formula + "')"
                );
              }
              var a;
              if (parsed[1]) {
                a = parseInt(parsed[1], 10);
                if (isNaN(a)) {
                  if (parsed[1].charAt(0) === '-') a = -1;
                  else a = 1;
                }
              } else a = 0;
              return [
                a,
                parsed[3] ? parseInt((parsed[2] || '') + parsed[3], 10) : 0
              ];
            }
          }
        },
        {}
      ],
      447: [
        function(require, module, exports) {
          exports.pbkdf2 = require('./lib/async');
          exports.pbkdf2Sync = require('./lib/sync');
        },
        { './lib/async': 448, './lib/sync': 451 }
      ],
      448: [
        function(require, module, exports) {
          (function(process, global) {
            var checkParameters = require('./precondition');
            var defaultEncoding = require('./default-encoding');
            var sync = require('./sync');
            var Buffer = require('safe-buffer').Buffer;
            var ZERO_BUF;
            var subtle = global.crypto && global.crypto.subtle;
            var toBrowser = {
              sha: 'SHA-1',
              'sha-1': 'SHA-1',
              sha1: 'SHA-1',
              sha256: 'SHA-256',
              'sha-256': 'SHA-256',
              sha384: 'SHA-384',
              'sha-384': 'SHA-384',
              'sha-512': 'SHA-512',
              sha512: 'SHA-512'
            };
            var checks = [];
            function checkNative(algo) {
              if (global.process && !global.process.browser) {
                return Promise.resolve(false);
              }
              if (!subtle || !subtle.importKey || !subtle.deriveBits) {
                return Promise.resolve(false);
              }
              if (checks[algo] !== undefined) {
                return checks[algo];
              }
              ZERO_BUF = ZERO_BUF || Buffer.alloc(8);
              var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo)
                .then(function() {
                  return true;
                })
                .catch(function() {
                  return false;
                });
              checks[algo] = prom;
              return prom;
            }
            function browserPbkdf2(password, salt, iterations, length, algo) {
              return subtle
                .importKey('raw', password, { name: 'PBKDF2' }, false, [
                  'deriveBits'
                ])
                .then(function(key) {
                  return subtle.deriveBits(
                    {
                      name: 'PBKDF2',
                      salt: salt,
                      iterations: iterations,
                      hash: { name: algo }
                    },
                    key,
                    length << 3
                  );
                })
                .then(function(res) {
                  return Buffer.from(res);
                });
            }
            function resolvePromise(promise, callback) {
              promise.then(
                function(out) {
                  process.nextTick(function() {
                    callback(null, out);
                  });
                },
                function(e) {
                  process.nextTick(function() {
                    callback(e);
                  });
                }
              );
            }
            module.exports = function(
              password,
              salt,
              iterations,
              keylen,
              digest,
              callback
            ) {
              if (typeof digest === 'function') {
                callback = digest;
                digest = undefined;
              }
              digest = digest || 'sha1';
              var algo = toBrowser[digest.toLowerCase()];
              if (!algo || typeof global.Promise !== 'function') {
                return process.nextTick(function() {
                  var out;
                  try {
                    out = sync(password, salt, iterations, keylen, digest);
                  } catch (e) {
                    return callback(e);
                  }
                  callback(null, out);
                });
              }
              checkParameters(password, salt, iterations, keylen);
              if (typeof callback !== 'function')
                throw new Error('No callback provided to pbkdf2');
              if (!Buffer.isBuffer(password))
                password = Buffer.from(password, defaultEncoding);
              if (!Buffer.isBuffer(salt))
                salt = Buffer.from(salt, defaultEncoding);
              resolvePromise(
                checkNative(algo).then(function(resp) {
                  if (resp)
                    return browserPbkdf2(
                      password,
                      salt,
                      iterations,
                      keylen,
                      algo
                    );
                  return sync(password, salt, iterations, keylen, digest);
                }),
                callback
              );
            };
          }.call(
            this,
            require('_process'),
            typeof global !== 'undefined'
              ? global
              : typeof self !== 'undefined'
              ? self
              : typeof window !== 'undefined'
              ? window
              : {}
          ));
        },
        {
          './default-encoding': 449,
          './precondition': 450,
          './sync': 451,
          _process: 223,
          'safe-buffer': 460
        }
      ],
      449: [
        function(require, module, exports) {
          arguments[4][219][0].apply(exports, arguments);
        },
        { _process: 223, dup: 219 }
      ],
      450: [
        function(require, module, exports) {
          (function(Buffer) {
            var MAX_ALLOC = Math.pow(2, 30) - 1;
            function checkBuffer(buf, name) {
              if (typeof buf !== 'string' && !Buffer.isBuffer(buf)) {
                throw new TypeError(name + ' must be a buffer or string');
              }
            }
            module.exports = function(password, salt, iterations, keylen) {
              checkBuffer(password, 'Password');
              checkBuffer(salt, 'Salt');
              if (typeof iterations !== 'number') {
                throw new TypeError('Iterations not a number');
              }
              if (iterations < 0) {
                throw new TypeError('Bad iterations');
              }
              if (typeof keylen !== 'number') {
                throw new TypeError('Key length not a number');
              }
              if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) {
                throw new TypeError('Bad key length');
              }
            };
          }.call(this, {
            isBuffer: require('../../browserify/node_modules/is-buffer/index.js')
          }));
        },
        { '../../browserify/node_modules/is-buffer/index.js': 208 }
      ],
      451: [
        function(require, module, exports) {
          var md5 = require('create-hash/md5');
          var rmd160 = require('ripemd160');
          var sha = require('sha.js');
          var checkParameters = require('./precondition');
          var defaultEncoding = require('./default-encoding');
          var Buffer = require('safe-buffer').Buffer;
          var ZEROS = Buffer.alloc(128);
          var sizes = {
            md5: 16,
            sha1: 20,
            sha224: 28,
            sha256: 32,
            sha384: 48,
            sha512: 64,
            rmd160: 20,
            ripemd160: 20
          };
          function Hmac(alg, key, saltLen) {
            var hash = getDigest(alg);
            var blocksize = alg === 'sha512' || alg === 'sha384' ? 128 : 64;
            if (key.length > blocksize) {
              key = hash(key);
            } else if (key.length < blocksize) {
              key = Buffer.concat([key, ZEROS], blocksize);
            }
            var ipad = Buffer.allocUnsafe(blocksize + sizes[alg]);
            var opad = Buffer.allocUnsafe(blocksize + sizes[alg]);
            for (var i = 0; i < blocksize; i++) {
              ipad[i] = key[i] ^ 54;
              opad[i] = key[i] ^ 92;
            }
            var ipad1 = Buffer.allocUnsafe(blocksize + saltLen + 4);
            ipad.copy(ipad1, 0, 0, blocksize);
            this.ipad1 = ipad1;
            this.ipad2 = ipad;
            this.opad = opad;
            this.alg = alg;
            this.blocksize = blocksize;
            this.hash = hash;
            this.size = sizes[alg];
          }
          Hmac.prototype.run = function(data, ipad) {
            data.copy(ipad, this.blocksize);
            var h = this.hash(ipad);
            h.copy(this.opad, this.blocksize);
            return this.hash(this.opad);
          };
          function getDigest(alg) {
            function shaFunc(data) {
              return sha(alg)
                .update(data)
                .digest();
            }
            if (alg === 'rmd160' || alg === 'ripemd160') return rmd160;
            if (alg === 'md5') return md5;
            return shaFunc;
          }
          function pbkdf2(password, salt, iterations, keylen, digest) {
            checkParameters(password, salt, iterations, keylen);
            if (!Buffer.isBuffer(password))
              password = Buffer.from(password, defaultEncoding);
            if (!Buffer.isBuffer(salt))
              salt = Buffer.from(salt, defaultEncoding);
            digest = digest || 'sha1';
            var hmac = new Hmac(digest, password, salt.length);
            var DK = Buffer.allocUnsafe(keylen);
            var block1 = Buffer.allocUnsafe(salt.length + 4);
            salt.copy(block1, 0, 0, salt.length);
            var destPos = 0;
            var hLen = sizes[digest];
            var l = Math.ceil(keylen / hLen);
            for (var i = 1; i <= l; i++) {
              block1.writeUInt32BE(i, salt.length);
              var T = hmac.run(block1, hmac.ipad1);
              var U = T;
              for (var j = 1; j < iterations; j++) {
                U = hmac.run(U, hmac.ipad2);
                for (var k = 0; k < hLen; k++) T[k] ^= U[k];
              }
              T.copy(DK, destPos);
              destPos += hLen;
            }
            return DK;
          }
          module.exports = pbkdf2;
        },
        {
          './default-encoding': 449,
          './precondition': 450,
          'create-hash/md5': 284,
          ripemd160: 459,
          'safe-buffer': 460,
          'sha.js': 465
        }
      ],
      452: [
        function(require, module, exports) {
          var OPS = require('bitcoin-ops');
          function encodingLength(i) {
            return i < OPS.OP_PUSHDATA1 ? 1 : i <= 255 ? 2 : i <= 65535 ? 3 : 5;
          }
          function encode(buffer, number, offset) {
            var size = encodingLength(number);
            if (size === 1) {
              buffer.writeUInt8(number, offset);
            } else if (size === 2) {
              buffer.writeUInt8(OPS.OP_PUSHDATA1, offset);
              buffer.writeUInt8(number, offset + 1);
            } else if (size === 3) {
              buffer.writeUInt8(OPS.OP_PUSHDATA2, offset);
              buffer.writeUInt16LE(number, offset + 1);
            } else {
              buffer.writeUInt8(OPS.OP_PUSHDATA4, offset);
              buffer.writeUInt32LE(number, offset + 1);
            }
            return size;
          }
          function decode(buffer, offset) {
            var opcode = buffer.readUInt8(offset);
            var number, size;
            if (opcode < OPS.OP_PUSHDATA1) {
              number = opcode;
              size = 1;
            } else if (opcode === OPS.OP_PUSHDATA1) {
              if (offset + 2 > buffer.length) return null;
              number = buffer.readUInt8(offset + 1);
              size = 2;
            } else if (opcode === OPS.OP_PUSHDATA2) {
              if (offset + 3 > buffer.length) return null;
              number = buffer.readUInt16LE(offset + 1);
              size = 3;
            } else {
              if (offset + 5 > buffer.length) return null;
              if (opcode !== OPS.OP_PUSHDATA4)
                throw new Error('Unexpected opcode');
              number = buffer.readUInt32LE(offset + 1);
              size = 5;
            }
            return { opcode: opcode, number: number, size: size };
          }
          module.exports = {
            encodingLength: encodingLength,
            encode: encode,
            decode: decode
          };
        },
        { 'bitcoin-ops': 88 }
      ],
      453: [
        function(require, module, exports) {
          'use strict';
          var strictUriEncode = require('strict-uri-encode');
          var objectAssign = require('object-assign');
          function encoderForArrayFormat(opts) {
            switch (opts.arrayFormat) {
              case 'index':
                return function(key, value, index) {
                  return value === null
                    ? [encode(key, opts), '[', index, ']'].join('')
                    : [
                        encode(key, opts),
                        '[',
                        encode(index, opts),
                        ']=',
                        encode(value, opts)
                      ].join('');
                };
              case 'bracket':
                return function(key, value) {
                  return value === null
                    ? encode(key, opts)
                    : [encode(key, opts), '[]=', encode(value, opts)].join('');
                };
              default:
                return function(key, value) {
                  return value === null
                    ? encode(key, opts)
                    : [encode(key, opts), '=', encode(value, opts)].join('');
                };
            }
          }
          function parserForArrayFormat(opts) {
            var result;
            switch (opts.arrayFormat) {
              case 'index':
                return function(key, value, accumulator) {
                  result = /\[(\d*)\]$/.exec(key);
                  key = key.replace(/\[\d*\]$/, '');
                  if (!result) {
                    accumulator[key] = value;
                    return;
                  }
                  if (accumulator[key] === undefined) {
                    accumulator[key] = {};
                  }
                  accumulator[key][result[1]] = value;
                };
              case 'bracket':
                return function(key, value, accumulator) {
                  result = /(\[\])$/.exec(key);
                  key = key.replace(/\[\]$/, '');
                  if (!result) {
                    accumulator[key] = value;
                    return;
                  } else if (accumulator[key] === undefined) {
                    accumulator[key] = [value];
                    return;
                  }
                  accumulator[key] = [].concat(accumulator[key], value);
                };
              default:
                return function(key, value, accumulator) {
                  if (accumulator[key] === undefined) {
                    accumulator[key] = value;
                    return;
                  }
                  accumulator[key] = [].concat(accumulator[key], value);
                };
            }
          }
          function encode(value, opts) {
            if (opts.encode) {
              return opts.strict
                ? strictUriEncode(value)
                : encodeURIComponent(value);
            }
            return value;
          }
          function keysSorter(input) {
            if (Array.isArray(input)) {
              return input.sort();
            } else if (typeof input === 'object') {
              return keysSorter(Object.keys(input))
                .sort(function(a, b) {
                  return Number(a) - Number(b);
                })
                .map(function(key) {
                  return input[key];
                });
            }
            return input;
          }
          exports.extract = function(str) {
            return str.split('?')[1] || '';
          };
          exports.parse = function(str, opts) {
            opts = objectAssign({ arrayFormat: 'none' }, opts);
            var formatter = parserForArrayFormat(opts);
            var ret = Object.create(null);
            if (typeof str !== 'string') {
              return ret;
            }
            str = str.trim().replace(/^(\?|#|&)/, '');
            if (!str) {
              return ret;
            }
            str.split('&').forEach(function(param) {
              var parts = param.replace(/\+/g, ' ').split('=');
              var key = parts.shift();
              var val = parts.length > 0 ? parts.join('=') : undefined;
              val = val === undefined ? null : decodeURIComponent(val);
              formatter(decodeURIComponent(key), val, ret);
            });
            return Object.keys(ret)
              .sort()
              .reduce(function(result, key) {
                var val = ret[key];
                if (
                  Boolean(val) &&
                  typeof val === 'object' &&
                  !Array.isArray(val)
                ) {
                  result[key] = keysSorter(val);
                } else {
                  result[key] = val;
                }
                return result;
              }, Object.create(null));
          };
          exports.stringify = function(obj, opts) {
            var defaults = { encode: true, strict: true, arrayFormat: 'none' };
            opts = objectAssign(defaults, opts);
            var formatter = encoderForArrayFormat(opts);
            return obj
              ? Object.keys(obj)
                  .sort()
                  .map(function(key) {
                    var val = obj[key];
                    if (val === undefined) {
                      return '';
                    }
                    if (val === null) {
                      return encode(key, opts);
                    }
                    if (Array.isArray(val)) {
                      var result = [];
                      val.slice().forEach(function(val2) {
                        if (val2 === undefined) {
                          return;
                        }
                        result.push(formatter(key, val2, result.length));
                      });
                      return result.join('&');
                    }
                    return encode(key, opts) + '=' + encode(val, opts);
                  })
                  .filter(function(x) {
                    return x.length > 0;
                  })
                  .join('&')
              : '';
          };
        },
        { 'object-assign': 454, 'strict-uri-encode': 455 }
      ],
      454: [
        function(require, module, exports) {
          'use strict';
          var getOwnPropertySymbols = Object.getOwnPropertySymbols;
          var hasOwnProperty = Object.prototype.hasOwnProperty;
          var propIsEnumerable = Object.prototype.propertyIsEnumerable;
          function toObject(val) {
            if (val === null || val === undefined) {
              throw new TypeError(
                'Object.assign cannot be called with null or undefined'
              );
            }
            return Object(val);
          }
          function shouldUseNative() {
            try {
              if (!Object.assign) {
                return false;
              }
              var test1 = new String('abc');
              test1[5] = 'de';
              if (Object.getOwnPropertyNames(test1)[0] === '5') {
                return false;
              }
              var test2 = {};
              for (var i = 0; i < 10; i++) {
                test2['_' + String.fromCharCode(i)] = i;
              }
              var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
                return test2[n];
              });
              if (order2.join('') !== '0123456789') {
                return false;
              }
              var test3 = {};
              'abcdefghijklmnopqrst'.split('').forEach(function(letter) {
                test3[letter] = letter;
              });
              if (
                Object.keys(Object.assign({}, test3)).join('') !==
                'abcdefghijklmnopqrst'
              ) {
                return false;
              }
              return true;
            } catch (err) {
              return false;
            }
          }
          module.exports = shouldUseNative()
            ? Object.assign
            : function(target, source) {
                var from;
                var to = toObject(target);
                var symbols;
                for (var s = 1; s < arguments.length; s++) {
                  from = Object(arguments[s]);
                  for (var key in from) {
                    if (hasOwnProperty.call(from, key)) {
                      to[key] = from[key];
                    }
                  }
                  if (getOwnPropertySymbols) {
                    symbols = getOwnPropertySymbols(from);
                    for (var i = 0; i < symbols.length; i++) {
                      if (propIsEnumerable.call(from, symbols[i])) {
                        to[symbols[i]] = from[symbols[i]];
                      }
                    }
                  }
                }
                return to;
              };
        },
        {}
      ],
      455: [
        function(require, module, exports) {
          'use strict';
          module.exports = function(str) {
            return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
              return (
                '%' +
                c
                  .charCodeAt(0)
                  .toString(16)
                  .toUpperCase()
              );
            });
          };
        },
        {}
      ],
      456: [
        function(require, module, exports) {
          (function(process, global) {
            'use strict';
            function oldBrowser() {
              throw new Error(
                'Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11'
              );
            }
            var Buffer = require('safe-buffer').Buffer;
            var crypto = global.crypto || global.msCrypto;
            if (crypto && crypto.getRandomValues) {
              module.exports = randomBytes;
            } else {
              module.exports = oldBrowser;
            }
            function randomBytes(size, cb) {
              if (size > 65536)
                throw new Error('requested too many random bytes');
              var rawBytes = new global.Uint8Array(size);
              if (size > 0) {
                crypto.getRandomValues(rawBytes);
              }
              var bytes = Buffer.from(rawBytes.buffer);
              if (typeof cb === 'function') {
                return process.nextTick(function() {
                  cb(null, bytes);
                });
              }
              return bytes;
            }
          }.call(
            this,
            require('_process'),
            typeof global !== 'undefined'
              ? global
              : typeof self !== 'undefined'
              ? self
              : typeof window !== 'undefined'
              ? window
              : {}
          ));
        },
        { _process: 223, 'safe-buffer': 460 }
      ],
      457: [
        function(require, module, exports) {
          var g =
            (function() {
              return this;
            })() || Function('return this')();
          var hadRuntime =
            g.regeneratorRuntime &&
            Object.getOwnPropertyNames(g).indexOf('regeneratorRuntime') >= 0;
          var oldRuntime = hadRuntime && g.regeneratorRuntime;
          g.regeneratorRuntime = undefined;
          module.exports = require('./runtime');
          if (hadRuntime) {
            g.regeneratorRuntime = oldRuntime;
          } else {
            try {
              delete g.regeneratorRuntime;
            } catch (e) {
              g.regeneratorRuntime = undefined;
            }
          }
        },
        { './runtime': 458 }
      ],
      458: [
        function(require, module, exports) {
          !(function(global) {
            'use strict';
            var Op = Object.prototype;
            var hasOwn = Op.hasOwnProperty;
            var undefined;
            var $Symbol = typeof Symbol === 'function' ? Symbol : {};
            var iteratorSymbol = $Symbol.iterator || '@@iterator';
            var asyncIteratorSymbol =
              $Symbol.asyncIterator || '@@asyncIterator';
            var toStringTagSymbol = $Symbol.toStringTag || '@@toStringTag';
            var inModule = typeof module === 'object';
            var runtime = global.regeneratorRuntime;
            if (runtime) {
              if (inModule) {
                module.exports = runtime;
              }
              return;
            }
            runtime = global.regeneratorRuntime = inModule
              ? module.exports
              : {};
            function wrap(innerFn, outerFn, self, tryLocsList) {
              var protoGenerator =
                outerFn && outerFn.prototype instanceof Generator
                  ? outerFn
                  : Generator;
              var generator = Object.create(protoGenerator.prototype);
              var context = new Context(tryLocsList || []);
              generator._invoke = makeInvokeMethod(innerFn, self, context);
              return generator;
            }
            runtime.wrap = wrap;
            function tryCatch(fn, obj, arg) {
              try {
                return { type: 'normal', arg: fn.call(obj, arg) };
              } catch (err) {
                return { type: 'throw', arg: err };
              }
            }
            var GenStateSuspendedStart = 'suspendedStart';
            var GenStateSuspendedYield = 'suspendedYield';
            var GenStateExecuting = 'executing';
            var GenStateCompleted = 'completed';
            var ContinueSentinel = {};
            function Generator() {}
            function GeneratorFunction() {}
            function GeneratorFunctionPrototype() {}
            var IteratorPrototype = {};
            IteratorPrototype[iteratorSymbol] = function() {
              return this;
            };
            var getProto = Object.getPrototypeOf;
            var NativeIteratorPrototype =
              getProto && getProto(getProto(values([])));
            if (
              NativeIteratorPrototype &&
              NativeIteratorPrototype !== Op &&
              hasOwn.call(NativeIteratorPrototype, iteratorSymbol)
            ) {
              IteratorPrototype = NativeIteratorPrototype;
            }
            var Gp = (GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(
              IteratorPrototype
            ));
            GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
            GeneratorFunctionPrototype.constructor = GeneratorFunction;
            GeneratorFunctionPrototype[
              toStringTagSymbol
            ] = GeneratorFunction.displayName = 'GeneratorFunction';
            function defineIteratorMethods(prototype) {
              ['next', 'throw', 'return'].forEach(function(method) {
                prototype[method] = function(arg) {
                  return this._invoke(method, arg);
                };
              });
            }
            runtime.isGeneratorFunction = function(genFun) {
              var ctor = typeof genFun === 'function' && genFun.constructor;
              return ctor
                ? ctor === GeneratorFunction ||
                    (ctor.displayName || ctor.name) === 'GeneratorFunction'
                : false;
            };
            runtime.mark = function(genFun) {
              if (Object.setPrototypeOf) {
                Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
              } else {
                genFun.__proto__ = GeneratorFunctionPrototype;
                if (!(toStringTagSymbol in genFun)) {
                  genFun[toStringTagSymbol] = 'GeneratorFunction';
                }
              }
              genFun.prototype = Object.create(Gp);
              return genFun;
            };
            runtime.awrap = function(arg) {
              return { __await: arg };
            };
            function AsyncIterator(generator) {
              function invoke(method, arg, resolve, reject) {
                var record = tryCatch(generator[method], generator, arg);
                if (record.type === 'throw') {
                  reject(record.arg);
                } else {
                  var result = record.arg;
                  var value = result.value;
                  if (
                    value &&
                    typeof value === 'object' &&
                    hasOwn.call(value, '__await')
                  ) {
                    return Promise.resolve(value.__await).then(
                      function(value) {
                        invoke('next', value, resolve, reject);
                      },
                      function(err) {
                        invoke('throw', err, resolve, reject);
                      }
                    );
                  }
                  return Promise.resolve(value).then(function(unwrapped) {
                    result.value = unwrapped;
                    resolve(result);
                  }, reject);
                }
              }
              var previousPromise;
              function enqueue(method, arg) {
                function callInvokeWithMethodAndArg() {
                  return new Promise(function(resolve, reject) {
                    invoke(method, arg, resolve, reject);
                  });
                }
                return (previousPromise = previousPromise
                  ? previousPromise.then(
                      callInvokeWithMethodAndArg,
                      callInvokeWithMethodAndArg
                    )
                  : callInvokeWithMethodAndArg());
              }
              this._invoke = enqueue;
            }
            defineIteratorMethods(AsyncIterator.prototype);
            AsyncIterator.prototype[asyncIteratorSymbol] = function() {
              return this;
            };
            runtime.AsyncIterator = AsyncIterator;
            runtime.async = function(innerFn, outerFn, self, tryLocsList) {
              var iter = new AsyncIterator(
                wrap(innerFn, outerFn, self, tryLocsList)
              );
              return runtime.isGeneratorFunction(outerFn)
                ? iter
                : iter.next().then(function(result) {
                    return result.done ? result.value : iter.next();
                  });
            };
            function makeInvokeMethod(innerFn, self, context) {
              var state = GenStateSuspendedStart;
              return function invoke(method, arg) {
                if (state === GenStateExecuting) {
                  throw new Error('Generator is already running');
                }
                if (state === GenStateCompleted) {
                  if (method === 'throw') {
                    throw arg;
                  }
                  return doneResult();
                }
                context.method = method;
                context.arg = arg;
                while (true) {
                  var delegate = context.delegate;
                  if (delegate) {
                    var delegateResult = maybeInvokeDelegate(delegate, context);
                    if (delegateResult) {
                      if (delegateResult === ContinueSentinel) continue;
                      return delegateResult;
                    }
                  }
                  if (context.method === 'next') {
                    context.sent = context._sent = context.arg;
                  } else if (context.method === 'throw') {
                    if (state === GenStateSuspendedStart) {
                      state = GenStateCompleted;
                      throw context.arg;
                    }
                    context.dispatchException(context.arg);
                  } else if (context.method === 'return') {
                    context.abrupt('return', context.arg);
                  }
                  state = GenStateExecuting;
                  var record = tryCatch(innerFn, self, context);
                  if (record.type === 'normal') {
                    state = context.done
                      ? GenStateCompleted
                      : GenStateSuspendedYield;
                    if (record.arg === ContinueSentinel) {
                      continue;
                    }
                    return { value: record.arg, done: context.done };
                  } else if (record.type === 'throw') {
                    state = GenStateCompleted;
                    context.method = 'throw';
                    context.arg = record.arg;
                  }
                }
              };
            }
            function maybeInvokeDelegate(delegate, context) {
              var method = delegate.iterator[context.method];
              if (method === undefined) {
                context.delegate = null;
                if (context.method === 'throw') {
                  if (delegate.iterator.return) {
                    context.method = 'return';
                    context.arg = undefined;
                    maybeInvokeDelegate(delegate, context);
                    if (context.method === 'throw') {
                      return ContinueSentinel;
                    }
                  }
                  context.method = 'throw';
                  context.arg = new TypeError(
                    "The iterator does not provide a 'throw' method"
                  );
                }
                return ContinueSentinel;
              }
              var record = tryCatch(method, delegate.iterator, context.arg);
              if (record.type === 'throw') {
                context.method = 'throw';
                context.arg = record.arg;
                context.delegate = null;
                return ContinueSentinel;
              }
              var info = record.arg;
              if (!info) {
                context.method = 'throw';
                context.arg = new TypeError('iterator result is not an object');
                context.delegate = null;
                return ContinueSentinel;
              }
              if (info.done) {
                context[delegate.resultName] = info.value;
                context.next = delegate.nextLoc;
                if (context.method !== 'return') {
                  context.method = 'next';
                  context.arg = undefined;
                }
              } else {
                return info;
              }
              context.delegate = null;
              return ContinueSentinel;
            }
            defineIteratorMethods(Gp);
            Gp[toStringTagSymbol] = 'Generator';
            Gp[iteratorSymbol] = function() {
              return this;
            };
            Gp.toString = function() {
              return '[object Generator]';
            };
            function pushTryEntry(locs) {
              var entry = { tryLoc: locs[0] };
              if (1 in locs) {
                entry.catchLoc = locs[1];
              }
              if (2 in locs) {
                entry.finallyLoc = locs[2];
                entry.afterLoc = locs[3];
              }
              this.tryEntries.push(entry);
            }
            function resetTryEntry(entry) {
              var record = entry.completion || {};
              record.type = 'normal';
              delete record.arg;
              entry.completion = record;
            }
            function Context(tryLocsList) {
              this.tryEntries = [{ tryLoc: 'root' }];
              tryLocsList.forEach(pushTryEntry, this);
              this.reset(true);
            }
            runtime.keys = function(object) {
              var keys = [];
              for (var key in object) {
                keys.push(key);
              }
              keys.reverse();
              return function next() {
                while (keys.length) {
                  var key = keys.pop();
                  if (key in object) {
                    next.value = key;
                    next.done = false;
                    return next;
                  }
                }
                next.done = true;
                return next;
              };
            };
            function values(iterable) {
              if (iterable) {
                var iteratorMethod = iterable[iteratorSymbol];
                if (iteratorMethod) {
                  return iteratorMethod.call(iterable);
                }
                if (typeof iterable.next === 'function') {
                  return iterable;
                }
                if (!isNaN(iterable.length)) {
                  var i = -1,
                    next = function next() {
                      while (++i < iterable.length) {
                        if (hasOwn.call(iterable, i)) {
                          next.value = iterable[i];
                          next.done = false;
                          return next;
                        }
                      }
                      next.value = undefined;
                      next.done = true;
                      return next;
                    };
                  return (next.next = next);
                }
              }
              return { next: doneResult };
            }
            runtime.values = values;
            function doneResult() {
              return { value: undefined, done: true };
            }
            Context.prototype = {
              constructor: Context,
              reset: function(skipTempReset) {
                this.prev = 0;
                this.next = 0;
                this.sent = this._sent = undefined;
                this.done = false;
                this.delegate = null;
                this.method = 'next';
                this.arg = undefined;
                this.tryEntries.forEach(resetTryEntry);
                if (!skipTempReset) {
                  for (var name in this) {
                    if (
                      name.charAt(0) === 't' &&
                      hasOwn.call(this, name) &&
                      !isNaN(+name.slice(1))
                    ) {
                      this[name] = undefined;
                    }
                  }
                }
              },
              stop: function() {
                this.done = true;
                var rootEntry = this.tryEntries[0];
                var rootRecord = rootEntry.completion;
                if (rootRecord.type === 'throw') {
                  throw rootRecord.arg;
                }
                return this.rval;
              },
              dispatchException: function(exception) {
                if (this.done) {
                  throw exception;
                }
                var context = this;
                function handle(loc, caught) {
                  record.type = 'throw';
                  record.arg = exception;
                  context.next = loc;
                  if (caught) {
                    context.method = 'next';
                    context.arg = undefined;
                  }
                  return !!caught;
                }
                for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                  var entry = this.tryEntries[i];
                  var record = entry.completion;
                  if (entry.tryLoc === 'root') {
                    return handle('end');
                  }
                  if (entry.tryLoc <= this.prev) {
                    var hasCatch = hasOwn.call(entry, 'catchLoc');
                    var hasFinally = hasOwn.call(entry, 'finallyLoc');
                    if (hasCatch && hasFinally) {
                      if (this.prev < entry.catchLoc) {
                        return handle(entry.catchLoc, true);
                      } else if (this.prev < entry.finallyLoc) {
                        return handle(entry.finallyLoc);
                      }
                    } else if (hasCatch) {
                      if (this.prev < entry.catchLoc) {
                        return handle(entry.catchLoc, true);
                      }
                    } else if (hasFinally) {
                      if (this.prev < entry.finallyLoc) {
                        return handle(entry.finallyLoc);
                      }
                    } else {
                      throw new Error('try statement without catch or finally');
                    }
                  }
                }
              },
              abrupt: function(type, arg) {
                for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                  var entry = this.tryEntries[i];
                  if (
                    entry.tryLoc <= this.prev &&
                    hasOwn.call(entry, 'finallyLoc') &&
                    this.prev < entry.finallyLoc
                  ) {
                    var finallyEntry = entry;
                    break;
                  }
                }
                if (
                  finallyEntry &&
                  (type === 'break' || type === 'continue') &&
                  finallyEntry.tryLoc <= arg &&
                  arg <= finallyEntry.finallyLoc
                ) {
                  finallyEntry = null;
                }
                var record = finallyEntry ? finallyEntry.completion : {};
                record.type = type;
                record.arg = arg;
                if (finallyEntry) {
                  this.method = 'next';
                  this.next = finallyEntry.finallyLoc;
                  return ContinueSentinel;
                }
                return this.complete(record);
              },
              complete: function(record, afterLoc) {
                if (record.type === 'throw') {
                  throw record.arg;
                }
                if (record.type === 'break' || record.type === 'continue') {
                  this.next = record.arg;
                } else if (record.type === 'return') {
                  this.rval = this.arg = record.arg;
                  this.method = 'return';
                  this.next = 'end';
                } else if (record.type === 'normal' && afterLoc) {
                  this.next = afterLoc;
                }
                return ContinueSentinel;
              },
              finish: function(finallyLoc) {
                for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                  var entry = this.tryEntries[i];
                  if (entry.finallyLoc === finallyLoc) {
                    this.complete(entry.completion, entry.afterLoc);
                    resetTryEntry(entry);
                    return ContinueSentinel;
                  }
                }
              },
              catch: function(tryLoc) {
                for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                  var entry = this.tryEntries[i];
                  if (entry.tryLoc === tryLoc) {
                    var record = entry.completion;
                    if (record.type === 'throw') {
                      var thrown = record.arg;
                      resetTryEntry(entry);
                    }
                    return thrown;
                  }
                }
                throw new Error('illegal catch attempt');
              },
              delegateYield: function(iterable, resultName, nextLoc) {
                this.delegate = {
                  iterator: values(iterable),
                  resultName: resultName,
                  nextLoc: nextLoc
                };
                if (this.method === 'next') {
                  this.arg = undefined;
                }
                return ContinueSentinel;
              }
            };
          })(
            (function() {
              return this;
            })() || Function('return this')()
          );
        },
        {}
      ],
      459: [
        function(require, module, exports) {
          arguments[4][249][0].apply(exports, arguments);
        },
        { buffer: 183, dup: 249, 'hash-base': 352, inherits: 381 }
      ],
      460: [
        function(require, module, exports) {
          arguments[4][270][0].apply(exports, arguments);
        },
        { buffer: 183, dup: 270 }
      ],
      461: [
        function(require, module, exports) {
          module.exports = require('./lib/schema-inspector');
        },
        { './lib/schema-inspector': 462 }
      ],
      462: [
        function(require, module, exports) {
          (function() {
            var root = {};
            root.async =
              typeof require === 'function' ? require('async') : window.async;
            if (typeof root.async !== 'object') {
              throw new Error(
                'Module async is required (https://github.com/caolan/async)'
              );
            }
            var async = root.async;
            function _extend(origin, add) {
              if (!add || typeof add !== 'object') {
                return origin;
              }
              var keys = Object.keys(add);
              var i = keys.length;
              while (i--) {
                origin[keys[i]] = add[keys[i]];
              }
              return origin;
            }
            function _merge() {
              var ret = {};
              var args = Array.prototype.slice.call(arguments);
              var keys = null;
              var i = null;
              args.forEach(function(arg) {
                if (arg && arg.constructor === Object) {
                  keys = Object.keys(arg);
                  i = keys.length;
                  while (i--) {
                    ret[keys[i]] = arg[keys[i]];
                  }
                }
              });
              return ret;
            }
            function Customisable() {
              this.custom = {};
              this.extend = function(custom) {
                return _extend(this.custom, custom);
              };
              this.reset = function() {
                this.custom = {};
              };
              this.remove = function(fields) {
                if (!_typeIs.array(fields)) {
                  fields = [fields];
                }
                fields.forEach(function(field) {
                  delete this.custom[field];
                }, this);
              };
            }
            function Inspection(schema, custom) {
              var _stack = ['@'];
              this._schema = schema;
              this._custom = {};
              if (custom != null) {
                for (var key in custom) {
                  if (custom.hasOwnProperty(key)) {
                    this._custom['$' + key] = custom[key];
                  }
                }
              }
              this._getDepth = function() {
                return _stack.length;
              };
              this._dumpStack = function() {
                return _stack
                  .map(function(i) {
                    return i.replace(/^\[/g, '');
                  })
                  .join('.')
                  .replace(/\.\u001b\u001c\u001d\u001e/g, '[');
              };
              this._deeperObject = function(name) {
                _stack.push(
                  /^[a-z$_][a-z0-9$_]*$/i.test(name) ? name : '["' + name + '"]'
                );
                return this;
              };
              this._deeperArray = function(i) {
                _stack.push('[' + i + ']');
                return this;
              };
              this._back = function() {
                _stack.pop();
                return this;
              };
            }
            var _typeIs = {
              function: function(element) {
                return typeof element === 'function';
              },
              string: function(element) {
                return typeof element === 'string';
              },
              number: function(element) {
                return typeof element === 'number' && !isNaN(element);
              },
              integer: function(element) {
                return typeof element === 'number' && element % 1 === 0;
              },
              NaN: function(element) {
                return typeof element === 'number' && isNaN(element);
              },
              boolean: function(element) {
                return typeof element === 'boolean';
              },
              null: function(element) {
                return element === null;
              },
              date: function(element) {
                return element != null && element instanceof Date;
              },
              object: function(element) {
                return element != null && element.constructor === Object;
              },
              array: function(element) {
                return element != null && element.constructor === Array;
              },
              any: function(element) {
                return true;
              }
            };
            function _simpleType(type, candidate) {
              if (typeof type == 'function') {
                return candidate instanceof type;
              }
              type = type in _typeIs ? type : 'any';
              return _typeIs[type](candidate);
            }
            function _realType(candidate) {
              for (var i in _typeIs) {
                if (_simpleType(i, candidate)) {
                  if (i !== 'any') {
                    return i;
                  }
                  return 'an instance of ' + candidate.constructor.name;
                }
              }
            }
            function getIndexes(a, value) {
              var indexes = [];
              var i = a.indexOf(value);
              while (i !== -1) {
                indexes.push(i);
                i = a.indexOf(value, i + 1);
              }
              return indexes;
            }
            var _formats = {
              void: /^$/,
              url: /^(https?|ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)?(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i,
              'date-time': /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{3})?(Z?|(-|\+)\d{2}:\d{2})$/,
              date: /^\d{4}-\d{2}-\d{2}$/,
              coolDateTime: /^\d{4}(-|\/)\d{2}(-|\/)\d{2}(T| )\d{2}:\d{2}:\d{2}(\.\d{3})?Z?$/,
              time: /^\d{2}\:\d{2}\:\d{2}$/,
              color: /^#([0-9a-f])+$/i,
              email: /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?$/i,
              numeric: /^[0-9]+$/,
              integer: /^\-?[0-9]+$/,
              decimal: /^\-?[0-9]*\.?[0-9]+$/,
              alpha: /^[a-z]+$/i,
              alphaNumeric: /^[a-z0-9]+$/i,
              alphaDash: /^[a-z0-9_-]+$/i,
              javascript: /^[a-z_\$][a-z0-9_\$]*$/i,
              upperString: /^[A-Z ]*$/,
              lowerString: /^[a-z ]*$/
            };
            var _validationAttribut = {
              optional: function(schema, candidate) {
                var opt =
                  typeof schema.optional === 'boolean'
                    ? schema.optional
                    : schema.optional === 'true';
                if (opt === true) {
                  return;
                }
                if (typeof candidate === 'undefined') {
                  this.report('is missing and not optional', null, 'optional');
                }
              },
              type: function(schema, candidate) {
                if (
                  typeof candidate === 'undefined' ||
                  (typeof schema.type !== 'string' &&
                    !(schema.type instanceof Array) &&
                    typeof schema.type !== 'function')
                ) {
                  return;
                }
                var types = _typeIs.array(schema.type)
                  ? schema.type
                  : [schema.type];
                var typeIsValid = types.some(function(type) {
                  return _simpleType(type, candidate);
                });
                if (!typeIsValid) {
                  types = types.map(function(t) {
                    return typeof t === 'function'
                      ? 'and instance of ' + t.name
                      : t;
                  });
                  this.report(
                    'must be ' +
                      types.join(' or ') +
                      ', but is ' +
                      _realType(candidate),
                    null,
                    'type'
                  );
                }
              },
              uniqueness: function(schema, candidate) {
                if (typeof schema.uniqueness === 'string') {
                  schema.uniqueness = schema.uniqueness === 'true';
                }
                if (
                  typeof schema.uniqueness !== 'boolean' ||
                  schema.uniqueness === false ||
                  (!_typeIs.array(candidate) && typeof candidate !== 'string')
                ) {
                  return;
                }
                var reported = [];
                for (var i = 0; i < candidate.length; i++) {
                  if (reported.indexOf(candidate[i]) >= 0) {
                    continue;
                  }
                  var indexes = getIndexes(candidate, candidate[i]);
                  if (indexes.length > 1) {
                    reported.push(candidate[i]);
                    this.report(
                      'has value [' +
                        candidate[i] +
                        '] more than once at indexes [' +
                        indexes.join(', ') +
                        ']',
                      null,
                      'uniqueness'
                    );
                  }
                }
              },
              pattern: function(schema, candidate) {
                var self = this;
                var regexs = schema.pattern;
                if (typeof candidate !== 'string') {
                  return;
                }
                var matches = false;
                if (!_typeIs.array(regexs)) {
                  regexs = [regexs];
                }
                regexs.forEach(function(regex) {
                  if (typeof regex === 'string' && regex in _formats) {
                    regex = _formats[regex];
                  }
                  if (regex instanceof RegExp) {
                    if (regex.test(candidate)) {
                      matches = true;
                    }
                  }
                });
                if (!matches) {
                  self.report(
                    'must match [' +
                      regexs.join(' or ') +
                      '], but is equal to "' +
                      candidate +
                      '"',
                    null,
                    'pattern'
                  );
                }
              },
              validDate: function(schema, candidate) {
                if (
                  String(schema.validDate) === 'true' &&
                  candidate instanceof Date &&
                  isNaN(candidate.getTime())
                ) {
                  this.report('must be a valid date', null, 'validDate');
                }
              },
              minLength: function(schema, candidate) {
                if (
                  typeof candidate !== 'string' &&
                  !_typeIs.array(candidate)
                ) {
                  return;
                }
                var minLength = Number(schema.minLength);
                if (isNaN(minLength)) {
                  return;
                }
                if (candidate.length < minLength) {
                  this.report(
                    'must be longer than ' +
                      minLength +
                      ' elements, but it has ' +
                      candidate.length,
                    null,
                    'minLength'
                  );
                }
              },
              maxLength: function(schema, candidate) {
                if (
                  typeof candidate !== 'string' &&
                  !_typeIs.array(candidate)
                ) {
                  return;
                }
                var maxLength = Number(schema.maxLength);
                if (isNaN(maxLength)) {
                  return;
                }
                if (candidate.length > maxLength) {
                  this.report(
                    'must be shorter than ' +
                      maxLength +
                      ' elements, but it has ' +
                      candidate.length,
                    null,
                    'maxLength'
                  );
                }
              },
              exactLength: function(schema, candidate) {
                if (
                  typeof candidate !== 'string' &&
                  !_typeIs.array(candidate)
                ) {
                  return;
                }
                var exactLength = Number(schema.exactLength);
                if (isNaN(exactLength)) {
                  return;
                }
                if (candidate.length !== exactLength) {
                  this.report(
                    'must have exactly ' +
                      exactLength +
                      ' elements, but it have ' +
                      candidate.length,
                    null,
                    'exactLength'
                  );
                }
              },
              lt: function(schema, candidate) {
                var limit = Number(schema.lt);
                if (typeof candidate !== 'number' || isNaN(limit)) {
                  return;
                }
                if (candidate >= limit) {
                  this.report(
                    'must be less than ' +
                      limit +
                      ', but is equal to "' +
                      candidate +
                      '"',
                    null,
                    'lt'
                  );
                }
              },
              lte: function(schema, candidate) {
                var limit = Number(schema.lte);
                if (typeof candidate !== 'number' || isNaN(limit)) {
                  return;
                }
                if (candidate > limit) {
                  this.report(
                    'must be less than or equal to ' +
                      limit +
                      ', but is equal to "' +
                      candidate +
                      '"',
                    null,
                    'lte'
                  );
                }
              },
              gt: function(schema, candidate) {
                var limit = Number(schema.gt);
                if (typeof candidate !== 'number' || isNaN(limit)) {
                  return;
                }
                if (candidate <= limit) {
                  this.report(
                    'must be greater than ' +
                      limit +
                      ', but is equal to "' +
                      candidate +
                      '"',
                    null,
                    'gt'
                  );
                }
              },
              gte: function(schema, candidate) {
                var limit = Number(schema.gte);
                if (typeof candidate !== 'number' || isNaN(limit)) {
                  return;
                }
                if (candidate < limit) {
                  this.report(
                    'must be greater than or equal to ' +
                      limit +
                      ', but is equal to "' +
                      candidate +
                      '"',
                    null,
                    'gte'
                  );
                }
              },
              eq: function(schema, candidate) {
                if (
                  typeof candidate !== 'number' &&
                  typeof candidate !== 'string' &&
                  typeof candidate !== 'boolean'
                ) {
                  return;
                }
                var limit = schema.eq;
                if (
                  typeof limit !== 'number' &&
                  typeof limit !== 'string' &&
                  typeof limit !== 'boolean' &&
                  !_typeIs.array(limit)
                ) {
                  return;
                }
                if (_typeIs.array(limit)) {
                  for (var i = 0; i < limit.length; i++) {
                    if (candidate === limit[i]) {
                      return;
                    }
                  }
                  this.report(
                    'must be equal to [' +
                      limit
                        .map(function(l) {
                          return '"' + l + '"';
                        })
                        .join(' or ') +
                      '], but is equal to "' +
                      candidate +
                      '"',
                    null,
                    'eq'
                  );
                } else {
                  if (candidate !== limit) {
                    this.report(
                      'must be equal to "' +
                        limit +
                        '", but is equal to "' +
                        candidate +
                        '"',
                      null,
                      'eq'
                    );
                  }
                }
              },
              ne: function(schema, candidate) {
                if (
                  typeof candidate !== 'number' &&
                  typeof candidate !== 'string'
                ) {
                  return;
                }
                var limit = schema.ne;
                if (
                  typeof limit !== 'number' &&
                  typeof limit !== 'string' &&
                  !_typeIs.array(limit)
                ) {
                  return;
                }
                if (_typeIs.array(limit)) {
                  for (var i = 0; i < limit.length; i++) {
                    if (candidate === limit[i]) {
                      this.report(
                        'must not be equal to "' + limit[i] + '"',
                        null,
                        'ne'
                      );
                      return;
                    }
                  }
                } else {
                  if (candidate === limit) {
                    this.report(
                      'must not be equal to "' + limit + '"',
                      null,
                      'ne'
                    );
                  }
                }
              },
              someKeys: function(schema, candidat) {
                var _keys = schema.someKeys;
                if (!_typeIs.object(candidat)) {
                  return;
                }
                var valid = _keys.some(function(action) {
                  return action in candidat;
                });
                if (!valid) {
                  this.report(
                    'must have at least key ' +
                      _keys
                        .map(function(i) {
                          return '"' + i + '"';
                        })
                        .join(' or '),
                    null,
                    'someKeys'
                  );
                }
              },
              strict: function(schema, candidate) {
                if (typeof schema.strict === 'string') {
                  schema.strict = schema.strict === 'true';
                }
                if (
                  schema.strict !== true ||
                  !_typeIs.object(candidate) ||
                  !_typeIs.object(schema.properties)
                ) {
                  return;
                }
                var self = this;
                if (typeof schema.properties['*'] === 'undefined') {
                  var intruder = Object.keys(candidate).filter(function(key) {
                    return typeof schema.properties[key] === 'undefined';
                  });
                  if (intruder.length > 0) {
                    var msg =
                      'should not contains ' +
                      (intruder.length > 1 ? 'properties' : 'property') +
                      ' [' +
                      intruder
                        .map(function(i) {
                          return '"' + i + '"';
                        })
                        .join(', ') +
                      ']';
                    self.report(msg, null, 'strict');
                  }
                }
              },
              exec: function(schema, candidate, callback) {
                var self = this;
                if (typeof callback === 'function') {
                  return this.asyncExec(schema, candidate, callback);
                }
                (_typeIs.array(schema.exec)
                  ? schema.exec
                  : [schema.exec]
                ).forEach(function(exec) {
                  if (typeof exec === 'function') {
                    exec.call(self, schema, candidate);
                  }
                });
              },
              properties: function(schema, candidate, callback) {
                if (typeof callback === 'function') {
                  return this.asyncProperties(schema, candidate, callback);
                }
                if (
                  !(schema.properties instanceof Object) ||
                  !(candidate instanceof Object)
                ) {
                  return;
                }
                var properties = schema.properties,
                  i;
                if (properties['*'] != null) {
                  for (i in candidate) {
                    if (i in properties) {
                      continue;
                    }
                    this._deeperObject(i);
                    this._validate(properties['*'], candidate[i]);
                    this._back();
                  }
                }
                for (i in properties) {
                  if (i === '*') {
                    continue;
                  }
                  this._deeperObject(i);
                  this._validate(properties[i], candidate[i]);
                  this._back();
                }
              },
              items: function(schema, candidate, callback) {
                if (typeof callback === 'function') {
                  return this.asyncItems(schema, candidate, callback);
                }
                if (
                  !(schema.items instanceof Object) ||
                  !(candidate instanceof Object)
                ) {
                  return;
                }
                var items = schema.items;
                var i, l;
                if (_typeIs.array(items) && _typeIs.array(candidate)) {
                  for (i = 0, l = items.length; i < l; i++) {
                    this._deeperArray(i);
                    this._validate(items[i], candidate[i]);
                    this._back();
                  }
                } else {
                  for (var key in candidate) {
                    if (candidate.hasOwnProperty(key)) {
                      this._deeperArray(key);
                      this._validate(items, candidate[key]);
                      this._back();
                    }
                  }
                }
              }
            };
            var _asyncValidationAttribut = {
              asyncExec: function(schema, candidate, callback) {
                var self = this;
                async.eachSeries(
                  _typeIs.array(schema.exec) ? schema.exec : [schema.exec],
                  function(exec, done) {
                    if (typeof exec === 'function') {
                      if (exec.length > 2) {
                        return exec.call(self, schema, candidate, done);
                      }
                      exec.call(self, schema, candidate);
                    }
                    async.nextTick(done);
                  },
                  callback
                );
              },
              asyncProperties: function(schema, candidate, callback) {
                if (
                  !(schema.properties instanceof Object) ||
                  !_typeIs.object(candidate)
                ) {
                  return callback();
                }
                var self = this;
                var properties = schema.properties;
                async.series(
                  [
                    function(next) {
                      if (properties['*'] == null) {
                        return next();
                      }
                      async.eachSeries(
                        Object.keys(candidate),
                        function(i, done) {
                          if (i in properties) {
                            return async.nextTick(done);
                          }
                          self._deeperObject(i);
                          self._asyncValidate(
                            properties['*'],
                            candidate[i],
                            function(err) {
                              self._back();
                              done(err);
                            }
                          );
                        },
                        next
                      );
                    },
                    function(next) {
                      async.eachSeries(
                        Object.keys(properties),
                        function(i, done) {
                          if (i === '*') {
                            return async.nextTick(done);
                          }
                          self._deeperObject(i);
                          self._asyncValidate(
                            properties[i],
                            candidate[i],
                            function(err) {
                              self._back();
                              done(err);
                            }
                          );
                        },
                        next
                      );
                    }
                  ],
                  callback
                );
              },
              asyncItems: function(schema, candidate, callback) {
                if (
                  !(schema.items instanceof Object) ||
                  !(candidate instanceof Object)
                ) {
                  return callback();
                }
                var self = this;
                var items = schema.items;
                var i, l;
                if (_typeIs.array(items) && _typeIs.array(candidate)) {
                  async.timesSeries(
                    items.length,
                    function(i, done) {
                      self._deeperArray(i);
                      self._asyncValidate(items[i], candidate[i], function(
                        err,
                        res
                      ) {
                        self._back();
                        done(err, res);
                      });
                      self._back();
                    },
                    callback
                  );
                } else {
                  async.eachSeries(
                    Object.keys(candidate),
                    function(key, done) {
                      self._deeperArray(key);
                      self._asyncValidate(items, candidate[key], function(
                        err,
                        res
                      ) {
                        self._back();
                        done(err, res);
                      });
                    },
                    callback
                  );
                }
              }
            };
            function Validation(schema, custom) {
              Inspection.prototype.constructor.call(
                this,
                schema,
                _merge(Validation.custom, custom)
              );
              var _error = [];
              this._basicFields = Object.keys(_validationAttribut);
              this._customFields = Object.keys(this._custom);
              this.origin = null;
              this.report = function(message, code, reason) {
                var newErr = {
                  code: code || this.userCode || null,
                  reason: reason || 'unknown',
                  message: this.userError || message || 'is invalid',
                  property: this.userAlias
                    ? this.userAlias + ' (' + this._dumpStack() + ')'
                    : this._dumpStack()
                };
                _error.push(newErr);
                return this;
              };
              this.result = function() {
                return {
                  error: _error,
                  valid: _error.length === 0,
                  format: function() {
                    if (this.valid === true) {
                      return 'Candidate is valid';
                    }
                    return this.error
                      .map(function(i) {
                        return 'Property ' + i.property + ': ' + i.message;
                      })
                      .join('\n');
                  }
                };
              };
            }
            _extend(Validation.prototype, _validationAttribut);
            _extend(Validation.prototype, _asyncValidationAttribut);
            _extend(Validation, new Customisable());
            Validation.prototype.validate = function(candidate, callback) {
              this.origin = candidate;
              if (typeof callback === 'function') {
                var self = this;
                return async.nextTick(function() {
                  self._asyncValidate(self._schema, candidate, function(err) {
                    self.origin = null;
                    callback(err, self.result());
                  });
                });
              }
              return this._validate(this._schema, candidate).result();
            };
            Validation.prototype._validate = function(
              schema,
              candidate,
              callback
            ) {
              this.userCode = schema.code || null;
              this.userError = schema.error || null;
              this.userAlias = schema.alias || null;
              this._basicFields.forEach(function(i) {
                if (
                  (i in schema || i === 'optional') &&
                  typeof this[i] === 'function'
                ) {
                  this[i](schema, candidate);
                }
              }, this);
              this._customFields.forEach(function(i) {
                if (i in schema && typeof this._custom[i] === 'function') {
                  this._custom[i].call(this, schema, candidate);
                }
              }, this);
              return this;
            };
            Validation.prototype._asyncValidate = function(
              schema,
              candidate,
              callback
            ) {
              var self = this;
              this.userCode = schema.code || null;
              this.userError = schema.error || null;
              this.userAlias = schema.alias || null;
              async.series(
                [
                  function(next) {
                    async.eachSeries(
                      Object.keys(_validationAttribut),
                      function(i, done) {
                        async.nextTick(function() {
                          if (
                            (i in schema || i === 'optional') &&
                            typeof self[i] === 'function'
                          ) {
                            if (self[i].length > 2) {
                              return self[i](schema, candidate, done);
                            }
                            self[i](schema, candidate);
                          }
                          done();
                        });
                      },
                      next
                    );
                  },
                  function(next) {
                    async.eachSeries(
                      Object.keys(self._custom),
                      function(i, done) {
                        async.nextTick(function() {
                          if (
                            i in schema &&
                            typeof self._custom[i] === 'function'
                          ) {
                            if (self._custom[i].length > 2) {
                              return self._custom[i].call(
                                self,
                                schema,
                                candidate,
                                done
                              );
                            }
                            self._custom[i].call(self, schema, candidate);
                          }
                          done();
                        });
                      },
                      next
                    );
                  }
                ],
                callback
              );
            };
            var _forceType = {
              number: function(post, schema) {
                var n;
                if (typeof post === 'number') {
                  return post;
                } else if (post === '') {
                  if (typeof schema.def !== 'undefined') return schema.def;
                  return null;
                } else if (typeof post === 'string') {
                  n = parseFloat(post.replace(/,/g, '.').replace(/ /g, ''));
                  if (typeof n === 'number') {
                    return n;
                  }
                } else if (post instanceof Date) {
                  return +post;
                }
                return null;
              },
              integer: function(post, schema) {
                var n;
                if (typeof post === 'number' && post % 1 === 0) {
                  return post;
                } else if (post === '') {
                  if (typeof schema.def !== 'undefined') return schema.def;
                  return null;
                } else if (typeof post === 'string') {
                  n = parseInt(post.replace(/ /g, ''), 10);
                  if (typeof n === 'number') {
                    return n;
                  }
                } else if (typeof post === 'number') {
                  return parseInt(post, 10);
                } else if (typeof post === 'boolean') {
                  if (post) {
                    return 1;
                  }
                  return 0;
                } else if (post instanceof Date) {
                  return +post;
                }
                return null;
              },
              string: function(post, schema) {
                if (
                  typeof post === 'boolean' ||
                  typeof post === 'number' ||
                  post instanceof Date
                ) {
                  return post.toString();
                } else if (_typeIs.array(post)) {
                  if (schema.items || schema.properties) return post;
                  return post.join(String(schema.joinWith || ','));
                } else if (post instanceof Object) {
                  if (schema.items || schema.properties) return post;
                  return JSON.stringify(post);
                } else if (typeof post === 'string' && post.length) {
                  return post;
                }
                return null;
              },
              date: function(post, schema) {
                if (post instanceof Date) {
                  return post;
                } else {
                  var d = new Date(post);
                  if (!isNaN(d.getTime())) {
                    return d;
                  }
                }
                return null;
              },
              boolean: function(post, schema) {
                if (typeof post === 'undefined') return null;
                if (typeof post === 'string' && post.toLowerCase() === 'false')
                  return false;
                return !!post;
              },
              object: function(post, schema) {
                if (typeof post !== 'string' || _typeIs.object(post)) {
                  return post;
                }
                try {
                  return JSON.parse(post);
                } catch (e) {
                  return null;
                }
              },
              array: function(post, schema) {
                if (_typeIs.array(post)) return post;
                if (typeof post === 'undefined') return null;
                if (typeof post === 'string') {
                  if (post.substring(0, 1) === '[' && post.slice(-1) === ']') {
                    try {
                      return JSON.parse(post);
                    } catch (e) {
                      return null;
                    }
                  }
                  return post.split(String(schema.splitWith || ','));
                }
                if (!_typeIs.array(post)) return [post];
                return null;
              }
            };
            var _applyRules = {
              upper: function(post) {
                return post.toUpperCase();
              },
              lower: function(post) {
                return post.toLowerCase();
              },
              title: function(post) {
                return post.replace(/\S*/g, function(txt) {
                  return (
                    txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase()
                  );
                });
              },
              capitalize: function(post) {
                return (
                  post.charAt(0).toUpperCase() + post.substr(1).toLowerCase()
                );
              },
              ucfirst: function(post) {
                return post.charAt(0).toUpperCase() + post.substr(1);
              },
              trim: function(post) {
                return post.trim();
              }
            };
            var _sanitizationAttribut = {
              strict: function(schema, post) {
                if (typeof schema.strict === 'string') {
                  schema.strict = schema.strict === 'true';
                }
                if (schema.strict !== true) return post;
                if (!_typeIs.object(schema.properties)) return post;
                if (!_typeIs.object(post)) return post;
                var that = this;
                Object.keys(post).forEach(function(key) {
                  if (!(key in schema.properties)) {
                    delete post[key];
                  }
                });
                return post;
              },
              optional: function(schema, post) {
                var opt =
                  typeof schema.optional === 'boolean'
                    ? schema.optional
                    : schema.optional !== 'false';
                if (opt === true) {
                  return post;
                }
                if (typeof post !== 'undefined') {
                  return post;
                }
                this.report();
                if (schema.def === Date) {
                  return new Date();
                }
                return schema.def;
              },
              type: function(schema, post) {
                if (
                  typeof schema.type !== 'string' ||
                  typeof _forceType[schema.type] !== 'function'
                ) {
                  return post;
                }
                var n;
                var opt =
                  typeof schema.optional === 'boolean' ? schema.optional : true;
                if (typeof _forceType[schema.type] === 'function') {
                  n = _forceType[schema.type](post, schema);
                  if (
                    (n === null && !opt) ||
                    (!n && isNaN(n)) ||
                    (n === null && schema.type === 'string')
                  ) {
                    n = schema.def;
                  }
                } else if (!opt) {
                  n = schema.def;
                }
                if (
                  (n != null ||
                    (typeof schema.def !== 'undefined' && schema.def === n)) &&
                  n !== post
                ) {
                  this.report();
                  return n;
                }
                return post;
              },
              rules: function(schema, post) {
                var rules = schema.rules;
                if (
                  typeof post !== 'string' ||
                  (typeof rules !== 'string' && !_typeIs.array(rules))
                ) {
                  return post;
                }
                var modified = false;
                (_typeIs.array(rules) ? rules : [rules]).forEach(function(
                  rule
                ) {
                  if (typeof _applyRules[rule] === 'function') {
                    post = _applyRules[rule](post);
                    modified = true;
                  }
                });
                if (modified) {
                  this.report();
                }
                return post;
              },
              min: function(schema, post) {
                var postTest = Number(post);
                if (isNaN(postTest)) {
                  return post;
                }
                var min = Number(schema.min);
                if (isNaN(min)) {
                  return post;
                }
                if (postTest < min) {
                  this.report();
                  return min;
                }
                return post;
              },
              max: function(schema, post) {
                var postTest = Number(post);
                if (isNaN(postTest)) {
                  return post;
                }
                var max = Number(schema.max);
                if (isNaN(max)) {
                  return post;
                }
                if (postTest > max) {
                  this.report();
                  return max;
                }
                return post;
              },
              minLength: function(schema, post) {
                var limit = Number(schema.minLength);
                if (typeof post !== 'string' || isNaN(limit) || limit < 0) {
                  return post;
                }
                var str = '';
                var gap = limit - post.length;
                if (gap > 0) {
                  for (var i = 0; i < gap; i++) {
                    str += '-';
                  }
                  this.report();
                  return post + str;
                }
                return post;
              },
              maxLength: function(schema, post) {
                var limit = Number(schema.maxLength);
                if (typeof post !== 'string' || isNaN(limit) || limit < 0) {
                  return post;
                }
                if (post.length > limit) {
                  this.report();
                  return post.slice(0, limit);
                }
                return post;
              },
              properties: function(schema, post, callback) {
                if (typeof callback === 'function') {
                  return this.asyncProperties(schema, post, callback);
                }
                if (!post || typeof post !== 'object') {
                  return post;
                }
                var properties = schema.properties;
                var tmp;
                var i;
                if (typeof properties['*'] !== 'undefined') {
                  for (i in post) {
                    if (i in properties) {
                      continue;
                    }
                    this._deeperObject(i);
                    tmp = this._sanitize(schema.properties['*'], post[i]);
                    if (typeof tmp !== 'undefined') {
                      post[i] = tmp;
                    }
                    this._back();
                  }
                }
                for (i in schema.properties) {
                  if (i !== '*') {
                    this._deeperObject(i);
                    tmp = this._sanitize(schema.properties[i], post[i]);
                    if (typeof tmp !== 'undefined') {
                      post[i] = tmp;
                    }
                    this._back();
                  }
                }
                return post;
              },
              items: function(schema, post, callback) {
                if (typeof callback === 'function') {
                  return this.asyncItems(schema, post, callback);
                }
                if (
                  !(schema.items instanceof Object) ||
                  !(post instanceof Object)
                ) {
                  return post;
                }
                var i;
                if (_typeIs.array(schema.items) && _typeIs.array(post)) {
                  var minLength =
                    schema.items.length < post.length
                      ? schema.items.length
                      : post.length;
                  for (i = 0; i < minLength; i++) {
                    this._deeperArray(i);
                    post[i] = this._sanitize(schema.items[i], post[i]);
                    this._back();
                  }
                } else {
                  for (i in post) {
                    if (post.hasOwnProperty(i)) {
                      this._deeperArray(i);
                      post[i] = this._sanitize(schema.items, post[i]);
                      this._back();
                    }
                  }
                }
                return post;
              },
              exec: function(schema, post, callback) {
                if (typeof callback === 'function') {
                  return this.asyncExec(schema, post, callback);
                }
                var execs = _typeIs.array(schema.exec)
                  ? schema.exec
                  : [schema.exec];
                execs.forEach(function(exec) {
                  if (typeof exec === 'function') {
                    post = exec.call(this, schema, post);
                  }
                }, this);
                return post;
              }
            };
            var _asyncSanitizationAttribut = {
              asyncExec: function(schema, post, callback) {
                var self = this;
                var execs = _typeIs.array(schema.exec)
                  ? schema.exec
                  : [schema.exec];
                async.eachSeries(
                  execs,
                  function(exec, done) {
                    if (typeof exec === 'function') {
                      if (exec.length > 2) {
                        return exec.call(self, schema, post, function(
                          err,
                          res
                        ) {
                          if (err) {
                            return done(err);
                          }
                          post = res;
                          done();
                        });
                      }
                      post = exec.call(self, schema, post);
                    }
                    done();
                  },
                  function(err) {
                    callback(err, post);
                  }
                );
              },
              asyncProperties: function(schema, post, callback) {
                if (!post || typeof post !== 'object') {
                  return callback(null, post);
                }
                var self = this;
                var properties = schema.properties;
                async.series(
                  [
                    function(next) {
                      if (properties['*'] == null) {
                        return next();
                      }
                      var globing = properties['*'];
                      async.eachSeries(
                        Object.keys(post),
                        function(i, next) {
                          if (i in properties) {
                            return next();
                          }
                          self._deeperObject(i);
                          self._asyncSanitize(globing, post[i], function(
                            err,
                            res
                          ) {
                            if (err) {
                            }
                            if (typeof res !== 'undefined') {
                              post[i] = res;
                            }
                            self._back();
                            next();
                          });
                        },
                        next
                      );
                    },
                    function(next) {
                      async.eachSeries(
                        Object.keys(properties),
                        function(i, next) {
                          if (i === '*') {
                            return next();
                          }
                          self._deeperObject(i);
                          self._asyncSanitize(properties[i], post[i], function(
                            err,
                            res
                          ) {
                            if (err) {
                              return next(err);
                            }
                            if (typeof res !== 'undefined') {
                              post[i] = res;
                            }
                            self._back();
                            next();
                          });
                        },
                        next
                      );
                    }
                  ],
                  function(err) {
                    return callback(err, post);
                  }
                );
              },
              asyncItems: function(schema, post, callback) {
                if (
                  !(schema.items instanceof Object) ||
                  !(post instanceof Object)
                ) {
                  return callback(null, post);
                }
                var self = this;
                var items = schema.items;
                if (_typeIs.array(items) && _typeIs.array(post)) {
                  var minLength =
                    items.length < post.length ? items.length : post.length;
                  async.timesSeries(
                    minLength,
                    function(i, next) {
                      self._deeperArray(i);
                      self._asyncSanitize(items[i], post[i], function(
                        err,
                        res
                      ) {
                        if (err) {
                          return next(err);
                        }
                        post[i] = res;
                        self._back();
                        next();
                      });
                    },
                    function(err) {
                      callback(err, post);
                    }
                  );
                } else {
                  async.eachSeries(
                    Object.keys(post),
                    function(key, next) {
                      self._deeperArray(key);
                      self._asyncSanitize(items, post[key], function(err, res) {
                        if (err) {
                          return next();
                        }
                        post[key] = res;
                        self._back();
                        next();
                      });
                    },
                    function(err) {
                      callback(err, post);
                    }
                  );
                }
                return post;
              }
            };
            function Sanitization(schema, custom) {
              Inspection.prototype.constructor.call(
                this,
                schema,
                _merge(Sanitization.custom, custom)
              );
              var _reporting = [];
              this._basicFields = Object.keys(_sanitizationAttribut);
              this._customFields = Object.keys(this._custom);
              this.origin = null;
              this.report = function(message) {
                var newNot = {
                  message: message || 'was sanitized',
                  property: this.userAlias
                    ? this.userAlias + ' (' + this._dumpStack() + ')'
                    : this._dumpStack()
                };
                if (
                  !_reporting.some(function(e) {
                    return e.property === newNot.property;
                  })
                ) {
                  _reporting.push(newNot);
                }
              };
              this.result = function(data) {
                return {
                  data: data,
                  reporting: _reporting,
                  format: function() {
                    return this.reporting
                      .map(function(i) {
                        return 'Property ' + i.property + ' ' + i.message;
                      })
                      .join('\n');
                  }
                };
              };
            }
            _extend(Sanitization.prototype, _sanitizationAttribut);
            _extend(Sanitization.prototype, _asyncSanitizationAttribut);
            _extend(Sanitization, new Customisable());
            Sanitization.prototype.sanitize = function(post, callback) {
              this.origin = post;
              if (typeof callback === 'function') {
                var self = this;
                return this._asyncSanitize(this._schema, post, function(
                  err,
                  data
                ) {
                  self.origin = null;
                  callback(err, self.result(data));
                });
              }
              var data = this._sanitize(this._schema, post);
              this.origin = null;
              return this.result(data);
            };
            Sanitization.prototype._sanitize = function(schema, post) {
              this.userAlias = schema.alias || null;
              this._basicFields.forEach(function(i) {
                if (
                  (i in schema || i === 'optional') &&
                  typeof this[i] === 'function'
                ) {
                  post = this[i](schema, post);
                }
              }, this);
              this._customFields.forEach(function(i) {
                if (i in schema && typeof this._custom[i] === 'function') {
                  post = this._custom[i].call(this, schema, post);
                }
              }, this);
              return post;
            };
            Sanitization.prototype._asyncSanitize = function(
              schema,
              post,
              callback
            ) {
              var self = this;
              this.userAlias = schema.alias || null;
              async.waterfall(
                [
                  function(next) {
                    async.reduce(
                      self._basicFields,
                      post,
                      function(value, i, next) {
                        async.nextTick(function() {
                          if (
                            (i in schema || i === 'optional') &&
                            typeof self[i] === 'function'
                          ) {
                            if (self[i].length > 2) {
                              return self[i](schema, value, next);
                            }
                            value = self[i](schema, value);
                          }
                          next(null, value);
                        });
                      },
                      next
                    );
                  },
                  function(inter, next) {
                    async.reduce(
                      self._customFields,
                      inter,
                      function(value, i, next) {
                        async.nextTick(function() {
                          if (
                            i in schema &&
                            typeof self._custom[i] === 'function'
                          ) {
                            if (self._custom[i].length > 2) {
                              return self._custom[i].call(
                                self,
                                schema,
                                value,
                                next
                              );
                            }
                            value = self._custom[i].call(self, schema, value);
                          }
                          next(null, value);
                        });
                      },
                      next
                    );
                  }
                ],
                callback
              );
            };
            var INT_MIN = -2147483648;
            var INT_MAX = 2147483647;
            var _rand = {
              int: function(min, max) {
                return min + (0 | (Math.random() * (max - min + 1)));
              },
              float: function(min, max) {
                return Math.random() * (max - min) + min;
              },
              bool: function() {
                return Math.random() > 0.5;
              },
              char: function(min, max) {
                return String.fromCharCode(this.int(min, max));
              },
              fromList: function(list) {
                return list[this.int(0, list.length - 1)];
              }
            };
            var _formatSample = {
              'date-time': function() {
                return new Date().toISOString();
              },
              date: function() {
                return new Date().toISOString().replace(/T.*$/, '');
              },
              time: function() {
                return new Date().toLocaleTimeString({}, { hour12: false });
              },
              color: function(min, max) {
                var s = '#';
                if (min < 1) {
                  min = 1;
                }
                for (var i = 0, l = _rand.int(min, max); i < l; i++) {
                  s += _rand.fromList('0123456789abcdefABCDEF');
                }
                return s;
              },
              numeric: function() {
                return '' + _rand.int(0, INT_MAX);
              },
              integer: function() {
                if (_rand.bool() === true) {
                  return '-' + this.numeric();
                }
                return this.numeric();
              },
              decimal: function() {
                return this.integer() + '.' + this.numeric();
              },
              alpha: function(min, max) {
                var s = '';
                if (min < 1) {
                  min = 1;
                }
                for (var i = 0, l = _rand.int(min, max); i < l; i++) {
                  s += _rand.fromList(
                    'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
                  );
                }
                return s;
              },
              alphaNumeric: function(min, max) {
                var s = '';
                if (min < 1) {
                  min = 1;
                }
                for (var i = 0, l = _rand.int(min, max); i < l; i++) {
                  s += _rand.fromList(
                    'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
                  );
                }
                return s;
              },
              alphaDash: function(min, max) {
                var s = '';
                if (min < 1) {
                  min = 1;
                }
                for (var i = 0, l = _rand.int(min, max); i < l; i++) {
                  s += _rand.fromList(
                    '_-abcdefghijklmnopqrstuvwxyz_-ABCDEFGHIJKLMNOPQRSTUVWXYZ_-0123456789_-'
                  );
                }
                return s;
              },
              javascript: function(min, max) {
                var s = _rand.fromList(
                  '_$abcdefghijklmnopqrstuvwxyz_$ABCDEFGHIJKLMNOPQRSTUVWXYZ_$'
                );
                for (var i = 0, l = _rand.int(min, max - 1); i < l; i++) {
                  s += _rand.fromList(
                    '_$abcdefghijklmnopqrstuvwxyz_$ABCDEFGHIJKLMNOPQRSTUVWXYZ_$0123456789_$'
                  );
                }
                return s;
              }
            };
            function _getLimits(schema) {
              var min = INT_MIN;
              var max = INT_MAX;
              if (schema.gte != null) {
                min = schema.gte;
              } else if (schema.gt != null) {
                min = schema.gt + 1;
              }
              if (schema.lte != null) {
                max = schema.lte;
              } else if (schema.lt != null) {
                max = schema.lt - 1;
              }
              return { min: min, max: max };
            }
            var _typeGenerator = {
              string: function(schema) {
                if (schema.eq != null) {
                  return schema.eq;
                }
                var s = '';
                var minLength = schema.minLength != null ? schema.minLength : 0;
                var maxLength =
                  schema.maxLength != null ? schema.maxLength : 32;
                if (
                  typeof schema.pattern === 'string' &&
                  typeof _formatSample[schema.pattern] === 'function'
                ) {
                  return _formatSample[schema.pattern](minLength, maxLength);
                }
                var l =
                  schema.exactLength != null
                    ? schema.exactLength
                    : _rand.int(minLength, maxLength);
                for (var i = 0; i < l; i++) {
                  s += _rand.char(32, 126);
                }
                return s;
              },
              number: function(schema) {
                if (schema.eq != null) {
                  return schema.eq;
                }
                var limit = _getLimits(schema);
                var n = _rand.float(limit.min, limit.max);
                if (schema.ne != null) {
                  var ne = _typeIs.array(schema.ne) ? schema.ne : [schema.ne];
                  while (ne.indexOf(n) !== -1) {
                    n = _rand.float(limit.min, limit.max);
                  }
                }
                return n;
              },
              integer: function(schema) {
                if (schema.eq != null) {
                  return schema.eq;
                }
                var limit = _getLimits(schema);
                var n = _rand.int(limit.min, limit.max);
                if (schema.ne != null) {
                  var ne = _typeIs.array(schema.ne) ? schema.ne : [schema.ne];
                  while (ne.indexOf(n) !== -1) {
                    n = _rand.int(limit.min, limit.max);
                  }
                }
                return n;
              },
              boolean: function(schema) {
                if (schema.eq != null) {
                  return schema.eq;
                }
                return _rand.bool();
              },
              null: function(schema) {
                return null;
              },
              date: function(schema) {
                if (schema.eq != null) {
                  return schema.eq;
                }
                return new Date();
              },
              object: function(schema) {
                var o = {};
                var prop = schema.properties || {};
                for (var key in prop) {
                  if (prop.hasOwnProperty(key)) {
                    if (prop[key].optional === true && _rand.bool() === true) {
                      continue;
                    }
                    if (key !== '*') {
                      o[key] = this.generate(prop[key]);
                    } else {
                      var rk = '__random_key_';
                      var randomKey = rk + 0;
                      var n = _rand.int(1, 9);
                      for (var i = 1; i <= n; i++) {
                        if (!(randomKey in prop)) {
                          o[randomKey] = this.generate(prop[key]);
                        }
                        randomKey = rk + i;
                      }
                    }
                  }
                }
                return o;
              },
              array: function(schema) {
                var self = this;
                var items = schema.items || {};
                var minLength = schema.minLength != null ? schema.minLength : 0;
                var maxLength =
                  schema.maxLength != null ? schema.maxLength : 16;
                var type;
                var candidate;
                var size;
                var i;
                if (_typeIs.array(items)) {
                  size = items.length;
                  if (schema.exactLength != null) {
                    size = schema.exactLength;
                  } else if (size < minLength) {
                    size = minLength;
                  } else if (size > maxLength) {
                    size = maxLength;
                  }
                  candidate = new Array(size);
                  type = null;
                  for (i = 0; i < size; i++) {
                    type = items[i].type || 'any';
                    if (_typeIs.array(type)) {
                      type = type[_rand.int(0, type.length - 1)];
                    }
                    candidate[i] = self[type](items[i]);
                  }
                } else {
                  size =
                    schema.exactLength != null
                      ? schema.exactLength
                      : _rand.int(minLength, maxLength);
                  candidate = new Array(size);
                  type = items.type || 'any';
                  if (_typeIs.array(type)) {
                    type = type[_rand.int(0, type.length - 1)];
                  }
                  for (i = 0; i < size; i++) {
                    candidate[i] = self[type](items);
                  }
                }
                return candidate;
              },
              any: function(schema) {
                var fields = Object.keys(_typeGenerator);
                var i = fields[_rand.int(0, fields.length - 2)];
                return this[i](schema);
              }
            };
            function CandidateGenerator() {}
            _extend(CandidateGenerator.prototype, _typeGenerator);
            var _instance = null;
            CandidateGenerator.instance = function() {
              if (!(_instance instanceof CandidateGenerator)) {
                _instance = new CandidateGenerator();
              }
              return _instance;
            };
            CandidateGenerator.prototype.generate = function(schema) {
              var type = schema.type || 'any';
              if (_typeIs.array(type)) {
                type = type[_rand.int(0, type.length - 1)];
              }
              return this[type](schema);
            };
            var SchemaInspector = {};
            if (typeof module !== 'undefined' && module.exports) {
              module.exports = SchemaInspector;
            } else {
              window.SchemaInspector = SchemaInspector;
            }
            SchemaInspector.newSanitization = function(schema, custom) {
              return new Sanitization(schema, custom);
            };
            SchemaInspector.newValidation = function(schema, custom) {
              return new Validation(schema, custom);
            };
            SchemaInspector.Validation = Validation;
            SchemaInspector.Sanitization = Sanitization;
            SchemaInspector.sanitize = function(
              schema,
              post,
              custom,
              callback
            ) {
              if (arguments.length === 3 && typeof custom === 'function') {
                callback = custom;
                custom = null;
              }
              return new Sanitization(schema, custom).sanitize(post, callback);
            };
            SchemaInspector.validate = function(
              schema,
              candidate,
              custom,
              callback
            ) {
              if (arguments.length === 3 && typeof custom === 'function') {
                callback = custom;
                custom = null;
              }
              return new Validation(schema, custom).validate(
                candidate,
                callback
              );
            };
            SchemaInspector.generate = function(schema, n) {
              if (typeof n === 'number') {
                var r = new Array(n);
                for (var i = 0; i < n; i++) {
                  r[i] = CandidateGenerator.instance().generate(schema);
                }
                return r;
              }
              return CandidateGenerator.instance().generate(schema);
            };
          })();
        },
        { async: 463 }
      ],
      463: [
        function(require, module, exports) {
          (function(process, global) {
            (function() {
              var async = {};
              function noop() {}
              function identity(v) {
                return v;
              }
              function toBool(v) {
                return !!v;
              }
              function notId(v) {
                return !v;
              }
              var previous_async;
              var root =
                (typeof self === 'object' && self.self === self && self) ||
                (typeof global === 'object' &&
                  global.global === global &&
                  global) ||
                this;
              if (root != null) {
                previous_async = root.async;
              }
              async.noConflict = function() {
                root.async = previous_async;
                return async;
              };
              function only_once(fn) {
                return function() {
                  if (fn === null)
                    throw new Error('Callback was already called.');
                  fn.apply(this, arguments);
                  fn = null;
                };
              }
              function _once(fn) {
                return function() {
                  if (fn === null) return;
                  fn.apply(this, arguments);
                  fn = null;
                };
              }
              var _toString = Object.prototype.toString;
              var _isArray =
                Array.isArray ||
                function(obj) {
                  return _toString.call(obj) === '[object Array]';
                };
              var _isObject = function(obj) {
                var type = typeof obj;
                return type === 'function' || (type === 'object' && !!obj);
              };
              function _isArrayLike(arr) {
                return (
                  _isArray(arr) ||
                  (typeof arr.length === 'number' &&
                    arr.length >= 0 &&
                    arr.length % 1 === 0)
                );
              }
              function _arrayEach(arr, iterator) {
                var index = -1,
                  length = arr.length;
                while (++index < length) {
                  iterator(arr[index], index, arr);
                }
              }
              function _map(arr, iterator) {
                var index = -1,
                  length = arr.length,
                  result = Array(length);
                while (++index < length) {
                  result[index] = iterator(arr[index], index, arr);
                }
                return result;
              }
              function _range(count) {
                return _map(Array(count), function(v, i) {
                  return i;
                });
              }
              function _reduce(arr, iterator, memo) {
                _arrayEach(arr, function(x, i, a) {
                  memo = iterator(memo, x, i, a);
                });
                return memo;
              }
              function _forEachOf(object, iterator) {
                _arrayEach(_keys(object), function(key) {
                  iterator(object[key], key);
                });
              }
              function _indexOf(arr, item) {
                for (var i = 0; i < arr.length; i++) {
                  if (arr[i] === item) return i;
                }
                return -1;
              }
              var _keys =
                Object.keys ||
                function(obj) {
                  var keys = [];
                  for (var k in obj) {
                    if (obj.hasOwnProperty(k)) {
                      keys.push(k);
                    }
                  }
                  return keys;
                };
              function _keyIterator(coll) {
                var i = -1;
                var len;
                var keys;
                if (_isArrayLike(coll)) {
                  len = coll.length;
                  return function next() {
                    i++;
                    return i < len ? i : null;
                  };
                } else {
                  keys = _keys(coll);
                  len = keys.length;
                  return function next() {
                    i++;
                    return i < len ? keys[i] : null;
                  };
                }
              }
              function _restParam(func, startIndex) {
                startIndex = startIndex == null ? func.length - 1 : +startIndex;
                return function() {
                  var length = Math.max(arguments.length - startIndex, 0);
                  var rest = Array(length);
                  for (var index = 0; index < length; index++) {
                    rest[index] = arguments[index + startIndex];
                  }
                  switch (startIndex) {
                    case 0:
                      return func.call(this, rest);
                    case 1:
                      return func.call(this, arguments[0], rest);
                  }
                };
              }
              function _withoutIndex(iterator) {
                return function(value, index, callback) {
                  return iterator(value, callback);
                };
              }
              var _setImmediate =
                typeof setImmediate === 'function' && setImmediate;
              var _delay = _setImmediate
                ? function(fn) {
                    _setImmediate(fn);
                  }
                : function(fn) {
                    setTimeout(fn, 0);
                  };
              if (
                typeof process === 'object' &&
                typeof process.nextTick === 'function'
              ) {
                async.nextTick = process.nextTick;
              } else {
                async.nextTick = _delay;
              }
              async.setImmediate = _setImmediate ? _delay : async.nextTick;
              async.forEach = async.each = function(arr, iterator, callback) {
                return async.eachOf(arr, _withoutIndex(iterator), callback);
              };
              async.forEachSeries = async.eachSeries = function(
                arr,
                iterator,
                callback
              ) {
                return async.eachOfSeries(
                  arr,
                  _withoutIndex(iterator),
                  callback
                );
              };
              async.forEachLimit = async.eachLimit = function(
                arr,
                limit,
                iterator,
                callback
              ) {
                return _eachOfLimit(limit)(
                  arr,
                  _withoutIndex(iterator),
                  callback
                );
              };
              async.forEachOf = async.eachOf = function(
                object,
                iterator,
                callback
              ) {
                callback = _once(callback || noop);
                object = object || [];
                var iter = _keyIterator(object);
                var key,
                  completed = 0;
                while ((key = iter()) != null) {
                  completed += 1;
                  iterator(object[key], key, only_once(done));
                }
                if (completed === 0) callback(null);
                function done(err) {
                  completed--;
                  if (err) {
                    callback(err);
                  } else if (key === null && completed <= 0) {
                    callback(null);
                  }
                }
              };
              async.forEachOfSeries = async.eachOfSeries = function(
                obj,
                iterator,
                callback
              ) {
                callback = _once(callback || noop);
                obj = obj || [];
                var nextKey = _keyIterator(obj);
                var key = nextKey();
                function iterate() {
                  var sync = true;
                  if (key === null) {
                    return callback(null);
                  }
                  iterator(
                    obj[key],
                    key,
                    only_once(function(err) {
                      if (err) {
                        callback(err);
                      } else {
                        key = nextKey();
                        if (key === null) {
                          return callback(null);
                        } else {
                          if (sync) {
                            async.setImmediate(iterate);
                          } else {
                            iterate();
                          }
                        }
                      }
                    })
                  );
                  sync = false;
                }
                iterate();
              };
              async.forEachOfLimit = async.eachOfLimit = function(
                obj,
                limit,
                iterator,
                callback
              ) {
                _eachOfLimit(limit)(obj, iterator, callback);
              };
              function _eachOfLimit(limit) {
                return function(obj, iterator, callback) {
                  callback = _once(callback || noop);
                  obj = obj || [];
                  var nextKey = _keyIterator(obj);
                  if (limit <= 0) {
                    return callback(null);
                  }
                  var done = false;
                  var running = 0;
                  var errored = false;
                  (function replenish() {
                    if (done && running <= 0) {
                      return callback(null);
                    }
                    while (running < limit && !errored) {
                      var key = nextKey();
                      if (key === null) {
                        done = true;
                        if (running <= 0) {
                          callback(null);
                        }
                        return;
                      }
                      running += 1;
                      iterator(
                        obj[key],
                        key,
                        only_once(function(err) {
                          running -= 1;
                          if (err) {
                            callback(err);
                            errored = true;
                          } else {
                            replenish();
                          }
                        })
                      );
                    }
                  })();
                };
              }
              function doParallel(fn) {
                return function(obj, iterator, callback) {
                  return fn(async.eachOf, obj, iterator, callback);
                };
              }
              function doParallelLimit(fn) {
                return function(obj, limit, iterator, callback) {
                  return fn(_eachOfLimit(limit), obj, iterator, callback);
                };
              }
              function doSeries(fn) {
                return function(obj, iterator, callback) {
                  return fn(async.eachOfSeries, obj, iterator, callback);
                };
              }
              function _asyncMap(eachfn, arr, iterator, callback) {
                callback = _once(callback || noop);
                arr = arr || [];
                var results = _isArrayLike(arr) ? [] : {};
                eachfn(
                  arr,
                  function(value, index, callback) {
                    iterator(value, function(err, v) {
                      results[index] = v;
                      callback(err);
                    });
                  },
                  function(err) {
                    callback(err, results);
                  }
                );
              }
              async.map = doParallel(_asyncMap);
              async.mapSeries = doSeries(_asyncMap);
              async.mapLimit = doParallelLimit(_asyncMap);
              async.inject = async.foldl = async.reduce = function(
                arr,
                memo,
                iterator,
                callback
              ) {
                async.eachOfSeries(
                  arr,
                  function(x, i, callback) {
                    iterator(memo, x, function(err, v) {
                      memo = v;
                      callback(err);
                    });
                  },
                  function(err) {
                    callback(err, memo);
                  }
                );
              };
              async.foldr = async.reduceRight = function(
                arr,
                memo,
                iterator,
                callback
              ) {
                var reversed = _map(arr, identity).reverse();
                async.reduce(reversed, memo, iterator, callback);
              };
              async.transform = function(arr, memo, iterator, callback) {
                if (arguments.length === 3) {
                  callback = iterator;
                  iterator = memo;
                  memo = _isArray(arr) ? [] : {};
                }
                async.eachOf(
                  arr,
                  function(v, k, cb) {
                    iterator(memo, v, k, cb);
                  },
                  function(err) {
                    callback(err, memo);
                  }
                );
              };
              function _filter(eachfn, arr, iterator, callback) {
                var results = [];
                eachfn(
                  arr,
                  function(x, index, callback) {
                    iterator(x, function(v) {
                      if (v) {
                        results.push({ index: index, value: x });
                      }
                      callback();
                    });
                  },
                  function() {
                    callback(
                      _map(
                        results.sort(function(a, b) {
                          return a.index - b.index;
                        }),
                        function(x) {
                          return x.value;
                        }
                      )
                    );
                  }
                );
              }
              async.select = async.filter = doParallel(_filter);
              async.selectLimit = async.filterLimit = doParallelLimit(_filter);
              async.selectSeries = async.filterSeries = doSeries(_filter);
              function _reject(eachfn, arr, iterator, callback) {
                _filter(
                  eachfn,
                  arr,
                  function(value, cb) {
                    iterator(value, function(v) {
                      cb(!v);
                    });
                  },
                  callback
                );
              }
              async.reject = doParallel(_reject);
              async.rejectLimit = doParallelLimit(_reject);
              async.rejectSeries = doSeries(_reject);
              function _createTester(eachfn, check, getResult) {
                return function(arr, limit, iterator, cb) {
                  function done() {
                    if (cb) cb(getResult(false, void 0));
                  }
                  function iteratee(x, _, callback) {
                    if (!cb) return callback();
                    iterator(x, function(v) {
                      if (cb && check(v)) {
                        cb(getResult(true, x));
                        cb = iterator = false;
                      }
                      callback();
                    });
                  }
                  if (arguments.length > 3) {
                    eachfn(arr, limit, iteratee, done);
                  } else {
                    cb = iterator;
                    iterator = limit;
                    eachfn(arr, iteratee, done);
                  }
                };
              }
              async.any = async.some = _createTester(
                async.eachOf,
                toBool,
                identity
              );
              async.someLimit = _createTester(
                async.eachOfLimit,
                toBool,
                identity
              );
              async.all = async.every = _createTester(
                async.eachOf,
                notId,
                notId
              );
              async.everyLimit = _createTester(async.eachOfLimit, notId, notId);
              function _findGetResult(v, x) {
                return x;
              }
              async.detect = _createTester(
                async.eachOf,
                identity,
                _findGetResult
              );
              async.detectSeries = _createTester(
                async.eachOfSeries,
                identity,
                _findGetResult
              );
              async.detectLimit = _createTester(
                async.eachOfLimit,
                identity,
                _findGetResult
              );
              async.sortBy = function(arr, iterator, callback) {
                async.map(
                  arr,
                  function(x, callback) {
                    iterator(x, function(err, criteria) {
                      if (err) {
                        callback(err);
                      } else {
                        callback(null, { value: x, criteria: criteria });
                      }
                    });
                  },
                  function(err, results) {
                    if (err) {
                      return callback(err);
                    } else {
                      callback(
                        null,
                        _map(results.sort(comparator), function(x) {
                          return x.value;
                        })
                      );
                    }
                  }
                );
                function comparator(left, right) {
                  var a = left.criteria,
                    b = right.criteria;
                  return a < b ? -1 : a > b ? 1 : 0;
                }
              };
              async.auto = function(tasks, concurrency, callback) {
                if (typeof arguments[1] === 'function') {
                  callback = concurrency;
                  concurrency = null;
                }
                callback = _once(callback || noop);
                var keys = _keys(tasks);
                var remainingTasks = keys.length;
                if (!remainingTasks) {
                  return callback(null);
                }
                if (!concurrency) {
                  concurrency = remainingTasks;
                }
                var results = {};
                var runningTasks = 0;
                var hasError = false;
                var listeners = [];
                function addListener(fn) {
                  listeners.unshift(fn);
                }
                function removeListener(fn) {
                  var idx = _indexOf(listeners, fn);
                  if (idx >= 0) listeners.splice(idx, 1);
                }
                function taskComplete() {
                  remainingTasks--;
                  _arrayEach(listeners.slice(0), function(fn) {
                    fn();
                  });
                }
                addListener(function() {
                  if (!remainingTasks) {
                    callback(null, results);
                  }
                });
                _arrayEach(keys, function(k) {
                  if (hasError) return;
                  var task = _isArray(tasks[k]) ? tasks[k] : [tasks[k]];
                  var taskCallback = _restParam(function(err, args) {
                    runningTasks--;
                    if (args.length <= 1) {
                      args = args[0];
                    }
                    if (err) {
                      var safeResults = {};
                      _forEachOf(results, function(val, rkey) {
                        safeResults[rkey] = val;
                      });
                      safeResults[k] = args;
                      hasError = true;
                      callback(err, safeResults);
                    } else {
                      results[k] = args;
                      async.setImmediate(taskComplete);
                    }
                  });
                  var requires = task.slice(0, task.length - 1);
                  var len = requires.length;
                  var dep;
                  while (len--) {
                    if (!(dep = tasks[requires[len]])) {
                      throw new Error(
                        'Has nonexistent dependency in ' + requires.join(', ')
                      );
                    }
                    if (_isArray(dep) && _indexOf(dep, k) >= 0) {
                      throw new Error('Has cyclic dependencies');
                    }
                  }
                  function ready() {
                    return (
                      runningTasks < concurrency &&
                      _reduce(
                        requires,
                        function(a, x) {
                          return a && results.hasOwnProperty(x);
                        },
                        true
                      ) &&
                      !results.hasOwnProperty(k)
                    );
                  }
                  if (ready()) {
                    runningTasks++;
                    task[task.length - 1](taskCallback, results);
                  } else {
                    addListener(listener);
                  }
                  function listener() {
                    if (ready()) {
                      runningTasks++;
                      removeListener(listener);
                      task[task.length - 1](taskCallback, results);
                    }
                  }
                });
              };
              async.retry = function(times, task, callback) {
                var DEFAULT_TIMES = 5;
                var DEFAULT_INTERVAL = 0;
                var attempts = [];
                var opts = { times: DEFAULT_TIMES, interval: DEFAULT_INTERVAL };
                function parseTimes(acc, t) {
                  if (typeof t === 'number') {
                    acc.times = parseInt(t, 10) || DEFAULT_TIMES;
                  } else if (typeof t === 'object') {
                    acc.times = parseInt(t.times, 10) || DEFAULT_TIMES;
                    acc.interval = parseInt(t.interval, 10) || DEFAULT_INTERVAL;
                  } else {
                    throw new Error(
                      "Unsupported argument type for 'times': " + typeof t
                    );
                  }
                }
                var length = arguments.length;
                if (length < 1 || length > 3) {
                  throw new Error(
                    'Invalid arguments - must be either (task), (task, callback), (times, task) or (times, task, callback)'
                  );
                } else if (length <= 2 && typeof times === 'function') {
                  callback = task;
                  task = times;
                }
                if (typeof times !== 'function') {
                  parseTimes(opts, times);
                }
                opts.callback = callback;
                opts.task = task;
                function wrappedTask(wrappedCallback, wrappedResults) {
                  function retryAttempt(task, finalAttempt) {
                    return function(seriesCallback) {
                      task(function(err, result) {
                        seriesCallback(!err || finalAttempt, {
                          err: err,
                          result: result
                        });
                      }, wrappedResults);
                    };
                  }
                  function retryInterval(interval) {
                    return function(seriesCallback) {
                      setTimeout(function() {
                        seriesCallback(null);
                      }, interval);
                    };
                  }
                  while (opts.times) {
                    var finalAttempt = !(opts.times -= 1);
                    attempts.push(retryAttempt(opts.task, finalAttempt));
                    if (!finalAttempt && opts.interval > 0) {
                      attempts.push(retryInterval(opts.interval));
                    }
                  }
                  async.series(attempts, function(done, data) {
                    data = data[data.length - 1];
                    (wrappedCallback || opts.callback)(data.err, data.result);
                  });
                }
                return opts.callback ? wrappedTask() : wrappedTask;
              };
              async.waterfall = function(tasks, callback) {
                callback = _once(callback || noop);
                if (!_isArray(tasks)) {
                  var err = new Error(
                    'First argument to waterfall must be an array of functions'
                  );
                  return callback(err);
                }
                if (!tasks.length) {
                  return callback();
                }
                function wrapIterator(iterator) {
                  return _restParam(function(err, args) {
                    if (err) {
                      callback.apply(null, [err].concat(args));
                    } else {
                      var next = iterator.next();
                      if (next) {
                        args.push(wrapIterator(next));
                      } else {
                        args.push(callback);
                      }
                      ensureAsync(iterator).apply(null, args);
                    }
                  });
                }
                wrapIterator(async.iterator(tasks))();
              };
              function _parallel(eachfn, tasks, callback) {
                callback = callback || noop;
                var results = _isArrayLike(tasks) ? [] : {};
                eachfn(
                  tasks,
                  function(task, key, callback) {
                    task(
                      _restParam(function(err, args) {
                        if (args.length <= 1) {
                          args = args[0];
                        }
                        results[key] = args;
                        callback(err);
                      })
                    );
                  },
                  function(err) {
                    callback(err, results);
                  }
                );
              }
              async.parallel = function(tasks, callback) {
                _parallel(async.eachOf, tasks, callback);
              };
              async.parallelLimit = function(tasks, limit, callback) {
                _parallel(_eachOfLimit(limit), tasks, callback);
              };
              async.series = function(tasks, callback) {
                _parallel(async.eachOfSeries, tasks, callback);
              };
              async.iterator = function(tasks) {
                function makeCallback(index) {
                  function fn() {
                    if (tasks.length) {
                      tasks[index].apply(null, arguments);
                    }
                    return fn.next();
                  }
                  fn.next = function() {
                    return index < tasks.length - 1
                      ? makeCallback(index + 1)
                      : null;
                  };
                  return fn;
                }
                return makeCallback(0);
              };
              async.apply = _restParam(function(fn, args) {
                return _restParam(function(callArgs) {
                  return fn.apply(null, args.concat(callArgs));
                });
              });
              function _concat(eachfn, arr, fn, callback) {
                var result = [];
                eachfn(
                  arr,
                  function(x, index, cb) {
                    fn(x, function(err, y) {
                      result = result.concat(y || []);
                      cb(err);
                    });
                  },
                  function(err) {
                    callback(err, result);
                  }
                );
              }
              async.concat = doParallel(_concat);
              async.concatSeries = doSeries(_concat);
              async.whilst = function(test, iterator, callback) {
                callback = callback || noop;
                if (test()) {
                  var next = _restParam(function(err, args) {
                    if (err) {
                      callback(err);
                    } else if (test.apply(this, args)) {
                      iterator(next);
                    } else {
                      callback.apply(null, [null].concat(args));
                    }
                  });
                  iterator(next);
                } else {
                  callback(null);
                }
              };
              async.doWhilst = function(iterator, test, callback) {
                var calls = 0;
                return async.whilst(
                  function() {
                    return ++calls <= 1 || test.apply(this, arguments);
                  },
                  iterator,
                  callback
                );
              };
              async.until = function(test, iterator, callback) {
                return async.whilst(
                  function() {
                    return !test.apply(this, arguments);
                  },
                  iterator,
                  callback
                );
              };
              async.doUntil = function(iterator, test, callback) {
                return async.doWhilst(
                  iterator,
                  function() {
                    return !test.apply(this, arguments);
                  },
                  callback
                );
              };
              async.during = function(test, iterator, callback) {
                callback = callback || noop;
                var next = _restParam(function(err, args) {
                  if (err) {
                    callback(err);
                  } else {
                    args.push(check);
                    test.apply(this, args);
                  }
                });
                var check = function(err, truth) {
                  if (err) {
                    callback(err);
                  } else if (truth) {
                    iterator(next);
                  } else {
                    callback(null);
                  }
                };
                test(check);
              };
              async.doDuring = function(iterator, test, callback) {
                var calls = 0;
                async.during(
                  function(next) {
                    if (calls++ < 1) {
                      next(null, true);
                    } else {
                      test.apply(this, arguments);
                    }
                  },
                  iterator,
                  callback
                );
              };
              function _queue(worker, concurrency, payload) {
                if (concurrency == null) {
                  concurrency = 1;
                } else if (concurrency === 0) {
                  throw new Error('Concurrency must not be zero');
                }
                function _insert(q, data, pos, callback) {
                  if (callback != null && typeof callback !== 'function') {
                    throw new Error('task callback must be a function');
                  }
                  q.started = true;
                  if (!_isArray(data)) {
                    data = [data];
                  }
                  if (data.length === 0 && q.idle()) {
                    return async.setImmediate(function() {
                      q.drain();
                    });
                  }
                  _arrayEach(data, function(task) {
                    var item = { data: task, callback: callback || noop };
                    if (pos) {
                      q.tasks.unshift(item);
                    } else {
                      q.tasks.push(item);
                    }
                    if (q.tasks.length === q.concurrency) {
                      q.saturated();
                    }
                  });
                  async.setImmediate(q.process);
                }
                function _next(q, tasks) {
                  return function() {
                    workers -= 1;
                    var removed = false;
                    var args = arguments;
                    _arrayEach(tasks, function(task) {
                      _arrayEach(workersList, function(worker, index) {
                        if (worker === task && !removed) {
                          workersList.splice(index, 1);
                          removed = true;
                        }
                      });
                      task.callback.apply(task, args);
                    });
                    if (q.tasks.length + workers === 0) {
                      q.drain();
                    }
                    q.process();
                  };
                }
                var workers = 0;
                var workersList = [];
                var q = {
                  tasks: [],
                  concurrency: concurrency,
                  payload: payload,
                  saturated: noop,
                  empty: noop,
                  drain: noop,
                  started: false,
                  paused: false,
                  push: function(data, callback) {
                    _insert(q, data, false, callback);
                  },
                  kill: function() {
                    q.drain = noop;
                    q.tasks = [];
                  },
                  unshift: function(data, callback) {
                    _insert(q, data, true, callback);
                  },
                  process: function() {
                    while (
                      !q.paused &&
                      workers < q.concurrency &&
                      q.tasks.length
                    ) {
                      var tasks = q.payload
                        ? q.tasks.splice(0, q.payload)
                        : q.tasks.splice(0, q.tasks.length);
                      var data = _map(tasks, function(task) {
                        return task.data;
                      });
                      if (q.tasks.length === 0) {
                        q.empty();
                      }
                      workers += 1;
                      workersList.push(tasks[0]);
                      var cb = only_once(_next(q, tasks));
                      worker(data, cb);
                    }
                  },
                  length: function() {
                    return q.tasks.length;
                  },
                  running: function() {
                    return workers;
                  },
                  workersList: function() {
                    return workersList;
                  },
                  idle: function() {
                    return q.tasks.length + workers === 0;
                  },
                  pause: function() {
                    q.paused = true;
                  },
                  resume: function() {
                    if (q.paused === false) {
                      return;
                    }
                    q.paused = false;
                    var resumeCount = Math.min(q.concurrency, q.tasks.length);
                    for (var w = 1; w <= resumeCount; w++) {
                      async.setImmediate(q.process);
                    }
                  }
                };
                return q;
              }
              async.queue = function(worker, concurrency) {
                var q = _queue(
                  function(items, cb) {
                    worker(items[0], cb);
                  },
                  concurrency,
                  1
                );
                return q;
              };
              async.priorityQueue = function(worker, concurrency) {
                function _compareTasks(a, b) {
                  return a.priority - b.priority;
                }
                function _binarySearch(sequence, item, compare) {
                  var beg = -1,
                    end = sequence.length - 1;
                  while (beg < end) {
                    var mid = beg + ((end - beg + 1) >>> 1);
                    if (compare(item, sequence[mid]) >= 0) {
                      beg = mid;
                    } else {
                      end = mid - 1;
                    }
                  }
                  return beg;
                }
                function _insert(q, data, priority, callback) {
                  if (callback != null && typeof callback !== 'function') {
                    throw new Error('task callback must be a function');
                  }
                  q.started = true;
                  if (!_isArray(data)) {
                    data = [data];
                  }
                  if (data.length === 0) {
                    return async.setImmediate(function() {
                      q.drain();
                    });
                  }
                  _arrayEach(data, function(task) {
                    var item = {
                      data: task,
                      priority: priority,
                      callback: typeof callback === 'function' ? callback : noop
                    };
                    q.tasks.splice(
                      _binarySearch(q.tasks, item, _compareTasks) + 1,
                      0,
                      item
                    );
                    if (q.tasks.length === q.concurrency) {
                      q.saturated();
                    }
                    async.setImmediate(q.process);
                  });
                }
                var q = async.queue(worker, concurrency);
                q.push = function(data, priority, callback) {
                  _insert(q, data, priority, callback);
                };
                delete q.unshift;
                return q;
              };
              async.cargo = function(worker, payload) {
                return _queue(worker, 1, payload);
              };
              function _console_fn(name) {
                return _restParam(function(fn, args) {
                  fn.apply(
                    null,
                    args.concat([
                      _restParam(function(err, args) {
                        if (typeof console === 'object') {
                          if (err) {
                            if (console.error) {
                              console.error(err);
                            }
                          } else if (console[name]) {
                            _arrayEach(args, function(x) {
                              console[name](x);
                            });
                          }
                        }
                      })
                    ])
                  );
                });
              }
              async.log = _console_fn('log');
              async.dir = _console_fn('dir');
              async.memoize = function(fn, hasher) {
                var memo = {};
                var queues = {};
                var has = Object.prototype.hasOwnProperty;
                hasher = hasher || identity;
                var memoized = _restParam(function memoized(args) {
                  var callback = args.pop();
                  var key = hasher.apply(null, args);
                  if (has.call(memo, key)) {
                    async.setImmediate(function() {
                      callback.apply(null, memo[key]);
                    });
                  } else if (has.call(queues, key)) {
                    queues[key].push(callback);
                  } else {
                    queues[key] = [callback];
                    fn.apply(
                      null,
                      args.concat([
                        _restParam(function(args) {
                          memo[key] = args;
                          var q = queues[key];
                          delete queues[key];
                          for (var i = 0, l = q.length; i < l; i++) {
                            q[i].apply(null, args);
                          }
                        })
                      ])
                    );
                  }
                });
                memoized.memo = memo;
                memoized.unmemoized = fn;
                return memoized;
              };
              async.unmemoize = function(fn) {
                return function() {
                  return (fn.unmemoized || fn).apply(null, arguments);
                };
              };
              function _times(mapper) {
                return function(count, iterator, callback) {
                  mapper(_range(count), iterator, callback);
                };
              }
              async.times = _times(async.map);
              async.timesSeries = _times(async.mapSeries);
              async.timesLimit = function(count, limit, iterator, callback) {
                return async.mapLimit(_range(count), limit, iterator, callback);
              };
              async.seq = function() {
                var fns = arguments;
                return _restParam(function(args) {
                  var that = this;
                  var callback = args[args.length - 1];
                  if (typeof callback == 'function') {
                    args.pop();
                  } else {
                    callback = noop;
                  }
                  async.reduce(
                    fns,
                    args,
                    function(newargs, fn, cb) {
                      fn.apply(
                        that,
                        newargs.concat([
                          _restParam(function(err, nextargs) {
                            cb(err, nextargs);
                          })
                        ])
                      );
                    },
                    function(err, results) {
                      callback.apply(that, [err].concat(results));
                    }
                  );
                });
              };
              async.compose = function() {
                return async.seq.apply(
                  null,
                  Array.prototype.reverse.call(arguments)
                );
              };
              function _applyEach(eachfn) {
                return _restParam(function(fns, args) {
                  var go = _restParam(function(args) {
                    var that = this;
                    var callback = args.pop();
                    return eachfn(
                      fns,
                      function(fn, _, cb) {
                        fn.apply(that, args.concat([cb]));
                      },
                      callback
                    );
                  });
                  if (args.length) {
                    return go.apply(this, args);
                  } else {
                    return go;
                  }
                });
              }
              async.applyEach = _applyEach(async.eachOf);
              async.applyEachSeries = _applyEach(async.eachOfSeries);
              async.forever = function(fn, callback) {
                var done = only_once(callback || noop);
                var task = ensureAsync(fn);
                function next(err) {
                  if (err) {
                    return done(err);
                  }
                  task(next);
                }
                next();
              };
              function ensureAsync(fn) {
                return _restParam(function(args) {
                  var callback = args.pop();
                  args.push(function() {
                    var innerArgs = arguments;
                    if (sync) {
                      async.setImmediate(function() {
                        callback.apply(null, innerArgs);
                      });
                    } else {
                      callback.apply(null, innerArgs);
                    }
                  });
                  var sync = true;
                  fn.apply(this, args);
                  sync = false;
                });
              }
              async.ensureAsync = ensureAsync;
              async.constant = _restParam(function(values) {
                var args = [null].concat(values);
                return function(callback) {
                  return callback.apply(this, args);
                };
              });
              async.wrapSync = async.asyncify = function asyncify(func) {
                return _restParam(function(args) {
                  var callback = args.pop();
                  var result;
                  try {
                    result = func.apply(this, args);
                  } catch (e) {
                    return callback(e);
                  }
                  if (_isObject(result) && typeof result.then === 'function') {
                    result
                      .then(function(value) {
                        callback(null, value);
                      })
                      ['catch'](function(err) {
                        callback(err.message ? err : new Error(err));
                      });
                  } else {
                    callback(null, result);
                  }
                });
              };
              if (typeof module === 'object' && module.exports) {
                module.exports = async;
              } else if (typeof define === 'function' && define.amd) {
                define([], function() {
                  return async;
                });
              } else {
                root.async = async;
              }
            })();
          }.call(
            this,
            require('_process'),
            typeof global !== 'undefined'
              ? global
              : typeof self !== 'undefined'
              ? self
              : typeof window !== 'undefined'
              ? window
              : {}
          ));
        },
        { _process: 223 }
      ],
      464: [
        function(require, module, exports) {
          var Buffer = require('safe-buffer').Buffer;
          function Hash(blockSize, finalSize) {
            this._block = Buffer.alloc(blockSize);
            this._finalSize = finalSize;
            this._blockSize = blockSize;
            this._len = 0;
          }
          Hash.prototype.update = function(data, enc) {
            if (typeof data === 'string') {
              enc = enc || 'utf8';
              data = Buffer.from(data, enc);
            }
            var block = this._block;
            var blockSize = this._blockSize;
            var length = data.length;
            var accum = this._len;
            for (var offset = 0; offset < length; ) {
              var assigned = accum % blockSize;
              var remainder = Math.min(length - offset, blockSize - assigned);
              for (var i = 0; i < remainder; i++) {
                block[assigned + i] = data[offset + i];
              }
              accum += remainder;
              offset += remainder;
              if (accum % blockSize === 0) {
                this._update(block);
              }
            }
            this._len += length;
            return this;
          };
          Hash.prototype.digest = function(enc) {
            var rem = this._len % this._blockSize;
            this._block[rem] = 128;
            this._block.fill(0, rem + 1);
            if (rem >= this._finalSize) {
              this._update(this._block);
              this._block.fill(0);
            }
            var bits = this._len * 8;
            if (bits <= 4294967295) {
              this._block.writeUInt32BE(bits, this._blockSize - 4);
            } else {
              var lowBits = (bits & 4294967295) >>> 0;
              var highBits = (bits - lowBits) / 4294967296;
              this._block.writeUInt32BE(highBits, this._blockSize - 8);
              this._block.writeUInt32BE(lowBits, this._blockSize - 4);
            }
            this._update(this._block);
            var hash = this._hash();
            return enc ? hash.toString(enc) : hash;
          };
          Hash.prototype._update = function() {
            throw new Error('_update must be implemented by subclass');
          };
          module.exports = Hash;
        },
        { 'safe-buffer': 460 }
      ],
      465: [
        function(require, module, exports) {
          arguments[4][251][0].apply(exports, arguments);
        },
        {
          './sha': 466,
          './sha1': 467,
          './sha224': 468,
          './sha256': 469,
          './sha384': 470,
          './sha512': 471,
          dup: 251
        }
      ],
      466: [
        function(require, module, exports) {
          arguments[4][252][0].apply(exports, arguments);
        },
        { './hash': 464, dup: 252, inherits: 381, 'safe-buffer': 460 }
      ],
      467: [
        function(require, module, exports) {
          arguments[4][253][0].apply(exports, arguments);
        },
        { './hash': 464, dup: 253, inherits: 381, 'safe-buffer': 460 }
      ],
      468: [
        function(require, module, exports) {
          arguments[4][254][0].apply(exports, arguments);
        },
        {
          './hash': 464,
          './sha256': 469,
          dup: 254,
          inherits: 381,
          'safe-buffer': 460
        }
      ],
      469: [
        function(require, module, exports) {
          arguments[4][255][0].apply(exports, arguments);
        },
        { './hash': 464, dup: 255, inherits: 381, 'safe-buffer': 460 }
      ],
      470: [
        function(require, module, exports) {
          arguments[4][256][0].apply(exports, arguments);
        },
        {
          './hash': 464,
          './sha512': 471,
          dup: 256,
          inherits: 381,
          'safe-buffer': 460
        }
      ],
      471: [
        function(require, module, exports) {
          arguments[4][257][0].apply(exports, arguments);
        },
        { './hash': 464, dup: 257, inherits: 381, 'safe-buffer': 460 }
      ],
      472: [
        function(require, module, exports) {
          (function(Buffer) {
            let BN = require('bn.js');
            let createHmac = require('create-hmac');
            let EC = require('elliptic').ec;
            let secp256k1 = new EC('secp256k1');
            const ONE1 = Buffer.alloc(1, 1);
            const ZERO1 = Buffer.alloc(1, 0);
            const ZERO32 = Buffer.alloc(32, 0);
            const EC_GROUP_ORDER = Buffer.from(
              'fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141',
              'hex'
            );
            const EC_P = Buffer.from(
              'fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f',
              'hex'
            );
            const n = secp256k1.curve.n;
            const nDiv2 = n.shrn(1);
            const G = secp256k1.curve.g;
            let THROW_BAD_PRIVATE = 'Expected Private';
            let THROW_BAD_POINT = 'Expected Point';
            let THROW_BAD_TWEAK = 'Expected Tweak';
            let THROW_BAD_HASH = 'Expected Hash';
            let THROW_BAD_SIGNATURE = 'Expected Signature';
            function isScalar(x) {
              return Buffer.isBuffer(x) && x.length === 32;
            }
            function isOrderScalar(x) {
              if (!isScalar(x)) return false;
              return x.compare(EC_GROUP_ORDER) < 0;
            }
            function isPoint(p) {
              if (!Buffer.isBuffer(p)) return false;
              if (p.length < 33) return false;
              let t = p[0];
              let x = p.slice(1, 33);
              if (x.compare(ZERO32) === 0) return false;
              if (x.compare(EC_P) >= 0) return false;
              if ((t === 2 || t === 3) && p.length === 33) return true;
              let y = p.slice(33);
              if (y.compare(ZERO32) === 0) return false;
              if (y.compare(EC_P) >= 0) return false;
              if (t === 4 && p.length === 65) return true;
              return false;
            }
            function __isPointCompressed(p) {
              return p[0] !== 4;
            }
            function isPointCompressed(p) {
              if (!isPoint(p)) return false;
              return __isPointCompressed(p);
            }
            function isPrivate(x) {
              if (!isScalar(x)) return false;
              return x.compare(ZERO32) > 0 && x.compare(EC_GROUP_ORDER) < 0;
            }
            function isSignature(value) {
              let r = value.slice(0, 32);
              let s = value.slice(32, 64);
              return (
                Buffer.isBuffer(value) &&
                value.length === 64 &&
                r.compare(EC_GROUP_ORDER) < 0 &&
                s.compare(EC_GROUP_ORDER) < 0
              );
            }
            function assumeCompression(value, pubkey) {
              if (value === undefined && pubkey !== undefined)
                return __isPointCompressed(pubkey);
              if (value === undefined) return true;
              return value;
            }
            function fromBuffer(d) {
              return new BN(d);
            }
            function toBuffer(d) {
              return d.toArrayLike(Buffer, 'be', 32);
            }
            function decodeFrom(P) {
              return secp256k1.curve.decodePoint(P);
            }
            function getEncoded(P, compressed) {
              return Buffer.from(P._encode(compressed));
            }
            function pointAdd(pA, pB, __compressed) {
              if (!isPoint(pA)) throw new TypeError(THROW_BAD_POINT);
              if (!isPoint(pB)) throw new TypeError(THROW_BAD_POINT);
              let a = decodeFrom(pA);
              let b = decodeFrom(pB);
              let pp = a.add(b);
              if (pp.isInfinity()) return null;
              let compressed = assumeCompression(__compressed, pA);
              return getEncoded(pp, compressed);
            }
            function pointAddScalar(p, tweak, __compressed) {
              if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT);
              if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK);
              let compressed = assumeCompression(__compressed, p);
              let pp = decodeFrom(p);
              if (tweak.compare(ZERO32) === 0)
                return getEncoded(pp, compressed);
              let tt = fromBuffer(tweak);
              let qq = G.mul(tt);
              let uu = pp.add(qq);
              if (uu.isInfinity()) return null;
              return getEncoded(uu, compressed);
            }
            function pointCompress(p, compressed) {
              if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT);
              let pp = decodeFrom(p);
              if (pp.isInfinity()) throw new TypeError(THROW_BAD_POINT);
              return getEncoded(pp, compressed);
            }
            function pointFromScalar(d, __compressed) {
              if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE);
              let dd = fromBuffer(d);
              let pp = G.mul(dd);
              if (pp.isInfinity()) return null;
              let compressed = assumeCompression(__compressed);
              return getEncoded(pp, compressed);
            }
            function pointMultiply(p, tweak, __compressed) {
              if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT);
              if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK);
              let compressed = assumeCompression(__compressed, p);
              let pp = decodeFrom(p);
              let tt = fromBuffer(tweak);
              let qq = pp.mul(tt);
              if (qq.isInfinity()) return null;
              return getEncoded(qq, compressed);
            }
            function privateAdd(d, tweak) {
              if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE);
              if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK);
              let dd = fromBuffer(d);
              let tt = fromBuffer(tweak);
              let dt = toBuffer(dd.add(tt).umod(n));
              if (!isPrivate(dt)) return null;
              return dt;
            }
            function privateSub(d, tweak) {
              if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE);
              if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK);
              let dd = fromBuffer(d);
              let tt = fromBuffer(tweak);
              let dt = toBuffer(dd.sub(tt).umod(n));
              if (!isPrivate(dt)) return null;
              return dt;
            }
            function deterministicGenerateK(hash, x, checkSig) {
              let k = Buffer.alloc(32, 0);
              let v = Buffer.alloc(32, 1);
              k = createHmac('sha256', k)
                .update(v)
                .update(ZERO1)
                .update(x)
                .update(hash)
                .digest();
              v = createHmac('sha256', k)
                .update(v)
                .digest();
              k = createHmac('sha256', k)
                .update(v)
                .update(ONE1)
                .update(x)
                .update(hash)
                .digest();
              v = createHmac('sha256', k)
                .update(v)
                .digest();
              v = createHmac('sha256', k)
                .update(v)
                .digest();
              let T = v;
              while (!isPrivate(T) || !checkSig(T)) {
                k = createHmac('sha256', k)
                  .update(v)
                  .update(ZERO1)
                  .digest();
                v = createHmac('sha256', k)
                  .update(v)
                  .digest();
                v = createHmac('sha256', k)
                  .update(v)
                  .digest();
                T = v;
              }
              return T;
            }
            function sign(hash, x) {
              if (!isScalar(hash)) throw new TypeError(THROW_BAD_HASH);
              if (!isPrivate(x)) throw new TypeError(THROW_BAD_PRIVATE);
              let d = fromBuffer(x);
              let e = fromBuffer(hash);
              let r, s;
              deterministicGenerateK(hash, x, function(k) {
                let kI = fromBuffer(k);
                let Q = G.mul(kI);
                if (Q.isInfinity()) return false;
                r = Q.x.umod(n);
                if (r.isZero() === 0) return false;
                s = kI
                  .invm(n)
                  .mul(e.add(d.mul(r)))
                  .umod(n);
                if (s.isZero() === 0) return false;
                return true;
              });
              if (s.cmp(nDiv2) > 0) {
                s = n.sub(s);
              }
              let buffer = Buffer.allocUnsafe(64);
              toBuffer(r).copy(buffer, 0);
              toBuffer(s).copy(buffer, 32);
              return buffer;
            }
            function verify(hash, q, signature) {
              if (!isScalar(hash)) throw new TypeError(THROW_BAD_HASH);
              if (!isPoint(q)) throw new TypeError(THROW_BAD_POINT);
              if (!isSignature(signature))
                throw new TypeError(THROW_BAD_SIGNATURE);
              let Q = decodeFrom(q);
              let r = fromBuffer(signature.slice(0, 32));
              let s = fromBuffer(signature.slice(32, 64));
              if (r.gtn(0) <= 0) return false;
              if (s.gtn(0) <= 0) return false;
              let e = fromBuffer(hash);
              let sInv = s.invm(n);
              let u1 = e.mul(sInv).umod(n);
              let u2 = r.mul(sInv).umod(n);
              let R = G.mulAdd(u1, Q, u2);
              if (R.isInfinity()) return false;
              let xR = R.x;
              let v = xR.umod(n);
              return v.eq(r);
            }
            module.exports = {
              isPoint: isPoint,
              isPointCompressed: isPointCompressed,
              isPrivate: isPrivate,
              pointAdd: pointAdd,
              pointAddScalar: pointAddScalar,
              pointCompress: pointCompress,
              pointFromScalar: pointFromScalar,
              pointMultiply: pointMultiply,
              privateAdd: privateAdd,
              privateSub: privateSub,
              sign: sign,
              verify: verify
            };
          }.call(this, require('buffer').Buffer));
        },
        { 'bn.js': 134, buffer: 183, 'create-hmac': 285, elliptic: 309 }
      ],
      473: [
        function(require, module, exports) {
          (function() {
            var AES,
              BlockCipher,
              G,
              Global,
              scrub_vec,
              __hasProp = {}.hasOwnProperty,
              __extends = function(child, parent) {
                for (var key in parent) {
                  if (__hasProp.call(parent, key)) child[key] = parent[key];
                }
                function ctor() {
                  this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
              };
            BlockCipher = require('./algbase').BlockCipher;
            scrub_vec = require('./util').scrub_vec;
            Global = (function() {
              function Global() {
                var i;
                this.SBOX = [];
                this.INV_SBOX = [];
                this.SUB_MIX = (function() {
                  var _i, _results;
                  _results = [];
                  for (i = _i = 0; _i < 4; i = ++_i) {
                    _results.push([]);
                  }
                  return _results;
                })();
                this.INV_SUB_MIX = (function() {
                  var _i, _results;
                  _results = [];
                  for (i = _i = 0; _i < 4; i = ++_i) {
                    _results.push([]);
                  }
                  return _results;
                })();
                this.init();
                this.RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
              }
              Global.prototype.init = function() {
                var d, i, sx, t, x, x2, x4, x8, xi, _i;
                d = (function() {
                  var _i, _results;
                  _results = [];
                  for (i = _i = 0; _i < 256; i = ++_i) {
                    if (i < 128) {
                      _results.push(i << 1);
                    } else {
                      _results.push((i << 1) ^ 283);
                    }
                  }
                  return _results;
                })();
                x = 0;
                xi = 0;
                for (i = _i = 0; _i < 256; i = ++_i) {
                  sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
                  sx = (sx >>> 8) ^ (sx & 255) ^ 99;
                  this.SBOX[x] = sx;
                  this.INV_SBOX[sx] = x;
                  x2 = d[x];
                  x4 = d[x2];
                  x8 = d[x4];
                  t = (d[sx] * 257) ^ (sx * 16843008);
                  this.SUB_MIX[0][x] = (t << 24) | (t >>> 8);
                  this.SUB_MIX[1][x] = (t << 16) | (t >>> 16);
                  this.SUB_MIX[2][x] = (t << 8) | (t >>> 24);
                  this.SUB_MIX[3][x] = t;
                  t =
                    (x8 * 16843009) ^
                    (x4 * 65537) ^
                    (x2 * 257) ^
                    (x * 16843008);
                  this.INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8);
                  this.INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16);
                  this.INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24);
                  this.INV_SUB_MIX[3][sx] = t;
                  if (x === 0) {
                    x = xi = 1;
                  } else {
                    x = x2 ^ d[d[d[x8 ^ x2]]];
                    xi ^= d[d[xi]];
                  }
                }
                return true;
              };
              return Global;
            })();
            G = new Global();
            AES = (function(_super) {
              __extends(AES, _super);
              AES.blockSize = 4 * 4;
              AES.prototype.blockSize = AES.blockSize;
              AES.keySize = 256 / 8;
              AES.prototype.keySize = AES.keySize;
              AES.ivSize = AES.blockSize;
              AES.prototype.ivSize = AES.ivSize;
              function AES(key) {
                this._key = key.clone();
                this._doReset();
              }
              AES.prototype._doReset = function() {
                var invKsRow, keySize, keyWords, ksRow, ksRows, t, _i, _j;
                keyWords = this._key.words;
                keySize = this._key.sigBytes / 4;
                this._nRounds = keySize + 6;
                ksRows = (this._nRounds + 1) * 4;
                this._keySchedule = [];
                for (
                  ksRow = _i = 0;
                  0 <= ksRows ? _i < ksRows : _i > ksRows;
                  ksRow = 0 <= ksRows ? ++_i : --_i
                ) {
                  this._keySchedule[ksRow] =
                    ksRow < keySize
                      ? keyWords[ksRow]
                      : ((t = this._keySchedule[ksRow - 1]),
                        ksRow % keySize === 0
                          ? ((t = (t << 8) | (t >>> 24)),
                            (t =
                              (G.SBOX[t >>> 24] << 24) |
                              (G.SBOX[(t >>> 16) & 255] << 16) |
                              (G.SBOX[(t >>> 8) & 255] << 8) |
                              G.SBOX[t & 255]),
                            (t ^= G.RCON[(ksRow / keySize) | 0] << 24))
                          : keySize > 6 && ksRow % keySize === 4
                          ? (t =
                              (G.SBOX[t >>> 24] << 24) |
                              (G.SBOX[(t >>> 16) & 255] << 16) |
                              (G.SBOX[(t >>> 8) & 255] << 8) |
                              G.SBOX[t & 255])
                          : void 0,
                        this._keySchedule[ksRow - keySize] ^ t);
                }
                this._invKeySchedule = [];
                for (
                  invKsRow = _j = 0;
                  0 <= ksRows ? _j < ksRows : _j > ksRows;
                  invKsRow = 0 <= ksRows ? ++_j : --_j
                ) {
                  ksRow = ksRows - invKsRow;
                  t = this._keySchedule[ksRow - (invKsRow % 4 ? 0 : 4)];
                  this._invKeySchedule[invKsRow] =
                    invKsRow < 4 || ksRow <= 4
                      ? t
                      : G.INV_SUB_MIX[0][G.SBOX[t >>> 24]] ^
                        G.INV_SUB_MIX[1][G.SBOX[(t >>> 16) & 255]] ^
                        G.INV_SUB_MIX[2][G.SBOX[(t >>> 8) & 255]] ^
                        G.INV_SUB_MIX[3][G.SBOX[t & 255]];
                }
                return true;
              };
              AES.prototype.encryptBlock = function(M, offset) {
                if (offset == null) {
                  offset = 0;
                }
                return this._doCryptBlock(
                  M,
                  offset,
                  this._keySchedule,
                  G.SUB_MIX,
                  G.SBOX
                );
              };
              AES.prototype.decryptBlock = function(M, offset) {
                var _ref, _ref1;
                if (offset == null) {
                  offset = 0;
                }
                (_ref = [M[offset + 3], M[offset + 1]]),
                  (M[offset + 1] = _ref[0]),
                  (M[offset + 3] = _ref[1]);
                this._doCryptBlock(
                  M,
                  offset,
                  this._invKeySchedule,
                  G.INV_SUB_MIX,
                  G.INV_SBOX
                );
                return (
                  (_ref1 = [M[offset + 3], M[offset + 1]]),
                  (M[offset + 1] = _ref1[0]),
                  (M[offset + 3] = _ref1[1]),
                  _ref1
                );
              };
              AES.prototype.scrub = function() {
                scrub_vec(this._keySchedule);
                scrub_vec(this._invKeySchedule);
                return this._key.scrub();
              };
              AES.prototype._doCryptBlock = function(
                M,
                offset,
                keySchedule,
                SUB_MIX,
                SBOX
              ) {
                var ksRow, round, s0, s1, s2, s3, t0, t1, t2, t3, _i, _ref;
                s0 = M[offset] ^ keySchedule[0];
                s1 = M[offset + 1] ^ keySchedule[1];
                s2 = M[offset + 2] ^ keySchedule[2];
                s3 = M[offset + 3] ^ keySchedule[3];
                ksRow = 4;
                for (
                  round = _i = 1, _ref = this._nRounds;
                  1 <= _ref ? _i < _ref : _i > _ref;
                  round = 1 <= _ref ? ++_i : --_i
                ) {
                  t0 =
                    SUB_MIX[0][s0 >>> 24] ^
                    SUB_MIX[1][(s1 >>> 16) & 255] ^
                    SUB_MIX[2][(s2 >>> 8) & 255] ^
                    SUB_MIX[3][s3 & 255] ^
                    keySchedule[ksRow++];
                  t1 =
                    SUB_MIX[0][s1 >>> 24] ^
                    SUB_MIX[1][(s2 >>> 16) & 255] ^
                    SUB_MIX[2][(s3 >>> 8) & 255] ^
                    SUB_MIX[3][s0 & 255] ^
                    keySchedule[ksRow++];
                  t2 =
                    SUB_MIX[0][s2 >>> 24] ^
                    SUB_MIX[1][(s3 >>> 16) & 255] ^
                    SUB_MIX[2][(s0 >>> 8) & 255] ^
                    SUB_MIX[3][s1 & 255] ^
                    keySchedule[ksRow++];
                  t3 =
                    SUB_MIX[0][s3 >>> 24] ^
                    SUB_MIX[1][(s0 >>> 16) & 255] ^
                    SUB_MIX[2][(s1 >>> 8) & 255] ^
                    SUB_MIX[3][s2 & 255] ^
                    keySchedule[ksRow++];
                  s0 = t0;
                  s1 = t1;
                  s2 = t2;
                  s3 = t3;
                }
                t0 =
                  ((SBOX[s0 >>> 24] << 24) |
                    (SBOX[(s1 >>> 16) & 255] << 16) |
                    (SBOX[(s2 >>> 8) & 255] << 8) |
                    SBOX[s3 & 255]) ^
                  keySchedule[ksRow++];
                t1 =
                  ((SBOX[s1 >>> 24] << 24) |
                    (SBOX[(s2 >>> 16) & 255] << 16) |
                    (SBOX[(s3 >>> 8) & 255] << 8) |
                    SBOX[s0 & 255]) ^
                  keySchedule[ksRow++];
                t2 =
                  ((SBOX[s2 >>> 24] << 24) |
                    (SBOX[(s3 >>> 16) & 255] << 16) |
                    (SBOX[(s0 >>> 8) & 255] << 8) |
                    SBOX[s1 & 255]) ^
                  keySchedule[ksRow++];
                t3 =
                  ((SBOX[s3 >>> 24] << 24) |
                    (SBOX[(s0 >>> 16) & 255] << 16) |
                    (SBOX[(s1 >>> 8) & 255] << 8) |
                    SBOX[s2 & 255]) ^
                  keySchedule[ksRow++];
                M[offset] = t0;
                M[offset + 1] = t1;
                M[offset + 2] = t2;
                return (M[offset + 3] = t3);
              };
              return AES;
            })(BlockCipher);
            exports.AES = AES;
          }.call(this));
        },
        { './algbase': 474, './util': 495 }
      ],
      474: [
        function(require, module, exports) {
          (function() {
            var BlockCipher,
              BufferedBlockAlgorithm,
              Hasher,
              StreamCipher,
              WordArray,
              util,
              __hasProp = {}.hasOwnProperty,
              __extends = function(child, parent) {
                for (var key in parent) {
                  if (__hasProp.call(parent, key)) child[key] = parent[key];
                }
                function ctor() {
                  this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
              };
            WordArray = require('./wordarray').WordArray;
            util = require('./util');
            BufferedBlockAlgorithm = (function() {
              BufferedBlockAlgorithm.prototype._minBufferSize = 0;
              function BufferedBlockAlgorithm() {
                this.reset();
              }
              BufferedBlockAlgorithm.prototype.reset = function() {
                this._data = new WordArray();
                return (this._nDataBytes = 0);
              };
              BufferedBlockAlgorithm.prototype._append = function(data) {
                this._data.concat(data);
                return (this._nDataBytes += data.sigBytes);
              };
              BufferedBlockAlgorithm.prototype._process = function(doFlush) {
                var blockSizeBytes,
                  data,
                  dataSigBytes,
                  dataWords,
                  nBlocksReady,
                  nBytesReady,
                  nWordsReady,
                  offset,
                  processedWords,
                  _i,
                  _ref;
                data = this._data;
                dataWords = data.words;
                dataSigBytes = data.sigBytes;
                blockSizeBytes = this.blockSize * 4;
                nBlocksReady = dataSigBytes / blockSizeBytes;
                if (doFlush) {
                  nBlocksReady = Math.ceil(nBlocksReady);
                } else {
                  nBlocksReady = Math.max(
                    (nBlocksReady | 0) - this._minBufferSize,
                    0
                  );
                }
                nWordsReady = nBlocksReady * this.blockSize;
                nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);
                if (nWordsReady) {
                  for (
                    offset = _i = 0, _ref = this.blockSize;
                    _ref > 0 ? _i < nWordsReady : _i > nWordsReady;
                    offset = _i += _ref
                  ) {
                    this._doProcessBlock(dataWords, offset);
                  }
                  processedWords = dataWords.splice(0, nWordsReady);
                  data.sigBytes -= nBytesReady;
                }
                return new WordArray(processedWords, nBytesReady);
              };
              BufferedBlockAlgorithm.prototype.copy_to = function(out) {
                out._data = this._data.clone();
                return (out._nDataBytes = this._nDataBytes);
              };
              BufferedBlockAlgorithm.prototype.clone = function() {
                var obj;
                obj = new BufferedBlockAlgorithm();
                this.copy_to(obj);
                return obj;
              };
              return BufferedBlockAlgorithm;
            })();
            Hasher = (function(_super) {
              __extends(Hasher, _super);
              function Hasher() {
                Hasher.__super__.constructor.call(this);
              }
              Hasher.prototype.reset = function() {
                Hasher.__super__.reset.call(this);
                this._doReset();
                return this;
              };
              Hasher.prototype.update = function(messageUpdate) {
                this._append(messageUpdate);
                this._process();
                return this;
              };
              Hasher.prototype.finalize = function(messageUpdate) {
                if (messageUpdate) {
                  this._append(messageUpdate);
                }
                return this._doFinalize();
              };
              Hasher.prototype.bufhash = function(input) {
                var out, wa_in, wa_out;
                wa_in = WordArray.from_buffer(input);
                wa_out = this.finalize(wa_in);
                out = wa_out.to_buffer();
                wa_in.scrub();
                wa_out.scrub();
                return out;
              };
              return Hasher;
            })(BufferedBlockAlgorithm);
            exports.BlockCipher = BlockCipher = (function() {
              function BlockCipher(key) {}
              BlockCipher.prototype.encryptBlock = function(M, offset) {};
              return BlockCipher;
            })();
            StreamCipher = (function() {
              function StreamCipher() {}
              StreamCipher.prototype.encryptBlock = function(
                word_array,
                dst_offset
              ) {
                var n_words, pad;
                if (dst_offset == null) {
                  dst_offset = 0;
                }
                pad = this.get_pad();
                n_words = Math.min(
                  word_array.words.length - dst_offset,
                  this.bsiw
                );
                word_array.xor(pad, {
                  dst_offset: dst_offset,
                  n_words: n_words
                });
                pad.scrub();
                return this.bsiw;
              };
              StreamCipher.prototype.encrypt = function(word_array) {
                var i, _i, _ref, _ref1;
                for (
                  i = _i = 0, _ref = word_array.words.length, _ref1 = this.bsiw;
                  _ref1 > 0 ? _i < _ref : _i > _ref;
                  i = _i += _ref1
                ) {
                  this.encryptBlock(word_array, i);
                }
                return word_array;
              };
              StreamCipher.prototype.bulk_encrypt = function(_arg, cb) {
                var async_args, input, progress_hook, slice_args, what;
                (input = _arg.input),
                  (progress_hook = _arg.progress_hook),
                  (what = _arg.what);
                slice_args = {
                  update: (function(_this) {
                    return function(lo, hi) {
                      var i, _i, _ref, _results;
                      _results = [];
                      for (
                        i = _i = lo, _ref = _this.bsiw;
                        _ref > 0 ? _i < hi : _i > hi;
                        i = _i += _ref
                      ) {
                        _results.push(_this.encryptBlock(input, i));
                      }
                      return _results;
                    };
                  })(this),
                  finalize: function() {
                    return input;
                  },
                  default_n: this.bsiw * 1024
                };
                async_args = {
                  progress_hook: progress_hook,
                  cb: cb,
                  what: what
                };
                return util.bulk(input.sigBytes, slice_args, async_args);
              };
              return StreamCipher;
            })();
            exports.BlockCipher = BlockCipher;
            exports.Hasher = Hasher;
            exports.BufferedBlockAlgorithm = BufferedBlockAlgorithm;
            exports.StreamCipher = StreamCipher;
          }.call(this));
        },
        { './util': 495, './wordarray': 496 }
      ],
      475: [
        function(require, module, exports) {
          (function() {
            var CombineBase,
              Concat,
              HMAC,
              SHA3,
              SHA512,
              WordArray,
              XOR,
              bulk_sign,
              _ref,
              __hasProp = {}.hasOwnProperty,
              __extends = function(child, parent) {
                for (var key in parent) {
                  if (__hasProp.call(parent, key)) child[key] = parent[key];
                }
                function ctor() {
                  this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
              };
            (_ref = require('./hmac')),
              (HMAC = _ref.HMAC),
              (bulk_sign = _ref.bulk_sign);
            SHA512 = require('./sha512').SHA512;
            SHA3 = require('./sha3').SHA3;
            WordArray = require('./wordarray').WordArray;
            CombineBase = (function() {
              function CombineBase() {
                this.hasherBlockSize = this.hashers[0].hasherBlockSize;
                this.hasherBlockSizeBytes = this.hasherBlockSize * 4;
                this.reset();
              }
              CombineBase.prototype.reset = function() {
                var h, _i, _len, _ref1;
                _ref1 = this.hashers;
                for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                  h = _ref1[_i];
                  h.reset();
                }
                return this;
              };
              CombineBase.prototype.update = function(w) {
                var h, _i, _len, _ref1;
                _ref1 = this.hashers;
                for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                  h = _ref1[_i];
                  h.update(w);
                }
                return this;
              };
              CombineBase.prototype.scrub = function() {
                var h, _i, _len, _ref1;
                _ref1 = this.hashers;
                for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                  h = _ref1[_i];
                  h.scrub();
                }
                return this;
              };
              CombineBase.prototype.finalize = function(w) {
                var h, hashes, out, _i, _len, _ref1;
                hashes = function() {
                  var _i, _len, _ref1, _results;
                  _ref1 = this.hashers;
                  _results = [];
                  for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                    h = _ref1[_i];
                    _results.push(h.finalize(w));
                  }
                  return _results;
                }.call(this);
                out = hashes[0];
                _ref1 = hashes.slice(1);
                for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                  h = _ref1[_i];
                  this._coalesce(out, h);
                  h.scrub();
                }
                return out;
              };
              return CombineBase;
            })();
            Concat = (function(_super) {
              __extends(Concat, _super);
              function Concat(key, klasses) {
                var hm, i, klass, subkey, subkeys;
                if (klasses == null) {
                  klasses = [SHA512, SHA3];
                }
                subkeys = key.split(klasses.length);
                this.hashers = (function() {
                  var _i, _len, _results;
                  _results = [];
                  for (i = _i = 0, _len = klasses.length; _i < _len; i = ++_i) {
                    klass = klasses[i];
                    subkey = subkeys[i];
                    hm = new HMAC(subkey, klass);
                    subkey.scrub();
                    _results.push(hm);
                  }
                  return _results;
                })();
                Concat.__super__.constructor.call(this);
              }
              Concat.get_output_size = function() {
                return SHA512.output_size + SHA3.output_size;
              };
              Concat.prototype._coalesce = function(out, h) {
                return out.concat(h);
              };
              Concat.prototype.get_output_size = function() {
                var h, tot, _i, _len, _ref1;
                tot = 0;
                _ref1 = this.hashers;
                for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                  h = _ref1[_i];
                  tot += h.get_output_size();
                }
                return tot;
              };
              Concat.sign = function(_arg) {
                var input, key;
                (key = _arg.key), (input = _arg.input);
                return new Concat(key).finalize(input);
              };
              Concat.bulk_sign = function(args, cb) {
                args.klass = Concat;
                args.what = 'HMAC-SHA512-SHA3';
                return bulk_sign(args, cb);
              };
              return Concat;
            })(CombineBase);
            XOR = (function(_super) {
              __extends(XOR, _super);
              function XOR(key, klasses) {
                var klass;
                if (klasses == null) {
                  klasses = [SHA512, SHA3];
                }
                this.hashers = (function() {
                  var _i, _len, _results;
                  _results = [];
                  for (_i = 0, _len = klasses.length; _i < _len; _i++) {
                    klass = klasses[_i];
                    _results.push(new HMAC(key, klass));
                  }
                  return _results;
                })();
                XOR.__super__.constructor.call(this);
              }
              XOR.prototype.reset = function() {
                var h, i, _i, _len, _ref1;
                XOR.__super__.reset.call(this);
                _ref1 = this.hashers;
                for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
                  h = _ref1[i];
                  h.update(new WordArray([i]));
                }
                return this;
              };
              XOR.get_output_size = function() {
                return Math.max(SHA512.output_size, SHA3.output_size);
              };
              XOR.prototype._coalesce = function(out, h) {
                return out.xor(h, {});
              };
              XOR.prototype.get_output_size = function() {
                var h;
                return Math.max.apply(
                  Math,
                  function() {
                    var _i, _len, _ref1, _results;
                    _ref1 = this.hashers;
                    _results = [];
                    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                      h = _ref1[_i];
                      _results.push(h.get_output_size());
                    }
                    return _results;
                  }.call(this)
                );
              };
              XOR.sign = function(_arg) {
                var input, key;
                (key = _arg.key), (input = _arg.input);
                return new XOR(key).finalize(input);
              };
              XOR.bulk_sign = function(arg, cb) {
                arg.klass = XOR;
                arg.what = 'HMAC-SHA512-XOR-SHA3';
                return bulk_sign(arg, cb);
              };
              return XOR;
            })(CombineBase);
            exports.Concat = Concat;
            exports.XOR = XOR;
          }.call(this));
        },
        { './hmac': 480, './sha3': 491, './sha512': 493, './wordarray': 496 }
      ],
      476: [
        function(require, module, exports) {
          (function() {
            var Cipher,
              Counter,
              StreamCipher,
              WordArray,
              bulk_encrypt,
              encrypt,
              iced,
              __iced_k,
              __iced_k_noop,
              __hasProp = {}.hasOwnProperty,
              __extends = function(child, parent) {
                for (var key in parent) {
                  if (__hasProp.call(parent, key)) child[key] = parent[key];
                }
                function ctor() {
                  this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
              };
            iced = require('iced-runtime');
            __iced_k = __iced_k_noop = function() {};
            WordArray = require('./wordarray').WordArray;
            StreamCipher = require('./algbase').StreamCipher;
            Counter = (function() {
              Counter.prototype.WORD_MAX = 4294967295;
              function Counter(_arg) {
                var i, len, value;
                (value = _arg.value), (len = _arg.len);
                this._value =
                  value != null
                    ? value.clone()
                    : (len == null ? (len = 2) : void 0,
                      new WordArray(
                        (function() {
                          var _i, _results;
                          _results = [];
                          for (
                            i = _i = 0;
                            0 <= len ? _i < len : _i > len;
                            i = 0 <= len ? ++_i : --_i
                          ) {
                            _results.push(0);
                          }
                          return _results;
                        })()
                      ));
              }
              Counter.prototype.inc = function() {
                var go, i;
                go = true;
                i = this._value.words.length - 1;
                while (go && i >= 0) {
                  if (++this._value.words[i] > Counter.WORD_MAX) {
                    this._value.words[i] = 0;
                  } else {
                    go = false;
                  }
                  i--;
                }
                return this;
              };
              Counter.prototype.inc_le = function() {
                var go, i;
                go = true;
                i = 0;
                while (go && i < this._value.words.length) {
                  if (++this._value.words[i] > Counter.WORD_MAX) {
                    this._value.words[i] = 0;
                  } else {
                    go = false;
                  }
                  i++;
                }
                return this;
              };
              Counter.prototype.get = function() {
                return this._value;
              };
              Counter.prototype.copy = function() {
                return this._value.clone();
              };
              return Counter;
            })();
            Cipher = (function(_super) {
              __extends(Cipher, _super);
              function Cipher(_arg) {
                (this.block_cipher = _arg.block_cipher), (this.iv = _arg.iv);
                Cipher.__super__.constructor.call(this);
                this.bsiw = this.block_cipher.blockSize / 4;
                if (!(this.iv.sigBytes === this.block_cipher.blockSize)) {
                  throw new Error(
                    'IV is wrong length (' + this.iv.sigBytes + ')'
                  );
                }
                this.ctr = new Counter({ value: this.iv });
              }
              Cipher.prototype.scrub = function() {
                return this.block_cipher.scrub();
              };
              Cipher.prototype.get_pad = function() {
                var pad;
                pad = this.ctr.copy();
                this.ctr.inc();
                this.block_cipher.encryptBlock(pad.words);
                return pad;
              };
              return Cipher;
            })(StreamCipher);
            encrypt = function(_arg) {
              var block_cipher, cipher, input, iv, ret;
              (block_cipher = _arg.block_cipher),
                (iv = _arg.iv),
                (input = _arg.input);
              cipher = new Cipher({ block_cipher: block_cipher, iv: iv });
              ret = cipher.encrypt(input);
              cipher.scrub();
              return ret;
            };
            bulk_encrypt = function(_arg, cb) {
              var block_cipher,
                cipher,
                input,
                iv,
                progress_hook,
                ret,
                what,
                ___iced_passed_deferral,
                __iced_deferrals,
                __iced_k;
              __iced_k = __iced_k_noop;
              ___iced_passed_deferral = iced.findDeferral(arguments);
              (block_cipher = _arg.block_cipher),
                (iv = _arg.iv),
                (input = _arg.input),
                (progress_hook = _arg.progress_hook),
                (what = _arg.what);
              cipher = new Cipher({ block_cipher: block_cipher, iv: iv });
              (function(_this) {
                return function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: '/Users/max/src/keybase/triplesec/src/ctr.iced'
                  });
                  cipher.bulk_encrypt(
                    { input: input, progress_hook: progress_hook, what: what },
                    __iced_deferrals.defer({
                      assign_fn: (function() {
                        return function() {
                          return (ret = arguments[0]);
                        };
                      })(),
                      lineno: 121
                    })
                  );
                  __iced_deferrals._fulfill();
                };
              })(this)(
                (function(_this) {
                  return function() {
                    return cb(ret);
                  };
                })(this)
              );
            };
            exports.Counter = Counter;
            exports.Cipher = Cipher;
            exports.encrypt = encrypt;
            exports.bulk_encrypt = bulk_encrypt;
          }.call(this));
        },
        { './algbase': 474, './wordarray': 496, 'iced-runtime': 379 }
      ],
      477: [
        function(require, module, exports) {
          (function() {
            var AES,
              Base,
              Concat,
              Decryptor,
              SHA512,
              Salsa20,
              TwoFish,
              V,
              WordArray,
              ctr,
              decrypt,
              iced,
              make_esc,
              salsa20,
              __iced_k,
              __iced_k_noop,
              _ref,
              __hasProp = {}.hasOwnProperty,
              __extends = function(child, parent) {
                for (var key in parent) {
                  if (__hasProp.call(parent, key)) child[key] = parent[key];
                }
                function ctor() {
                  this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
              };
            iced = require('iced-runtime');
            __iced_k = __iced_k_noop = function() {};
            WordArray = require('./wordarray').WordArray;
            salsa20 = require('./salsa20');
            AES = require('./aes').AES;
            TwoFish = require('./twofish').TwoFish;
            ctr = require('./ctr');
            Concat = require('./combine').Concat;
            SHA512 = require('./sha512').SHA512;
            Salsa20 = require('./salsa20').Salsa20;
            (_ref = require('./enc')), (Base = _ref.Base), (V = _ref.V);
            make_esc = require('iced-error').make_esc;
            Decryptor = (function(_super) {
              __extends(Decryptor, _super);
              function Decryptor(_arg) {
                var enc, key;
                (key = _arg.key), (enc = _arg.enc);
                Decryptor.__super__.constructor.call(this, { key: key });
                if (enc != null) {
                  this.key = enc.key;
                  this.derived_keys = enc.derived_keys;
                }
              }
              Decryptor.prototype.read_header = function(cb) {
                var err, wa;
                err =
                  (wa = this.ct.unshift(2)) == null
                    ? new Error('Ciphertext underrun in header')
                    : (this.version = V[wa.words[1]]) == null
                    ? new Error(
                        "bad header; couldn't find a good version (got " +
                          wa.words[1] +
                          ')'
                      )
                    : wa.words[0] !== this.version.header[0]
                    ? new Error('Bad header: unrecognized magic value')
                    : null;
                return cb(err);
              };
              Decryptor.prototype.verify_sig = function(key, cb) {
                var computed,
                  err,
                  received,
                  ___iced_passed_deferral,
                  __iced_deferrals,
                  __iced_k;
                __iced_k = __iced_k_noop;
                ___iced_passed_deferral = iced.findDeferral(arguments);
                (function(_this) {
                  return function(__iced_k) {
                    if (
                      (received = _this.ct.unshift(
                        Concat.get_output_size() / 4
                      )) == null
                    ) {
                      return __iced_k(
                        (err = new Error('Ciphertext underrun in signature'))
                      );
                    } else {
                      (function(__iced_k) {
                        __iced_deferrals = new iced.Deferrals(__iced_k, {
                          parent: ___iced_passed_deferral,
                          filename:
                            '/Users/max/src/keybase/triplesec/src/dec.iced',
                          funcname: 'Decryptor.verify_sig'
                        });
                        _this.sign(
                          { input: _this.ct, key: key, salt: _this.salt },
                          __iced_deferrals.defer({
                            assign_fn: (function() {
                              return function() {
                                err = arguments[0];
                                return (computed = arguments[1]);
                              };
                            })(),
                            lineno: 63
                          })
                        );
                        __iced_deferrals._fulfill();
                      })(function() {
                        return __iced_k(
                          (err =
                            err != null
                              ? err
                              : received.equal(computed)
                              ? null
                              : new Error(
                                  'Signature mismatch or bad decryption key'
                                ))
                        );
                      });
                    }
                  };
                })(this)(
                  (function(_this) {
                    return function() {
                      return cb(err);
                    };
                  })(this)
                );
              };
              Decryptor.prototype.unshift_iv = function(n_bytes, which, cb) {
                var err, iv;
                err =
                  (iv = this.ct.unshift(n_bytes / 4)) != null
                    ? null
                    : new Error('Ciphertext underrun in ' + which);
                return cb(err, iv);
              };
              Decryptor.prototype.read_salt = function(cb) {
                var err;
                err =
                  (this.salt = this.ct.unshift(this.version.salt_size / 4)) ==
                  null
                    ? new Error('Ciphertext underrrun in read_salt')
                    : null;
                return cb(err);
              };
              Decryptor.prototype.generate_keys = function(_arg, cb) {
                var err,
                  keys,
                  progress_hook,
                  ___iced_passed_deferral,
                  __iced_deferrals,
                  __iced_k;
                __iced_k = __iced_k_noop;
                ___iced_passed_deferral = iced.findDeferral(arguments);
                progress_hook = _arg.progress_hook;
                (function(_this) {
                  return function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: '/Users/max/src/keybase/triplesec/src/dec.iced',
                      funcname: 'Decryptor.generate_keys'
                    });
                    _this.kdf(
                      { salt: _this.salt, progress_hook: progress_hook },
                      __iced_deferrals.defer({
                        assign_fn: (function() {
                          return function() {
                            err = arguments[0];
                            return (keys = arguments[1]);
                          };
                        })(),
                        lineno: 114
                      })
                    );
                    __iced_deferrals._fulfill();
                  };
                })(this)(
                  (function(_this) {
                    return function() {
                      return cb(err, keys);
                    };
                  })(this)
                );
              };
              Decryptor.prototype.run = function(_arg, cb) {
                var ct1,
                  ct2,
                  data,
                  esc,
                  iv,
                  progress_hook,
                  pt,
                  ___iced_passed_deferral,
                  __iced_deferrals,
                  __iced_k;
                __iced_k = __iced_k_noop;
                ___iced_passed_deferral = iced.findDeferral(arguments);
                (data = _arg.data), (progress_hook = _arg.progress_hook);
                esc = make_esc(cb, 'Decryptor::run');
                this.ct = WordArray.from_buffer(data);
                (function(_this) {
                  return function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: '/Users/max/src/keybase/triplesec/src/dec.iced',
                      funcname: 'Decryptor.run'
                    });
                    _this.read_header(
                      esc(__iced_deferrals.defer({ lineno: 141 }))
                    );
                    __iced_deferrals._fulfill();
                  };
                })(this)(
                  (function(_this) {
                    return function() {
                      (function(__iced_k) {
                        __iced_deferrals = new iced.Deferrals(__iced_k, {
                          parent: ___iced_passed_deferral,
                          filename:
                            '/Users/max/src/keybase/triplesec/src/dec.iced',
                          funcname: 'Decryptor.run'
                        });
                        _this.read_salt(
                          esc(__iced_deferrals.defer({ lineno: 142 }))
                        );
                        __iced_deferrals._fulfill();
                      })(function() {
                        (function(__iced_k) {
                          __iced_deferrals = new iced.Deferrals(__iced_k, {
                            parent: ___iced_passed_deferral,
                            filename:
                              '/Users/max/src/keybase/triplesec/src/dec.iced',
                            funcname: 'Decryptor.run'
                          });
                          _this.generate_keys(
                            { progress_hook: progress_hook },
                            esc(
                              __iced_deferrals.defer({
                                assign_fn: (function(__slot_1) {
                                  return function() {
                                    return (__slot_1.keys = arguments[0]);
                                  };
                                })(_this),
                                lineno: 143
                              })
                            )
                          );
                          __iced_deferrals._fulfill();
                        })(function() {
                          (function(__iced_k) {
                            __iced_deferrals = new iced.Deferrals(__iced_k, {
                              parent: ___iced_passed_deferral,
                              filename:
                                '/Users/max/src/keybase/triplesec/src/dec.iced',
                              funcname: 'Decryptor.run'
                            });
                            _this.verify_sig(
                              _this.keys.hmac,
                              esc(__iced_deferrals.defer({ lineno: 144 }))
                            );
                            __iced_deferrals._fulfill();
                          })(function() {
                            (function(__iced_k) {
                              __iced_deferrals = new iced.Deferrals(__iced_k, {
                                parent: ___iced_passed_deferral,
                                filename:
                                  '/Users/max/src/keybase/triplesec/src/dec.iced',
                                funcname: 'Decryptor.run'
                              });
                              _this.unshift_iv(
                                AES.ivSize,
                                'AES',
                                esc(
                                  __iced_deferrals.defer({
                                    assign_fn: (function() {
                                      return function() {
                                        return (iv = arguments[0]);
                                      };
                                    })(),
                                    lineno: 145
                                  })
                                )
                              );
                              __iced_deferrals._fulfill();
                            })(function() {
                              (function(__iced_k) {
                                __iced_deferrals = new iced.Deferrals(
                                  __iced_k,
                                  {
                                    parent: ___iced_passed_deferral,
                                    filename:
                                      '/Users/max/src/keybase/triplesec/src/dec.iced',
                                    funcname: 'Decryptor.run'
                                  }
                                );
                                _this.run_aes(
                                  {
                                    iv: iv,
                                    input: _this.ct,
                                    key: _this.keys.aes,
                                    progress_hook: progress_hook
                                  },
                                  esc(
                                    __iced_deferrals.defer({
                                      assign_fn: (function() {
                                        return function() {
                                          return (ct2 = arguments[0]);
                                        };
                                      })(),
                                      lineno: 146
                                    })
                                  )
                                );
                                __iced_deferrals._fulfill();
                              })(function() {
                                (function(__iced_k) {
                                  __iced_deferrals = new iced.Deferrals(
                                    __iced_k,
                                    {
                                      parent: ___iced_passed_deferral,
                                      filename:
                                        '/Users/max/src/keybase/triplesec/src/dec.iced',
                                      funcname: 'Decryptor.run'
                                    }
                                  );
                                  _this.unshift_iv(
                                    TwoFish.ivSize,
                                    '2fish',
                                    esc(
                                      __iced_deferrals.defer({
                                        assign_fn: (function() {
                                          return function() {
                                            return (iv = arguments[0]);
                                          };
                                        })(),
                                        lineno: 147
                                      })
                                    )
                                  );
                                  __iced_deferrals._fulfill();
                                })(function() {
                                  (function(__iced_k) {
                                    __iced_deferrals = new iced.Deferrals(
                                      __iced_k,
                                      {
                                        parent: ___iced_passed_deferral,
                                        filename:
                                          '/Users/max/src/keybase/triplesec/src/dec.iced',
                                        funcname: 'Decryptor.run'
                                      }
                                    );
                                    _this.run_twofish(
                                      {
                                        iv: iv,
                                        input: _this.ct,
                                        key: _this.keys.twofish,
                                        progress_hook: progress_hook
                                      },
                                      esc(
                                        __iced_deferrals.defer({
                                          assign_fn: (function() {
                                            return function() {
                                              return (ct1 = arguments[0]);
                                            };
                                          })(),
                                          lineno: 148
                                        })
                                      )
                                    );
                                    __iced_deferrals._fulfill();
                                  })(function() {
                                    (function(__iced_k) {
                                      __iced_deferrals = new iced.Deferrals(
                                        __iced_k,
                                        {
                                          parent: ___iced_passed_deferral,
                                          filename:
                                            '/Users/max/src/keybase/triplesec/src/dec.iced',
                                          funcname: 'Decryptor.run'
                                        }
                                      );
                                      _this.unshift_iv(
                                        Salsa20.ivSize,
                                        'Salsa',
                                        esc(
                                          __iced_deferrals.defer({
                                            assign_fn: (function() {
                                              return function() {
                                                return (iv = arguments[0]);
                                              };
                                            })(),
                                            lineno: 149
                                          })
                                        )
                                      );
                                      __iced_deferrals._fulfill();
                                    })(function() {
                                      (function(__iced_k) {
                                        __iced_deferrals = new iced.Deferrals(
                                          __iced_k,
                                          {
                                            parent: ___iced_passed_deferral,
                                            filename:
                                              '/Users/max/src/keybase/triplesec/src/dec.iced',
                                            funcname: 'Decryptor.run'
                                          }
                                        );
                                        _this.run_salsa20(
                                          {
                                            iv: iv,
                                            input: _this.ct,
                                            key: _this.keys.salsa20,
                                            output_iv: false,
                                            progress_hook: progress_hook
                                          },
                                          esc(
                                            __iced_deferrals.defer({
                                              assign_fn: (function() {
                                                return function() {
                                                  return (pt = arguments[0]);
                                                };
                                              })(),
                                              lineno: 150
                                            })
                                          )
                                        );
                                        __iced_deferrals._fulfill();
                                      })(function() {
                                        return cb(null, pt.to_buffer());
                                      });
                                    });
                                  });
                                });
                              });
                            });
                          });
                        });
                      });
                    };
                  })(this)
                );
              };
              Decryptor.prototype.clone = function() {
                var ret, _ref1;
                ret = new Decryptor({
                  key: (_ref1 = this.key) != null ? _ref1.to_buffer() : void 0,
                  rng: this.rng,
                  version: this.version
                });
                ret.derived_keys = this.clone_derived_keys();
                return ret;
              };
              return Decryptor;
            })(Base);
            decrypt = function(_arg, cb) {
              var data,
                dec,
                err,
                key,
                progress_hook,
                pt,
                ___iced_passed_deferral,
                __iced_deferrals,
                __iced_k;
              __iced_k = __iced_k_noop;
              ___iced_passed_deferral = iced.findDeferral(arguments);
              (key = _arg.key),
                (data = _arg.data),
                (progress_hook = _arg.progress_hook);
              dec = new Decryptor({ key: key });
              (function(_this) {
                return function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: '/Users/max/src/keybase/triplesec/src/dec.iced'
                  });
                  dec.run(
                    { data: data, progress_hook: progress_hook },
                    __iced_deferrals.defer({
                      assign_fn: (function() {
                        return function() {
                          err = arguments[0];
                          return (pt = arguments[1]);
                        };
                      })(),
                      lineno: 180
                    })
                  );
                  __iced_deferrals._fulfill();
                };
              })(this)(
                (function(_this) {
                  return function() {
                    dec.scrub();
                    return cb(err, pt);
                  };
                })(this)
              );
            };
            exports.Decryptor = Decryptor;
            exports.decrypt = decrypt;
          }.call(this));
        },
        {
          './aes': 473,
          './combine': 475,
          './ctr': 476,
          './enc': 479,
          './salsa20': 486,
          './sha512': 493,
          './twofish': 494,
          './wordarray': 496,
          'iced-error': 375,
          'iced-runtime': 379
        }
      ],
      478: [
        function(require, module, exports) {
          (function(Buffer) {
            (function() {
              var ADRBG,
                DRBG,
                Lock,
                WordArray,
                XOR,
                hmac,
                iced,
                sha3,
                sha512,
                __iced_k,
                __iced_k_noop;
              iced = require('iced-runtime');
              __iced_k = __iced_k_noop = function() {};
              hmac = require('./hmac');
              XOR = require('./combine').XOR;
              sha512 = require('./sha512');
              sha3 = require('./sha3');
              WordArray = require('./wordarray').WordArray;
              Lock = require('iced-lock').Lock;
              DRBG = (function() {
                function DRBG(entropy, personalization_string, hmac_func) {
                  this.hmac = hmac_func || hmac.sign;
                  this.security_strength = 256;
                  entropy = this.check_entropy(entropy);
                  personalization_string ||
                    (personalization_string = new WordArray([]));
                  this._instantiate(entropy, personalization_string);
                }
                DRBG.prototype.check_entropy = function(entropy, reseed) {
                  if (reseed == null) {
                    reseed = false;
                  }
                  if (
                    entropy.sigBytes * 8 * 2 <
                    (reseed ? 2 : 3) * this.security_strength
                  ) {
                    throw new Error(
                      'entropy must be at least ' +
                        1.5 * this.security_strength +
                        ' bits.'
                    );
                  }
                  return entropy;
                };
                DRBG.prototype._hmac = function(key, input) {
                  return this.hmac({ key: key, input: input });
                };
                DRBG.prototype._update = function(provided_data) {
                  var V, V_in;
                  V = new WordArray([0], 1);
                  if (provided_data != null) {
                    V = V.concat(provided_data);
                  }
                  V_in = this.V.clone().concat(V);
                  this.K = this._hmac(this.K, V_in);
                  V_in.scrub();
                  V.scrub();
                  this.V = this._hmac(this.K, this.V);
                  if (provided_data != null) {
                    V_in = this.V.clone()
                      .concat(new WordArray([1 << 24], 1))
                      .concat(provided_data);
                    this.K = this._hmac(this.K, V_in);
                    V_in.scrub();
                    this.V = this._hmac(this.K, this.V);
                  }
                  return provided_data != null ? provided_data.scrub() : void 0;
                };
                DRBG.prototype._instantiate = function(
                  entropy,
                  personalization_string
                ) {
                  var i, n, seed_material;
                  seed_material = entropy.concat(personalization_string);
                  n = 64;
                  this.K = WordArray.from_buffer(
                    new Buffer(
                      (function() {
                        var _i, _results;
                        _results = [];
                        for (
                          i = _i = 0;
                          0 <= n ? _i < n : _i > n;
                          i = 0 <= n ? ++_i : --_i
                        ) {
                          _results.push(0);
                        }
                        return _results;
                      })()
                    )
                  );
                  this.V = WordArray.from_buffer(
                    new Buffer(
                      (function() {
                        var _i, _results;
                        _results = [];
                        for (
                          i = _i = 0;
                          0 <= n ? _i < n : _i > n;
                          i = 0 <= n ? ++_i : --_i
                        ) {
                          _results.push(1);
                        }
                        return _results;
                      })()
                    )
                  );
                  this._update(seed_material);
                  entropy.scrub();
                  return (this.reseed_counter = 1);
                };
                DRBG.prototype.reseed = function(entropy) {
                  this._update(this.check_entropy(entropy, true));
                  return (this.reseed_counter = 1);
                };
                DRBG.prototype.generate = function(num_bytes) {
                  var i, tmp, _ref;
                  if (num_bytes * 8 > 7500) {
                    throw new Error(
                      'generate cannot generate > 7500 bits in 1 call.'
                    );
                  }
                  if (this.reseed_counter >= 1e4) {
                    throw new Error('Need a reseed!');
                  }
                  tmp = [];
                  i = 0;
                  while (
                    tmp.length === 0 ||
                    tmp.length * tmp[0].length * 4 < num_bytes
                  ) {
                    this.V = this._hmac(this.K, this.V);
                    tmp.push(this.V.words);
                  }
                  this._update();
                  this.reseed_counter += 1;
                  return new WordArray(
                    (_ref = []).concat.apply(_ref, tmp)
                  ).truncate(num_bytes);
                };
                return DRBG;
              })();
              ADRBG = (function() {
                function ADRBG(gen_seed, hmac) {
                  this.gen_seed = gen_seed;
                  this.hmac = hmac;
                  this.drbg = null;
                  this.lock = new Lock();
                }
                ADRBG.prototype.generate = function(n, cb) {
                  var ret,
                    seed,
                    ___iced_passed_deferral,
                    __iced_deferrals,
                    __iced_k;
                  __iced_k = __iced_k_noop;
                  ___iced_passed_deferral = iced.findDeferral(arguments);
                  (function(_this) {
                    return function(__iced_k) {
                      __iced_deferrals = new iced.Deferrals(__iced_k, {
                        parent: ___iced_passed_deferral,
                        filename:
                          '/Users/max/src/keybase/triplesec/src/drbg.iced',
                        funcname: 'ADRBG.generate'
                      });
                      _this.lock.acquire(
                        __iced_deferrals.defer({ lineno: 148 })
                      );
                      __iced_deferrals._fulfill();
                    };
                  })(this)(
                    (function(_this) {
                      return function() {
                        (function(__iced_k) {
                          if (_this.drbg == null) {
                            (function(__iced_k) {
                              __iced_deferrals = new iced.Deferrals(__iced_k, {
                                parent: ___iced_passed_deferral,
                                filename:
                                  '/Users/max/src/keybase/triplesec/src/drbg.iced',
                                funcname: 'ADRBG.generate'
                              });
                              _this.gen_seed(
                                256,
                                __iced_deferrals.defer({
                                  assign_fn: (function() {
                                    return function() {
                                      return (seed = arguments[0]);
                                    };
                                  })(),
                                  lineno: 150
                                })
                              );
                              __iced_deferrals._fulfill();
                            })(function() {
                              return __iced_k(
                                (_this.drbg = new DRBG(seed, null, _this.hmac))
                              );
                            });
                          } else {
                            return __iced_k();
                          }
                        })(function() {
                          (function(__iced_k) {
                            if (_this.drbg.reseed_counter > 100) {
                              (function(__iced_k) {
                                __iced_deferrals = new iced.Deferrals(
                                  __iced_k,
                                  {
                                    parent: ___iced_passed_deferral,
                                    filename:
                                      '/Users/max/src/keybase/triplesec/src/drbg.iced',
                                    funcname: 'ADRBG.generate'
                                  }
                                );
                                _this.gen_seed(
                                  256,
                                  __iced_deferrals.defer({
                                    assign_fn: (function() {
                                      return function() {
                                        return (seed = arguments[0]);
                                      };
                                    })(),
                                    lineno: 153
                                  })
                                );
                                __iced_deferrals._fulfill();
                              })(function() {
                                return __iced_k(_this.drbg.reseed(seed));
                              });
                            } else {
                              return __iced_k();
                            }
                          })(function() {
                            ret = _this.drbg.generate(n);
                            _this.lock.release();
                            return cb(ret);
                          });
                        });
                      };
                    })(this)
                  );
                };
                return ADRBG;
              })();
              exports.DRBG = DRBG;
              exports.ADRBG = ADRBG;
            }.call(this));
          }.call(this, require('buffer').Buffer));
        },
        {
          './combine': 475,
          './hmac': 480,
          './sha3': 491,
          './sha512': 493,
          './wordarray': 496,
          buffer: 183,
          'iced-lock': 376,
          'iced-runtime': 379
        }
      ],
      479: [
        function(require, module, exports) {
          (function() {
            var AES,
              Base,
              CURRENT_VERSION,
              Concat,
              Encryptor,
              HMAC_SHA256,
              PBKDF2,
              SHA512,
              Scrypt,
              TwoFish,
              V,
              WordArray,
              XOR,
              ctr,
              encrypt,
              iced,
              make_esc,
              prng,
              salsa20,
              util,
              __iced_k,
              __iced_k_noop,
              _ref,
              __hasProp = {}.hasOwnProperty,
              __extends = function(child, parent) {
                for (var key in parent) {
                  if (__hasProp.call(parent, key)) child[key] = parent[key];
                }
                function ctor() {
                  this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
              };
            iced = require('iced-runtime');
            __iced_k = __iced_k_noop = function() {};
            WordArray = require('./wordarray').WordArray;
            salsa20 = require('./salsa20');
            AES = require('./aes').AES;
            TwoFish = require('./twofish').TwoFish;
            ctr = require('./ctr');
            (_ref = require('./combine')),
              (XOR = _ref.XOR),
              (Concat = _ref.Concat);
            SHA512 = require('./sha512').SHA512;
            PBKDF2 = require('./pbkdf2').PBKDF2;
            Scrypt = require('./scrypt').Scrypt;
            util = require('./util');
            prng = require('./prng');
            make_esc = require('iced-error').make_esc;
            HMAC_SHA256 = require('./hmac').HMAC_SHA256;
            V = {
              1: {
                header: [479516638, 1],
                salt_size: 8,
                xsalsa20_rev: true,
                kdf: { klass: PBKDF2, opts: { c: 1024, klass: XOR } },
                hmac_key_size: 768 / 8,
                version: 1
              },
              2: {
                header: [479516638, 2],
                salt_size: 16,
                xsalsa20_rev: true,
                kdf: {
                  klass: Scrypt,
                  opts: { c: 64, klass: XOR, N: 12, r: 8, p: 1 }
                },
                hmac_key_size: 768 / 8,
                version: 2
              },
              3: {
                header: [479516638, 3],
                salt_size: 16,
                xsalsa20_rev: false,
                kdf: {
                  klass: Scrypt,
                  opts: { c: 1, klass: HMAC_SHA256, N: 15, r: 8, p: 1 }
                },
                hmac_key_size: 768 / 8,
                version: 3
              }
            };
            exports.CURRENT_VERSION = CURRENT_VERSION = 3;
            Base = (function() {
              function Base(_arg) {
                var key, version;
                (key = _arg.key), (version = _arg.version);
                this.version = V[version != null ? version : CURRENT_VERSION];
                if (this.version == null) {
                  throw new Error('unknown version: ' + version);
                }
                this.set_key(key);
                this.derived_keys = {};
              }
              Base.prototype.kdf = function(_arg, cb) {
                var args,
                  dkLen,
                  end,
                  extra_keymaterial,
                  i,
                  k,
                  key,
                  keys,
                  len,
                  lens,
                  order,
                  progress_hook,
                  raw,
                  salt,
                  salt_hex,
                  v,
                  ___iced_passed_deferral,
                  __iced_deferrals,
                  __iced_k;
                __iced_k = __iced_k_noop;
                ___iced_passed_deferral = iced.findDeferral(arguments);
                (salt = _arg.salt),
                  (extra_keymaterial = _arg.extra_keymaterial),
                  (progress_hook = _arg.progress_hook);
                (function(_this) {
                  return function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: '/Users/max/src/keybase/triplesec/src/enc.iced',
                      funcname: 'Base.kdf'
                    });
                    _this._check_scrubbed(
                      _this.key,
                      'in KDF',
                      cb,
                      __iced_deferrals.defer({ lineno: 97 })
                    );
                    __iced_deferrals._fulfill();
                  };
                })(this)(
                  (function(_this) {
                    return function() {
                      salt_hex = salt.to_hex();
                      key = _this.key.clone();
                      (function(__iced_k) {
                        __iced_deferrals = new iced.Deferrals(__iced_k, {
                          parent: ___iced_passed_deferral,
                          filename:
                            '/Users/max/src/keybase/triplesec/src/enc.iced',
                          funcname: 'Base.kdf'
                        });
                        _this._check_scrubbed(
                          key,
                          'KDF',
                          cb,
                          __iced_deferrals.defer({ lineno: 105 })
                        );
                        __iced_deferrals._fulfill();
                      })(function() {
                        (function(__iced_k) {
                          if ((keys = _this.derived_keys[salt_hex]) == null) {
                            _this._kdf = new _this.version.kdf.klass(
                              _this.version.kdf.opts
                            );
                            lens = {
                              hmac: _this.version.hmac_key_size,
                              aes: AES.keySize,
                              twofish: TwoFish.keySize,
                              salsa20: salsa20.Salsa20.keySize
                            };
                            order = ['hmac', 'aes', 'twofish', 'salsa20'];
                            dkLen = extra_keymaterial || 0;
                            for (k in lens) {
                              v = lens[k];
                              dkLen += v;
                            }
                            args = {
                              dkLen: dkLen,
                              key: key,
                              progress_hook: progress_hook,
                              salt: salt
                            };
                            (function(__iced_k) {
                              __iced_deferrals = new iced.Deferrals(__iced_k, {
                                parent: ___iced_passed_deferral,
                                filename:
                                  '/Users/max/src/keybase/triplesec/src/enc.iced',
                                funcname: 'Base.kdf'
                              });
                              _this._kdf.run(
                                args,
                                __iced_deferrals.defer({
                                  assign_fn: (function() {
                                    return function() {
                                      return (raw = arguments[0]);
                                    };
                                  })(),
                                  lineno: 124
                                })
                              );
                              __iced_deferrals._fulfill();
                            })(function() {
                              var _i, _len;
                              keys = {};
                              i = 0;
                              for (
                                _i = 0, _len = order.length;
                                _i < _len;
                                _i++
                              ) {
                                k = order[_i];
                                v = lens[k];
                                len = v / 4;
                                end = i + len;
                                keys[k] = new WordArray(
                                  raw.words.slice(i, end)
                                );
                                i = end;
                              }
                              keys.extra = new WordArray(
                                raw.words.slice(end)
                              ).to_buffer();
                              return __iced_k(
                                (_this.derived_keys[salt_hex] = keys)
                              );
                            });
                          } else {
                            return __iced_k();
                          }
                        })(function() {
                          return cb(null, keys);
                        });
                      });
                    };
                  })(this)
                );
              };
              Base.prototype.set_key = function(key) {
                var wakey;
                if (key != null) {
                  wakey = WordArray.from_buffer(key);
                  if (!this.key || !this.key.equal(wakey)) {
                    this.scrub();
                    return (this.key = wakey);
                  }
                } else {
                  return this.scrub();
                }
              };
              Base.prototype._check_scrubbed = function(key, where, ecb, okcb) {
                if (key != null && !key.is_scrubbed()) {
                  return okcb();
                } else {
                  return ecb(
                    new Error('' + where + ': Failed due to scrubbed key!'),
                    null
                  );
                }
              };
              Base.prototype.sign = function(_arg, cb) {
                var input,
                  key,
                  out,
                  progress_hook,
                  salt,
                  ___iced_passed_deferral,
                  __iced_deferrals,
                  __iced_k;
                __iced_k = __iced_k_noop;
                ___iced_passed_deferral = iced.findDeferral(arguments);
                (input = _arg.input),
                  (key = _arg.key),
                  (salt = _arg.salt),
                  (progress_hook = _arg.progress_hook);
                (function(_this) {
                  return function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: '/Users/max/src/keybase/triplesec/src/enc.iced',
                      funcname: 'Base.sign'
                    });
                    _this._check_scrubbed(
                      key,
                      'HMAC',
                      cb,
                      __iced_deferrals.defer({ lineno: 182 })
                    );
                    __iced_deferrals._fulfill();
                  };
                })(this)(
                  (function(_this) {
                    return function() {
                      input = new WordArray(_this.version.header)
                        .concat(salt)
                        .concat(input);
                      (function(__iced_k) {
                        __iced_deferrals = new iced.Deferrals(__iced_k, {
                          parent: ___iced_passed_deferral,
                          filename:
                            '/Users/max/src/keybase/triplesec/src/enc.iced',
                          funcname: 'Base.sign'
                        });
                        Concat.bulk_sign(
                          {
                            key: key,
                            input: input,
                            progress_hook: progress_hook
                          },
                          __iced_deferrals.defer({
                            assign_fn: (function() {
                              return function() {
                                return (out = arguments[0]);
                              };
                            })(),
                            lineno: 184
                          })
                        );
                        __iced_deferrals._fulfill();
                      })(function() {
                        input.scrub();
                        return cb(null, out);
                      });
                    };
                  })(this)
                );
              };
              Base.prototype.run_salsa20 = function(_arg, cb) {
                var args,
                  ct,
                  input,
                  iv,
                  key,
                  output_iv,
                  progress_hook,
                  ___iced_passed_deferral,
                  __iced_deferrals,
                  __iced_k;
                __iced_k = __iced_k_noop;
                ___iced_passed_deferral = iced.findDeferral(arguments);
                (input = _arg.input),
                  (key = _arg.key),
                  (iv = _arg.iv),
                  (output_iv = _arg.output_iv),
                  (progress_hook = _arg.progress_hook);
                (function(_this) {
                  return function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: '/Users/max/src/keybase/triplesec/src/enc.iced',
                      funcname: 'Base.run_salsa20'
                    });
                    _this._check_scrubbed(
                      key,
                      'Salsa20',
                      cb,
                      __iced_deferrals.defer({ lineno: 200 })
                    );
                    __iced_deferrals._fulfill();
                  };
                })(this)(
                  (function(_this) {
                    return function() {
                      args = {
                        input: input,
                        progress_hook: progress_hook,
                        key: key,
                        iv: iv
                      };
                      if (_this.version.xsalsa20_rev) {
                        args.key = key.clone().endian_reverse();
                        args.iv = iv.clone().endian_reverse();
                      }
                      (function(__iced_k) {
                        __iced_deferrals = new iced.Deferrals(__iced_k, {
                          parent: ___iced_passed_deferral,
                          filename:
                            '/Users/max/src/keybase/triplesec/src/enc.iced',
                          funcname: 'Base.run_salsa20'
                        });
                        salsa20.bulk_encrypt(
                          args,
                          __iced_deferrals.defer({
                            assign_fn: (function() {
                              return function() {
                                return (ct = arguments[0]);
                              };
                            })(),
                            lineno: 212
                          })
                        );
                        __iced_deferrals._fulfill();
                      })(function() {
                        if (output_iv) {
                          ct = iv.clone().concat(ct);
                        }
                        if (_this.version.xsalsa20_rev) {
                          args.key.scrub();
                          args.iv.scrub();
                        }
                        return cb(null, ct);
                      });
                    };
                  })(this)
                );
              };
              Base.prototype.run_twofish = function(_arg, cb) {
                var block_cipher,
                  ct,
                  input,
                  iv,
                  key,
                  progress_hook,
                  ___iced_passed_deferral,
                  __iced_deferrals,
                  __iced_k;
                __iced_k = __iced_k_noop;
                ___iced_passed_deferral = iced.findDeferral(arguments);
                (input = _arg.input),
                  (key = _arg.key),
                  (iv = _arg.iv),
                  (progress_hook = _arg.progress_hook);
                (function(_this) {
                  return function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: '/Users/max/src/keybase/triplesec/src/enc.iced',
                      funcname: 'Base.run_twofish'
                    });
                    _this._check_scrubbed(
                      key,
                      'TwoFish',
                      cb,
                      __iced_deferrals.defer({ lineno: 235 })
                    );
                    __iced_deferrals._fulfill();
                  };
                })(this)(
                  (function(_this) {
                    return function() {
                      block_cipher = new TwoFish(key);
                      (function(__iced_k) {
                        __iced_deferrals = new iced.Deferrals(__iced_k, {
                          parent: ___iced_passed_deferral,
                          filename:
                            '/Users/max/src/keybase/triplesec/src/enc.iced',
                          funcname: 'Base.run_twofish'
                        });
                        ctr.bulk_encrypt(
                          {
                            block_cipher: block_cipher,
                            iv: iv,
                            input: input,
                            progress_hook: progress_hook,
                            what: 'twofish'
                          },
                          __iced_deferrals.defer({
                            assign_fn: (function() {
                              return function() {
                                return (ct = arguments[0]);
                              };
                            })(),
                            lineno: 237
                          })
                        );
                        __iced_deferrals._fulfill();
                      })(function() {
                        block_cipher.scrub();
                        return cb(null, iv.clone().concat(ct));
                      });
                    };
                  })(this)
                );
              };
              Base.prototype.run_aes = function(_arg, cb) {
                var block_cipher,
                  ct,
                  input,
                  iv,
                  key,
                  progress_hook,
                  ___iced_passed_deferral,
                  __iced_deferrals,
                  __iced_k;
                __iced_k = __iced_k_noop;
                ___iced_passed_deferral = iced.findDeferral(arguments);
                (input = _arg.input),
                  (key = _arg.key),
                  (iv = _arg.iv),
                  (progress_hook = _arg.progress_hook);
                (function(_this) {
                  return function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: '/Users/max/src/keybase/triplesec/src/enc.iced',
                      funcname: 'Base.run_aes'
                    });
                    _this._check_scrubbed(
                      key,
                      'AES',
                      cb,
                      __iced_deferrals.defer({ lineno: 252 })
                    );
                    __iced_deferrals._fulfill();
                  };
                })(this)(
                  (function(_this) {
                    return function() {
                      block_cipher = new AES(key);
                      (function(__iced_k) {
                        __iced_deferrals = new iced.Deferrals(__iced_k, {
                          parent: ___iced_passed_deferral,
                          filename:
                            '/Users/max/src/keybase/triplesec/src/enc.iced',
                          funcname: 'Base.run_aes'
                        });
                        ctr.bulk_encrypt(
                          {
                            block_cipher: block_cipher,
                            iv: iv,
                            input: input,
                            progress_hook: progress_hook,
                            what: 'aes'
                          },
                          __iced_deferrals.defer({
                            assign_fn: (function() {
                              return function() {
                                return (ct = arguments[0]);
                              };
                            })(),
                            lineno: 254
                          })
                        );
                        __iced_deferrals._fulfill();
                      })(function() {
                        block_cipher.scrub();
                        return cb(null, iv.clone().concat(ct));
                      });
                    };
                  })(this)
                );
              };
              Base.prototype.scrub = function() {
                var algo, key, key_ring, salt, _ref1;
                if (this.key != null) {
                  this.key.scrub();
                }
                if (this.derived_keys != null) {
                  _ref1 = this.derived_keys;
                  for (salt in _ref1) {
                    key_ring = _ref1[salt];
                    for (algo in key_ring) {
                      key = key_ring[algo];
                      if (algo !== 'extra') {
                        key.scrub();
                      }
                    }
                  }
                }
                this.derived_keys = {};
                if (this.salt != null) {
                  this.salt.scrub();
                }
                this.salt = null;
                return (this.key = null);
              };
              Base.prototype.clone_derived_keys = function() {
                var algo, key, key_ring, ret, salt, _ref1;
                ret = null;
                if (this.derived_keys != null) {
                  ret = {};
                  _ref1 = this.derived_keys;
                  for (salt in _ref1) {
                    key_ring = _ref1[salt];
                    ret[salt] = {};
                    for (algo in key_ring) {
                      key = key_ring[algo];
                      ret[salt][algo] = algo === 'extra' ? key : key.clone();
                    }
                  }
                }
                return ret;
              };
              return Base;
            })();
            Encryptor = (function(_super) {
              __extends(Encryptor, _super);
              function Encryptor(_arg) {
                var key, rng, version;
                (key = _arg.key), (rng = _arg.rng), (version = _arg.version);
                Encryptor.__super__.constructor.call(this, {
                  key: key,
                  version: version
                });
                this.rng = rng || prng.generate;
              }
              Encryptor.prototype.pick_random_ivs = function(_arg, cb) {
                var iv_lens,
                  ivs,
                  k,
                  progress_hook,
                  v,
                  ___iced_passed_deferral,
                  __iced_deferrals,
                  __iced_k;
                __iced_k = __iced_k_noop;
                ___iced_passed_deferral = iced.findDeferral(arguments);
                progress_hook = _arg.progress_hook;
                iv_lens = {
                  aes: AES.ivSize,
                  twofish: TwoFish.ivSize,
                  salsa20: salsa20.Salsa20.ivSize
                };
                ivs = {};
                (function(_this) {
                  return function(__iced_k) {
                    var _i, _k, _keys, _ref1, _results, _while;
                    _ref1 = iv_lens;
                    _keys = (function() {
                      var _results1;
                      _results1 = [];
                      for (_k in _ref1) {
                        _results1.push(_k);
                      }
                      return _results1;
                    })();
                    _i = 0;
                    _while = function(__iced_k) {
                      var _break, _continue, _next;
                      _break = __iced_k;
                      _continue = function() {
                        return iced.trampoline(function() {
                          ++_i;
                          return _while(__iced_k);
                        });
                      };
                      _next = _continue;
                      if (!(_i < _keys.length)) {
                        return _break();
                      } else {
                        k = _keys[_i];
                        v = _ref1[k];
                        (function(__iced_k) {
                          __iced_deferrals = new iced.Deferrals(__iced_k, {
                            parent: ___iced_passed_deferral,
                            filename:
                              '/Users/max/src/keybase/triplesec/src/enc.iced',
                            funcname: 'Encryptor.pick_random_ivs'
                          });
                          _this.rng(
                            v,
                            __iced_deferrals.defer({
                              assign_fn: (function(__slot_1, __slot_2) {
                                return function() {
                                  return (__slot_1[__slot_2] = arguments[0]);
                                };
                              })(ivs, k),
                              lineno: 377
                            })
                          );
                          __iced_deferrals._fulfill();
                        })(_next);
                      }
                    };
                    _while(__iced_k);
                  };
                })(this)(
                  (function(_this) {
                    return function() {
                      return cb(ivs);
                    };
                  })(this)
                );
              };
              Encryptor.prototype.resalt = function(_arg, cb) {
                var err,
                  extra_keymaterial,
                  progress_hook,
                  salt,
                  ___iced_passed_deferral,
                  __iced_deferrals,
                  __iced_k;
                __iced_k = __iced_k_noop;
                ___iced_passed_deferral = iced.findDeferral(arguments);
                (salt = _arg.salt),
                  (extra_keymaterial = _arg.extra_keymaterial),
                  (progress_hook = _arg.progress_hook);
                err = null;
                (function(_this) {
                  return function(__iced_k) {
                    if (salt == null) {
                      (function(__iced_k) {
                        __iced_deferrals = new iced.Deferrals(__iced_k, {
                          parent: ___iced_passed_deferral,
                          filename:
                            '/Users/max/src/keybase/triplesec/src/enc.iced',
                          funcname: 'Encryptor.resalt'
                        });
                        _this.rng(
                          _this.version.salt_size,
                          __iced_deferrals.defer({
                            assign_fn: (function(__slot_1) {
                              return function() {
                                return (__slot_1.salt = arguments[0]);
                              };
                            })(_this),
                            lineno: 393
                          })
                        );
                        __iced_deferrals._fulfill();
                      })(__iced_k);
                    } else {
                      return __iced_k(
                        salt.length !== _this.version.salt_size
                          ? (err = new Error(
                              'Need a salt of exactly ' +
                                _this.version.salt_size +
                                ' bytes (got ' +
                                salt.length +
                                ')'
                            ))
                          : (_this.salt = WordArray.alloc(salt))
                      );
                    }
                  };
                })(this)(
                  (function(_this) {
                    return function() {
                      (function(__iced_k) {
                        if (err == null) {
                          (function(__iced_k) {
                            __iced_deferrals = new iced.Deferrals(__iced_k, {
                              parent: ___iced_passed_deferral,
                              filename:
                                '/Users/max/src/keybase/triplesec/src/enc.iced',
                              funcname: 'Encryptor.resalt'
                            });
                            _this.kdf(
                              {
                                extra_keymaterial: extra_keymaterial,
                                progress_hook: progress_hook,
                                salt: _this.salt
                              },
                              __iced_deferrals.defer({
                                assign_fn: (function(__slot_1) {
                                  return function() {
                                    err = arguments[0];
                                    return (__slot_1.keys = arguments[1]);
                                  };
                                })(_this),
                                lineno: 399
                              })
                            );
                            __iced_deferrals._fulfill();
                          })(__iced_k);
                        } else {
                          return __iced_k();
                        }
                      })(function() {
                        return cb(err, _this.keys);
                      });
                    };
                  })(this)
                );
              };
              Encryptor.prototype.run = function(_arg, cb) {
                var ct1,
                  ct2,
                  ct3,
                  data,
                  esc,
                  extra_keymaterial,
                  ivs,
                  progress_hook,
                  pt,
                  ret,
                  salt,
                  sig,
                  ___iced_passed_deferral,
                  __iced_deferrals,
                  __iced_k;
                __iced_k = __iced_k_noop;
                ___iced_passed_deferral = iced.findDeferral(arguments);
                (data = _arg.data),
                  (salt = _arg.salt),
                  (extra_keymaterial = _arg.extra_keymaterial),
                  (progress_hook = _arg.progress_hook);
                esc = make_esc(cb, 'Encryptor::run');
                (function(_this) {
                  return function(__iced_k) {
                    if (salt != null || _this.salt == null) {
                      (function(__iced_k) {
                        __iced_deferrals = new iced.Deferrals(__iced_k, {
                          parent: ___iced_passed_deferral,
                          filename:
                            '/Users/max/src/keybase/triplesec/src/enc.iced',
                          funcname: 'Encryptor.run'
                        });
                        _this.resalt(
                          {
                            salt: salt,
                            extra_keymaterial: extra_keymaterial,
                            progress_hook: progress_hook
                          },
                          esc(__iced_deferrals.defer({ lineno: 430 }))
                        );
                        __iced_deferrals._fulfill();
                      })(__iced_k);
                    } else {
                      return __iced_k();
                    }
                  };
                })(this)(
                  (function(_this) {
                    return function() {
                      (function(__iced_k) {
                        __iced_deferrals = new iced.Deferrals(__iced_k, {
                          parent: ___iced_passed_deferral,
                          filename:
                            '/Users/max/src/keybase/triplesec/src/enc.iced',
                          funcname: 'Encryptor.run'
                        });
                        _this.pick_random_ivs(
                          { progress_hook: progress_hook },
                          __iced_deferrals.defer({
                            assign_fn: (function() {
                              return function() {
                                return (ivs = arguments[0]);
                              };
                            })(),
                            lineno: 431
                          })
                        );
                        __iced_deferrals._fulfill();
                      })(function() {
                        pt = WordArray.from_buffer(data);
                        (function(__iced_k) {
                          __iced_deferrals = new iced.Deferrals(__iced_k, {
                            parent: ___iced_passed_deferral,
                            filename:
                              '/Users/max/src/keybase/triplesec/src/enc.iced',
                            funcname: 'Encryptor.run'
                          });
                          _this.run_salsa20(
                            {
                              input: pt,
                              key: _this.keys.salsa20,
                              progress_hook: progress_hook,
                              iv: ivs.salsa20,
                              output_iv: true
                            },
                            esc(
                              __iced_deferrals.defer({
                                assign_fn: (function() {
                                  return function() {
                                    return (ct1 = arguments[0]);
                                  };
                                })(),
                                lineno: 433
                              })
                            )
                          );
                          __iced_deferrals._fulfill();
                        })(function() {
                          (function(__iced_k) {
                            __iced_deferrals = new iced.Deferrals(__iced_k, {
                              parent: ___iced_passed_deferral,
                              filename:
                                '/Users/max/src/keybase/triplesec/src/enc.iced',
                              funcname: 'Encryptor.run'
                            });
                            _this.run_twofish(
                              {
                                input: ct1,
                                key: _this.keys.twofish,
                                progress_hook: progress_hook,
                                iv: ivs.twofish
                              },
                              esc(
                                __iced_deferrals.defer({
                                  assign_fn: (function() {
                                    return function() {
                                      return (ct2 = arguments[0]);
                                    };
                                  })(),
                                  lineno: 434
                                })
                              )
                            );
                            __iced_deferrals._fulfill();
                          })(function() {
                            (function(__iced_k) {
                              __iced_deferrals = new iced.Deferrals(__iced_k, {
                                parent: ___iced_passed_deferral,
                                filename:
                                  '/Users/max/src/keybase/triplesec/src/enc.iced',
                                funcname: 'Encryptor.run'
                              });
                              _this.run_aes(
                                {
                                  input: ct2,
                                  key: _this.keys.aes,
                                  progress_hook: progress_hook,
                                  iv: ivs.aes
                                },
                                esc(
                                  __iced_deferrals.defer({
                                    assign_fn: (function() {
                                      return function() {
                                        return (ct3 = arguments[0]);
                                      };
                                    })(),
                                    lineno: 435
                                  })
                                )
                              );
                              __iced_deferrals._fulfill();
                            })(function() {
                              (function(__iced_k) {
                                __iced_deferrals = new iced.Deferrals(
                                  __iced_k,
                                  {
                                    parent: ___iced_passed_deferral,
                                    filename:
                                      '/Users/max/src/keybase/triplesec/src/enc.iced',
                                    funcname: 'Encryptor.run'
                                  }
                                );
                                _this.sign(
                                  {
                                    input: ct3,
                                    key: _this.keys.hmac,
                                    progress_hook: progress_hook,
                                    salt: _this.salt
                                  },
                                  esc(
                                    __iced_deferrals.defer({
                                      assign_fn: (function() {
                                        return function() {
                                          return (sig = arguments[0]);
                                        };
                                      })(),
                                      lineno: 436
                                    })
                                  )
                                );
                                __iced_deferrals._fulfill();
                              })(function() {
                                ret = new WordArray(_this.version.header)
                                  .concat(_this.salt)
                                  .concat(sig)
                                  .concat(ct3)
                                  .to_buffer();
                                util.scrub_buffer(data);
                                return cb(null, ret);
                              });
                            });
                          });
                        });
                      });
                    };
                  })(this)
                );
              };
              Encryptor.prototype.clone = function() {
                var ret, _ref1, _ref2;
                ret = new Encryptor({
                  key: (_ref1 = this.key) != null ? _ref1.to_buffer() : void 0,
                  rng: this.rng,
                  version:
                    (_ref2 = this.version) != null ? _ref2.version : void 0
                });
                ret.derived_keys = this.clone_derived_keys();
                return ret;
              };
              return Encryptor;
            })(Base);
            encrypt = function(_arg, cb) {
              var data,
                enc,
                err,
                key,
                progress_hook,
                ret,
                rng,
                version,
                ___iced_passed_deferral,
                __iced_deferrals,
                __iced_k;
              __iced_k = __iced_k_noop;
              ___iced_passed_deferral = iced.findDeferral(arguments);
              (key = _arg.key),
                (data = _arg.data),
                (rng = _arg.rng),
                (progress_hook = _arg.progress_hook),
                (version = _arg.version);
              enc = new Encryptor({ key: key, rng: rng, version: version });
              (function(_this) {
                return function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: '/Users/max/src/keybase/triplesec/src/enc.iced'
                  });
                  enc.run(
                    { data: data, progress_hook: progress_hook },
                    __iced_deferrals.defer({
                      assign_fn: (function() {
                        return function() {
                          err = arguments[0];
                          return (ret = arguments[1]);
                        };
                      })(),
                      lineno: 475
                    })
                  );
                  __iced_deferrals._fulfill();
                };
              })(this)(
                (function(_this) {
                  return function() {
                    enc.scrub();
                    return cb(err, ret);
                  };
                })(this)
              );
            };
            exports.V = V;
            exports.encrypt = encrypt;
            exports.Base = Base;
            exports.Encryptor = Encryptor;
          }.call(this));
        },
        {
          './aes': 473,
          './combine': 475,
          './ctr': 476,
          './hmac': 480,
          './pbkdf2': 483,
          './prng': 484,
          './salsa20': 486,
          './scrypt': 487,
          './sha512': 493,
          './twofish': 494,
          './util': 495,
          './wordarray': 496,
          'iced-error': 375,
          'iced-runtime': 379
        }
      ],
      480: [
        function(require, module, exports) {
          (function() {
            var HMAC,
              HMAC_SHA256,
              SHA256,
              SHA512,
              bulk_sign,
              iced,
              sign,
              util,
              __iced_k,
              __iced_k_noop,
              __hasProp = {}.hasOwnProperty,
              __extends = function(child, parent) {
                for (var key in parent) {
                  if (__hasProp.call(parent, key)) child[key] = parent[key];
                }
                function ctor() {
                  this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
              };
            iced = require('iced-runtime');
            __iced_k = __iced_k_noop = function() {};
            SHA512 = require('./sha512').SHA512;
            SHA256 = require('./sha256').SHA256;
            util = require('./util');
            HMAC = (function() {
              HMAC.outputSize = 512 / 8;
              HMAC.prototype.outputSize = HMAC.outputSize;
              function HMAC(key, klass) {
                var i, _i, _ref;
                if (klass == null) {
                  klass = SHA512;
                }
                this.key = key.clone();
                this.hasher = new klass();
                this.hasherBlockSize = this.hasher.blockSize;
                this.hasherBlockSizeBytes = this.hasherBlockSize * 4;
                if (this.key.sigBytes > this.hasherBlockSizeBytes) {
                  this.key = this.hasher.finalize(this.key);
                }
                this.key.clamp();
                this._oKey = this.key.clone();
                this._iKey = this.key.clone();
                for (
                  i = _i = 0, _ref = this.hasherBlockSize;
                  0 <= _ref ? _i < _ref : _i > _ref;
                  i = 0 <= _ref ? ++_i : --_i
                ) {
                  this._oKey.words[i] ^= 1549556828;
                  this._iKey.words[i] ^= 909522486;
                }
                this._oKey.sigBytes = this._iKey.sigBytes = this.hasherBlockSizeBytes;
                this.reset();
              }
              HMAC.prototype.get_output_size = function() {
                return this.hasher.output_size;
              };
              HMAC.prototype.reset = function() {
                return this.hasher.reset().update(this._iKey);
              };
              HMAC.prototype.update = function(wa) {
                this.hasher.update(wa);
                return this;
              };
              HMAC.prototype.finalize = function(wa) {
                var innerHash, innerHash2, out;
                innerHash = this.hasher.finalize(wa);
                this.hasher.reset();
                innerHash2 = this._oKey.clone().concat(innerHash);
                out = this.hasher.finalize(innerHash2);
                innerHash.scrub();
                innerHash2.scrub();
                return out;
              };
              HMAC.prototype.scrub = function() {
                this.key.scrub();
                this._iKey.scrub();
                return this._oKey.scrub();
              };
              return HMAC;
            })();
            sign = function(_arg) {
              var eng, hash_class, input, key, out;
              (key = _arg.key),
                (input = _arg.input),
                (hash_class = _arg.hash_class);
              eng = new HMAC(key, hash_class);
              out = eng.finalize(input.clamp());
              eng.scrub();
              return out;
            };
            bulk_sign = function(_arg, cb) {
              var eng,
                input,
                key,
                klass,
                progress_hook,
                res,
                slice_args,
                what,
                ___iced_passed_deferral,
                __iced_deferrals,
                __iced_k;
              __iced_k = __iced_k_noop;
              ___iced_passed_deferral = iced.findDeferral(arguments);
              (key = _arg.key),
                (input = _arg.input),
                (progress_hook = _arg.progress_hook),
                (klass = _arg.klass),
                (what = _arg.what);
              klass || (klass = HMAC);
              what || (what = 'hmac_sha512');
              eng = new klass(key);
              input.clamp();
              slice_args = {
                update: function(lo, hi) {
                  return eng.update(input.slice(lo, hi));
                },
                finalize: function() {
                  return eng.finalize();
                },
                default_n: eng.hasherBlockSize * 1e3
              };
              (function(_this) {
                return function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: '/Users/max/src/keybase/triplesec/src/hmac.iced'
                  });
                  util.bulk(input.sigBytes, slice_args, {
                    what: what,
                    progress_hook: progress_hook,
                    cb: __iced_deferrals.defer({
                      assign_fn: (function() {
                        return function() {
                          return (res = arguments[0]);
                        };
                      })(),
                      lineno: 137
                    })
                  });
                  __iced_deferrals._fulfill();
                };
              })(this)(
                (function(_this) {
                  return function() {
                    eng.scrub();
                    return cb(res);
                  };
                })(this)
              );
            };
            exports.HMAC_SHA256 = HMAC_SHA256 = (function(_super) {
              __extends(HMAC_SHA256, _super);
              function HMAC_SHA256(key) {
                HMAC_SHA256.__super__.constructor.call(this, key, SHA256);
              }
              return HMAC_SHA256;
            })(HMAC);
            exports.HMAC = HMAC;
            exports.sign = sign;
            exports.bulk_sign = bulk_sign;
          }.call(this));
        },
        { './sha256': 490, './sha512': 493, './util': 495, 'iced-runtime': 379 }
      ],
      481: [
        function(require, module, exports) {
          (function(Buffer) {
            (function() {
              var hmac, k, v, _ref, _ref1;
              _ref = require('./enc');
              for (k in _ref) {
                v = _ref[k];
                exports[k] = v;
              }
              _ref1 = require('./dec');
              for (k in _ref1) {
                v = _ref1[k];
                exports[k] = v;
              }
              exports.prng = require('./prng');
              exports.Buffer = Buffer;
              exports.WordArray = require('./wordarray').WordArray;
              exports.util = require('./util');
              exports.ciphers = {
                AES: require('./aes').AES,
                TwoFish: require('./twofish').TwoFish,
                Salsa20: require('./salsa20').Salsa20
              };
              exports.hash = {
                SHA1: require('./sha1').SHA1,
                SHA224: require('./sha224').SHA224,
                SHA256: require('./sha256').SHA256,
                SHA384: require('./sha384').SHA384,
                SHA512: require('./sha512').SHA512,
                SHA3: require('./sha3').SHA3,
                MD5: require('./md5').MD5,
                RIPEMD160: require('./ripemd160').RIPEMD160
              };
              exports.modes = { CTR: require('./ctr') };
              exports.scrypt = require('./scrypt').scrypt;
              exports.pbkdf2 = require('./pbkdf2').pbkdf2;
              exports.hmac = hmac = require('./hmac');
              exports.HMAC_SHA256 = hmac.HMAC_SHA256;
              exports.HMAC = hmac.HMAC;
            }.call(this));
          }.call(this, require('buffer').Buffer));
        },
        {
          './aes': 473,
          './ctr': 476,
          './dec': 477,
          './enc': 479,
          './hmac': 480,
          './md5': 482,
          './pbkdf2': 483,
          './prng': 484,
          './ripemd160': 485,
          './salsa20': 486,
          './scrypt': 487,
          './sha1': 488,
          './sha224': 489,
          './sha256': 490,
          './sha3': 491,
          './sha384': 492,
          './sha512': 493,
          './twofish': 494,
          './util': 495,
          './wordarray': 496,
          buffer: 183
        }
      ],
      482: [
        function(require, module, exports) {
          (function() {
            var FF,
              GG,
              Global,
              HH,
              Hasher,
              II,
              MD5,
              WordArray,
              glbl,
              __hasProp = {}.hasOwnProperty,
              __extends = function(child, parent) {
                for (var key in parent) {
                  if (__hasProp.call(parent, key)) child[key] = parent[key];
                }
                function ctor() {
                  this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
              };
            WordArray = require('./wordarray').WordArray;
            Hasher = require('./algbase').Hasher;
            Global = (function() {
              function Global() {
                var i;
                this.T = (function() {
                  var _i, _results;
                  _results = [];
                  for (i = _i = 0; _i < 64; i = ++_i) {
                    _results.push((Math.abs(Math.sin(i + 1)) * 4294967296) | 0);
                  }
                  return _results;
                })();
              }
              return Global;
            })();
            glbl = new Global();
            exports.MD5 = MD5 = (function(_super) {
              __extends(MD5, _super);
              function MD5() {
                return MD5.__super__.constructor.apply(this, arguments);
              }
              MD5.blockSize = 512 / 32;
              MD5.prototype.blockSize = MD5.blockSize;
              MD5.output_size = 16;
              MD5.prototype.output_size = MD5.output_size;
              MD5.prototype._doReset = function() {
                return (this._hash = new WordArray([
                  1732584193,
                  4023233417,
                  2562383102,
                  271733878
                ]));
              };
              MD5.prototype._doProcessBlock = function(M, offset) {
                var H,
                  M_offset_0,
                  M_offset_1,
                  M_offset_10,
                  M_offset_11,
                  M_offset_12,
                  M_offset_13,
                  M_offset_14,
                  M_offset_15,
                  M_offset_2,
                  M_offset_3,
                  M_offset_4,
                  M_offset_5,
                  M_offset_6,
                  M_offset_7,
                  M_offset_8,
                  M_offset_9,
                  M_offset_i,
                  a,
                  b,
                  c,
                  d,
                  i,
                  offset_i,
                  _i;
                for (i = _i = 0; _i < 16; i = ++_i) {
                  offset_i = offset + i;
                  M_offset_i = M[offset_i];
                  M[offset_i] =
                    (((M_offset_i << 8) | (M_offset_i >>> 24)) & 16711935) |
                    (((M_offset_i << 24) | (M_offset_i >>> 8)) & 4278255360);
                }
                H = this._hash.words;
                M_offset_0 = M[offset + 0];
                M_offset_1 = M[offset + 1];
                M_offset_2 = M[offset + 2];
                M_offset_3 = M[offset + 3];
                M_offset_4 = M[offset + 4];
                M_offset_5 = M[offset + 5];
                M_offset_6 = M[offset + 6];
                M_offset_7 = M[offset + 7];
                M_offset_8 = M[offset + 8];
                M_offset_9 = M[offset + 9];
                M_offset_10 = M[offset + 10];
                M_offset_11 = M[offset + 11];
                M_offset_12 = M[offset + 12];
                M_offset_13 = M[offset + 13];
                M_offset_14 = M[offset + 14];
                M_offset_15 = M[offset + 15];
                a = H[0];
                b = H[1];
                c = H[2];
                d = H[3];
                a = FF(a, b, c, d, M_offset_0, 7, glbl.T[0]);
                d = FF(d, a, b, c, M_offset_1, 12, glbl.T[1]);
                c = FF(c, d, a, b, M_offset_2, 17, glbl.T[2]);
                b = FF(b, c, d, a, M_offset_3, 22, glbl.T[3]);
                a = FF(a, b, c, d, M_offset_4, 7, glbl.T[4]);
                d = FF(d, a, b, c, M_offset_5, 12, glbl.T[5]);
                c = FF(c, d, a, b, M_offset_6, 17, glbl.T[6]);
                b = FF(b, c, d, a, M_offset_7, 22, glbl.T[7]);
                a = FF(a, b, c, d, M_offset_8, 7, glbl.T[8]);
                d = FF(d, a, b, c, M_offset_9, 12, glbl.T[9]);
                c = FF(c, d, a, b, M_offset_10, 17, glbl.T[10]);
                b = FF(b, c, d, a, M_offset_11, 22, glbl.T[11]);
                a = FF(a, b, c, d, M_offset_12, 7, glbl.T[12]);
                d = FF(d, a, b, c, M_offset_13, 12, glbl.T[13]);
                c = FF(c, d, a, b, M_offset_14, 17, glbl.T[14]);
                b = FF(b, c, d, a, M_offset_15, 22, glbl.T[15]);
                a = GG(a, b, c, d, M_offset_1, 5, glbl.T[16]);
                d = GG(d, a, b, c, M_offset_6, 9, glbl.T[17]);
                c = GG(c, d, a, b, M_offset_11, 14, glbl.T[18]);
                b = GG(b, c, d, a, M_offset_0, 20, glbl.T[19]);
                a = GG(a, b, c, d, M_offset_5, 5, glbl.T[20]);
                d = GG(d, a, b, c, M_offset_10, 9, glbl.T[21]);
                c = GG(c, d, a, b, M_offset_15, 14, glbl.T[22]);
                b = GG(b, c, d, a, M_offset_4, 20, glbl.T[23]);
                a = GG(a, b, c, d, M_offset_9, 5, glbl.T[24]);
                d = GG(d, a, b, c, M_offset_14, 9, glbl.T[25]);
                c = GG(c, d, a, b, M_offset_3, 14, glbl.T[26]);
                b = GG(b, c, d, a, M_offset_8, 20, glbl.T[27]);
                a = GG(a, b, c, d, M_offset_13, 5, glbl.T[28]);
                d = GG(d, a, b, c, M_offset_2, 9, glbl.T[29]);
                c = GG(c, d, a, b, M_offset_7, 14, glbl.T[30]);
                b = GG(b, c, d, a, M_offset_12, 20, glbl.T[31]);
                a = HH(a, b, c, d, M_offset_5, 4, glbl.T[32]);
                d = HH(d, a, b, c, M_offset_8, 11, glbl.T[33]);
                c = HH(c, d, a, b, M_offset_11, 16, glbl.T[34]);
                b = HH(b, c, d, a, M_offset_14, 23, glbl.T[35]);
                a = HH(a, b, c, d, M_offset_1, 4, glbl.T[36]);
                d = HH(d, a, b, c, M_offset_4, 11, glbl.T[37]);
                c = HH(c, d, a, b, M_offset_7, 16, glbl.T[38]);
                b = HH(b, c, d, a, M_offset_10, 23, glbl.T[39]);
                a = HH(a, b, c, d, M_offset_13, 4, glbl.T[40]);
                d = HH(d, a, b, c, M_offset_0, 11, glbl.T[41]);
                c = HH(c, d, a, b, M_offset_3, 16, glbl.T[42]);
                b = HH(b, c, d, a, M_offset_6, 23, glbl.T[43]);
                a = HH(a, b, c, d, M_offset_9, 4, glbl.T[44]);
                d = HH(d, a, b, c, M_offset_12, 11, glbl.T[45]);
                c = HH(c, d, a, b, M_offset_15, 16, glbl.T[46]);
                b = HH(b, c, d, a, M_offset_2, 23, glbl.T[47]);
                a = II(a, b, c, d, M_offset_0, 6, glbl.T[48]);
                d = II(d, a, b, c, M_offset_7, 10, glbl.T[49]);
                c = II(c, d, a, b, M_offset_14, 15, glbl.T[50]);
                b = II(b, c, d, a, M_offset_5, 21, glbl.T[51]);
                a = II(a, b, c, d, M_offset_12, 6, glbl.T[52]);
                d = II(d, a, b, c, M_offset_3, 10, glbl.T[53]);
                c = II(c, d, a, b, M_offset_10, 15, glbl.T[54]);
                b = II(b, c, d, a, M_offset_1, 21, glbl.T[55]);
                a = II(a, b, c, d, M_offset_8, 6, glbl.T[56]);
                d = II(d, a, b, c, M_offset_15, 10, glbl.T[57]);
                c = II(c, d, a, b, M_offset_6, 15, glbl.T[58]);
                b = II(b, c, d, a, M_offset_13, 21, glbl.T[59]);
                a = II(a, b, c, d, M_offset_4, 6, glbl.T[60]);
                d = II(d, a, b, c, M_offset_11, 10, glbl.T[61]);
                c = II(c, d, a, b, M_offset_2, 15, glbl.T[62]);
                b = II(b, c, d, a, M_offset_9, 21, glbl.T[63]);
                H[0] = (H[0] + a) | 0;
                H[1] = (H[1] + b) | 0;
                H[2] = (H[2] + c) | 0;
                return (H[3] = (H[3] + d) | 0);
              };
              MD5.prototype._doFinalize = function() {
                var H,
                  H_i,
                  data,
                  dataWords,
                  hash,
                  i,
                  nBitsLeft,
                  nBitsTotal,
                  nBitsTotalH,
                  nBitsTotalL,
                  _i;
                data = this._data;
                dataWords = data.words;
                nBitsTotal = this._nDataBytes * 8;
                nBitsLeft = data.sigBytes * 8;
                dataWords[nBitsLeft >>> 5] |= 128 << (24 - (nBitsLeft % 32));
                nBitsTotalH = Math.floor(nBitsTotal / 4294967296);
                nBitsTotalL = nBitsTotal;
                dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] =
                  (((nBitsTotalH << 8) | (nBitsTotalH >>> 24)) & 16711935) |
                  (((nBitsTotalH << 24) | (nBitsTotalH >>> 8)) & 4278255360);
                dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] =
                  (((nBitsTotalL << 8) | (nBitsTotalL >>> 24)) & 16711935) |
                  (((nBitsTotalL << 24) | (nBitsTotalL >>> 8)) & 4278255360);
                data.sigBytes = (dataWords.length + 1) * 4;
                this._process();
                hash = this._hash;
                H = hash.words;
                for (i = _i = 0; _i < 4; i = ++_i) {
                  H_i = H[i];
                  H[i] =
                    (((H_i << 8) | (H_i >>> 24)) & 16711935) |
                    (((H_i << 24) | (H_i >>> 8)) & 4278255360);
                }
                return hash;
              };
              MD5.prototype.copy_to = function(obj) {
                MD5.__super__.copy_to.call(this, obj);
                return (obj._hash = this._hash.clone());
              };
              MD5.prototype.clone = function() {
                var out;
                out = new MD5();
                this.copy_to(out);
                return out;
              };
              return MD5;
            })(Hasher);
            FF = function(a, b, c, d, x, s, t) {
              var n;
              n = a + ((b & c) | (~b & d)) + x + t;
              return ((n << s) | (n >>> (32 - s))) + b;
            };
            GG = function(a, b, c, d, x, s, t) {
              var n;
              n = a + ((b & d) | (c & ~d)) + x + t;
              return ((n << s) | (n >>> (32 - s))) + b;
            };
            HH = function(a, b, c, d, x, s, t) {
              var n;
              n = a + (b ^ c ^ d) + x + t;
              return ((n << s) | (n >>> (32 - s))) + b;
            };
            II = function(a, b, c, d, x, s, t) {
              var n;
              n = a + (c ^ (b | ~d)) + x + t;
              return ((n << s) | (n >>> (32 - s))) + b;
            };
            exports.transform = function(x) {
              var out;
              out = new MD5().finalize(x);
              x.scrub();
              return out;
            };
          }.call(this));
        },
        { './algbase': 474, './wordarray': 496 }
      ],
      483: [
        function(require, module, exports) {
          (function() {
            var HMAC,
              PBKDF2,
              WordArray,
              iced,
              pbkdf2,
              util,
              __iced_k,
              __iced_k_noop;
            iced = require('iced-runtime');
            __iced_k = __iced_k_noop = function() {};
            HMAC = require('./hmac').HMAC;
            WordArray = require('./wordarray').WordArray;
            util = require('./util');
            PBKDF2 = (function() {
              function PBKDF2(_arg) {
                (this.klass = _arg.klass), (this.c = _arg.c);
                this.c || (this.c = 1024);
                this.klass || (this.klass = HMAC);
              }
              PBKDF2.prototype._PRF = function(input) {
                this.prf.reset();
                return this.prf.finalize(input);
              };
              PBKDF2.prototype._gen_T_i = function(_arg, cb) {
                var U,
                  i,
                  progress_hook,
                  ret,
                  salt,
                  seed,
                  stop,
                  ___iced_passed_deferral,
                  __iced_deferrals,
                  __iced_k;
                __iced_k = __iced_k_noop;
                ___iced_passed_deferral = iced.findDeferral(arguments);
                (salt = _arg.salt),
                  (i = _arg.i),
                  (progress_hook = _arg.progress_hook);
                progress_hook(0);
                seed = salt.clone().concat(new WordArray([i]));
                U = this._PRF(seed);
                ret = U.clone();
                i = 1;
                (function(_this) {
                  return function(__iced_k) {
                    var _while;
                    _while = function(__iced_k) {
                      var _break, _continue, _next;
                      _break = __iced_k;
                      _continue = function() {
                        return iced.trampoline(function() {
                          return _while(__iced_k);
                        });
                      };
                      _next = _continue;
                      if (!(i < _this.c)) {
                        return _break();
                      } else {
                        stop = Math.min(_this.c, i + 128);
                        while (i < stop) {
                          U = _this._PRF(U);
                          ret.xor(U, {});
                          i++;
                        }
                        progress_hook(i);
                        (function(__iced_k) {
                          __iced_deferrals = new iced.Deferrals(__iced_k, {
                            parent: ___iced_passed_deferral,
                            filename:
                              '/Users/max/src/keybase/triplesec/src/pbkdf2.iced',
                            funcname: 'PBKDF2._gen_T_i'
                          });
                          util.default_delay(
                            0,
                            0,
                            __iced_deferrals.defer({ lineno: 57 })
                          );
                          __iced_deferrals._fulfill();
                        })(function() {
                          return _next(null);
                        });
                      }
                    };
                    _while(__iced_k);
                  };
                })(this)(
                  (function(_this) {
                    return function() {
                      progress_hook(i);
                      return cb(ret);
                    };
                  })(this)
                );
              };
              PBKDF2.prototype.run = function(_arg, cb) {
                var bs,
                  dkLen,
                  flat,
                  i,
                  key,
                  n,
                  ph,
                  progress_hook,
                  salt,
                  tmp,
                  tph,
                  words,
                  ___iced_passed_deferral,
                  __iced_deferrals,
                  __iced_k,
                  _begin,
                  _end,
                  _positive;
                __iced_k = __iced_k_noop;
                ___iced_passed_deferral = iced.findDeferral(arguments);
                (key = _arg.key),
                  (salt = _arg.salt),
                  (dkLen = _arg.dkLen),
                  (progress_hook = _arg.progress_hook);
                this.prf = new this.klass(key);
                bs = this.prf.get_output_size();
                n = Math.ceil(dkLen / bs);
                words = [];
                tph = null;
                ph = (function(_this) {
                  return function(block) {
                    return function(iter) {
                      return typeof progress_hook === 'function'
                        ? progress_hook({
                            what: 'pbkdf2',
                            total: n * _this.c,
                            i: block * _this.c + iter
                          })
                        : void 0;
                    };
                  };
                })(this);
                ph(0)(0);
                (function(_this) {
                  return function(__iced_k) {
                    var _i, _results, _while;
                    i = 1;
                    _begin = 1;
                    _end = n;
                    _positive = _end > _begin;
                    _while = function(__iced_k) {
                      var _break, _continue, _next;
                      _break = __iced_k;
                      _continue = function() {
                        return iced.trampoline(function() {
                          if (_positive) {
                            i += 1;
                          } else {
                            i -= 1;
                          }
                          return _while(__iced_k);
                        });
                      };
                      _next = _continue;
                      if (
                        !!(
                          (_positive === true && i > n) ||
                          (_positive === false && i < n)
                        )
                      ) {
                        return _break();
                      } else {
                        (function(__iced_k) {
                          __iced_deferrals = new iced.Deferrals(__iced_k, {
                            parent: ___iced_passed_deferral,
                            filename:
                              '/Users/max/src/keybase/triplesec/src/pbkdf2.iced',
                            funcname: 'PBKDF2.run'
                          });
                          _this._gen_T_i(
                            { salt: salt, i: i, progress_hook: ph(i - 1) },
                            __iced_deferrals.defer({
                              assign_fn: (function() {
                                return function() {
                                  return (tmp = arguments[0]);
                                };
                              })(),
                              lineno: 80
                            })
                          );
                          __iced_deferrals._fulfill();
                        })(function() {
                          return _next(words.push(tmp.words));
                        });
                      }
                    };
                    _while(__iced_k);
                  };
                })(this)(
                  (function(_this) {
                    return function() {
                      var _ref;
                      ph(n)(0);
                      flat = (_ref = []).concat.apply(_ref, words);
                      key.scrub();
                      _this.prf.scrub();
                      _this.prf = null;
                      return cb(new WordArray(flat, dkLen));
                    };
                  })(this)
                );
              };
              return PBKDF2;
            })();
            pbkdf2 = function(_arg, cb) {
              var c,
                dkLen,
                eng,
                key,
                klass,
                out,
                progress_hook,
                salt,
                ___iced_passed_deferral,
                __iced_deferrals,
                __iced_k;
              __iced_k = __iced_k_noop;
              ___iced_passed_deferral = iced.findDeferral(arguments);
              (key = _arg.key),
                (salt = _arg.salt),
                (klass = _arg.klass),
                (c = _arg.c),
                (dkLen = _arg.dkLen),
                (progress_hook = _arg.progress_hook);
              eng = new PBKDF2({ klass: klass, c: c });
              (function(_this) {
                return function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: '/Users/max/src/keybase/triplesec/src/pbkdf2.iced'
                  });
                  eng.run(
                    {
                      key: key,
                      salt: salt,
                      dkLen: dkLen,
                      progress_hook: progress_hook
                    },
                    __iced_deferrals.defer({
                      assign_fn: (function() {
                        return function() {
                          return (out = arguments[0]);
                        };
                      })(),
                      lineno: 106
                    })
                  );
                  __iced_deferrals._fulfill();
                };
              })(this)(
                (function(_this) {
                  return function() {
                    return cb(out);
                  };
                })(this)
              );
            };
            exports.pbkdf2 = pbkdf2;
            exports.PBKDF2 = PBKDF2;
          }.call(this));
        },
        {
          './hmac': 480,
          './util': 495,
          './wordarray': 496,
          'iced-runtime': 379
        }
      ],
      484: [
        function(require, module, exports) {
          (function(Buffer) {
            (function() {
              var ADRBG,
                PRNG,
                WordArray,
                XOR,
                browser_rng,
                e,
                generate,
                iced,
                m,
                more_entropy,
                native_rng,
                rng,
                util,
                __iced_k,
                __iced_k_noop,
                _browser_rng_primitive,
                _native_rng,
                _prng,
                _ref,
                _ref1;
              iced = require('iced-runtime');
              __iced_k = __iced_k_noop = function() {};
              more_entropy = require('more-entropy');
              ADRBG = require('./drbg').ADRBG;
              WordArray = require('./wordarray').WordArray;
              XOR = require('./combine').XOR;
              util = require('./util');
              _browser_rng_primitive = null;
              browser_rng = function(n) {
                var v;
                v = new Uint8Array(n);
                _browser_rng_primitive(v);
                return new Buffer(v);
              };
              _browser_rng_primitive =
                (m =
                  typeof window !== 'undefined' && window !== null
                    ? (_ref = window.crypto) != null
                      ? _ref.getRandomValues
                      : void 0
                    : void 0) != null
                  ? m.bind(window.crypto)
                  : (m =
                      typeof window !== 'undefined' && window !== null
                        ? (_ref1 = window.msCrypto) != null
                          ? _ref1.getRandomValues
                          : void 0
                        : void 0) != null
                  ? m.bind(window.msCrypto)
                  : null;
              if (_browser_rng_primitive != null) {
                _native_rng = browser_rng;
              } else {
                try {
                  rng = require('cry' + 'pto').rng;
                  if (rng != null) {
                    _native_rng = rng;
                  }
                } catch (_error) {
                  e = _error;
                }
              }
              native_rng = function(x) {
                if (_native_rng == null) {
                  throw new Error(
                    'No rng found; tried requiring "crypto" and window.crypto'
                  );
                }
                return _native_rng(x);
              };
              PRNG = (function() {
                function PRNG() {
                  this.meg = new more_entropy.Generator();
                  this.adrbg = new ADRBG(
                    (function(_this) {
                      return function(n, cb) {
                        return _this.gen_seed(n, cb);
                      };
                    })(this),
                    XOR.sign
                  );
                }
                PRNG.prototype.now_to_buffer = function() {
                  var buf, d, ms, s;
                  d = Date.now();
                  ms = d % 1e3;
                  s = Math.floor(d / 1e3);
                  buf = new Buffer(8);
                  buf.writeUInt32BE(s, 0);
                  buf.writeUInt32BE(ms, 4);
                  return buf;
                };
                PRNG.prototype.gen_seed = function(nbits, cb) {
                  var b,
                    bufs,
                    cat,
                    nbytes,
                    wa,
                    words,
                    ___iced_passed_deferral,
                    __iced_deferrals,
                    __iced_k;
                  __iced_k = __iced_k_noop;
                  ___iced_passed_deferral = iced.findDeferral(arguments);
                  nbytes = nbits / 8;
                  bufs = [];
                  bufs.push(this.now_to_buffer());
                  (function(_this) {
                    return function(__iced_k) {
                      __iced_deferrals = new iced.Deferrals(__iced_k, {
                        parent: ___iced_passed_deferral,
                        filename:
                          '/Users/max/src/keybase/triplesec/src/prng.iced',
                        funcname: 'PRNG.gen_seed'
                      });
                      _this.meg.generate(
                        nbits,
                        __iced_deferrals.defer({
                          assign_fn: (function() {
                            return function() {
                              return (words = arguments[0]);
                            };
                          })(),
                          lineno: 83
                        })
                      );
                      __iced_deferrals._fulfill();
                    };
                  })(this)(
                    (function(_this) {
                      return function() {
                        var _i, _len;
                        bufs.push(_this.now_to_buffer());
                        bufs.push(new Buffer(words));
                        bufs.push(native_rng(nbytes));
                        bufs.push(_this.now_to_buffer());
                        cat = Buffer.concat(bufs);
                        wa = WordArray.from_buffer(cat);
                        util.scrub_buffer(cat);
                        for (_i = 0, _len = bufs.length; _i < _len; _i++) {
                          b = bufs[_i];
                          util.scrub_buffer(b);
                        }
                        return cb(wa);
                      };
                    })(this)
                  );
                };
                PRNG.prototype.generate = function(n, cb) {
                  return this.adrbg.generate(n, cb);
                };
                return PRNG;
              })();
              _prng = null;
              generate = function(n, cb) {
                if (_prng == null) {
                  _prng = new PRNG();
                }
                return _prng.generate(n, cb);
              };
              exports.PRNG = PRNG;
              exports.generate = generate;
              exports.native_rng = native_rng;
            }.call(this));
          }.call(this, require('buffer').Buffer));
        },
        {
          './combine': 475,
          './drbg': 478,
          './util': 495,
          './wordarray': 496,
          buffer: 183,
          'iced-runtime': 379,
          'more-entropy': 443
        }
      ],
      485: [
        function(require, module, exports) {
          (function() {
            var G,
              Global,
              Hasher,
              RIPEMD160,
              WordArray,
              X64Word,
              X64WordArray,
              f1,
              f2,
              f3,
              f4,
              f5,
              rotl,
              transform,
              _ref,
              __hasProp = {}.hasOwnProperty,
              __extends = function(child, parent) {
                for (var key in parent) {
                  if (__hasProp.call(parent, key)) child[key] = parent[key];
                }
                function ctor() {
                  this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
              };
            (_ref = require('./wordarray')),
              (WordArray = _ref.WordArray),
              (X64Word = _ref.X64Word),
              (X64WordArray = _ref.X64WordArray);
            Hasher = require('./algbase').Hasher;
            Global = (function() {
              function Global() {
                this._zl = new WordArray([
                  0,
                  1,
                  2,
                  3,
                  4,
                  5,
                  6,
                  7,
                  8,
                  9,
                  10,
                  11,
                  12,
                  13,
                  14,
                  15,
                  7,
                  4,
                  13,
                  1,
                  10,
                  6,
                  15,
                  3,
                  12,
                  0,
                  9,
                  5,
                  2,
                  14,
                  11,
                  8,
                  3,
                  10,
                  14,
                  4,
                  9,
                  15,
                  8,
                  1,
                  2,
                  7,
                  0,
                  6,
                  13,
                  11,
                  5,
                  12,
                  1,
                  9,
                  11,
                  10,
                  0,
                  8,
                  12,
                  4,
                  13,
                  3,
                  7,
                  15,
                  14,
                  5,
                  6,
                  2,
                  4,
                  0,
                  5,
                  9,
                  7,
                  12,
                  2,
                  10,
                  14,
                  1,
                  3,
                  8,
                  11,
                  6,
                  15,
                  13
                ]);
                this._zr = new WordArray([
                  5,
                  14,
                  7,
                  0,
                  9,
                  2,
                  11,
                  4,
                  13,
                  6,
                  15,
                  8,
                  1,
                  10,
                  3,
                  12,
                  6,
                  11,
                  3,
                  7,
                  0,
                  13,
                  5,
                  10,
                  14,
                  15,
                  8,
                  12,
                  4,
                  9,
                  1,
                  2,
                  15,
                  5,
                  1,
                  3,
                  7,
                  14,
                  6,
                  9,
                  11,
                  8,
                  12,
                  2,
                  10,
                  0,
                  4,
                  13,
                  8,
                  6,
                  4,
                  1,
                  3,
                  11,
                  15,
                  0,
                  5,
                  12,
                  2,
                  13,
                  9,
                  7,
                  10,
                  14,
                  12,
                  15,
                  10,
                  4,
                  1,
                  5,
                  8,
                  7,
                  6,
                  2,
                  13,
                  14,
                  0,
                  3,
                  9,
                  11
                ]);
                this._sl = new WordArray([
                  11,
                  14,
                  15,
                  12,
                  5,
                  8,
                  7,
                  9,
                  11,
                  13,
                  14,
                  15,
                  6,
                  7,
                  9,
                  8,
                  7,
                  6,
                  8,
                  13,
                  11,
                  9,
                  7,
                  15,
                  7,
                  12,
                  15,
                  9,
                  11,
                  7,
                  13,
                  12,
                  11,
                  13,
                  6,
                  7,
                  14,
                  9,
                  13,
                  15,
                  14,
                  8,
                  13,
                  6,
                  5,
                  12,
                  7,
                  5,
                  11,
                  12,
                  14,
                  15,
                  14,
                  15,
                  9,
                  8,
                  9,
                  14,
                  5,
                  6,
                  8,
                  6,
                  5,
                  12,
                  9,
                  15,
                  5,
                  11,
                  6,
                  8,
                  13,
                  12,
                  5,
                  12,
                  13,
                  14,
                  11,
                  8,
                  5,
                  6
                ]);
                this._sr = new WordArray([
                  8,
                  9,
                  9,
                  11,
                  13,
                  15,
                  15,
                  5,
                  7,
                  7,
                  8,
                  11,
                  14,
                  14,
                  12,
                  6,
                  9,
                  13,
                  15,
                  7,
                  12,
                  8,
                  9,
                  11,
                  7,
                  7,
                  12,
                  7,
                  6,
                  15,
                  13,
                  11,
                  9,
                  7,
                  15,
                  11,
                  8,
                  6,
                  6,
                  14,
                  12,
                  13,
                  5,
                  14,
                  13,
                  13,
                  7,
                  5,
                  15,
                  5,
                  8,
                  11,
                  14,
                  14,
                  6,
                  14,
                  6,
                  9,
                  12,
                  9,
                  12,
                  5,
                  15,
                  8,
                  8,
                  5,
                  12,
                  9,
                  12,
                  5,
                  14,
                  6,
                  8,
                  13,
                  6,
                  5,
                  15,
                  13,
                  11,
                  11
                ]);
                this._hl = new WordArray([
                  0,
                  1518500249,
                  1859775393,
                  2400959708,
                  2840853838
                ]);
                this._hr = new WordArray([
                  1352829926,
                  1548603684,
                  1836072691,
                  2053994217,
                  0
                ]);
              }
              return Global;
            })();
            G = new Global();
            RIPEMD160 = (function(_super) {
              __extends(RIPEMD160, _super);
              function RIPEMD160() {
                return RIPEMD160.__super__.constructor.apply(this, arguments);
              }
              RIPEMD160.blockSize = 512 / 32;
              RIPEMD160.prototype.blockSize = RIPEMD160.blockSize;
              RIPEMD160.output_size = 160 / 8;
              RIPEMD160.prototype.output_size = RIPEMD160.output_size;
              RIPEMD160.prototype._doReset = function() {
                return (this._hash = new WordArray([
                  1732584193,
                  4023233417,
                  2562383102,
                  271733878,
                  3285377520
                ]));
              };
              RIPEMD160.prototype.get_output_size = function() {
                return this.output_size;
              };
              RIPEMD160.prototype._doProcessBlock = function(M, offset) {
                var H,
                  M_offset_i,
                  al,
                  ar,
                  bl,
                  br,
                  cl,
                  cr,
                  dl,
                  dr,
                  el,
                  er,
                  hl,
                  hr,
                  i,
                  offset_i,
                  sl,
                  sr,
                  t,
                  zl,
                  zr,
                  _i,
                  _j;
                for (i = _i = 0; _i < 16; i = ++_i) {
                  offset_i = offset + i;
                  M_offset_i = M[offset_i];
                  M[offset_i] =
                    (((M_offset_i << 8) | (M_offset_i >>> 24)) & 16711935) |
                    (((M_offset_i << 24) | (M_offset_i >>> 8)) & 4278255360);
                }
                H = this._hash.words;
                hl = G._hl.words;
                hr = G._hr.words;
                zl = G._zl.words;
                zr = G._zr.words;
                sl = G._sl.words;
                sr = G._sr.words;
                ar = al = H[0];
                br = bl = H[1];
                cr = cl = H[2];
                dr = dl = H[3];
                er = el = H[4];
                for (i = _j = 0; _j < 80; i = ++_j) {
                  t = (al + M[offset + zl[i]]) | 0;
                  if (i < 16) {
                    t += f1(bl, cl, dl) + hl[0];
                  } else if (i < 32) {
                    t += f2(bl, cl, dl) + hl[1];
                  } else if (i < 48) {
                    t += f3(bl, cl, dl) + hl[2];
                  } else if (i < 64) {
                    t += f4(bl, cl, dl) + hl[3];
                  } else {
                    t += f5(bl, cl, dl) + hl[4];
                  }
                  t = t | 0;
                  t = rotl(t, sl[i]);
                  t = (t + el) | 0;
                  al = el;
                  el = dl;
                  dl = rotl(cl, 10);
                  cl = bl;
                  bl = t;
                  t = (ar + M[offset + zr[i]]) | 0;
                  if (i < 16) {
                    t += f5(br, cr, dr) + hr[0];
                  } else if (i < 32) {
                    t += f4(br, cr, dr) + hr[1];
                  } else if (i < 48) {
                    t += f3(br, cr, dr) + hr[2];
                  } else if (i < 64) {
                    t += f2(br, cr, dr) + hr[3];
                  } else {
                    t += f1(br, cr, dr) + hr[4];
                  }
                  t = t | 0;
                  t = rotl(t, sr[i]);
                  t = (t + er) | 0;
                  ar = er;
                  er = dr;
                  dr = rotl(cr, 10);
                  cr = br;
                  br = t;
                }
                t = (H[1] + cl + dr) | 0;
                H[1] = (H[2] + dl + er) | 0;
                H[2] = (H[3] + el + ar) | 0;
                H[3] = (H[4] + al + br) | 0;
                H[4] = (H[0] + bl + cr) | 0;
                return (H[0] = t);
              };
              RIPEMD160.prototype._doFinalize = function() {
                var H, H_i, data, dataWords, hash, i, nBitsLeft, nBitsTotal, _i;
                data = this._data;
                dataWords = data.words;
                nBitsTotal = this._nDataBytes * 8;
                nBitsLeft = data.sigBytes * 8;
                dataWords[nBitsLeft >>> 5] |= 128 << (24 - (nBitsLeft % 32));
                dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] =
                  (((nBitsTotal << 8) | (nBitsTotal >>> 24)) & 16711935) |
                  (((nBitsTotal << 24) | (nBitsTotal >>> 8)) & 4278255360);
                data.sigBytes = (dataWords.length + 1) * 4;
                this._process();
                hash = this._hash;
                H = hash.words;
                for (i = _i = 0; _i < 5; i = ++_i) {
                  H_i = H[i];
                  H[i] =
                    (((H_i << 8) | (H_i >>> 24)) & 16711935) |
                    (((H_i << 24) | (H_i >>> 8)) & 4278255360);
                }
                return hash;
              };
              RIPEMD160.prototype.scrub = function() {
                return this._hash.scrub();
              };
              RIPEMD160.prototype.copy_to = function(obj) {
                RIPEMD160.__super__.copy_to.call(this, obj);
                return (obj._hash = this._hash.clone());
              };
              RIPEMD160.prototype.clone = function() {
                var out;
                out = new RIPEMD160();
                this.copy_to(out);
                return out;
              };
              return RIPEMD160;
            })(Hasher);
            f1 = function(x, y, z) {
              return x ^ y ^ z;
            };
            f2 = function(x, y, z) {
              return (x & y) | (~x & z);
            };
            f3 = function(x, y, z) {
              return (x | ~y) ^ z;
            };
            f4 = function(x, y, z) {
              return (x & z) | (y & ~z);
            };
            f5 = function(x, y, z) {
              return x ^ (y | ~z);
            };
            rotl = function(x, n) {
              return (x << n) | (x >>> (32 - n));
            };
            transform = function(x) {
              var out;
              out = new RIPEMD160().finalize(x);
              x.scrub();
              return out;
            };
            exports.RIPEMD160 = RIPEMD160;
            exports.transform = transform;
          }.call(this));
        },
        { './algbase': 474, './wordarray': 496 }
      ],
      486: [
        function(require, module, exports) {
          (function(Buffer) {
            (function() {
              var Cipher,
                Counter,
                Salsa20,
                Salsa20Core,
                Salsa20InnerCore,
                Salsa20WordStream,
                StreamCipher,
                WordArray,
                asum,
                bulk_encrypt,
                encrypt,
                endian_reverse,
                fixup_uint32,
                iced,
                util,
                __iced_k,
                __iced_k_noop,
                _ref,
                __hasProp = {}.hasOwnProperty,
                __extends = function(child, parent) {
                  for (var key in parent) {
                    if (__hasProp.call(parent, key)) child[key] = parent[key];
                  }
                  function ctor() {
                    this.constructor = child;
                  }
                  ctor.prototype = parent.prototype;
                  child.prototype = new ctor();
                  child.__super__ = parent.prototype;
                  return child;
                };
              iced = require('iced-runtime');
              __iced_k = __iced_k_noop = function() {};
              (_ref = require('./wordarray')),
                (endian_reverse = _ref.endian_reverse),
                (WordArray = _ref.WordArray);
              Counter = require('./ctr').Counter;
              fixup_uint32 = require('./util').fixup_uint32;
              StreamCipher = require('./algbase').StreamCipher;
              util = require('./util');
              asum = function(out, v) {
                var e, i, _i, _len;
                for (i = _i = 0, _len = v.length; _i < _len; i = ++_i) {
                  e = v[i];
                  out[i] += e;
                }
                return false;
              };
              Salsa20InnerCore = (function() {
                function Salsa20InnerCore(rounds) {
                  this.rounds = rounds;
                }
                Salsa20InnerCore.prototype._core = function(v) {
                  'use asm';
                  var i,
                    u,
                    x0,
                    x1,
                    x10,
                    x11,
                    x12,
                    x13,
                    x14,
                    x15,
                    x2,
                    x3,
                    x4,
                    x5,
                    x6,
                    x7,
                    x8,
                    x9,
                    _i,
                    _ref1;
                  (x0 = v[0]),
                    (x1 = v[1]),
                    (x2 = v[2]),
                    (x3 = v[3]),
                    (x4 = v[4]),
                    (x5 = v[5]),
                    (x6 = v[6]),
                    (x7 = v[7]),
                    (x8 = v[8]),
                    (x9 = v[9]),
                    (x10 = v[10]),
                    (x11 = v[11]),
                    (x12 = v[12]),
                    (x13 = v[13]),
                    (x14 = v[14]),
                    (x15 = v[15]);
                  for (
                    i = _i = 0, _ref1 = this.rounds;
                    _i < _ref1;
                    i = _i += 2
                  ) {
                    u = (x0 + x12) | 0;
                    x4 ^= (u << 7) | (u >>> 25);
                    u = (x4 + x0) | 0;
                    x8 ^= (u << 9) | (u >>> 23);
                    u = (x8 + x4) | 0;
                    x12 ^= (u << 13) | (u >>> 19);
                    u = (x12 + x8) | 0;
                    x0 ^= (u << 18) | (u >>> 14);
                    u = (x5 + x1) | 0;
                    x9 ^= (u << 7) | (u >>> 25);
                    u = (x9 + x5) | 0;
                    x13 ^= (u << 9) | (u >>> 23);
                    u = (x13 + x9) | 0;
                    x1 ^= (u << 13) | (u >>> 19);
                    u = (x1 + x13) | 0;
                    x5 ^= (u << 18) | (u >>> 14);
                    u = (x10 + x6) | 0;
                    x14 ^= (u << 7) | (u >>> 25);
                    u = (x14 + x10) | 0;
                    x2 ^= (u << 9) | (u >>> 23);
                    u = (x2 + x14) | 0;
                    x6 ^= (u << 13) | (u >>> 19);
                    u = (x6 + x2) | 0;
                    x10 ^= (u << 18) | (u >>> 14);
                    u = (x15 + x11) | 0;
                    x3 ^= (u << 7) | (u >>> 25);
                    u = (x3 + x15) | 0;
                    x7 ^= (u << 9) | (u >>> 23);
                    u = (x7 + x3) | 0;
                    x11 ^= (u << 13) | (u >>> 19);
                    u = (x11 + x7) | 0;
                    x15 ^= (u << 18) | (u >>> 14);
                    u = (x0 + x3) | 0;
                    x1 ^= (u << 7) | (u >>> 25);
                    u = (x1 + x0) | 0;
                    x2 ^= (u << 9) | (u >>> 23);
                    u = (x2 + x1) | 0;
                    x3 ^= (u << 13) | (u >>> 19);
                    u = (x3 + x2) | 0;
                    x0 ^= (u << 18) | (u >>> 14);
                    u = (x5 + x4) | 0;
                    x6 ^= (u << 7) | (u >>> 25);
                    u = (x6 + x5) | 0;
                    x7 ^= (u << 9) | (u >>> 23);
                    u = (x7 + x6) | 0;
                    x4 ^= (u << 13) | (u >>> 19);
                    u = (x4 + x7) | 0;
                    x5 ^= (u << 18) | (u >>> 14);
                    u = (x10 + x9) | 0;
                    x11 ^= (u << 7) | (u >>> 25);
                    u = (x11 + x10) | 0;
                    x8 ^= (u << 9) | (u >>> 23);
                    u = (x8 + x11) | 0;
                    x9 ^= (u << 13) | (u >>> 19);
                    u = (x9 + x8) | 0;
                    x10 ^= (u << 18) | (u >>> 14);
                    u = (x15 + x14) | 0;
                    x12 ^= (u << 7) | (u >>> 25);
                    u = (x12 + x15) | 0;
                    x13 ^= (u << 9) | (u >>> 23);
                    u = (x13 + x12) | 0;
                    x14 ^= (u << 13) | (u >>> 19);
                    u = (x14 + x13) | 0;
                    x15 ^= (u << 18) | (u >>> 14);
                  }
                  return [
                    x0,
                    x1,
                    x2,
                    x3,
                    x4,
                    x5,
                    x6,
                    x7,
                    x8,
                    x9,
                    x10,
                    x11,
                    x12,
                    x13,
                    x14,
                    x15
                  ];
                };
                return Salsa20InnerCore;
              })();
              Salsa20Core = (function(_super) {
                __extends(Salsa20Core, _super);
                Salsa20Core.prototype.sigma = WordArray.from_buffer_le(
                  new Buffer('expand 32-byte k')
                );
                Salsa20Core.prototype.tau = WordArray.from_buffer_le(
                  new Buffer('expand 16-byte k')
                );
                Salsa20Core.blockSize = 64;
                Salsa20Core.prototype.blockSize = Salsa20Core.blockSize;
                Salsa20Core.keySize = 32;
                Salsa20Core.prototype.keySize = Salsa20Core.keySize;
                Salsa20Core.ivSize = 192 / 8;
                Salsa20Core.prototype.ivSize = Salsa20Core.ivSize;
                function Salsa20Core(key, nonce) {
                  var _ref1;
                  Salsa20Core.__super__.constructor.call(this, 20);
                  this.key = key.clone().endian_reverse();
                  this.nonce = nonce.clone().endian_reverse();
                  if (
                    !(
                      (this.key.sigBytes === 16 && this.nonce.sigBytes === 8) ||
                      (this.key.sigBytes === 32 &&
                        ((_ref1 = this.nonce.sigBytes) === 8 || _ref1 === 24))
                    )
                  ) {
                    throw new Error('Bad key/nonce lengths');
                  }
                  if (this.nonce.sigBytes === 24) {
                    this.xsalsa_setup();
                  }
                  this.input = this.key_iv_setup(this.nonce, this.key);
                  this._reset();
                }
                Salsa20Core.prototype.scrub = function() {
                  this.key.scrub();
                  this.nonce.scrub();
                  return util.scrub_vec(this.input);
                };
                Salsa20Core.prototype.xsalsa_setup = function() {
                  var n0, n1;
                  n0 = new WordArray(this.nonce.words.slice(0, 4));
                  this.nonce = n1 = new WordArray(this.nonce.words.slice(4));
                  return (this.key = this.hsalsa20(n0, this.key));
                };
                Salsa20Core.prototype.hsalsa20 = function(nonce, key) {
                  var i, indexes, input, v;
                  input = this.key_iv_setup(nonce, key);
                  input[8] = nonce.words[2];
                  input[9] = nonce.words[3];
                  v = this._core(input);
                  indexes = [0, 5, 10, 15, 6, 7, 8, 9];
                  v = (function() {
                    var _i, _len, _results;
                    _results = [];
                    for (_i = 0, _len = indexes.length; _i < _len; _i++) {
                      i = indexes[_i];
                      _results.push(fixup_uint32(v[i]));
                    }
                    return _results;
                  })();
                  util.scrub_vec(input);
                  return new WordArray(v);
                };
                Salsa20Core.prototype.key_iv_setup = function(nonce, key) {
                  var A, C, i, out, _i, _j, _k, _ref1;
                  out = [];
                  for (i = _i = 0; _i < 4; i = ++_i) {
                    out[i + 1] = key.words[i];
                  }
                  (_ref1 =
                    key.sigBytes === 32
                      ? [this.sigma, key.words.slice(4)]
                      : [this.tau, key.words]),
                    (C = _ref1[0]),
                    (A = _ref1[1]);
                  for (i = _j = 0; _j < 4; i = ++_j) {
                    out[i + 11] = A[i];
                  }
                  for (i = _k = 0; _k < 4; i = ++_k) {
                    out[i * 5] = C.words[i];
                  }
                  out[6] = nonce.words[0];
                  out[7] = nonce.words[1];
                  return out;
                };
                Salsa20Core.prototype.counter_setup = function() {
                  this.input[8] = this.counter.get().words[0];
                  return (this.input[9] = this.counter.get().words[1]);
                };
                Salsa20Core.prototype._reset = function() {
                  return (this.counter = new Counter({ len: 2 }));
                };
                Salsa20Core.prototype._generateBlock = function() {
                  var v;
                  this.counter_setup();
                  v = this._core(this.input);
                  asum(v, this.input);
                  this.counter.inc_le();
                  return v;
                };
                return Salsa20Core;
              })(Salsa20InnerCore);
              exports.Salsa20WordStream = Salsa20WordStream = (function(
                _super
              ) {
                __extends(Salsa20WordStream, _super);
                function Salsa20WordStream() {
                  return Salsa20WordStream.__super__.constructor.apply(
                    this,
                    arguments
                  );
                }
                Salsa20WordStream.prototype._reset = function() {
                  return Salsa20WordStream.__super__._reset.call(this);
                };
                Salsa20WordStream.prototype.getWordArray = function(nbytes) {
                  var blocks, i, nblocks, w, words, _i, _len, _ref1;
                  if (nbytes == null || nbytes === this.blockSize) {
                    words = this._generateBlock();
                  } else {
                    nblocks = Math.ceil(nbytes / this.blockSize);
                    blocks = function() {
                      var _i, _results;
                      _results = [];
                      for (
                        i = _i = 0;
                        0 <= nblocks ? _i < nblocks : _i > nblocks;
                        i = 0 <= nblocks ? ++_i : --_i
                      ) {
                        _results.push(this._generateBlock());
                      }
                      return _results;
                    }.call(this);
                    words = (_ref1 = []).concat.apply(_ref1, blocks);
                  }
                  for (i = _i = 0, _len = words.length; _i < _len; i = ++_i) {
                    w = words[i];
                    words[i] = endian_reverse(w);
                  }
                  return new WordArray(words, nbytes);
                };
                return Salsa20WordStream;
              })(Salsa20Core);
              exports.Salsa20 = Salsa20 = (function(_super) {
                __extends(Salsa20, _super);
                function Salsa20() {
                  return Salsa20.__super__.constructor.apply(this, arguments);
                }
                Salsa20.prototype._reset = function() {
                  Salsa20.__super__._reset.call(this);
                  return (this._i = this.blockSize);
                };
                Salsa20.prototype.getBytes = function(needed) {
                  var bsz, n, v;
                  if (needed == null) {
                    needed = this.blockSize;
                  }
                  v = [];
                  bsz = this.blockSize;
                  if (this._i === bsz && needed === bsz) {
                    return this._generateBlockBuffer();
                  } else {
                    while (needed > 0) {
                      if (this._i === bsz) {
                        this._generateBlockBuffer();
                        this._i = 0;
                      }
                      n = Math.min(needed, bsz - this._i);
                      v.push(
                        n === bsz
                          ? this._buf
                          : this._buf.slice(this._i, this._i + n)
                      );
                      this._i += n;
                      needed -= n;
                    }
                    return Buffer.concat(v);
                  }
                };
                Salsa20.prototype._generateBlockBuffer = function() {
                  var e, i, v, _i, _len;
                  this._buf = new Buffer(this.blockSize);
                  v = this._generateBlock();
                  for (i = _i = 0, _len = v.length; _i < _len; i = ++_i) {
                    e = v[i];
                    this._buf.writeUInt32LE(fixup_uint32(e), i * 4);
                  }
                  return this._buf;
                };
                return Salsa20;
              })(Salsa20Core);
              exports.Cipher = Cipher = (function(_super) {
                __extends(Cipher, _super);
                function Cipher(_arg) {
                  var iv, key;
                  (key = _arg.key), (iv = _arg.iv);
                  Cipher.__super__.constructor.call(this);
                  this.salsa = new Salsa20WordStream(key, iv);
                  this.bsiw = this.salsa.blockSize / 4;
                }
                Cipher.prototype.scrub = function() {
                  return this.salsa.scrub();
                };
                Cipher.prototype.get_pad = function() {
                  var pad;
                  pad = this.salsa.getWordArray();
                  return pad;
                };
                return Cipher;
              })(StreamCipher);
              exports.encrypt = encrypt = function(_arg) {
                var cipher, input, iv, key, ret;
                (key = _arg.key), (iv = _arg.iv), (input = _arg.input);
                cipher = new Cipher({ key: key, iv: iv });
                ret = cipher.encrypt(input);
                cipher.scrub();
                return ret;
              };
              exports.bulk_encrypt = bulk_encrypt = function(_arg, cb) {
                var cipher,
                  input,
                  iv,
                  key,
                  progress_hook,
                  ret,
                  ___iced_passed_deferral,
                  __iced_deferrals,
                  __iced_k;
                __iced_k = __iced_k_noop;
                ___iced_passed_deferral = iced.findDeferral(arguments);
                (key = _arg.key),
                  (iv = _arg.iv),
                  (input = _arg.input),
                  (progress_hook = _arg.progress_hook);
                cipher = new Cipher({ key: key, iv: iv });
                (function(_this) {
                  return function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename:
                        '/Users/max/src/keybase/triplesec/src/salsa20.iced'
                    });
                    cipher.bulk_encrypt(
                      {
                        input: input,
                        progress_hook: progress_hook,
                        what: 'salsa20'
                      },
                      __iced_deferrals.defer({
                        assign_fn: (function() {
                          return function() {
                            return (ret = arguments[0]);
                          };
                        })(),
                        lineno: 257
                      })
                    );
                    __iced_deferrals._fulfill();
                  };
                })(this)(
                  (function(_this) {
                    return function() {
                      cipher.scrub();
                      return cb(ret);
                    };
                  })(this)
                );
              };
              exports.Salsa20InnerCore = Salsa20InnerCore;
              exports.endian_reverse = endian_reverse;
              exports.asum = asum;
            }.call(this));
          }.call(this, require('buffer').Buffer));
        },
        {
          './algbase': 474,
          './ctr': 476,
          './util': 495,
          './wordarray': 496,
          buffer: 183,
          'iced-runtime': 379
        }
      ],
      487: [
        function(require, module, exports) {
          (function() {
            var HMAC_SHA256,
              Salsa20InnerCore,
              Scrypt,
              Timer,
              WordArray,
              blkcpy,
              blkxor,
              default_delay,
              endian_reverse,
              fixup_uint32,
              iced,
              pbkdf2,
              scrub_vec,
              scrypt,
              timer,
              ui8a_to_buffer,
              v_endian_reverse,
              __iced_k,
              __iced_k_noop,
              _ref,
              _ref1,
              _ref2;
            iced = require('iced-runtime');
            __iced_k = __iced_k_noop = function() {};
            HMAC_SHA256 = require('./hmac').HMAC_SHA256;
            pbkdf2 = require('./pbkdf2').pbkdf2;
            (_ref = require('./salsa20')),
              (endian_reverse = _ref.endian_reverse),
              (Salsa20InnerCore = _ref.Salsa20InnerCore);
            (_ref1 = require('./wordarray')),
              (ui8a_to_buffer = _ref1.ui8a_to_buffer),
              (WordArray = _ref1.WordArray);
            (_ref2 = require('./util')),
              (fixup_uint32 = _ref2.fixup_uint32),
              (default_delay = _ref2.default_delay),
              (scrub_vec = _ref2.scrub_vec);
            Timer = (function() {
              function Timer() {
                this.tot = 0;
              }
              Timer.prototype.start = function() {
                return (this._t = Date.now());
              };
              Timer.prototype.stop = function() {
                return (this.tot += Date.now() - this._t);
              };
              return Timer;
            })();
            timer = new Timer();
            blkcpy = function(D, S, d_offset, s_offset, len) {
              'use asm';
              var end, i, j;
              j = (d_offset << 4) | 0;
              i = (s_offset << 4) | 0;
              end = (i + (len << 4)) | 0;
              while (i < end) {
                D[j] = S[i];
                D[j + 1] = S[i + 1];
                D[j + 2] = S[i + 2];
                D[j + 3] = S[i + 3];
                D[j + 4] = S[i + 4];
                D[j + 5] = S[i + 5];
                D[j + 6] = S[i + 6];
                D[j + 7] = S[i + 7];
                D[j + 8] = S[i + 8];
                D[j + 9] = S[i + 9];
                D[j + 10] = S[i + 10];
                D[j + 11] = S[i + 11];
                D[j + 12] = S[i + 12];
                D[j + 13] = S[i + 13];
                D[j + 14] = S[i + 14];
                D[j + 15] = S[i + 15];
                i += 16;
                j += 16;
              }
              return true;
            };
            blkxor = function(D, S, s_offset, len) {
              'use asm';
              var i, j;
              len = (len << 4) | 0;
              i = 0;
              j = (s_offset << 4) | 0;
              while (i < len) {
                D[i] ^= S[j];
                D[i + 1] ^= S[j + 1];
                D[i + 2] ^= S[j + 2];
                D[i + 3] ^= S[j + 3];
                D[i + 4] ^= S[j + 4];
                D[i + 5] ^= S[j + 5];
                D[i + 6] ^= S[j + 6];
                D[i + 7] ^= S[j + 7];
                D[i + 8] ^= S[j + 8];
                D[i + 9] ^= S[j + 9];
                D[i + 10] ^= S[j + 10];
                D[i + 11] ^= S[j + 11];
                D[i + 12] ^= S[j + 12];
                D[i + 13] ^= S[j + 13];
                D[i + 14] ^= S[j + 14];
                D[i + 15] ^= S[j + 15];
                i += 16;
                j += 16;
              }
              return true;
            };
            v_endian_reverse = function(v) {
              var e, i, _i, _len;
              for (i = _i = 0, _len = v.length; _i < _len; i = ++_i) {
                e = v[i];
                v[i] = endian_reverse(e);
              }
              return true;
            };
            Scrypt = (function() {
              function Scrypt(_arg) {
                var N, c, c0, c1;
                (N = _arg.N),
                  (this.r = _arg.r),
                  (this.p = _arg.p),
                  (c = _arg.c),
                  (c0 = _arg.c0),
                  (c1 = _arg.c1),
                  (this.klass = _arg.klass);
                this.N || (this.N = 1 << (N || 15));
                this.r || (this.r = 8);
                this.p || (this.p = 1);
                this.c0 = c0 || c || 1;
                this.c1 = c1 || c || 1;
                this.klass || (this.klass = HMAC_SHA256);
                this.X16_tmp = new Int32Array(16);
                this.s20ic = new Salsa20InnerCore(8);
              }
              Scrypt.prototype.salsa20_8 = function(B) {
                var X, i, x, _i, _len;
                X = this.s20ic._core(B);
                for (i = _i = 0, _len = X.length; _i < _len; i = ++_i) {
                  x = X[i];
                  B[i] += x;
                }
                return true;
              };
              Scrypt.prototype.pbkdf2 = function(_arg, cb) {
                var c,
                  dkLen,
                  key,
                  progress_hook,
                  salt,
                  wa,
                  ___iced_passed_deferral,
                  __iced_deferrals,
                  __iced_k;
                __iced_k = __iced_k_noop;
                ___iced_passed_deferral = iced.findDeferral(arguments);
                (key = _arg.key),
                  (salt = _arg.salt),
                  (dkLen = _arg.dkLen),
                  (progress_hook = _arg.progress_hook),
                  (c = _arg.c);
                (function(_this) {
                  return function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename:
                        '/Users/max/src/keybase/triplesec/src/scrypt.iced',
                      funcname: 'Scrypt.pbkdf2'
                    });
                    pbkdf2(
                      {
                        key: key,
                        salt: salt,
                        c: c,
                        dkLen: dkLen,
                        klass: _this.klass,
                        progress_hook: progress_hook
                      },
                      __iced_deferrals.defer({
                        assign_fn: (function() {
                          return function() {
                            return (wa = arguments[0]);
                          };
                        })(),
                        lineno: 113
                      })
                    );
                    __iced_deferrals._fulfill();
                  };
                })(this)(
                  (function(_this) {
                    return function() {
                      return cb(wa);
                    };
                  })(this)
                );
              };
              Scrypt.prototype.blockmix_salsa8 = function(B, Y) {
                var X, i, _i, _ref3;
                X = this.X16_tmp;
                blkcpy(X, B, 0, 2 * this.r - 1, 1);
                for (
                  i = _i = 0, _ref3 = 2 * this.r;
                  0 <= _ref3 ? _i < _ref3 : _i > _ref3;
                  i = 0 <= _ref3 ? ++_i : --_i
                ) {
                  blkxor(X, B, i, 1);
                  this.salsa20_8(X);
                  blkcpy(Y, X, i, 0, 1);
                }
                i = 0;
                while (i < this.r) {
                  blkcpy(B, Y, i, i * 2, 1);
                  i++;
                }
                i = 0;
                while (i < this.r) {
                  blkcpy(B, Y, i + this.r, i * 2 + 1, 1);
                  i++;
                }
                return true;
              };
              Scrypt.prototype.smix = function(_arg, cb) {
                var B,
                  V,
                  X,
                  XY,
                  Y,
                  i,
                  j,
                  lim,
                  progress_hook,
                  stop,
                  ___iced_passed_deferral,
                  __iced_deferrals,
                  __iced_k;
                __iced_k = __iced_k_noop;
                ___iced_passed_deferral = iced.findDeferral(arguments);
                (B = _arg.B),
                  (V = _arg.V),
                  (XY = _arg.XY),
                  (progress_hook = _arg.progress_hook);
                X = XY;
                lim = 2 * this.r;
                Y = XY.subarray(16 * lim);
                blkcpy(X, B, 0, 0, lim);
                i = 0;
                (function(_this) {
                  return function(__iced_k) {
                    var _while;
                    _while = function(__iced_k) {
                      var _break, _continue, _next;
                      _break = __iced_k;
                      _continue = function() {
                        return iced.trampoline(function() {
                          return _while(__iced_k);
                        });
                      };
                      _next = _continue;
                      if (!(i < _this.N)) {
                        return _break();
                      } else {
                        stop = Math.min(_this.N, i + 2048);
                        while (i < stop) {
                          blkcpy(V, X, lim * i, 0, lim);
                          _this.blockmix_salsa8(X, Y);
                          i++;
                        }
                        if (typeof progress_hook === 'function') {
                          progress_hook(i);
                        }
                        (function(__iced_k) {
                          __iced_deferrals = new iced.Deferrals(__iced_k, {
                            parent: ___iced_passed_deferral,
                            filename:
                              '/Users/max/src/keybase/triplesec/src/scrypt.iced',
                            funcname: 'Scrypt.smix'
                          });
                          default_delay(
                            0,
                            0,
                            __iced_deferrals.defer({ lineno: 170 })
                          );
                          __iced_deferrals._fulfill();
                        })(_next);
                      }
                    };
                    _while(__iced_k);
                  };
                })(this)(
                  (function(_this) {
                    return function() {
                      i = 0;
                      (function(__iced_k) {
                        var _while;
                        _while = function(__iced_k) {
                          var _break, _continue, _next;
                          _break = __iced_k;
                          _continue = function() {
                            return iced.trampoline(function() {
                              return _while(__iced_k);
                            });
                          };
                          _next = _continue;
                          if (!(i < _this.N)) {
                            return _break();
                          } else {
                            stop = Math.min(_this.N, i + 256);
                            while (i < stop) {
                              j =
                                fixup_uint32(X[16 * (lim - 1)]) & (_this.N - 1);
                              blkxor(X, V, j * lim, lim);
                              _this.blockmix_salsa8(X, Y);
                              i++;
                            }
                            if (typeof progress_hook === 'function') {
                              progress_hook(i + _this.N);
                            }
                            (function(__iced_k) {
                              __iced_deferrals = new iced.Deferrals(__iced_k, {
                                parent: ___iced_passed_deferral,
                                filename:
                                  '/Users/max/src/keybase/triplesec/src/scrypt.iced',
                                funcname: 'Scrypt.smix'
                              });
                              default_delay(
                                0,
                                0,
                                __iced_deferrals.defer({ lineno: 187 })
                              );
                              __iced_deferrals._fulfill();
                            })(_next);
                          }
                        };
                        _while(__iced_k);
                      })(function() {
                        blkcpy(B, X, 0, 0, lim);
                        return cb();
                      });
                    };
                  })(this)
                );
              };
              Scrypt.prototype.run = function(_arg, cb) {
                var B,
                  MAX,
                  V,
                  XY,
                  dkLen,
                  err,
                  j,
                  key,
                  lph,
                  out,
                  progress_hook,
                  ret,
                  salt,
                  ___iced_passed_deferral,
                  __iced_deferrals,
                  __iced_k,
                  _begin,
                  _end,
                  _positive;
                __iced_k = __iced_k_noop;
                ___iced_passed_deferral = iced.findDeferral(arguments);
                (key = _arg.key),
                  (salt = _arg.salt),
                  (dkLen = _arg.dkLen),
                  (progress_hook = _arg.progress_hook);
                MAX = 4294967295;
                err = ret = null;
                err =
                  dkLen > MAX
                    ? (err = new Error('asked for too much data'))
                    : this.r * this.p >= 1 << 30
                    ? new Error('r & p are too big')
                    : this.r > MAX / 128 / this.p ||
                      this.r > MAX / 256 ||
                      this.N > MAX / 128 / this.r
                    ? new Error('N is too big')
                    : null;
                XY = new Int32Array(64 * this.r);
                V = new Int32Array(32 * this.r * this.N);
                lph = function(o) {
                  o.what += ' (pass 1)';
                  return typeof progress_hook === 'function'
                    ? progress_hook(o)
                    : void 0;
                };
                (function(_this) {
                  return function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename:
                        '/Users/max/src/keybase/triplesec/src/scrypt.iced',
                      funcname: 'Scrypt.run'
                    });
                    _this.pbkdf2(
                      {
                        key: key.clone(),
                        salt: salt,
                        dkLen: 128 * _this.r * _this.p,
                        c: _this.c0,
                        progress_hook: lph
                      },
                      __iced_deferrals.defer({
                        assign_fn: (function() {
                          return function() {
                            return (B = arguments[0]);
                          };
                        })(),
                        lineno: 218
                      })
                    );
                    __iced_deferrals._fulfill();
                  };
                })(this)(
                  (function(_this) {
                    return function() {
                      B = new Int32Array(B.words);
                      v_endian_reverse(B);
                      lph = function(j) {
                        return function(i) {
                          return typeof progress_hook === 'function'
                            ? progress_hook({
                                i: i + j * _this.N * 2,
                                what: 'scrypt',
                                total: _this.p * _this.N * 2
                              })
                            : void 0;
                        };
                      };
                      (function(__iced_k) {
                        var _i, _results, _while;
                        j = 0;
                        _begin = 0;
                        _end = _this.p;
                        _positive = _end > _begin;
                        _while = function(__iced_k) {
                          var _break, _continue, _next;
                          _break = __iced_k;
                          _continue = function() {
                            return iced.trampoline(function() {
                              if (_positive) {
                                j += 1;
                              } else {
                                j -= 1;
                              }
                              return _while(__iced_k);
                            });
                          };
                          _next = _continue;
                          if (
                            !!(
                              (_positive === true && j >= _this.p) ||
                              (_positive === false && j <= _this.p)
                            )
                          ) {
                            return _break();
                          } else {
                            (function(__iced_k) {
                              __iced_deferrals = new iced.Deferrals(__iced_k, {
                                parent: ___iced_passed_deferral,
                                filename:
                                  '/Users/max/src/keybase/triplesec/src/scrypt.iced',
                                funcname: 'Scrypt.run'
                              });
                              _this.smix(
                                {
                                  B: B.subarray(32 * _this.r * j),
                                  V: V,
                                  XY: XY,
                                  progress_hook: lph(j)
                                },
                                __iced_deferrals.defer({ lineno: 225 })
                              );
                              __iced_deferrals._fulfill();
                            })(_next);
                          }
                        };
                        _while(__iced_k);
                      })(function() {
                        v_endian_reverse(B);
                        lph = function(o) {
                          o.what += ' (pass 2)';
                          return typeof progress_hook === 'function'
                            ? progress_hook(o)
                            : void 0;
                        };
                        (function(__iced_k) {
                          __iced_deferrals = new iced.Deferrals(__iced_k, {
                            parent: ___iced_passed_deferral,
                            filename:
                              '/Users/max/src/keybase/triplesec/src/scrypt.iced',
                            funcname: 'Scrypt.run'
                          });
                          _this.pbkdf2(
                            {
                              key: key,
                              salt: WordArray.from_i32a(B),
                              dkLen: dkLen,
                              c: _this.c1,
                              progress_hook: lph
                            },
                            __iced_deferrals.defer({
                              assign_fn: (function() {
                                return function() {
                                  return (out = arguments[0]);
                                };
                              })(),
                              lineno: 233
                            })
                          );
                          __iced_deferrals._fulfill();
                        })(function() {
                          scrub_vec(XY);
                          scrub_vec(V);
                          scrub_vec(B);
                          key.scrub();
                          return cb(out);
                        });
                      });
                    };
                  })(this)
                );
              };
              return Scrypt;
            })();
            scrypt = function(_arg, cb) {
              var N,
                c,
                c0,
                c1,
                dkLen,
                eng,
                key,
                klass,
                p,
                progress_hook,
                r,
                salt,
                wa,
                ___iced_passed_deferral,
                __iced_deferrals,
                __iced_k;
              __iced_k = __iced_k_noop;
              ___iced_passed_deferral = iced.findDeferral(arguments);
              (key = _arg.key),
                (salt = _arg.salt),
                (r = _arg.r),
                (N = _arg.N),
                (p = _arg.p),
                (c0 = _arg.c0),
                (c1 = _arg.c1),
                (c = _arg.c),
                (klass = _arg.klass),
                (progress_hook = _arg.progress_hook),
                (dkLen = _arg.dkLen);
              eng = new Scrypt({
                r: r,
                N: N,
                p: p,
                c: c,
                c0: c0,
                c1: c1,
                klass: klass
              });
              (function(_this) {
                return function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: '/Users/max/src/keybase/triplesec/src/scrypt.iced'
                  });
                  eng.run(
                    {
                      key: key,
                      salt: salt,
                      progress_hook: progress_hook,
                      dkLen: dkLen
                    },
                    __iced_deferrals.defer({
                      assign_fn: (function() {
                        return function() {
                          return (wa = arguments[0]);
                        };
                      })(),
                      lineno: 263
                    })
                  );
                  __iced_deferrals._fulfill();
                };
              })(this)(
                (function(_this) {
                  return function() {
                    return cb(wa);
                  };
                })(this)
              );
            };
            exports.Scrypt = Scrypt;
            exports.scrypt = scrypt;
            exports.v_endian_reverse = v_endian_reverse;
          }.call(this));
        },
        {
          './hmac': 480,
          './pbkdf2': 483,
          './salsa20': 486,
          './util': 495,
          './wordarray': 496,
          'iced-runtime': 379
        }
      ],
      488: [
        function(require, module, exports) {
          (function() {
            var Hasher,
              SHA1,
              W,
              WordArray,
              transform,
              __hasProp = {}.hasOwnProperty,
              __extends = function(child, parent) {
                for (var key in parent) {
                  if (__hasProp.call(parent, key)) child[key] = parent[key];
                }
                function ctor() {
                  this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
              };
            WordArray = require('./wordarray').WordArray;
            Hasher = require('./algbase').Hasher;
            W = [];
            SHA1 = (function(_super) {
              __extends(SHA1, _super);
              function SHA1() {
                return SHA1.__super__.constructor.apply(this, arguments);
              }
              SHA1.blockSize = 512 / 32;
              SHA1.prototype.blockSize = SHA1.blockSize;
              SHA1.output_size = 20;
              SHA1.prototype.output_size = SHA1.output_size;
              SHA1.prototype._doReset = function() {
                return (this._hash = new WordArray([
                  1732584193,
                  4023233417,
                  2562383102,
                  271733878,
                  3285377520
                ]));
              };
              SHA1.prototype._doProcessBlock = function(M, offset) {
                var H, a, b, c, d, e, i, n, t, _i;
                H = this._hash.words;
                a = H[0];
                b = H[1];
                c = H[2];
                d = H[3];
                e = H[4];
                for (i = _i = 0; _i < 80; i = ++_i) {
                  if (i < 16) {
                    W[i] = M[offset + i] | 0;
                  } else {
                    n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
                    W[i] = (n << 1) | (n >>> 31);
                  }
                  t = ((a << 5) | (a >>> 27)) + e + W[i];
                  if (i < 20) {
                    t += ((b & c) | (~b & d)) + 1518500249;
                  } else if (i < 40) {
                    t += (b ^ c ^ d) + 1859775393;
                  } else if (i < 60) {
                    t += ((b & c) | (b & d) | (c & d)) - 1894007588;
                  } else {
                    t += (b ^ c ^ d) - 899497514;
                  }
                  e = d;
                  d = c;
                  c = (b << 30) | (b >>> 2);
                  b = a;
                  a = t;
                }
                H[0] = (H[0] + a) | 0;
                H[1] = (H[1] + b) | 0;
                H[2] = (H[2] + c) | 0;
                H[3] = (H[3] + d) | 0;
                return (H[4] = (H[4] + e) | 0);
              };
              SHA1.prototype._doFinalize = function() {
                var data, dataWords, nBitsLeft, nBitsTotal;
                data = this._data;
                dataWords = data.words;
                nBitsTotal = this._nDataBytes * 8;
                nBitsLeft = data.sigBytes * 8;
                dataWords[nBitsLeft >>> 5] |= 128 << (24 - (nBitsLeft % 32));
                dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(
                  nBitsTotal / 4294967296
                );
                dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
                data.sigBytes = dataWords.length * 4;
                this._process();
                return this._hash;
              };
              SHA1.prototype.copy_to = function(obj) {
                SHA1.__super__.copy_to.call(this, obj);
                return (obj._hash = this._hash.clone());
              };
              SHA1.prototype.clone = function() {
                var out;
                out = new SHA1();
                this.copy_to(out);
                return out;
              };
              return SHA1;
            })(Hasher);
            transform = transform = function(x) {
              var out;
              out = new SHA1().finalize(x);
              x.scrub();
              return out;
            };
            exports.SHA1 = SHA1;
            exports.transform = transform;
          }.call(this));
        },
        { './algbase': 474, './wordarray': 496 }
      ],
      489: [
        function(require, module, exports) {
          (function() {
            var SHA224,
              SHA256,
              WordArray,
              transform,
              __hasProp = {}.hasOwnProperty,
              __extends = function(child, parent) {
                for (var key in parent) {
                  if (__hasProp.call(parent, key)) child[key] = parent[key];
                }
                function ctor() {
                  this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
              };
            WordArray = require('./wordarray').WordArray;
            SHA256 = require('./sha256').SHA256;
            SHA224 = (function(_super) {
              __extends(SHA224, _super);
              function SHA224() {
                return SHA224.__super__.constructor.apply(this, arguments);
              }
              SHA224.output_size = 224 / 8;
              SHA224.prototype.output_size = SHA224.output_size;
              SHA224.prototype._doReset = function() {
                return (this._hash = new WordArray([
                  3238371032,
                  914150663,
                  812702999,
                  4144912697,
                  4290775857,
                  1750603025,
                  1694076839,
                  3204075428
                ]));
              };
              SHA224.prototype._doFinalize = function() {
                var hash;
                hash = SHA224.__super__._doFinalize.call(this);
                hash.sigBytes -= 4;
                return hash;
              };
              SHA224.prototype.clone = function() {
                var out;
                out = new SHA224();
                this.copy_to(out);
                return out;
              };
              return SHA224;
            })(SHA256);
            transform = function(x) {
              var out;
              out = new SHA224().finalize(x);
              x.scrub();
              return out;
            };
            exports.SHA224 = SHA224;
            exports.transform = transform;
          }.call(this));
        },
        { './sha256': 490, './wordarray': 496 }
      ],
      490: [
        function(require, module, exports) {
          (function() {
            var Global,
              Hasher,
              SHA256,
              WordArray,
              glbl,
              transform,
              __hasProp = {}.hasOwnProperty,
              __extends = function(child, parent) {
                for (var key in parent) {
                  if (__hasProp.call(parent, key)) child[key] = parent[key];
                }
                function ctor() {
                  this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
              };
            WordArray = require('./wordarray').WordArray;
            Hasher = require('./algbase').Hasher;
            Global = (function() {
              function Global() {
                this.H = [];
                this.K = [];
                this.W = [];
                this.init();
              }
              Global.prototype.isPrime = function(n) {
                var f, sqn, _i;
                if (n === 2 || n === 3 || n === 5 || n === 7) {
                  return true;
                }
                if (n === 1 || n === 4 || n === 6 || n === 8 || n === 9) {
                  return false;
                }
                sqn = Math.ceil(Math.sqrt(n));
                for (
                  f = _i = 2;
                  2 <= sqn ? _i <= sqn : _i >= sqn;
                  f = 2 <= sqn ? ++_i : --_i
                ) {
                  if (n % f === 0) {
                    return false;
                  }
                }
                return true;
              };
              Global.prototype.getFractionalBits = function(n) {
                return ((n - (n | 0)) * 4294967296) | 0;
              };
              Global.prototype.init = function() {
                var n, nPrime, _results;
                n = 2;
                nPrime = 0;
                _results = [];
                while (nPrime < 64) {
                  if (this.isPrime(n)) {
                    if (nPrime < 8) {
                      this.H[nPrime] = this.getFractionalBits(
                        Math.pow(n, 1 / 2)
                      );
                    }
                    this.K[nPrime] = this.getFractionalBits(Math.pow(n, 1 / 3));
                    nPrime++;
                  }
                  _results.push(n++);
                }
                return _results;
              };
              return Global;
            })();
            glbl = new Global();
            SHA256 = (function(_super) {
              __extends(SHA256, _super);
              function SHA256() {
                return SHA256.__super__.constructor.apply(this, arguments);
              }
              SHA256.blockSize = 512 / 32;
              SHA256.prototype.blockSize = SHA256.blockSize;
              SHA256.output_size = 256 / 8;
              SHA256.prototype.output_size = SHA256.output_size;
              SHA256.prototype._doReset = function() {
                return (this._hash = new WordArray(glbl.H.slice(0)));
              };
              SHA256.prototype.get_output_size = function() {
                return this.output_size;
              };
              SHA256.prototype._doProcessBlock = function(M, offset) {
                var H,
                  K,
                  W,
                  a,
                  b,
                  c,
                  ch,
                  d,
                  e,
                  f,
                  g,
                  gamma0,
                  gamma0x,
                  gamma1,
                  gamma1x,
                  h,
                  i,
                  maj,
                  sigma0,
                  sigma1,
                  t1,
                  t2,
                  _i;
                H = this._hash.words;
                W = glbl.W;
                K = glbl.K;
                a = H[0];
                b = H[1];
                c = H[2];
                d = H[3];
                e = H[4];
                f = H[5];
                g = H[6];
                h = H[7];
                for (i = _i = 0; _i < 64; i = ++_i) {
                  if (i < 16) {
                    W[i] = M[offset + i] | 0;
                  } else {
                    gamma0x = W[i - 15];
                    gamma0 =
                      ((gamma0x << 25) | (gamma0x >>> 7)) ^
                      ((gamma0x << 14) | (gamma0x >>> 18)) ^
                      (gamma0x >>> 3);
                    gamma1x = W[i - 2];
                    gamma1 =
                      ((gamma1x << 15) | (gamma1x >>> 17)) ^
                      ((gamma1x << 13) | (gamma1x >>> 19)) ^
                      (gamma1x >>> 10);
                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
                  }
                  ch = (e & f) ^ (~e & g);
                  maj = (a & b) ^ (a & c) ^ (b & c);
                  sigma0 =
                    ((a << 30) | (a >>> 2)) ^
                    ((a << 19) | (a >>> 13)) ^
                    ((a << 10) | (a >>> 22));
                  sigma1 =
                    ((e << 26) | (e >>> 6)) ^
                    ((e << 21) | (e >>> 11)) ^
                    ((e << 7) | (e >>> 25));
                  t1 = h + sigma1 + ch + K[i] + W[i];
                  t2 = sigma0 + maj;
                  h = g;
                  g = f;
                  f = e;
                  e = (d + t1) | 0;
                  d = c;
                  c = b;
                  b = a;
                  a = (t1 + t2) | 0;
                }
                H[0] = (H[0] + a) | 0;
                H[1] = (H[1] + b) | 0;
                H[2] = (H[2] + c) | 0;
                H[3] = (H[3] + d) | 0;
                H[4] = (H[4] + e) | 0;
                H[5] = (H[5] + f) | 0;
                H[6] = (H[6] + g) | 0;
                return (H[7] = (H[7] + h) | 0);
              };
              SHA256.prototype._doFinalize = function() {
                var data, dataWords, nBitsLeft, nBitsTotal;
                data = this._data;
                dataWords = data.words;
                nBitsTotal = this._nDataBytes * 8;
                nBitsLeft = data.sigBytes * 8;
                dataWords[nBitsLeft >>> 5] |= 128 << (24 - (nBitsLeft % 32));
                dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(
                  nBitsTotal / 4294967296
                );
                dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
                data.sigBytes = dataWords.length * 4;
                this._process();
                return this._hash;
              };
              SHA256.prototype.scrub = function() {
                return this._hash.scrub();
              };
              SHA256.prototype.copy_to = function(obj) {
                SHA256.__super__.copy_to.call(this, obj);
                return (obj._hash = this._hash.clone());
              };
              SHA256.prototype.clone = function() {
                var out;
                out = new SHA256();
                this.copy_to(out);
                return out;
              };
              return SHA256;
            })(Hasher);
            transform = function(x) {
              var out;
              out = new SHA256().finalize(x);
              x.scrub();
              return out;
            };
            exports.SHA256 = SHA256;
            exports.transform = transform;
          }.call(this));
        },
        { './algbase': 474, './wordarray': 496 }
      ],
      491: [
        function(require, module, exports) {
          (function() {
            var Global,
              Hasher,
              SHA3,
              WordArray,
              X64Word,
              X64WordArray,
              glbl,
              _ref,
              __hasProp = {}.hasOwnProperty,
              __extends = function(child, parent) {
                for (var key in parent) {
                  if (__hasProp.call(parent, key)) child[key] = parent[key];
                }
                function ctor() {
                  this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
              };
            (_ref = require('./wordarray')),
              (WordArray = _ref.WordArray),
              (X64Word = _ref.X64Word),
              (X64WordArray = _ref.X64WordArray);
            Hasher = require('./algbase').Hasher;
            Global = (function() {
              function Global() {
                this.RHO_OFFSETS = [];
                this.PI_INDEXES = [];
                this.ROUND_CONSTANTS = [];
                this.T = [];
                this.compute_rho_offsets();
                this.compute_pi_indexes();
                this.compute_round_constants();
                this.make_reusables();
              }
              Global.prototype.compute_rho_offsets = function() {
                var newX, newY, t, x, y, _i, _results;
                x = 1;
                y = 0;
                _results = [];
                for (t = _i = 0; _i < 24; t = ++_i) {
                  this.RHO_OFFSETS[x + 5 * y] = (((t + 1) * (t + 2)) / 2) % 64;
                  newX = y % 5;
                  newY = (2 * x + 3 * y) % 5;
                  x = newX;
                  _results.push((y = newY));
                }
                return _results;
              };
              Global.prototype.compute_pi_indexes = function() {
                var x, y, _i, _results;
                _results = [];
                for (x = _i = 0; _i < 5; x = ++_i) {
                  _results.push(
                    function() {
                      var _j, _results1;
                      _results1 = [];
                      for (y = _j = 0; _j < 5; y = ++_j) {
                        _results1.push(
                          (this.PI_INDEXES[x + 5 * y] =
                            y + ((2 * x + 3 * y) % 5) * 5)
                        );
                      }
                      return _results1;
                    }.call(this)
                  );
                }
                return _results;
              };
              Global.prototype.compute_round_constants = function() {
                var LFSR,
                  bitPosition,
                  i,
                  j,
                  roundConstantLsw,
                  roundConstantMsw,
                  _i,
                  _j,
                  _results;
                LFSR = 1;
                _results = [];
                for (i = _i = 0; _i < 24; i = ++_i) {
                  roundConstantMsw = 0;
                  roundConstantLsw = 0;
                  for (j = _j = 0; _j < 7; j = ++_j) {
                    if (LFSR & 1) {
                      bitPosition = (1 << j) - 1;
                      if (bitPosition < 32) {
                        roundConstantLsw ^= 1 << bitPosition;
                      } else {
                        roundConstantMsw ^= 1 << (bitPosition - 32);
                      }
                    }
                    if (LFSR & 128) {
                      LFSR = (LFSR << 1) ^ 113;
                    } else {
                      LFSR <<= 1;
                    }
                  }
                  _results.push(
                    (this.ROUND_CONSTANTS[i] = new X64Word(
                      roundConstantMsw,
                      roundConstantLsw
                    ))
                  );
                }
                return _results;
              };
              Global.prototype.make_reusables = function() {
                var i;
                return (this.T = (function() {
                  var _i, _results;
                  _results = [];
                  for (i = _i = 0; _i < 25; i = ++_i) {
                    _results.push(new X64Word(0, 0));
                  }
                  return _results;
                })());
              };
              return Global;
            })();
            glbl = new Global();
            exports.SHA3 = SHA3 = (function(_super) {
              __extends(SHA3, _super);
              function SHA3() {
                return SHA3.__super__.constructor.apply(this, arguments);
              }
              SHA3.outputLength = 512;
              SHA3.prototype.outputLength = SHA3.outputLength;
              SHA3.blockSize = (1600 - 2 * SHA3.outputLength) / 32;
              SHA3.prototype.blockSize = SHA3.blockSize;
              SHA3.output_size = SHA3.outputLength / 8;
              SHA3.prototype.output_size = SHA3.output_size;
              SHA3.prototype._doReset = function() {
                var i;
                return (this._state = (function() {
                  var _i, _results;
                  _results = [];
                  for (i = _i = 0; _i < 25; i = ++_i) {
                    _results.push(new X64Word(0, 0));
                  }
                  return _results;
                })());
              };
              SHA3.prototype._doProcessBlock = function(M, offset) {
                var G,
                  M2i,
                  M2i1,
                  T0,
                  TLane,
                  TPiLane,
                  Tx,
                  Tx1,
                  Tx1Lane,
                  Tx1Lsw,
                  Tx1Msw,
                  Tx2Lane,
                  Tx4,
                  i,
                  lane,
                  laneIndex,
                  laneLsw,
                  laneMsw,
                  nBlockSizeLanes,
                  rhoOffset,
                  round,
                  roundConstant,
                  state,
                  state0,
                  tLsw,
                  tMsw,
                  x,
                  y,
                  _i,
                  _j,
                  _k,
                  _l,
                  _m,
                  _n,
                  _o,
                  _p,
                  _q,
                  _results;
                G = glbl;
                state = this._state;
                nBlockSizeLanes = this.blockSize / 2;
                for (
                  i = _i = 0;
                  0 <= nBlockSizeLanes
                    ? _i < nBlockSizeLanes
                    : _i > nBlockSizeLanes;
                  i = 0 <= nBlockSizeLanes ? ++_i : --_i
                ) {
                  M2i = M[offset + 2 * i];
                  M2i1 = M[offset + 2 * i + 1];
                  M2i =
                    (((M2i << 8) | (M2i >>> 24)) & 16711935) |
                    (((M2i << 24) | (M2i >>> 8)) & 4278255360);
                  M2i1 =
                    (((M2i1 << 8) | (M2i1 >>> 24)) & 16711935) |
                    (((M2i1 << 24) | (M2i1 >>> 8)) & 4278255360);
                  lane = state[i];
                  lane.high ^= M2i1;
                  lane.low ^= M2i;
                }
                _results = [];
                for (round = _j = 0; _j < 24; round = ++_j) {
                  for (x = _k = 0; _k < 5; x = ++_k) {
                    tMsw = tLsw = 0;
                    for (y = _l = 0; _l < 5; y = ++_l) {
                      lane = state[x + 5 * y];
                      tMsw ^= lane.high;
                      tLsw ^= lane.low;
                    }
                    Tx = G.T[x];
                    Tx.high = tMsw;
                    Tx.low = tLsw;
                  }
                  for (x = _m = 0; _m < 5; x = ++_m) {
                    Tx4 = G.T[(x + 4) % 5];
                    Tx1 = G.T[(x + 1) % 5];
                    Tx1Msw = Tx1.high;
                    Tx1Lsw = Tx1.low;
                    tMsw = Tx4.high ^ ((Tx1Msw << 1) | (Tx1Lsw >>> 31));
                    tLsw = Tx4.low ^ ((Tx1Lsw << 1) | (Tx1Msw >>> 31));
                    for (y = _n = 0; _n < 5; y = ++_n) {
                      lane = state[x + 5 * y];
                      lane.high ^= tMsw;
                      lane.low ^= tLsw;
                    }
                  }
                  for (laneIndex = _o = 1; _o < 25; laneIndex = ++_o) {
                    lane = state[laneIndex];
                    laneMsw = lane.high;
                    laneLsw = lane.low;
                    rhoOffset = G.RHO_OFFSETS[laneIndex];
                    if (rhoOffset < 32) {
                      tMsw =
                        (laneMsw << rhoOffset) | (laneLsw >>> (32 - rhoOffset));
                      tLsw =
                        (laneLsw << rhoOffset) | (laneMsw >>> (32 - rhoOffset));
                    } else {
                      tMsw =
                        (laneLsw << (rhoOffset - 32)) |
                        (laneMsw >>> (64 - rhoOffset));
                      tLsw =
                        (laneMsw << (rhoOffset - 32)) |
                        (laneLsw >>> (64 - rhoOffset));
                    }
                    TPiLane = G.T[G.PI_INDEXES[laneIndex]];
                    TPiLane.high = tMsw;
                    TPiLane.low = tLsw;
                  }
                  T0 = G.T[0];
                  state0 = state[0];
                  T0.high = state0.high;
                  T0.low = state0.low;
                  for (x = _p = 0; _p < 5; x = ++_p) {
                    for (y = _q = 0; _q < 5; y = ++_q) {
                      laneIndex = x + 5 * y;
                      lane = state[laneIndex];
                      TLane = G.T[laneIndex];
                      Tx1Lane = G.T[((x + 1) % 5) + 5 * y];
                      Tx2Lane = G.T[((x + 2) % 5) + 5 * y];
                      lane.high = TLane.high ^ (~Tx1Lane.high & Tx2Lane.high);
                      lane.low = TLane.low ^ (~Tx1Lane.low & Tx2Lane.low);
                    }
                  }
                  lane = state[0];
                  roundConstant = G.ROUND_CONSTANTS[round];
                  lane.high ^= roundConstant.high;
                  _results.push((lane.low ^= roundConstant.low));
                }
                return _results;
              };
              SHA3.prototype._doFinalize = function() {
                var blockSizeBits,
                  data,
                  dataWords,
                  hashWords,
                  i,
                  lane,
                  laneLsw,
                  laneMsw,
                  nBitsLeft,
                  nBitsTotal,
                  outputLengthBytes,
                  outputLengthLanes,
                  state,
                  _i;
                data = this._data;
                dataWords = data.words;
                nBitsTotal = this._nDataBytes * 8;
                nBitsLeft = data.sigBytes * 8;
                blockSizeBits = this.blockSize * 32;
                dataWords[nBitsLeft >>> 5] |= 1 << (24 - (nBitsLeft % 32));
                dataWords[
                  ((Math.ceil((nBitsLeft + 1) / blockSizeBits) *
                    blockSizeBits) >>>
                    5) -
                    1
                ] |= 128;
                data.sigBytes = dataWords.length * 4;
                this._process();
                state = this._state;
                outputLengthBytes = this.outputLength / 8;
                outputLengthLanes = outputLengthBytes / 8;
                hashWords = [];
                for (
                  i = _i = 0;
                  0 <= outputLengthLanes
                    ? _i < outputLengthLanes
                    : _i > outputLengthLanes;
                  i = 0 <= outputLengthLanes ? ++_i : --_i
                ) {
                  lane = state[i];
                  laneMsw = lane.high;
                  laneLsw = lane.low;
                  laneMsw =
                    (((laneMsw << 8) | (laneMsw >>> 24)) & 16711935) |
                    (((laneMsw << 24) | (laneMsw >>> 8)) & 4278255360);
                  laneLsw =
                    (((laneLsw << 8) | (laneLsw >>> 24)) & 16711935) |
                    (((laneLsw << 24) | (laneLsw >>> 8)) & 4278255360);
                  hashWords.push(laneLsw);
                  hashWords.push(laneMsw);
                }
                return new WordArray(hashWords, outputLengthBytes);
              };
              SHA3.prototype.copy_to = function(obj) {
                var s;
                SHA3.__super__.copy_to.call(this, obj);
                return (obj._state = function() {
                  var _i, _len, _ref1, _results;
                  _ref1 = this._state;
                  _results = [];
                  for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                    s = _ref1[_i];
                    _results.push(s.clone());
                  }
                  return _results;
                }.call(this));
              };
              SHA3.prototype.scrub = function() {};
              SHA3.prototype.clone = function() {
                var out;
                out = new SHA3();
                this.copy_to(out);
                return out;
              };
              return SHA3;
            })(Hasher);
            exports.transform = function(x) {
              var out;
              out = new SHA3().finalize(x);
              x.scrub();
              return out;
            };
          }.call(this));
        },
        { './algbase': 474, './wordarray': 496 }
      ],
      492: [
        function(require, module, exports) {
          (function() {
            var Global,
              SHA384,
              SHA512,
              WordArray,
              X64WordArray,
              transform,
              _ref,
              _ref1,
              __hasProp = {}.hasOwnProperty,
              __extends = function(child, parent) {
                for (var key in parent) {
                  if (__hasProp.call(parent, key)) child[key] = parent[key];
                }
                function ctor() {
                  this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
              };
            (_ref = require('./wordarray')),
              (X64WordArray = _ref.X64WordArray),
              (WordArray = _ref.WordArray);
            (_ref1 = require('./sha512')),
              (SHA512 = _ref1.SHA512),
              (Global = _ref1.Global);
            SHA384 = (function(_super) {
              __extends(SHA384, _super);
              function SHA384() {
                return SHA384.__super__.constructor.apply(this, arguments);
              }
              SHA384.output_size = 384 / 8;
              SHA384.prototype.output_size = SHA384.output_size;
              SHA384.prototype._doReset = function() {
                return (this._hash = new X64WordArray(
                  Global.convert([
                    3418070365,
                    3238371032,
                    1654270250,
                    914150663,
                    2438529370,
                    812702999,
                    355462360,
                    4144912697,
                    1731405415,
                    4290775857,
                    2394180231,
                    1750603025,
                    3675008525,
                    1694076839,
                    1203062813,
                    3204075428
                  ])
                ));
              };
              SHA384.prototype._doFinalize = function() {
                var hash;
                hash = SHA384.__super__._doFinalize.call(this);
                hash.sigBytes -= 16;
                return hash;
              };
              SHA384.prototype.clone = function() {
                var out;
                out = new SHA384();
                this.copy_to(out);
                return out;
              };
              return SHA384;
            })(SHA512);
            transform = function(x) {
              var out;
              out = new SHA384().finalize(x);
              x.scrub();
              return out;
            };
            exports.SHA384 = SHA384;
            exports.transform = transform;
          }.call(this));
        },
        { './sha512': 493, './wordarray': 496 }
      ],
      493: [
        function(require, module, exports) {
          (function() {
            var Global,
              Hasher,
              SHA512,
              X64Word,
              X64WordArray,
              glbl,
              _ref,
              __hasProp = {}.hasOwnProperty,
              __extends = function(child, parent) {
                for (var key in parent) {
                  if (__hasProp.call(parent, key)) child[key] = parent[key];
                }
                function ctor() {
                  this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
              };
            (_ref = require('./wordarray')),
              (X64Word = _ref.X64Word),
              (X64WordArray = _ref.X64WordArray);
            Hasher = require('./algbase').Hasher;
            Global = (function() {
              Global.convert = function(raw) {
                var i, _i, _ref1, _results;
                _results = [];
                for (i = _i = 0, _ref1 = raw.length; _i < _ref1; i = _i += 2) {
                  _results.push(new X64Word(raw[i], raw[i + 1]));
                }
                return _results;
              };
              Global.prototype.convert = function(raw) {
                return Global.convert(raw);
              };
              function Global() {
                var i;
                this.K = this.convert([
                  1116352408,
                  3609767458,
                  1899447441,
                  602891725,
                  3049323471,
                  3964484399,
                  3921009573,
                  2173295548,
                  961987163,
                  4081628472,
                  1508970993,
                  3053834265,
                  2453635748,
                  2937671579,
                  2870763221,
                  3664609560,
                  3624381080,
                  2734883394,
                  310598401,
                  1164996542,
                  607225278,
                  1323610764,
                  1426881987,
                  3590304994,
                  1925078388,
                  4068182383,
                  2162078206,
                  991336113,
                  2614888103,
                  633803317,
                  3248222580,
                  3479774868,
                  3835390401,
                  2666613458,
                  4022224774,
                  944711139,
                  264347078,
                  2341262773,
                  604807628,
                  2007800933,
                  770255983,
                  1495990901,
                  1249150122,
                  1856431235,
                  1555081692,
                  3175218132,
                  1996064986,
                  2198950837,
                  2554220882,
                  3999719339,
                  2821834349,
                  766784016,
                  2952996808,
                  2566594879,
                  3210313671,
                  3203337956,
                  3336571891,
                  1034457026,
                  3584528711,
                  2466948901,
                  113926993,
                  3758326383,
                  338241895,
                  168717936,
                  666307205,
                  1188179964,
                  773529912,
                  1546045734,
                  1294757372,
                  1522805485,
                  1396182291,
                  2643833823,
                  1695183700,
                  2343527390,
                  1986661051,
                  1014477480,
                  2177026350,
                  1206759142,
                  2456956037,
                  344077627,
                  2730485921,
                  1290863460,
                  2820302411,
                  3158454273,
                  3259730800,
                  3505952657,
                  3345764771,
                  106217008,
                  3516065817,
                  3606008344,
                  3600352804,
                  1432725776,
                  4094571909,
                  1467031594,
                  275423344,
                  851169720,
                  430227734,
                  3100823752,
                  506948616,
                  1363258195,
                  659060556,
                  3750685593,
                  883997877,
                  3785050280,
                  958139571,
                  3318307427,
                  1322822218,
                  3812723403,
                  1537002063,
                  2003034995,
                  1747873779,
                  3602036899,
                  1955562222,
                  1575990012,
                  2024104815,
                  1125592928,
                  2227730452,
                  2716904306,
                  2361852424,
                  442776044,
                  2428436474,
                  593698344,
                  2756734187,
                  3733110249,
                  3204031479,
                  2999351573,
                  3329325298,
                  3815920427,
                  3391569614,
                  3928383900,
                  3515267271,
                  566280711,
                  3940187606,
                  3454069534,
                  4118630271,
                  4000239992,
                  116418474,
                  1914138554,
                  174292421,
                  2731055270,
                  289380356,
                  3203993006,
                  460393269,
                  320620315,
                  685471733,
                  587496836,
                  852142971,
                  1086792851,
                  1017036298,
                  365543100,
                  1126000580,
                  2618297676,
                  1288033470,
                  3409855158,
                  1501505948,
                  4234509866,
                  1607167915,
                  987167468,
                  1816402316,
                  1246189591
                ]);
                this.I = new X64WordArray(
                  this.convert([
                    1779033703,
                    4089235720,
                    3144134277,
                    2227873595,
                    1013904242,
                    4271175723,
                    2773480762,
                    1595750129,
                    1359893119,
                    2917565137,
                    2600822924,
                    725511199,
                    528734635,
                    4215389547,
                    1541459225,
                    327033209
                  ])
                );
                this.W = (function() {
                  var _i, _results;
                  _results = [];
                  for (i = _i = 0; _i < 80; i = ++_i) {
                    _results.push(new X64Word(0, 0));
                  }
                  return _results;
                })();
              }
              return Global;
            })();
            exports.Global = Global;
            glbl = new Global();
            exports.SHA512 = SHA512 = (function(_super) {
              __extends(SHA512, _super);
              function SHA512() {
                return SHA512.__super__.constructor.apply(this, arguments);
              }
              SHA512.blockSize = 1024 / 32;
              SHA512.prototype.blockSize = SHA512.blockSize;
              SHA512.output_size = 512 / 8;
              SHA512.prototype.output_size = SHA512.output_size;
              SHA512.prototype._doReset = function() {
                return (this._hash = glbl.I.clone());
              };
              SHA512.prototype._doProcessBlock = function(M, offset) {
                var H,
                  H0,
                  H0h,
                  H0l,
                  H1,
                  H1h,
                  H1l,
                  H2,
                  H2h,
                  H2l,
                  H3,
                  H3h,
                  H3l,
                  H4,
                  H4h,
                  H4l,
                  H5,
                  H5h,
                  H5l,
                  H6,
                  H6h,
                  H6l,
                  H7,
                  H7h,
                  H7l,
                  Ki,
                  Kih,
                  Kil,
                  W,
                  Wi,
                  Wi16,
                  Wi16h,
                  Wi16l,
                  Wi7,
                  Wi7h,
                  Wi7l,
                  Wih,
                  Wil,
                  ah,
                  al,
                  bh,
                  bl,
                  ch,
                  chh,
                  chl,
                  cl,
                  dh,
                  dl,
                  eh,
                  el,
                  fh,
                  fl,
                  gamma0h,
                  gamma0l,
                  gamma0x,
                  gamma0xh,
                  gamma0xl,
                  gamma1h,
                  gamma1l,
                  gamma1x,
                  gamma1xh,
                  gamma1xl,
                  gh,
                  gl,
                  hh,
                  hl,
                  i,
                  majh,
                  majl,
                  sigma0h,
                  sigma0l,
                  sigma1h,
                  sigma1l,
                  t1h,
                  t1l,
                  t2h,
                  t2l,
                  _i;
                H = this._hash.words;
                W = glbl.W;
                H0 = H[0];
                H1 = H[1];
                H2 = H[2];
                H3 = H[3];
                H4 = H[4];
                H5 = H[5];
                H6 = H[6];
                H7 = H[7];
                H0h = H0.high;
                H0l = H0.low;
                H1h = H1.high;
                H1l = H1.low;
                H2h = H2.high;
                H2l = H2.low;
                H3h = H3.high;
                H3l = H3.low;
                H4h = H4.high;
                H4l = H4.low;
                H5h = H5.high;
                H5l = H5.low;
                H6h = H6.high;
                H6l = H6.low;
                H7h = H7.high;
                H7l = H7.low;
                ah = H0h;
                al = H0l;
                bh = H1h;
                bl = H1l;
                ch = H2h;
                cl = H2l;
                dh = H3h;
                dl = H3l;
                eh = H4h;
                el = H4l;
                fh = H5h;
                fl = H5l;
                gh = H6h;
                gl = H6l;
                hh = H7h;
                hl = H7l;
                for (i = _i = 0; _i < 80; i = ++_i) {
                  Wi = W[i];
                  if (i < 16) {
                    Wih = Wi.high = M[offset + i * 2] | 0;
                    Wil = Wi.low = M[offset + i * 2 + 1] | 0;
                  } else {
                    gamma0x = W[i - 15];
                    gamma0xh = gamma0x.high;
                    gamma0xl = gamma0x.low;
                    gamma0h =
                      ((gamma0xh >>> 1) | (gamma0xl << 31)) ^
                      ((gamma0xh >>> 8) | (gamma0xl << 24)) ^
                      (gamma0xh >>> 7);
                    gamma0l =
                      ((gamma0xl >>> 1) | (gamma0xh << 31)) ^
                      ((gamma0xl >>> 8) | (gamma0xh << 24)) ^
                      ((gamma0xl >>> 7) | (gamma0xh << 25));
                    gamma1x = W[i - 2];
                    gamma1xh = gamma1x.high;
                    gamma1xl = gamma1x.low;
                    gamma1h =
                      ((gamma1xh >>> 19) | (gamma1xl << 13)) ^
                      ((gamma1xh << 3) | (gamma1xl >>> 29)) ^
                      (gamma1xh >>> 6);
                    gamma1l =
                      ((gamma1xl >>> 19) | (gamma1xh << 13)) ^
                      ((gamma1xl << 3) | (gamma1xh >>> 29)) ^
                      ((gamma1xl >>> 6) | (gamma1xh << 26));
                    Wi7 = W[i - 7];
                    Wi7h = Wi7.high;
                    Wi7l = Wi7.low;
                    Wi16 = W[i - 16];
                    Wi16h = Wi16.high;
                    Wi16l = Wi16.low;
                    Wil = gamma0l + Wi7l;
                    Wih = gamma0h + Wi7h + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0);
                    Wil = Wil + gamma1l;
                    Wih = Wih + gamma1h + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0);
                    Wil = Wil + Wi16l;
                    Wih = Wih + Wi16h + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0);
                    Wi.high = Wih;
                    Wi.low = Wil;
                  }
                  chh = (eh & fh) ^ (~eh & gh);
                  chl = (el & fl) ^ (~el & gl);
                  majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);
                  majl = (al & bl) ^ (al & cl) ^ (bl & cl);
                  sigma0h =
                    ((ah >>> 28) | (al << 4)) ^
                    ((ah << 30) | (al >>> 2)) ^
                    ((ah << 25) | (al >>> 7));
                  sigma0l =
                    ((al >>> 28) | (ah << 4)) ^
                    ((al << 30) | (ah >>> 2)) ^
                    ((al << 25) | (ah >>> 7));
                  sigma1h =
                    ((eh >>> 14) | (el << 18)) ^
                    ((eh >>> 18) | (el << 14)) ^
                    ((eh << 23) | (el >>> 9));
                  sigma1l =
                    ((el >>> 14) | (eh << 18)) ^
                    ((el >>> 18) | (eh << 14)) ^
                    ((el << 23) | (eh >>> 9));
                  Ki = glbl.K[i];
                  Kih = Ki.high;
                  Kil = Ki.low;
                  t1l = hl + sigma1l;
                  t1h = hh + sigma1h + (t1l >>> 0 < hl >>> 0 ? 1 : 0);
                  t1l = t1l + chl;
                  t1h = t1h + chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0);
                  t1l = t1l + Kil;
                  t1h = t1h + Kih + (t1l >>> 0 < Kil >>> 0 ? 1 : 0);
                  t1l = t1l + Wil;
                  t1h = t1h + Wih + (t1l >>> 0 < Wil >>> 0 ? 1 : 0);
                  t2l = sigma0l + majl;
                  t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0);
                  hh = gh;
                  hl = gl;
                  gh = fh;
                  gl = fl;
                  fh = eh;
                  fl = el;
                  el = (dl + t1l) | 0;
                  eh = (dh + t1h + (el >>> 0 < dl >>> 0 ? 1 : 0)) | 0;
                  dh = ch;
                  dl = cl;
                  ch = bh;
                  cl = bl;
                  bh = ah;
                  bl = al;
                  al = (t1l + t2l) | 0;
                  ah = (t1h + t2h + (al >>> 0 < t1l >>> 0 ? 1 : 0)) | 0;
                }
                H0l = H0.low = H0l + al;
                H0.high = H0h + ah + (H0l >>> 0 < al >>> 0 ? 1 : 0);
                H1l = H1.low = H1l + bl;
                H1.high = H1h + bh + (H1l >>> 0 < bl >>> 0 ? 1 : 0);
                H2l = H2.low = H2l + cl;
                H2.high = H2h + ch + (H2l >>> 0 < cl >>> 0 ? 1 : 0);
                H3l = H3.low = H3l + dl;
                H3.high = H3h + dh + (H3l >>> 0 < dl >>> 0 ? 1 : 0);
                H4l = H4.low = H4l + el;
                H4.high = H4h + eh + (H4l >>> 0 < el >>> 0 ? 1 : 0);
                H5l = H5.low = H5l + fl;
                H5.high = H5h + fh + (H5l >>> 0 < fl >>> 0 ? 1 : 0);
                H6l = H6.low = H6l + gl;
                H6.high = H6h + gh + (H6l >>> 0 < gl >>> 0 ? 1 : 0);
                H7l = H7.low = H7l + hl;
                return (H7.high = H7h + hh + (H7l >>> 0 < hl >>> 0 ? 1 : 0));
              };
              SHA512.prototype._doFinalize = function() {
                var dataWords, nBitsLeft, nBitsTotal;
                dataWords = this._data.words;
                nBitsTotal = this._nDataBytes * 8;
                nBitsLeft = this._data.sigBytes * 8;
                dataWords[nBitsLeft >>> 5] |= 128 << (24 - (nBitsLeft % 32));
                dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 30] = Math.floor(
                  nBitsTotal / 4294967296
                );
                dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 31] = nBitsTotal;
                this._data.sigBytes = dataWords.length * 4;
                this._process();
                return this._hash.toX32();
              };
              SHA512.prototype.copy_to = function(obj) {
                SHA512.__super__.copy_to.call(this, obj);
                return (obj._hash = this._hash.clone());
              };
              SHA512.prototype.clone = function() {
                var out;
                out = new SHA512();
                this.copy_to(out);
                return out;
              };
              return SHA512;
            })(Hasher);
            exports.transform = function(x) {
              var out;
              out = new SHA512().finalize(x);
              x.scrub();
              return out;
            };
          }.call(this));
        },
        { './algbase': 474, './wordarray': 496 }
      ],
      494: [
        function(require, module, exports) {
          (function() {
            var BlockCipher,
              G,
              Global,
              TwoFish,
              scrub_vec,
              __hasProp = {}.hasOwnProperty,
              __extends = function(child, parent) {
                for (var key in parent) {
                  if (__hasProp.call(parent, key)) child[key] = parent[key];
                }
                function ctor() {
                  this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
              };
            BlockCipher = require('./algbase').BlockCipher;
            scrub_vec = require('./util').scrub_vec;
            Global = (function() {
              function Global() {
                this.P = [
                  [
                    169,
                    103,
                    179,
                    232,
                    4,
                    253,
                    163,
                    118,
                    154,
                    146,
                    128,
                    120,
                    228,
                    221,
                    209,
                    56,
                    13,
                    198,
                    53,
                    152,
                    24,
                    247,
                    236,
                    108,
                    67,
                    117,
                    55,
                    38,
                    250,
                    19,
                    148,
                    72,
                    242,
                    208,
                    139,
                    48,
                    132,
                    84,
                    223,
                    35,
                    25,
                    91,
                    61,
                    89,
                    243,
                    174,
                    162,
                    130,
                    99,
                    1,
                    131,
                    46,
                    217,
                    81,
                    155,
                    124,
                    166,
                    235,
                    165,
                    190,
                    22,
                    12,
                    227,
                    97,
                    192,
                    140,
                    58,
                    245,
                    115,
                    44,
                    37,
                    11,
                    187,
                    78,
                    137,
                    107,
                    83,
                    106,
                    180,
                    241,
                    225,
                    230,
                    189,
                    69,
                    226,
                    244,
                    182,
                    102,
                    204,
                    149,
                    3,
                    86,
                    212,
                    28,
                    30,
                    215,
                    251,
                    195,
                    142,
                    181,
                    233,
                    207,
                    191,
                    186,
                    234,
                    119,
                    57,
                    175,
                    51,
                    201,
                    98,
                    113,
                    129,
                    121,
                    9,
                    173,
                    36,
                    205,
                    249,
                    216,
                    229,
                    197,
                    185,
                    77,
                    68,
                    8,
                    134,
                    231,
                    161,
                    29,
                    170,
                    237,
                    6,
                    112,
                    178,
                    210,
                    65,
                    123,
                    160,
                    17,
                    49,
                    194,
                    39,
                    144,
                    32,
                    246,
                    96,
                    255,
                    150,
                    92,
                    177,
                    171,
                    158,
                    156,
                    82,
                    27,
                    95,
                    147,
                    10,
                    239,
                    145,
                    133,
                    73,
                    238,
                    45,
                    79,
                    143,
                    59,
                    71,
                    135,
                    109,
                    70,
                    214,
                    62,
                    105,
                    100,
                    42,
                    206,
                    203,
                    47,
                    252,
                    151,
                    5,
                    122,
                    172,
                    127,
                    213,
                    26,
                    75,
                    14,
                    167,
                    90,
                    40,
                    20,
                    63,
                    41,
                    136,
                    60,
                    76,
                    2,
                    184,
                    218,
                    176,
                    23,
                    85,
                    31,
                    138,
                    125,
                    87,
                    199,
                    141,
                    116,
                    183,
                    196,
                    159,
                    114,
                    126,
                    21,
                    34,
                    18,
                    88,
                    7,
                    153,
                    52,
                    110,
                    80,
                    222,
                    104,
                    101,
                    188,
                    219,
                    248,
                    200,
                    168,
                    43,
                    64,
                    220,
                    254,
                    50,
                    164,
                    202,
                    16,
                    33,
                    240,
                    211,
                    93,
                    15,
                    0,
                    111,
                    157,
                    54,
                    66,
                    74,
                    94,
                    193,
                    224
                  ],
                  [
                    117,
                    243,
                    198,
                    244,
                    219,
                    123,
                    251,
                    200,
                    74,
                    211,
                    230,
                    107,
                    69,
                    125,
                    232,
                    75,
                    214,
                    50,
                    216,
                    253,
                    55,
                    113,
                    241,
                    225,
                    48,
                    15,
                    248,
                    27,
                    135,
                    250,
                    6,
                    63,
                    94,
                    186,
                    174,
                    91,
                    138,
                    0,
                    188,
                    157,
                    109,
                    193,
                    177,
                    14,
                    128,
                    93,
                    210,
                    213,
                    160,
                    132,
                    7,
                    20,
                    181,
                    144,
                    44,
                    163,
                    178,
                    115,
                    76,
                    84,
                    146,
                    116,
                    54,
                    81,
                    56,
                    176,
                    189,
                    90,
                    252,
                    96,
                    98,
                    150,
                    108,
                    66,
                    247,
                    16,
                    124,
                    40,
                    39,
                    140,
                    19,
                    149,
                    156,
                    199,
                    36,
                    70,
                    59,
                    112,
                    202,
                    227,
                    133,
                    203,
                    17,
                    208,
                    147,
                    184,
                    166,
                    131,
                    32,
                    255,
                    159,
                    119,
                    195,
                    204,
                    3,
                    111,
                    8,
                    191,
                    64,
                    231,
                    43,
                    226,
                    121,
                    12,
                    170,
                    130,
                    65,
                    58,
                    234,
                    185,
                    228,
                    154,
                    164,
                    151,
                    126,
                    218,
                    122,
                    23,
                    102,
                    148,
                    161,
                    29,
                    61,
                    240,
                    222,
                    179,
                    11,
                    114,
                    167,
                    28,
                    239,
                    209,
                    83,
                    62,
                    143,
                    51,
                    38,
                    95,
                    236,
                    118,
                    42,
                    73,
                    129,
                    136,
                    238,
                    33,
                    196,
                    26,
                    235,
                    217,
                    197,
                    57,
                    153,
                    205,
                    173,
                    49,
                    139,
                    1,
                    24,
                    35,
                    221,
                    31,
                    78,
                    45,
                    249,
                    72,
                    79,
                    242,
                    101,
                    142,
                    120,
                    92,
                    88,
                    25,
                    141,
                    229,
                    152,
                    87,
                    103,
                    127,
                    5,
                    100,
                    175,
                    99,
                    182,
                    254,
                    245,
                    183,
                    60,
                    165,
                    206,
                    233,
                    104,
                    68,
                    224,
                    77,
                    67,
                    105,
                    41,
                    46,
                    172,
                    21,
                    89,
                    168,
                    10,
                    158,
                    110,
                    71,
                    223,
                    52,
                    53,
                    106,
                    207,
                    220,
                    34,
                    201,
                    192,
                    155,
                    137,
                    212,
                    237,
                    171,
                    18,
                    162,
                    13,
                    82,
                    187,
                    2,
                    47,
                    169,
                    215,
                    97,
                    30,
                    180,
                    80,
                    4,
                    246,
                    194,
                    22,
                    37,
                    134,
                    86,
                    85,
                    9,
                    190,
                    145
                  ]
                ];
                this.P_00 = 1;
                this.P_01 = 0;
                this.P_02 = 0;
                this.P_03 = 1;
                this.P_04 = 1;
                this.P_10 = 0;
                this.P_11 = 0;
                this.P_12 = 1;
                this.P_13 = 1;
                this.P_14 = 0;
                this.P_20 = 1;
                this.P_21 = 1;
                this.P_22 = 0;
                this.P_23 = 0;
                this.P_24 = 0;
                this.P_30 = 0;
                this.P_31 = 1;
                this.P_32 = 1;
                this.P_33 = 0;
                this.P_34 = 1;
                this.GF256_FDBK = 361;
                this.GF256_FDBK_2 = this.GF256_FDBK / 2;
                this.GF256_FDBK_4 = this.GF256_FDBK / 4;
                this.RS_GF_FDBK = 333;
                this.SK_STEP = 33686018;
                this.SK_BUMP = 16843009;
                this.SK_ROTL = 9;
              }
              return Global;
            })();
            G = new Global();
            exports.TwoFish = TwoFish = (function(_super) {
              __extends(TwoFish, _super);
              TwoFish.blockSize = 4 * 4;
              TwoFish.prototype.blockSize = TwoFish.blockSize;
              TwoFish.keySize = 256 / 8;
              TwoFish.prototype.keySize = TwoFish.keySize;
              TwoFish.ivSize = TwoFish.blockSize;
              TwoFish.prototype.ivSize = TwoFish.ivSize;
              function TwoFish(key) {
                this._key = key.clone();
                this.gMDS0 = [];
                this.gMDS1 = [];
                this.gMDS2 = [];
                this.gMDS3 = [];
                this.gSubKeys = [];
                this.gSBox = [];
                this.k64Cnt = 0;
                this._doReset();
              }
              TwoFish.prototype.getByte = function(x, n) {
                return (x >>> (n * 8)) & 255;
              };
              TwoFish.prototype.switchEndianness = function(word) {
                return (
                  ((word & 255) << 24) |
                  (((word >> 8) & 255) << 16) |
                  (((word >> 16) & 255) << 8) |
                  ((word >> 24) & 255)
                );
              };
              TwoFish.prototype.LFSR1 = function(x) {
                return (x >> 1) ^ ((x & 1) !== 0 ? G.GF256_FDBK_2 : 0);
              };
              TwoFish.prototype.LFSR2 = function(x) {
                return (
                  (x >> 2) ^
                  ((x & 2) !== 0 ? G.GF256_FDBK_2 : 0) ^
                  ((x & 1) !== 0 ? G.GF256_FDBK_4 : 0)
                );
              };
              TwoFish.prototype.Mx_X = function(x) {
                return x ^ this.LFSR2(x);
              };
              TwoFish.prototype.Mx_Y = function(x) {
                return x ^ this.LFSR1(x) ^ this.LFSR2(x);
              };
              TwoFish.prototype.RS_rem = function(x) {
                var b, g2, g3;
                b = (x >>> 24) & 255;
                g2 = ((b << 1) ^ ((b & 128) !== 0 ? G.RS_GF_FDBK : 0)) & 255;
                g3 = (b >>> 1) ^ ((b & 1) !== 0 ? G.RS_GF_FDBK >>> 1 : 0) ^ g2;
                return (x << 8) ^ (g3 << 24) ^ (g2 << 16) ^ (g3 << 8) ^ b;
              };
              TwoFish.prototype.RS_MDS_Encode = function(k0, k1) {
                var i, r, _i, _j;
                r = k1;
                for (i = _i = 0; _i < 4; i = ++_i) {
                  r = this.RS_rem(r);
                }
                r ^= k0;
                for (i = _j = 0; _j < 4; i = ++_j) {
                  r = this.RS_rem(r);
                }
                return r;
              };
              TwoFish.prototype.F32 = function(x, k32) {
                var b0, b1, b2, b3, k0, k1, k2, k3, m, res;
                b0 = this.getByte(x, 0);
                b1 = this.getByte(x, 1);
                b2 = this.getByte(x, 2);
                b3 = this.getByte(x, 3);
                k0 = k32[0];
                k1 = k32[1];
                k2 = k32[2];
                k3 = k32[3];
                m = this.k64Cnt & 3;
                res =
                  m === 1
                    ? this.gMDS0[
                        (G.P[G.P_01][b0] & 255) ^ this.getByte(k0, 0)
                      ] ^
                      this.gMDS1[
                        (G.P[G.P_11][b1] & 255) ^ this.getByte(k0, 1)
                      ] ^
                      this.gMDS2[
                        (G.P[G.P_21][b2] & 255) ^ this.getByte(k0, 2)
                      ] ^
                      this.gMDS3[(G.P[G.P_31][b3] & 255) ^ this.getByte(k0, 3)]
                    : (m === 0
                        ? ((b0 = (G.P[G.P_04][b0] & 255) ^ this.getByte(k3, 0)),
                          (b1 = (G.P[G.P_14][b1] & 255) ^ this.getByte(k3, 1)),
                          (b2 = (G.P[G.P_24][b2] & 255) ^ this.getByte(k3, 2)),
                          (b3 = (G.P[G.P_34][b3] & 255) ^ this.getByte(k3, 3)))
                        : void 0,
                      m === 0 || m === 3
                        ? ((b0 = (G.P[G.P_03][b0] & 255) ^ this.getByte(k2, 0)),
                          (b1 = (G.P[G.P_13][b1] & 255) ^ this.getByte(k2, 1)),
                          (b2 = (G.P[G.P_23][b2] & 255) ^ this.getByte(k2, 2)),
                          (b3 = (G.P[G.P_33][b3] & 255) ^ this.getByte(k2, 3)))
                        : void 0,
                      this.gMDS0[
                        (G.P[G.P_01][
                          (G.P[G.P_02][b0] & 255) ^ this.getByte(k1, 0)
                        ] &
                          255) ^
                          this.getByte(k0, 0)
                      ] ^
                        this.gMDS1[
                          (G.P[G.P_11][
                            (G.P[G.P_12][b1] & 255) ^ this.getByte(k1, 1)
                          ] &
                            255) ^
                            this.getByte(k0, 1)
                        ] ^
                        this.gMDS2[
                          (G.P[G.P_21][
                            (G.P[G.P_22][b2] & 255) ^ this.getByte(k1, 2)
                          ] &
                            255) ^
                            this.getByte(k0, 2)
                        ] ^
                        this.gMDS3[
                          (G.P[G.P_31][
                            (G.P[G.P_32][b3] & 255) ^ this.getByte(k1, 3)
                          ] &
                            255) ^
                            this.getByte(k0, 3)
                        ]);
                return res;
              };
              TwoFish.prototype.Fe32_0 = function(x) {
                return (
                  this.gSBox[0 + 2 * (x & 255)] ^
                  this.gSBox[1 + 2 * ((x >>> 8) & 255)] ^
                  this.gSBox[512 + 2 * ((x >>> 16) & 255)] ^
                  this.gSBox[513 + 2 * ((x >>> 24) & 255)]
                );
              };
              TwoFish.prototype.Fe32_3 = function(x) {
                return (
                  this.gSBox[0 + 2 * ((x >>> 24) & 255)] ^
                  this.gSBox[1 + 2 * (x & 255)] ^
                  this.gSBox[512 + 2 * ((x >>> 8) & 255)] ^
                  this.gSBox[513 + 2 * ((x >>> 16) & 255)]
                );
              };
              TwoFish.prototype._doReset = function() {
                var A,
                  B,
                  b0,
                  b1,
                  b2,
                  b3,
                  i,
                  j,
                  k0,
                  k1,
                  k2,
                  k3,
                  k32e,
                  k32o,
                  m,
                  m1,
                  mX,
                  mY,
                  p,
                  q,
                  sBoxKeys,
                  _i,
                  _j,
                  _k,
                  _l,
                  _ref,
                  _ref1,
                  _results;
                k32e = [];
                k32o = [];
                sBoxKeys = [];
                m1 = [];
                mX = [];
                mY = [];
                this.k64Cnt = this._key.words.length / 2;
                if (this.k64Cnt < 1) {
                  throw 'Key size less than 64 bits';
                }
                if (this.k64Cnt > 4) {
                  throw 'Key size larger than 256 bits';
                }
                for (i = _i = 0; _i < 256; i = ++_i) {
                  j = G.P[0][i] & 255;
                  m1[0] = j;
                  mX[0] = this.Mx_X(j) & 255;
                  mY[0] = this.Mx_Y(j) & 255;
                  j = G.P[1][i] & 255;
                  m1[1] = j;
                  mX[1] = this.Mx_X(j) & 255;
                  mY[1] = this.Mx_Y(j) & 255;
                  this.gMDS0[i] =
                    m1[G.P_00] |
                    (mX[G.P_00] << 8) |
                    (mY[G.P_00] << 16) |
                    (mY[G.P_00] << 24);
                  this.gMDS1[i] =
                    mY[G.P_10] |
                    (mY[G.P_10] << 8) |
                    (mX[G.P_10] << 16) |
                    (m1[G.P_10] << 24);
                  this.gMDS2[i] =
                    mX[G.P_20] |
                    (mY[G.P_20] << 8) |
                    (m1[G.P_20] << 16) |
                    (mY[G.P_20] << 24);
                  this.gMDS3[i] =
                    mX[G.P_30] |
                    (m1[G.P_30] << 8) |
                    (mY[G.P_30] << 16) |
                    (mX[G.P_30] << 24);
                }
                for (
                  i = _j = 0, _ref = this.k64Cnt;
                  0 <= _ref ? _j < _ref : _j > _ref;
                  i = 0 <= _ref ? ++_j : --_j
                ) {
                  p = i * 2;
                  k32e[i] = this.switchEndianness(this._key.words[p]);
                  k32o[i] = this.switchEndianness(this._key.words[p + 1]);
                  sBoxKeys[this.k64Cnt - 1 - i] = this.RS_MDS_Encode(
                    k32e[i],
                    k32o[i]
                  );
                }
                for (
                  i = _k = 0, _ref1 = 40 / 2;
                  0 <= _ref1 ? _k < _ref1 : _k > _ref1;
                  i = 0 <= _ref1 ? ++_k : --_k
                ) {
                  q = i * G.SK_STEP;
                  A = this.F32(q, k32e);
                  B = this.F32(q + G.SK_BUMP, k32o);
                  B = (B << 8) | (B >>> 24);
                  A += B;
                  this.gSubKeys[i * 2] = A;
                  A += B;
                  this.gSubKeys[i * 2 + 1] =
                    (A << G.SK_ROTL) | (A >>> (32 - G.SK_ROTL));
                }
                k0 = sBoxKeys[0];
                k1 = sBoxKeys[1];
                k2 = sBoxKeys[2];
                k3 = sBoxKeys[3];
                this.gSBox = [];
                _results = [];
                for (i = _l = 0; _l < 256; i = ++_l) {
                  b0 = b1 = b2 = b3 = i;
                  m = this.k64Cnt & 3;
                  if (m === 1) {
                    this.gSBox[i * 2] = this.gMDS0[
                      (G.P[G.P_01][b0] & 255) ^ this.getByte(k0, 0)
                    ];
                    this.gSBox[i * 2 + 1] = this.gMDS1[
                      (G.P[G.P_11][b1] & 255) ^ this.getByte(k0, 1)
                    ];
                    this.gSBox[i * 2 + 512] = this.gMDS2[
                      (G.P[G.P_21][b2] & 255) ^ this.getByte(k0, 2)
                    ];
                    _results.push(
                      (this.gSBox[i * 2 + 513] = this.gMDS3[
                        (G.P[G.P_31][b3] & 255) ^ this.getByte(k0, 3)
                      ])
                    );
                  } else {
                    if (m === 0) {
                      b0 = (G.P[G.P_04][b0] & 255) ^ this.getByte(k3, 0);
                      b1 = (G.P[G.P_14][b1] & 255) ^ this.getByte(k3, 1);
                      b2 = (G.P[G.P_24][b2] & 255) ^ this.getByte(k3, 2);
                      b3 = (G.P[G.P_34][b3] & 255) ^ this.getByte(k3, 3);
                    }
                    if (m === 0 || m === 3) {
                      b0 = (G.P[G.P_03][b0] & 255) ^ this.getByte(k2, 0);
                      b1 = (G.P[G.P_13][b1] & 255) ^ this.getByte(k2, 1);
                      b2 = (G.P[G.P_23][b2] & 255) ^ this.getByte(k2, 2);
                      b3 = (G.P[G.P_33][b3] & 255) ^ this.getByte(k2, 3);
                    }
                    this.gSBox[i * 2] = this.gMDS0[
                      (G.P[G.P_01][
                        (G.P[G.P_02][b0] & 255) ^ this.getByte(k1, 0)
                      ] &
                        255) ^
                        this.getByte(k0, 0)
                    ];
                    this.gSBox[i * 2 + 1] = this.gMDS1[
                      (G.P[G.P_11][
                        (G.P[G.P_12][b1] & 255) ^ this.getByte(k1, 1)
                      ] &
                        255) ^
                        this.getByte(k0, 1)
                    ];
                    this.gSBox[i * 2 + 512] = this.gMDS2[
                      (G.P[G.P_21][
                        (G.P[G.P_22][b2] & 255) ^ this.getByte(k1, 2)
                      ] &
                        255) ^
                        this.getByte(k0, 2)
                    ];
                    _results.push(
                      (this.gSBox[i * 2 + 513] = this.gMDS3[
                        (G.P[G.P_31][
                          (G.P[G.P_32][b3] & 255) ^ this.getByte(k1, 3)
                        ] &
                          255) ^
                          this.getByte(k0, 3)
                      ])
                    );
                  }
                }
                return _results;
              };
              TwoFish.prototype.scrub = function() {
                scrub_vec(this.gSubKeys);
                scrub_vec(this.gSBox);
                return this._key.scrub();
              };
              TwoFish.prototype.decryptBlock = function(M, offset) {
                var k, r, t0, t1, x0, x1, x2, x3, _i;
                if (offset == null) {
                  offset = 0;
                }
                x2 = this.switchEndianness(M[offset]) ^ this.gSubKeys[4];
                x3 = this.switchEndianness(M[offset + 1]) ^ this.gSubKeys[5];
                x0 = this.switchEndianness(M[offset + 2]) ^ this.gSubKeys[6];
                x1 = this.switchEndianness(M[offset + 3]) ^ this.gSubKeys[7];
                k = 8 + 2 * 16 - 1;
                for (r = _i = 0; _i < 16; r = _i += 2) {
                  t0 = this.Fe32_0(x2);
                  t1 = this.Fe32_3(x3);
                  x1 ^= t0 + 2 * t1 + this.gSubKeys[k--];
                  x0 =
                    ((x0 << 1) | (x0 >>> 31)) ^ (t0 + t1 + this.gSubKeys[k--]);
                  x1 = (x1 >>> 1) | (x1 << 31);
                  t0 = this.Fe32_0(x0);
                  t1 = this.Fe32_3(x1);
                  x3 ^= t0 + 2 * t1 + this.gSubKeys[k--];
                  x2 =
                    ((x2 << 1) | (x2 >>> 31)) ^ (t0 + t1 + this.gSubKeys[k--]);
                  x3 = (x3 >>> 1) | (x3 << 31);
                }
                M[offset] = this.switchEndianness(x0 ^ this.gSubKeys[0]);
                M[offset + 1] = this.switchEndianness(x1 ^ this.gSubKeys[1]);
                M[offset + 2] = this.switchEndianness(x2 ^ this.gSubKeys[2]);
                return (M[offset + 3] = this.switchEndianness(
                  x3 ^ this.gSubKeys[3]
                ));
              };
              TwoFish.prototype.encryptBlock = function(M, offset) {
                var k, r, t0, t1, x0, x1, x2, x3, _i;
                if (offset == null) {
                  offset = 0;
                }
                x0 = this.switchEndianness(M[offset]) ^ this.gSubKeys[0];
                x1 = this.switchEndianness(M[offset + 1]) ^ this.gSubKeys[1];
                x2 = this.switchEndianness(M[offset + 2]) ^ this.gSubKeys[2];
                x3 = this.switchEndianness(M[offset + 3]) ^ this.gSubKeys[3];
                k = 8;
                for (r = _i = 0; _i < 16; r = _i += 2) {
                  t0 = this.Fe32_0(x0);
                  t1 = this.Fe32_3(x1);
                  x2 ^= t0 + t1 + this.gSubKeys[k++];
                  x2 = (x2 >>> 1) | (x2 << 31);
                  x3 =
                    ((x3 << 1) | (x3 >>> 31)) ^
                    (t0 + 2 * t1 + this.gSubKeys[k++]);
                  t0 = this.Fe32_0(x2);
                  t1 = this.Fe32_3(x3);
                  x0 ^= t0 + t1 + this.gSubKeys[k++];
                  x0 = (x0 >>> 1) | (x0 << 31);
                  x1 =
                    ((x1 << 1) | (x1 >>> 31)) ^
                    (t0 + 2 * t1 + this.gSubKeys[k++]);
                }
                M[offset] = this.switchEndianness(x2 ^ this.gSubKeys[4]);
                M[offset + 1] = this.switchEndianness(x3 ^ this.gSubKeys[5]);
                M[offset + 2] = this.switchEndianness(x0 ^ this.gSubKeys[6]);
                return (M[offset + 3] = this.switchEndianness(
                  x1 ^ this.gSubKeys[7]
                ));
              };
              return TwoFish;
            })(BlockCipher);
          }.call(this));
        },
        { './algbase': 474, './util': 495 }
      ],
      495: [
        function(require, module, exports) {
          (function(Buffer) {
            (function() {
              var default_delay, iced, uint_max, __iced_k, __iced_k_noop;
              iced = require('iced-runtime');
              __iced_k = __iced_k_noop = function() {};
              uint_max = Math.pow(2, 32);
              exports.fixup_uint32 = function(x) {
                var ret, x_pos;
                ret =
                  x > uint_max || x < 0
                    ? ((x_pos = Math.abs(x) % uint_max),
                      x < 0 ? uint_max - x_pos : x_pos)
                    : x;
                return ret;
              };
              exports.scrub_buffer = function(b) {
                var i, n_full_words;
                n_full_words = b.length >> 2;
                i = 0;
                while (i < n_full_words) {
                  b.writeUInt32LE(0, i);
                  i += 4;
                }
                while (i < b.length) {
                  b.writeUInt8(0, i);
                  i++;
                }
                return false;
              };
              exports.copy_buffer = function(b) {
                var i, ret, _i, _ref;
                ret = new Buffer(b.length);
                for (
                  i = _i = 0, _ref = b.length;
                  0 <= _ref ? _i < _ref : _i > _ref;
                  i = 0 <= _ref ? ++_i : --_i
                ) {
                  ret.writeUInt8(b.readUInt8(i), i);
                }
                return ret;
              };
              exports.scrub_vec = function(v) {
                var i, _i, _ref;
                for (
                  i = _i = 0, _ref = v.length;
                  0 <= _ref ? _i < _ref : _i > _ref;
                  i = 0 <= _ref ? ++_i : --_i
                ) {
                  v[i] = 0;
                }
                return false;
              };
              exports.default_delay = default_delay = function(i, n, cb) {
                var ___iced_passed_deferral, __iced_deferrals, __iced_k;
                __iced_k = __iced_k_noop;
                ___iced_passed_deferral = iced.findDeferral(arguments);
                (function(_this) {
                  return function(__iced_k) {
                    if (
                      typeof setImmediate !== 'undefined' &&
                      setImmediate !== null
                    ) {
                      (function(__iced_k) {
                        __iced_deferrals = new iced.Deferrals(__iced_k, {
                          parent: ___iced_passed_deferral,
                          filename:
                            '/Users/max/src/keybase/triplesec/src/util.iced'
                        });
                        setImmediate(__iced_deferrals.defer({ lineno: 45 }));
                        __iced_deferrals._fulfill();
                      })(__iced_k);
                    } else {
                      (function(__iced_k) {
                        __iced_deferrals = new iced.Deferrals(__iced_k, {
                          parent: ___iced_passed_deferral,
                          filename:
                            '/Users/max/src/keybase/triplesec/src/util.iced'
                        });
                        setTimeout(__iced_deferrals.defer({ lineno: 47 }), 1);
                        __iced_deferrals._fulfill();
                      })(__iced_k);
                    }
                  };
                })(this)(
                  (function(_this) {
                    return function() {
                      return cb();
                    };
                  })(this)
                );
              };
              exports.buffer_cmp_ule = function(b1, b2) {
                var I, J, i, j, x, y;
                i = j = 0;
                I = b1.length;
                J = b2.length;
                while (i < I && b1.readUInt8(i) === 0) {
                  i++;
                }
                while (j < J && b2.readUInt8(j) === 0) {
                  j++;
                }
                if (I - i > J - j) {
                  return 1;
                } else if (J - j > I - i) {
                  return -1;
                }
                while (i < I) {
                  if ((x = b1.readUInt8(i)) < (y = b2.readUInt8(j))) {
                    return -1;
                  } else if (y < x) {
                    return 1;
                  }
                  i++;
                  j++;
                }
                return 0;
              };
              exports.bulk = function(n_input_bytes, _arg, _arg1) {
                var call_ph,
                  cb,
                  default_n,
                  delay,
                  finalize,
                  i,
                  left,
                  n,
                  n_words,
                  progress_hook,
                  ret,
                  total_words,
                  update,
                  what,
                  ___iced_passed_deferral,
                  __iced_deferrals,
                  __iced_k;
                __iced_k = __iced_k_noop;
                ___iced_passed_deferral = iced.findDeferral(arguments);
                (update = _arg.update),
                  (finalize = _arg.finalize),
                  (default_n = _arg.default_n);
                (delay = _arg1.delay),
                  (n = _arg1.n),
                  (cb = _arg1.cb),
                  (what = _arg1.what),
                  (progress_hook = _arg1.progress_hook);
                i = 0;
                left = 0;
                total_words = Math.ceil(n_input_bytes / 4);
                delay || (delay = default_delay);
                n || (n = default_n);
                call_ph = function(i) {
                  return typeof progress_hook === 'function'
                    ? progress_hook({ what: what, i: i, total: total_words })
                    : void 0;
                };
                call_ph(0);
                (function(_this) {
                  return function(__iced_k) {
                    var _while;
                    _while = function(__iced_k) {
                      var _break, _continue, _next;
                      _break = __iced_k;
                      _continue = function() {
                        return iced.trampoline(function() {
                          return _while(__iced_k);
                        });
                      };
                      _next = _continue;
                      if (!((left = total_words - i) > 0)) {
                        return _break();
                      } else {
                        n_words = Math.min(n, left);
                        update(i, i + n_words);
                        call_ph(i);
                        (function(__iced_k) {
                          __iced_deferrals = new iced.Deferrals(__iced_k, {
                            parent: ___iced_passed_deferral,
                            filename:
                              '/Users/max/src/keybase/triplesec/src/util.iced',
                            funcname: 'bulk'
                          });
                          delay(
                            i,
                            total_words,
                            __iced_deferrals.defer({ lineno: 105 })
                          );
                          __iced_deferrals._fulfill();
                        })(function() {
                          return _next((i += n_words));
                        });
                      }
                    };
                    _while(__iced_k);
                  };
                })(this)(
                  (function(_this) {
                    return function() {
                      call_ph(total_words);
                      ret = finalize();
                      return cb(ret);
                    };
                  })(this)
                );
              };
            }.call(this));
          }.call(this, require('buffer').Buffer));
        },
        { buffer: 183, 'iced-runtime': 379 }
      ],
      496: [
        function(require, module, exports) {
          (function(Buffer) {
            (function() {
              var WordArray,
                X64Word,
                X64WordArray,
                buffer_to_ui8a,
                endian_reverse,
                ui8a_to_buffer,
                util;
              util = require('./util');
              buffer_to_ui8a = function(b) {
                var i, ret, _i, _ref;
                ret = new Uint8Array(b.length);
                for (
                  i = _i = 0, _ref = b.length;
                  0 <= _ref ? _i < _ref : _i > _ref;
                  i = 0 <= _ref ? ++_i : --_i
                ) {
                  ret[i] = b.readUInt8(i);
                }
                return ret;
              };
              ui8a_to_buffer = function(v) {
                var i, ret, _i, _ref;
                ret = new Buffer(v.length);
                for (
                  i = _i = 0, _ref = v.length;
                  0 <= _ref ? _i < _ref : _i > _ref;
                  i = 0 <= _ref ? ++_i : --_i
                ) {
                  ret.writeUInt8(v[i], i);
                }
                return ret;
              };
              endian_reverse = function(x) {
                return (
                  ((x >>> 24) & 255) |
                  (((x >>> 16) & 255) << 8) |
                  (((x >>> 8) & 255) << 16) |
                  ((x & 255) << 24)
                );
              };
              exports.WordArray = WordArray = (function() {
                function WordArray(words, sigBytes) {
                  this.words = words || [];
                  this.sigBytes =
                    sigBytes != null ? sigBytes : this.words.length * 4;
                }
                WordArray.prototype.concat = function(wordArray) {
                  var i, thatByte, thatSigBytes, thatWords, _i;
                  thatWords = wordArray.words;
                  thatSigBytes = wordArray.sigBytes;
                  this.clamp();
                  if (this.sigBytes % 4) {
                    for (
                      i = _i = 0;
                      0 <= thatSigBytes ? _i < thatSigBytes : _i > thatSigBytes;
                      i = 0 <= thatSigBytes ? ++_i : --_i
                    ) {
                      thatByte =
                        (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 255;
                      this.words[(this.sigBytes + i) >>> 2] |=
                        thatByte << (24 - ((this.sigBytes + i) % 4) * 8);
                    }
                  } else {
                    this.words = this.words.concat(thatWords);
                  }
                  this.sigBytes += thatSigBytes;
                  return this;
                };
                WordArray.prototype.clamp = function() {
                  this.words[this.sigBytes >>> 2] &=
                    4294967295 << (32 - (this.sigBytes % 4) * 8);
                  this.words.length = Math.ceil(this.sigBytes / 4);
                  return this;
                };
                WordArray.prototype.clone = function() {
                  return new WordArray(this.words.slice(0), this.sigBytes);
                };
                WordArray.prototype.to_buffer = function() {
                  var ch, out, p, w, _i, _len, _ref;
                  out = new Buffer(this.sigBytes);
                  p = 0;
                  _ref = this.words;
                  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                    w = _ref[_i];
                    if (!(this.sigBytes - p >= 4)) {
                      continue;
                    }
                    w = util.fixup_uint32(w);
                    out.writeUInt32BE(w, p);
                    p += 4;
                  }
                  while (p < this.sigBytes) {
                    ch = (this.words[p >>> 2] >>> (24 - (p % 4) * 8)) & 255;
                    out.writeUInt8(ch, p);
                    p++;
                  }
                  return out;
                };
                WordArray.prototype.endian_reverse = function() {
                  var i, w, _i, _len, _ref;
                  _ref = this.words;
                  for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
                    w = _ref[i];
                    this.words[i] = endian_reverse(w);
                  }
                  return this;
                };
                WordArray.prototype.split = function(n) {
                  var i, out, sz;
                  if (
                    !(this.sigBytes % 4 === 0 && this.words.length % n === 0)
                  ) {
                    throw new Error('bad key alignment');
                  }
                  sz = this.words.length / n;
                  out = function() {
                    var _i, _ref, _results;
                    _results = [];
                    for (
                      i = _i = 0, _ref = this.words.length;
                      sz > 0 ? _i < _ref : _i > _ref;
                      i = _i += sz
                    ) {
                      _results.push(new WordArray(this.words.slice(i, i + sz)));
                    }
                    return _results;
                  }.call(this);
                  return out;
                };
                WordArray.prototype.to_utf8 = function() {
                  return this.to_buffer().toString('utf8');
                };
                WordArray.prototype.to_hex = function() {
                  return this.to_buffer().toString('hex');
                };
                WordArray.prototype.to_ui8a = function() {
                  return buffer_to_ui8a(this.to_buffer());
                };
                WordArray.alloc = function(b) {
                  if (Buffer.isBuffer(b)) {
                    return WordArray.from_buffer(b);
                  } else if (typeof b === 'object' && b instanceof WordArray) {
                    return b;
                  } else if (typeof b === 'string') {
                    return WordArray.from_hex(b);
                  } else {
                    return null;
                  }
                };
                WordArray.from_buffer = function(b) {
                  var ch, last, p, words;
                  words = [];
                  p = 0;
                  while (b.length - p >= 4) {
                    words.push(b.readUInt32BE(p));
                    p += 4;
                  }
                  if (p < b.length) {
                    last = 0;
                    while (p < b.length) {
                      ch = b.readUInt8(p);
                      last |= ch << (24 - (p % 4) * 8);
                      p++;
                    }
                    last = util.fixup_uint32(last);
                    words.push(last);
                  }
                  return new WordArray(words, b.length);
                };
                WordArray.from_buffer_le = function(b) {
                  var ch, last, p, words;
                  words = [];
                  p = 0;
                  while (b.length - p >= 4) {
                    words.push(b.readUInt32LE(p));
                    p += 4;
                  }
                  if (p < b.length) {
                    last = 0;
                    while (p < b.length) {
                      ch = b.readUInt8(p);
                      last |= ch << ((p % 4) * 8);
                      p++;
                    }
                    last = util.fixup_uint32(last);
                    words.push(last);
                  }
                  return new WordArray(words, b.length);
                };
                WordArray.from_utf8 = function(s) {
                  return WordArray.from_buffer(new Buffer(s, 'utf8'));
                };
                WordArray.from_utf8_le = function(s) {
                  return WordArray.from_buffer_le(new Buffer(s, 'utf8'));
                };
                WordArray.from_hex = function(s) {
                  return WordArray.from_buffer(new Buffer(s, 'hex'));
                };
                WordArray.from_hex_le = function(s) {
                  return WordArray.from_buffer_le(new Buffer(s, 'hex'));
                };
                WordArray.from_ui8a = function(v) {
                  return WordArray.from_buffer(ui8a_to_buffer(v));
                };
                WordArray.from_i32a = function(v) {
                  return new WordArray(Array.apply([], v));
                };
                WordArray.prototype.equal = function(wa) {
                  var i, ret, w, _i, _len, _ref;
                  ret = true;
                  if (wa.sigBytes !== this.sigBytes) {
                    ret = false;
                  } else {
                    _ref = this.words;
                    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
                      w = _ref[i];
                      if (
                        util.fixup_uint32(w) !== util.fixup_uint32(wa.words[i])
                      ) {
                        ret = false;
                      }
                    }
                  }
                  return ret;
                };
                WordArray.prototype.xor = function(wa2, _arg) {
                  var dst_offset, i, n_words, src_offset, tmp, _i;
                  (dst_offset = _arg.dst_offset),
                    (src_offset = _arg.src_offset),
                    (n_words = _arg.n_words);
                  if (!dst_offset) {
                    dst_offset = 0;
                  }
                  if (!src_offset) {
                    src_offset = 0;
                  }
                  if (n_words == null) {
                    n_words = wa2.words.length - src_offset;
                  }
                  if (this.words.length < dst_offset + n_words) {
                    throw new Error(
                      'dest range exceeded (' +
                        this.words.length +
                        ' < ' +
                        (dst_offset + n_words) +
                        ')'
                    );
                  }
                  if (wa2.words.length < src_offset + n_words) {
                    throw new Error('source range exceeded');
                  }
                  for (
                    i = _i = 0;
                    0 <= n_words ? _i < n_words : _i > n_words;
                    i = 0 <= n_words ? ++_i : --_i
                  ) {
                    tmp =
                      this.words[dst_offset + i] ^ wa2.words[src_offset + i];
                    this.words[dst_offset + i] = util.fixup_uint32(tmp);
                  }
                  return this;
                };
                WordArray.prototype.truncate = function(n_bytes) {
                  var n_words;
                  if (!(n_bytes <= this.sigBytes)) {
                    throw new Error(
                      'Cannot truncate: ' + n_bytes + ' > ' + this.sigBytes
                    );
                  }
                  n_words = Math.ceil(n_bytes / 4);
                  return new WordArray(this.words.slice(0, n_words), n_bytes);
                };
                WordArray.prototype.unshift = function(n_words) {
                  var ret;
                  if (this.words.length >= n_words) {
                    ret = this.words.splice(0, n_words);
                    this.sigBytes -= n_words * 4;
                    return new WordArray(ret);
                  } else {
                    return null;
                  }
                };
                WordArray.prototype.is_scrubbed = function() {
                  var w, _i, _len, _ref;
                  _ref = this.words;
                  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                    w = _ref[_i];
                    if (w !== 0) {
                      return false;
                    }
                  }
                  return true;
                };
                WordArray.prototype.scrub = function() {
                  return util.scrub_vec(this.words);
                };
                WordArray.prototype.cmp_ule = function(wa2) {
                  return util.buffer_cmp_ule(this.to_buffer(), wa2.to_buffer());
                };
                WordArray.prototype.slice = function(low, hi) {
                  var n, sb;
                  n = this.words.length;
                  if (!(low < hi && hi <= n)) {
                    throw new Error(
                      'Bad WordArray slice [' +
                        low +
                        ',' +
                        hi +
                        ')] when only ' +
                        n +
                        ' avail'
                    );
                  }
                  sb = (hi - low) * 4;
                  if (hi === n) {
                    sb -= n * 4 - this.sigBytes;
                  }
                  return new WordArray(this.words.slice(low, hi), sb);
                };
                return WordArray;
              })();
              exports.X64Word = X64Word = (function() {
                function X64Word(high, low) {
                  this.high = high;
                  this.low = low;
                }
                X64Word.prototype.clone = function() {
                  return new X64Word(this.high, this.low);
                };
                return X64Word;
              })();
              exports.X64WordArray = X64WordArray = (function() {
                function X64WordArray(words, sigBytes) {
                  this.sigBytes = sigBytes;
                  this.words = words || [];
                  if (!this.sigBytes) {
                    this.sigBytes = this.words.length * 8;
                  }
                }
                X64WordArray.prototype.toX32 = function() {
                  var v, w, _i, _len, _ref;
                  v = [];
                  _ref = this.words;
                  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                    w = _ref[_i];
                    v.push(w.high);
                    v.push(w.low);
                  }
                  return new WordArray(v, this.sigBytes);
                };
                X64WordArray.prototype.clone = function() {
                  var w;
                  return new X64WordArray(
                    function() {
                      var _i, _len, _ref, _results;
                      _ref = this.words;
                      _results = [];
                      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                        w = _ref[_i];
                        _results.push(w.clone());
                      }
                      return _results;
                    }.call(this),
                    this.sigBytes
                  );
                };
                return X64WordArray;
              })();
              exports.buffer_to_ui8a = buffer_to_ui8a;
              exports.ui8a_to_buffer = ui8a_to_buffer;
              exports.endian_reverse = endian_reverse;
            }.call(this));
          }.call(this, require('buffer').Buffer));
        },
        { './util': 495, buffer: 183 }
      ],
      497: [
        function(require, module, exports) {
          var native = require('./native');
          function getTypeName(fn) {
            return fn.name || fn.toString().match(/function (.*?)\s*\(/)[1];
          }
          function getValueTypeName(value) {
            return native.Nil(value) ? '' : getTypeName(value.constructor);
          }
          function getValue(value) {
            if (native.Function(value)) return '';
            if (native.String(value)) return JSON.stringify(value);
            if (value && native.Object(value)) return '';
            return value;
          }
          function tfJSON(type) {
            if (native.Function(type))
              return type.toJSON ? type.toJSON() : getTypeName(type);
            if (native.Array(type)) return 'Array';
            if (type && native.Object(type)) return 'Object';
            return type !== undefined ? type : '';
          }
          function tfErrorString(type, value, valueTypeName) {
            var valueJson = getValue(value);
            return (
              'Expected ' +
              tfJSON(type) +
              ', got' +
              (valueTypeName !== '' ? ' ' + valueTypeName : '') +
              (valueJson !== '' ? ' ' + valueJson : '')
            );
          }
          function TfTypeError(type, value, valueTypeName) {
            valueTypeName = valueTypeName || getValueTypeName(value);
            this.message = tfErrorString(type, value, valueTypeName);
            Error.captureStackTrace(this, TfTypeError);
            this.__type = type;
            this.__value = value;
            this.__valueTypeName = valueTypeName;
          }
          TfTypeError.prototype = Object.create(Error.prototype);
          TfTypeError.prototype.constructor = TfTypeError;
          function tfPropertyErrorString(
            type,
            label,
            name,
            value,
            valueTypeName
          ) {
            var description = '" of type ';
            if (label === 'key') description = '" with key type ';
            return tfErrorString(
              'property "' + tfJSON(name) + description + tfJSON(type),
              value,
              valueTypeName
            );
          }
          function TfPropertyTypeError(
            type,
            property,
            label,
            value,
            valueTypeName
          ) {
            if (type) {
              valueTypeName = valueTypeName || getValueTypeName(value);
              this.message = tfPropertyErrorString(
                type,
                label,
                property,
                value,
                valueTypeName
              );
            } else {
              this.message = 'Unexpected property "' + property + '"';
            }
            Error.captureStackTrace(this, TfTypeError);
            this.__label = label;
            this.__property = property;
            this.__type = type;
            this.__value = value;
            this.__valueTypeName = valueTypeName;
          }
          TfPropertyTypeError.prototype = Object.create(Error.prototype);
          TfPropertyTypeError.prototype.constructor = TfTypeError;
          function tfCustomError(expected, actual) {
            return new TfTypeError(expected, {}, actual);
          }
          function tfSubError(e, property, label) {
            if (e instanceof TfPropertyTypeError) {
              property = property + '.' + e.__property;
              e = new TfPropertyTypeError(
                e.__type,
                property,
                e.__label,
                e.__value,
                e.__valueTypeName
              );
            } else if (e instanceof TfTypeError) {
              e = new TfPropertyTypeError(
                e.__type,
                property,
                label,
                e.__value,
                e.__valueTypeName
              );
            }
            Error.captureStackTrace(e);
            return e;
          }
          module.exports = {
            TfTypeError: TfTypeError,
            TfPropertyTypeError: TfPropertyTypeError,
            tfCustomError: tfCustomError,
            tfSubError: tfSubError,
            tfJSON: tfJSON,
            getValueTypeName: getValueTypeName
          };
        },
        { './native': 500 }
      ],
      498: [
        function(require, module, exports) {
          (function(Buffer) {
            var NATIVE = require('./native');
            var ERRORS = require('./errors');
            function _Buffer(value) {
              return Buffer.isBuffer(value);
            }
            function Hex(value) {
              return (
                typeof value === 'string' && /^([0-9a-f]{2})+$/i.test(value)
              );
            }
            function _LengthN(type, length) {
              var name = type.toJSON();
              function Length(value) {
                if (!type(value)) return false;
                if (value.length === length) return true;
                throw ERRORS.tfCustomError(
                  name + '(Length: ' + length + ')',
                  name + '(Length: ' + value.length + ')'
                );
              }
              Length.toJSON = function() {
                return name;
              };
              return Length;
            }
            var _ArrayN = _LengthN.bind(null, NATIVE.Array);
            var _BufferN = _LengthN.bind(null, _Buffer);
            var _HexN = _LengthN.bind(null, Hex);
            var _StringN = _LengthN.bind(null, NATIVE.String);
            var UINT53_MAX = Math.pow(2, 53) - 1;
            function Finite(value) {
              return typeof value === 'number' && isFinite(value);
            }
            function Int8(value) {
              return (value << 24) >> 24 === value;
            }
            function Int16(value) {
              return (value << 16) >> 16 === value;
            }
            function Int32(value) {
              return (value | 0) === value;
            }
            function UInt8(value) {
              return (value & 255) === value;
            }
            function UInt16(value) {
              return (value & 65535) === value;
            }
            function UInt32(value) {
              return value >>> 0 === value;
            }
            function UInt53(value) {
              return (
                typeof value === 'number' &&
                value >= 0 &&
                value <= UINT53_MAX &&
                Math.floor(value) === value
              );
            }
            var types = {
              ArrayN: _ArrayN,
              Buffer: _Buffer,
              BufferN: _BufferN,
              Finite: Finite,
              Hex: Hex,
              HexN: _HexN,
              Int8: Int8,
              Int16: Int16,
              Int32: Int32,
              StringN: _StringN,
              UInt8: UInt8,
              UInt16: UInt16,
              UInt32: UInt32,
              UInt53: UInt53
            };
            for (var typeName in types) {
              types[typeName].toJSON = function(t) {
                return t;
              }.bind(null, typeName);
            }
            module.exports = types;
          }.call(this, {
            isBuffer: require('../browserify/node_modules/is-buffer/index.js')
          }));
        },
        {
          '../browserify/node_modules/is-buffer/index.js': 208,
          './errors': 497,
          './native': 500
        }
      ],
      499: [
        function(require, module, exports) {
          var ERRORS = require('./errors');
          var NATIVE = require('./native');
          var tfJSON = ERRORS.tfJSON;
          var TfTypeError = ERRORS.TfTypeError;
          var TfPropertyTypeError = ERRORS.TfPropertyTypeError;
          var tfSubError = ERRORS.tfSubError;
          var getValueTypeName = ERRORS.getValueTypeName;
          var TYPES = {
            arrayOf: function arrayOf(type) {
              type = compile(type);
              function _arrayOf(array, strict) {
                if (!NATIVE.Array(array)) return false;
                if (NATIVE.Nil(array)) return false;
                return array.every(function(value, i) {
                  try {
                    return typeforce(type, value, strict);
                  } catch (e) {
                    throw tfSubError(e, i);
                  }
                });
              }
              _arrayOf.toJSON = function() {
                return '[' + tfJSON(type) + ']';
              };
              return _arrayOf;
            },
            maybe: function maybe(type) {
              type = compile(type);
              function _maybe(value, strict) {
                return NATIVE.Nil(value) || type(value, strict, maybe);
              }
              _maybe.toJSON = function() {
                return '?' + tfJSON(type);
              };
              return _maybe;
            },
            map: function map(propertyType, propertyKeyType) {
              propertyType = compile(propertyType);
              if (propertyKeyType) propertyKeyType = compile(propertyKeyType);
              function _map(value, strict) {
                if (!NATIVE.Object(value)) return false;
                if (NATIVE.Nil(value)) return false;
                for (var propertyName in value) {
                  try {
                    if (propertyKeyType) {
                      typeforce(propertyKeyType, propertyName, strict);
                    }
                  } catch (e) {
                    throw tfSubError(e, propertyName, 'key');
                  }
                  try {
                    var propertyValue = value[propertyName];
                    typeforce(propertyType, propertyValue, strict);
                  } catch (e) {
                    throw tfSubError(e, propertyName);
                  }
                }
                return true;
              }
              if (propertyKeyType) {
                _map.toJSON = function() {
                  return (
                    '{' +
                    tfJSON(propertyKeyType) +
                    ': ' +
                    tfJSON(propertyType) +
                    '}'
                  );
                };
              } else {
                _map.toJSON = function() {
                  return '{' + tfJSON(propertyType) + '}';
                };
              }
              return _map;
            },
            object: function object(uncompiled) {
              var type = {};
              for (var typePropertyName in uncompiled) {
                type[typePropertyName] = compile(uncompiled[typePropertyName]);
              }
              function _object(value, strict) {
                if (!NATIVE.Object(value)) return false;
                if (NATIVE.Nil(value)) return false;
                var propertyName;
                try {
                  for (propertyName in type) {
                    var propertyType = type[propertyName];
                    var propertyValue = value[propertyName];
                    typeforce(propertyType, propertyValue, strict);
                  }
                } catch (e) {
                  throw tfSubError(e, propertyName);
                }
                if (strict) {
                  for (propertyName in value) {
                    if (type[propertyName]) continue;
                    throw new TfPropertyTypeError(undefined, propertyName);
                  }
                }
                return true;
              }
              _object.toJSON = function() {
                return tfJSON(type);
              };
              return _object;
            },
            oneOf: function oneOf() {
              var types = [].slice.call(arguments).map(compile);
              function _oneOf(value, strict) {
                return types.some(function(type) {
                  try {
                    return typeforce(type, value, strict);
                  } catch (e) {
                    return false;
                  }
                });
              }
              _oneOf.toJSON = function() {
                return types.map(tfJSON).join('|');
              };
              return _oneOf;
            },
            quacksLike: function quacksLike(type) {
              function _quacksLike(value) {
                return type === getValueTypeName(value);
              }
              _quacksLike.toJSON = function() {
                return type;
              };
              return _quacksLike;
            },
            tuple: function tuple() {
              var types = [].slice.call(arguments).map(compile);
              function _tuple(values, strict) {
                if (NATIVE.Nil(values)) return false;
                if (NATIVE.Nil(values.length)) return false;
                if (strict && values.length !== types.length) return false;
                return types.every(function(type, i) {
                  try {
                    return typeforce(type, values[i], strict);
                  } catch (e) {
                    throw tfSubError(e, i);
                  }
                });
              }
              _tuple.toJSON = function() {
                return '(' + types.map(tfJSON).join(', ') + ')';
              };
              return _tuple;
            },
            value: function value(expected) {
              function _value(actual) {
                return actual === expected;
              }
              _value.toJSON = function() {
                return expected;
              };
              return _value;
            }
          };
          function compile(type) {
            if (NATIVE.String(type)) {
              if (type[0] === '?') return TYPES.maybe(type.slice(1));
              return NATIVE[type] || TYPES.quacksLike(type);
            } else if (type && NATIVE.Object(type)) {
              if (NATIVE.Array(type)) return TYPES.arrayOf(type[0]);
              return TYPES.object(type);
            } else if (NATIVE.Function(type)) {
              return type;
            }
            return TYPES.value(type);
          }
          function typeforce(type, value, strict, surrogate) {
            if (NATIVE.Function(type)) {
              if (type(value, strict)) return true;
              throw new TfTypeError(surrogate || type, value);
            }
            return typeforce(compile(type), value, strict);
          }
          for (var typeName in NATIVE) {
            typeforce[typeName] = NATIVE[typeName];
          }
          for (typeName in TYPES) {
            typeforce[typeName] = TYPES[typeName];
          }
          var EXTRA = require('./extra');
          for (typeName in EXTRA) {
            typeforce[typeName] = EXTRA[typeName];
          }
          function __async(type, value, strict, callback) {
            if (typeof strict === 'function')
              return __async(type, value, false, strict);
            try {
              typeforce(type, value, strict);
            } catch (e) {
              return callback(e);
            }
            callback();
          }
          typeforce.async = __async;
          typeforce.compile = compile;
          typeforce.TfTypeError = TfTypeError;
          typeforce.TfPropertyTypeError = TfPropertyTypeError;
          module.exports = typeforce;
        },
        { './errors': 497, './extra': 498, './native': 500 }
      ],
      500: [
        function(require, module, exports) {
          var types = {
            Array: function(value) {
              return (
                value !== null &&
                value !== undefined &&
                value.constructor === Array
              );
            },
            Boolean: function(value) {
              return typeof value === 'boolean';
            },
            Function: function(value) {
              return typeof value === 'function';
            },
            Nil: function(value) {
              return value === undefined || value === null;
            },
            Number: function(value) {
              return typeof value === 'number';
            },
            Object: function(value) {
              return typeof value === 'object';
            },
            String: function(value) {
              return typeof value === 'string';
            },
            '': function() {
              return true;
            }
          };
          types.Null = types.Nil;
          for (var typeName in types) {
            types[typeName].toJSON = function(t) {
              return t;
            }.bind(null, typeName);
          }
          module.exports = types;
        },
        {}
      ],
      501: [
        function(require, module, exports) {
          (function(root) {
            'use strict';
            var DEFAULT_FEATURE = [null, 0, {}];
            var CACHE_THRESHOLD = 10;
            var SBase = 44032,
              LBase = 4352,
              VBase = 4449,
              TBase = 4519,
              LCount = 19,
              VCount = 21,
              TCount = 28;
            var NCount = VCount * TCount;
            var SCount = LCount * NCount;
            var UChar = function(cp, feature) {
              this.codepoint = cp;
              this.feature = feature;
            };
            var cache = {};
            var cacheCounter = [];
            for (var i = 0; i <= 255; ++i) {
              cacheCounter[i] = 0;
            }
            function fromCache(next, cp, needFeature) {
              var ret = cache[cp];
              if (!ret) {
                ret = next(cp, needFeature);
                if (
                  !!ret.feature &&
                  ++cacheCounter[(cp >> 8) & 255] > CACHE_THRESHOLD
                ) {
                  cache[cp] = ret;
                }
              }
              return ret;
            }
            function fromData(next, cp, needFeature) {
              var hash = cp & 65280;
              var dunit = UChar.udata[hash] || {};
              var f = dunit[cp];
              return f ? new UChar(cp, f) : new UChar(cp, DEFAULT_FEATURE);
            }
            function fromCpOnly(next, cp, needFeature) {
              return !!needFeature
                ? next(cp, needFeature)
                : new UChar(cp, null);
            }
            function fromRuleBasedJamo(next, cp, needFeature) {
              var j;
              if (
                cp < LBase ||
                (LBase + LCount <= cp && cp < SBase) ||
                SBase + SCount < cp
              ) {
                return next(cp, needFeature);
              }
              if (LBase <= cp && cp < LBase + LCount) {
                var c = {};
                var base = (cp - LBase) * VCount;
                for (j = 0; j < VCount; ++j) {
                  c[VBase + j] = SBase + TCount * (j + base);
                }
                return new UChar(cp, [, , c]);
              }
              var SIndex = cp - SBase;
              var TIndex = SIndex % TCount;
              var feature = [];
              if (TIndex !== 0) {
                feature[0] = [SBase + SIndex - TIndex, TBase + TIndex];
              } else {
                feature[0] = [
                  LBase + Math.floor(SIndex / NCount),
                  VBase + Math.floor((SIndex % NCount) / TCount)
                ];
                feature[2] = {};
                for (j = 1; j < TCount; ++j) {
                  feature[2][TBase + j] = cp + j;
                }
              }
              return new UChar(cp, feature);
            }
            function fromCpFilter(next, cp, needFeature) {
              return cp < 60 || (13311 < cp && cp < 42607)
                ? new UChar(cp, DEFAULT_FEATURE)
                : next(cp, needFeature);
            }
            var strategies = [
              fromCpFilter,
              fromCache,
              fromCpOnly,
              fromRuleBasedJamo,
              fromData
            ];
            UChar.fromCharCode = strategies.reduceRight(function(
              next,
              strategy
            ) {
              return function(cp, needFeature) {
                return strategy(next, cp, needFeature);
              };
            },
            null);
            UChar.isHighSurrogate = function(cp) {
              return cp >= 55296 && cp <= 56319;
            };
            UChar.isLowSurrogate = function(cp) {
              return cp >= 56320 && cp <= 57343;
            };
            UChar.prototype.prepFeature = function() {
              if (!this.feature) {
                this.feature = UChar.fromCharCode(this.codepoint, true).feature;
              }
            };
            UChar.prototype.toString = function() {
              if (this.codepoint < 65536) {
                return String.fromCharCode(this.codepoint);
              } else {
                var x = this.codepoint - 65536;
                return String.fromCharCode(
                  Math.floor(x / 1024) + 55296,
                  (x % 1024) + 56320
                );
              }
            };
            UChar.prototype.getDecomp = function() {
              this.prepFeature();
              return this.feature[0] || null;
            };
            UChar.prototype.isCompatibility = function() {
              this.prepFeature();
              return !!this.feature[1] && this.feature[1] & (1 << 8);
            };
            UChar.prototype.isExclude = function() {
              this.prepFeature();
              return !!this.feature[1] && this.feature[1] & (1 << 9);
            };
            UChar.prototype.getCanonicalClass = function() {
              this.prepFeature();
              return !!this.feature[1] ? this.feature[1] & 255 : 0;
            };
            UChar.prototype.getComposite = function(following) {
              this.prepFeature();
              if (!this.feature[2]) {
                return null;
              }
              var cp = this.feature[2][following.codepoint];
              return cp ? UChar.fromCharCode(cp) : null;
            };
            var UCharIterator = function(str) {
              this.str = str;
              this.cursor = 0;
            };
            UCharIterator.prototype.next = function() {
              if (!!this.str && this.cursor < this.str.length) {
                var cp = this.str.charCodeAt(this.cursor++);
                var d;
                if (
                  UChar.isHighSurrogate(cp) &&
                  this.cursor < this.str.length &&
                  UChar.isLowSurrogate((d = this.str.charCodeAt(this.cursor)))
                ) {
                  cp = (cp - 55296) * 1024 + (d - 56320) + 65536;
                  ++this.cursor;
                }
                return UChar.fromCharCode(cp);
              } else {
                this.str = null;
                return null;
              }
            };
            var RecursDecompIterator = function(it, cano) {
              this.it = it;
              this.canonical = cano;
              this.resBuf = [];
            };
            RecursDecompIterator.prototype.next = function() {
              function recursiveDecomp(cano, uchar) {
                var decomp = uchar.getDecomp();
                if (!!decomp && !(cano && uchar.isCompatibility())) {
                  var ret = [];
                  for (var i = 0; i < decomp.length; ++i) {
                    var a = recursiveDecomp(
                      cano,
                      UChar.fromCharCode(decomp[i])
                    );
                    ret = ret.concat(a);
                  }
                  return ret;
                } else {
                  return [uchar];
                }
              }
              if (this.resBuf.length === 0) {
                var uchar = this.it.next();
                if (!uchar) {
                  return null;
                }
                this.resBuf = recursiveDecomp(this.canonical, uchar);
              }
              return this.resBuf.shift();
            };
            var DecompIterator = function(it) {
              this.it = it;
              this.resBuf = [];
            };
            DecompIterator.prototype.next = function() {
              var cc;
              if (this.resBuf.length === 0) {
                do {
                  var uchar = this.it.next();
                  if (!uchar) {
                    break;
                  }
                  cc = uchar.getCanonicalClass();
                  var inspt = this.resBuf.length;
                  if (cc !== 0) {
                    for (; inspt > 0; --inspt) {
                      var uchar2 = this.resBuf[inspt - 1];
                      var cc2 = uchar2.getCanonicalClass();
                      if (cc2 <= cc) {
                        break;
                      }
                    }
                  }
                  this.resBuf.splice(inspt, 0, uchar);
                } while (cc !== 0);
              }
              return this.resBuf.shift();
            };
            var CompIterator = function(it) {
              this.it = it;
              this.procBuf = [];
              this.resBuf = [];
              this.lastClass = null;
            };
            CompIterator.prototype.next = function() {
              while (this.resBuf.length === 0) {
                var uchar = this.it.next();
                if (!uchar) {
                  this.resBuf = this.procBuf;
                  this.procBuf = [];
                  break;
                }
                if (this.procBuf.length === 0) {
                  this.lastClass = uchar.getCanonicalClass();
                  this.procBuf.push(uchar);
                } else {
                  var starter = this.procBuf[0];
                  var composite = starter.getComposite(uchar);
                  var cc = uchar.getCanonicalClass();
                  if (
                    !!composite &&
                    (this.lastClass < cc || this.lastClass === 0)
                  ) {
                    this.procBuf[0] = composite;
                  } else {
                    if (cc === 0) {
                      this.resBuf = this.procBuf;
                      this.procBuf = [];
                    }
                    this.lastClass = cc;
                    this.procBuf.push(uchar);
                  }
                }
              }
              return this.resBuf.shift();
            };
            var createIterator = function(mode, str) {
              switch (mode) {
                case 'NFD':
                  return new DecompIterator(
                    new RecursDecompIterator(new UCharIterator(str), true)
                  );
                case 'NFKD':
                  return new DecompIterator(
                    new RecursDecompIterator(new UCharIterator(str), false)
                  );
                case 'NFC':
                  return new CompIterator(
                    new DecompIterator(
                      new RecursDecompIterator(new UCharIterator(str), true)
                    )
                  );
                case 'NFKC':
                  return new CompIterator(
                    new DecompIterator(
                      new RecursDecompIterator(new UCharIterator(str), false)
                    )
                  );
              }
              throw mode + ' is invalid';
            };
            var normalize = function(mode, str) {
              var it = createIterator(mode, str);
              var ret = '';
              var uchar;
              while (!!(uchar = it.next())) {
                ret += uchar.toString();
              }
              return ret;
            };
            function nfd(str) {
              return normalize('NFD', str);
            }
            function nfkd(str) {
              return normalize('NFKD', str);
            }
            function nfc(str) {
              return normalize('NFC', str);
            }
            function nfkc(str) {
              return normalize('NFKC', str);
            }
            UChar.udata = {
              0: {
                60: [, , { 824: 8814 }],
                61: [, , { 824: 8800 }],
                62: [, , { 824: 8815 }],
                65: [
                  ,
                  ,
                  {
                    768: 192,
                    769: 193,
                    770: 194,
                    771: 195,
                    772: 256,
                    774: 258,
                    775: 550,
                    776: 196,
                    777: 7842,
                    778: 197,
                    780: 461,
                    783: 512,
                    785: 514,
                    803: 7840,
                    805: 7680,
                    808: 260
                  }
                ],
                66: [, , { 775: 7682, 803: 7684, 817: 7686 }],
                67: [, , { 769: 262, 770: 264, 775: 266, 780: 268, 807: 199 }],
                68: [
                  ,
                  ,
                  {
                    775: 7690,
                    780: 270,
                    803: 7692,
                    807: 7696,
                    813: 7698,
                    817: 7694
                  }
                ],
                69: [
                  ,
                  ,
                  {
                    768: 200,
                    769: 201,
                    770: 202,
                    771: 7868,
                    772: 274,
                    774: 276,
                    775: 278,
                    776: 203,
                    777: 7866,
                    780: 282,
                    783: 516,
                    785: 518,
                    803: 7864,
                    807: 552,
                    808: 280,
                    813: 7704,
                    816: 7706
                  }
                ],
                70: [, , { 775: 7710 }],
                71: [
                  ,
                  ,
                  {
                    769: 500,
                    770: 284,
                    772: 7712,
                    774: 286,
                    775: 288,
                    780: 486,
                    807: 290
                  }
                ],
                72: [
                  ,
                  ,
                  {
                    770: 292,
                    775: 7714,
                    776: 7718,
                    780: 542,
                    803: 7716,
                    807: 7720,
                    814: 7722
                  }
                ],
                73: [
                  ,
                  ,
                  {
                    768: 204,
                    769: 205,
                    770: 206,
                    771: 296,
                    772: 298,
                    774: 300,
                    775: 304,
                    776: 207,
                    777: 7880,
                    780: 463,
                    783: 520,
                    785: 522,
                    803: 7882,
                    808: 302,
                    816: 7724
                  }
                ],
                74: [, , { 770: 308 }],
                75: [
                  ,
                  ,
                  { 769: 7728, 780: 488, 803: 7730, 807: 310, 817: 7732 }
                ],
                76: [
                  ,
                  ,
                  {
                    769: 313,
                    780: 317,
                    803: 7734,
                    807: 315,
                    813: 7740,
                    817: 7738
                  }
                ],
                77: [, , { 769: 7742, 775: 7744, 803: 7746 }],
                78: [
                  ,
                  ,
                  {
                    768: 504,
                    769: 323,
                    771: 209,
                    775: 7748,
                    780: 327,
                    803: 7750,
                    807: 325,
                    813: 7754,
                    817: 7752
                  }
                ],
                79: [
                  ,
                  ,
                  {
                    768: 210,
                    769: 211,
                    770: 212,
                    771: 213,
                    772: 332,
                    774: 334,
                    775: 558,
                    776: 214,
                    777: 7886,
                    779: 336,
                    780: 465,
                    783: 524,
                    785: 526,
                    795: 416,
                    803: 7884,
                    808: 490
                  }
                ],
                80: [, , { 769: 7764, 775: 7766 }],
                82: [
                  ,
                  ,
                  {
                    769: 340,
                    775: 7768,
                    780: 344,
                    783: 528,
                    785: 530,
                    803: 7770,
                    807: 342,
                    817: 7774
                  }
                ],
                83: [
                  ,
                  ,
                  {
                    769: 346,
                    770: 348,
                    775: 7776,
                    780: 352,
                    803: 7778,
                    806: 536,
                    807: 350
                  }
                ],
                84: [
                  ,
                  ,
                  {
                    775: 7786,
                    780: 356,
                    803: 7788,
                    806: 538,
                    807: 354,
                    813: 7792,
                    817: 7790
                  }
                ],
                85: [
                  ,
                  ,
                  {
                    768: 217,
                    769: 218,
                    770: 219,
                    771: 360,
                    772: 362,
                    774: 364,
                    776: 220,
                    777: 7910,
                    778: 366,
                    779: 368,
                    780: 467,
                    783: 532,
                    785: 534,
                    795: 431,
                    803: 7908,
                    804: 7794,
                    808: 370,
                    813: 7798,
                    816: 7796
                  }
                ],
                86: [, , { 771: 7804, 803: 7806 }],
                87: [
                  ,
                  ,
                  {
                    768: 7808,
                    769: 7810,
                    770: 372,
                    775: 7814,
                    776: 7812,
                    803: 7816
                  }
                ],
                88: [, , { 775: 7818, 776: 7820 }],
                89: [
                  ,
                  ,
                  {
                    768: 7922,
                    769: 221,
                    770: 374,
                    771: 7928,
                    772: 562,
                    775: 7822,
                    776: 376,
                    777: 7926,
                    803: 7924
                  }
                ],
                90: [
                  ,
                  ,
                  {
                    769: 377,
                    770: 7824,
                    775: 379,
                    780: 381,
                    803: 7826,
                    817: 7828
                  }
                ],
                97: [
                  ,
                  ,
                  {
                    768: 224,
                    769: 225,
                    770: 226,
                    771: 227,
                    772: 257,
                    774: 259,
                    775: 551,
                    776: 228,
                    777: 7843,
                    778: 229,
                    780: 462,
                    783: 513,
                    785: 515,
                    803: 7841,
                    805: 7681,
                    808: 261
                  }
                ],
                98: [, , { 775: 7683, 803: 7685, 817: 7687 }],
                99: [, , { 769: 263, 770: 265, 775: 267, 780: 269, 807: 231 }],
                100: [
                  ,
                  ,
                  {
                    775: 7691,
                    780: 271,
                    803: 7693,
                    807: 7697,
                    813: 7699,
                    817: 7695
                  }
                ],
                101: [
                  ,
                  ,
                  {
                    768: 232,
                    769: 233,
                    770: 234,
                    771: 7869,
                    772: 275,
                    774: 277,
                    775: 279,
                    776: 235,
                    777: 7867,
                    780: 283,
                    783: 517,
                    785: 519,
                    803: 7865,
                    807: 553,
                    808: 281,
                    813: 7705,
                    816: 7707
                  }
                ],
                102: [, , { 775: 7711 }],
                103: [
                  ,
                  ,
                  {
                    769: 501,
                    770: 285,
                    772: 7713,
                    774: 287,
                    775: 289,
                    780: 487,
                    807: 291
                  }
                ],
                104: [
                  ,
                  ,
                  {
                    770: 293,
                    775: 7715,
                    776: 7719,
                    780: 543,
                    803: 7717,
                    807: 7721,
                    814: 7723,
                    817: 7830
                  }
                ],
                105: [
                  ,
                  ,
                  {
                    768: 236,
                    769: 237,
                    770: 238,
                    771: 297,
                    772: 299,
                    774: 301,
                    776: 239,
                    777: 7881,
                    780: 464,
                    783: 521,
                    785: 523,
                    803: 7883,
                    808: 303,
                    816: 7725
                  }
                ],
                106: [, , { 770: 309, 780: 496 }],
                107: [
                  ,
                  ,
                  { 769: 7729, 780: 489, 803: 7731, 807: 311, 817: 7733 }
                ],
                108: [
                  ,
                  ,
                  {
                    769: 314,
                    780: 318,
                    803: 7735,
                    807: 316,
                    813: 7741,
                    817: 7739
                  }
                ],
                109: [, , { 769: 7743, 775: 7745, 803: 7747 }],
                110: [
                  ,
                  ,
                  {
                    768: 505,
                    769: 324,
                    771: 241,
                    775: 7749,
                    780: 328,
                    803: 7751,
                    807: 326,
                    813: 7755,
                    817: 7753
                  }
                ],
                111: [
                  ,
                  ,
                  {
                    768: 242,
                    769: 243,
                    770: 244,
                    771: 245,
                    772: 333,
                    774: 335,
                    775: 559,
                    776: 246,
                    777: 7887,
                    779: 337,
                    780: 466,
                    783: 525,
                    785: 527,
                    795: 417,
                    803: 7885,
                    808: 491
                  }
                ],
                112: [, , { 769: 7765, 775: 7767 }],
                114: [
                  ,
                  ,
                  {
                    769: 341,
                    775: 7769,
                    780: 345,
                    783: 529,
                    785: 531,
                    803: 7771,
                    807: 343,
                    817: 7775
                  }
                ],
                115: [
                  ,
                  ,
                  {
                    769: 347,
                    770: 349,
                    775: 7777,
                    780: 353,
                    803: 7779,
                    806: 537,
                    807: 351
                  }
                ],
                116: [
                  ,
                  ,
                  {
                    775: 7787,
                    776: 7831,
                    780: 357,
                    803: 7789,
                    806: 539,
                    807: 355,
                    813: 7793,
                    817: 7791
                  }
                ],
                117: [
                  ,
                  ,
                  {
                    768: 249,
                    769: 250,
                    770: 251,
                    771: 361,
                    772: 363,
                    774: 365,
                    776: 252,
                    777: 7911,
                    778: 367,
                    779: 369,
                    780: 468,
                    783: 533,
                    785: 535,
                    795: 432,
                    803: 7909,
                    804: 7795,
                    808: 371,
                    813: 7799,
                    816: 7797
                  }
                ],
                118: [, , { 771: 7805, 803: 7807 }],
                119: [
                  ,
                  ,
                  {
                    768: 7809,
                    769: 7811,
                    770: 373,
                    775: 7815,
                    776: 7813,
                    778: 7832,
                    803: 7817
                  }
                ],
                120: [, , { 775: 7819, 776: 7821 }],
                121: [
                  ,
                  ,
                  {
                    768: 7923,
                    769: 253,
                    770: 375,
                    771: 7929,
                    772: 563,
                    775: 7823,
                    776: 255,
                    777: 7927,
                    778: 7833,
                    803: 7925
                  }
                ],
                122: [
                  ,
                  ,
                  {
                    769: 378,
                    770: 7825,
                    775: 380,
                    780: 382,
                    803: 7827,
                    817: 7829
                  }
                ],
                160: [[32], 256],
                168: [[32, 776], 256, { 768: 8173, 769: 901, 834: 8129 }],
                170: [[97], 256],
                175: [[32, 772], 256],
                178: [[50], 256],
                179: [[51], 256],
                180: [[32, 769], 256],
                181: [[956], 256],
                184: [[32, 807], 256],
                185: [[49], 256],
                186: [[111], 256],
                188: [[49, 8260, 52], 256],
                189: [[49, 8260, 50], 256],
                190: [[51, 8260, 52], 256],
                192: [[65, 768]],
                193: [[65, 769]],
                194: [
                  [65, 770],
                  ,
                  { 768: 7846, 769: 7844, 771: 7850, 777: 7848 }
                ],
                195: [[65, 771]],
                196: [[65, 776], , { 772: 478 }],
                197: [[65, 778], , { 769: 506 }],
                198: [, , { 769: 508, 772: 482 }],
                199: [[67, 807], , { 769: 7688 }],
                200: [[69, 768]],
                201: [[69, 769]],
                202: [
                  [69, 770],
                  ,
                  { 768: 7872, 769: 7870, 771: 7876, 777: 7874 }
                ],
                203: [[69, 776]],
                204: [[73, 768]],
                205: [[73, 769]],
                206: [[73, 770]],
                207: [[73, 776], , { 769: 7726 }],
                209: [[78, 771]],
                210: [[79, 768]],
                211: [[79, 769]],
                212: [
                  [79, 770],
                  ,
                  { 768: 7890, 769: 7888, 771: 7894, 777: 7892 }
                ],
                213: [[79, 771], , { 769: 7756, 772: 556, 776: 7758 }],
                214: [[79, 776], , { 772: 554 }],
                216: [, , { 769: 510 }],
                217: [[85, 768]],
                218: [[85, 769]],
                219: [[85, 770]],
                220: [[85, 776], , { 768: 475, 769: 471, 772: 469, 780: 473 }],
                221: [[89, 769]],
                224: [[97, 768]],
                225: [[97, 769]],
                226: [
                  [97, 770],
                  ,
                  { 768: 7847, 769: 7845, 771: 7851, 777: 7849 }
                ],
                227: [[97, 771]],
                228: [[97, 776], , { 772: 479 }],
                229: [[97, 778], , { 769: 507 }],
                230: [, , { 769: 509, 772: 483 }],
                231: [[99, 807], , { 769: 7689 }],
                232: [[101, 768]],
                233: [[101, 769]],
                234: [
                  [101, 770],
                  ,
                  { 768: 7873, 769: 7871, 771: 7877, 777: 7875 }
                ],
                235: [[101, 776]],
                236: [[105, 768]],
                237: [[105, 769]],
                238: [[105, 770]],
                239: [[105, 776], , { 769: 7727 }],
                241: [[110, 771]],
                242: [[111, 768]],
                243: [[111, 769]],
                244: [
                  [111, 770],
                  ,
                  { 768: 7891, 769: 7889, 771: 7895, 777: 7893 }
                ],
                245: [[111, 771], , { 769: 7757, 772: 557, 776: 7759 }],
                246: [[111, 776], , { 772: 555 }],
                248: [, , { 769: 511 }],
                249: [[117, 768]],
                250: [[117, 769]],
                251: [[117, 770]],
                252: [[117, 776], , { 768: 476, 769: 472, 772: 470, 780: 474 }],
                253: [[121, 769]],
                255: [[121, 776]]
              },
              256: {
                256: [[65, 772]],
                257: [[97, 772]],
                258: [
                  [65, 774],
                  ,
                  { 768: 7856, 769: 7854, 771: 7860, 777: 7858 }
                ],
                259: [
                  [97, 774],
                  ,
                  { 768: 7857, 769: 7855, 771: 7861, 777: 7859 }
                ],
                260: [[65, 808]],
                261: [[97, 808]],
                262: [[67, 769]],
                263: [[99, 769]],
                264: [[67, 770]],
                265: [[99, 770]],
                266: [[67, 775]],
                267: [[99, 775]],
                268: [[67, 780]],
                269: [[99, 780]],
                270: [[68, 780]],
                271: [[100, 780]],
                274: [[69, 772], , { 768: 7700, 769: 7702 }],
                275: [[101, 772], , { 768: 7701, 769: 7703 }],
                276: [[69, 774]],
                277: [[101, 774]],
                278: [[69, 775]],
                279: [[101, 775]],
                280: [[69, 808]],
                281: [[101, 808]],
                282: [[69, 780]],
                283: [[101, 780]],
                284: [[71, 770]],
                285: [[103, 770]],
                286: [[71, 774]],
                287: [[103, 774]],
                288: [[71, 775]],
                289: [[103, 775]],
                290: [[71, 807]],
                291: [[103, 807]],
                292: [[72, 770]],
                293: [[104, 770]],
                296: [[73, 771]],
                297: [[105, 771]],
                298: [[73, 772]],
                299: [[105, 772]],
                300: [[73, 774]],
                301: [[105, 774]],
                302: [[73, 808]],
                303: [[105, 808]],
                304: [[73, 775]],
                306: [[73, 74], 256],
                307: [[105, 106], 256],
                308: [[74, 770]],
                309: [[106, 770]],
                310: [[75, 807]],
                311: [[107, 807]],
                313: [[76, 769]],
                314: [[108, 769]],
                315: [[76, 807]],
                316: [[108, 807]],
                317: [[76, 780]],
                318: [[108, 780]],
                319: [[76, 183], 256],
                320: [[108, 183], 256],
                323: [[78, 769]],
                324: [[110, 769]],
                325: [[78, 807]],
                326: [[110, 807]],
                327: [[78, 780]],
                328: [[110, 780]],
                329: [[700, 110], 256],
                332: [[79, 772], , { 768: 7760, 769: 7762 }],
                333: [[111, 772], , { 768: 7761, 769: 7763 }],
                334: [[79, 774]],
                335: [[111, 774]],
                336: [[79, 779]],
                337: [[111, 779]],
                340: [[82, 769]],
                341: [[114, 769]],
                342: [[82, 807]],
                343: [[114, 807]],
                344: [[82, 780]],
                345: [[114, 780]],
                346: [[83, 769], , { 775: 7780 }],
                347: [[115, 769], , { 775: 7781 }],
                348: [[83, 770]],
                349: [[115, 770]],
                350: [[83, 807]],
                351: [[115, 807]],
                352: [[83, 780], , { 775: 7782 }],
                353: [[115, 780], , { 775: 7783 }],
                354: [[84, 807]],
                355: [[116, 807]],
                356: [[84, 780]],
                357: [[116, 780]],
                360: [[85, 771], , { 769: 7800 }],
                361: [[117, 771], , { 769: 7801 }],
                362: [[85, 772], , { 776: 7802 }],
                363: [[117, 772], , { 776: 7803 }],
                364: [[85, 774]],
                365: [[117, 774]],
                366: [[85, 778]],
                367: [[117, 778]],
                368: [[85, 779]],
                369: [[117, 779]],
                370: [[85, 808]],
                371: [[117, 808]],
                372: [[87, 770]],
                373: [[119, 770]],
                374: [[89, 770]],
                375: [[121, 770]],
                376: [[89, 776]],
                377: [[90, 769]],
                378: [[122, 769]],
                379: [[90, 775]],
                380: [[122, 775]],
                381: [[90, 780]],
                382: [[122, 780]],
                383: [[115], 256, { 775: 7835 }],
                416: [
                  [79, 795],
                  ,
                  { 768: 7900, 769: 7898, 771: 7904, 777: 7902, 803: 7906 }
                ],
                417: [
                  [111, 795],
                  ,
                  { 768: 7901, 769: 7899, 771: 7905, 777: 7903, 803: 7907 }
                ],
                431: [
                  [85, 795],
                  ,
                  { 768: 7914, 769: 7912, 771: 7918, 777: 7916, 803: 7920 }
                ],
                432: [
                  [117, 795],
                  ,
                  { 768: 7915, 769: 7913, 771: 7919, 777: 7917, 803: 7921 }
                ],
                439: [, , { 780: 494 }],
                452: [[68, 381], 256],
                453: [[68, 382], 256],
                454: [[100, 382], 256],
                455: [[76, 74], 256],
                456: [[76, 106], 256],
                457: [[108, 106], 256],
                458: [[78, 74], 256],
                459: [[78, 106], 256],
                460: [[110, 106], 256],
                461: [[65, 780]],
                462: [[97, 780]],
                463: [[73, 780]],
                464: [[105, 780]],
                465: [[79, 780]],
                466: [[111, 780]],
                467: [[85, 780]],
                468: [[117, 780]],
                469: [[220, 772]],
                470: [[252, 772]],
                471: [[220, 769]],
                472: [[252, 769]],
                473: [[220, 780]],
                474: [[252, 780]],
                475: [[220, 768]],
                476: [[252, 768]],
                478: [[196, 772]],
                479: [[228, 772]],
                480: [[550, 772]],
                481: [[551, 772]],
                482: [[198, 772]],
                483: [[230, 772]],
                486: [[71, 780]],
                487: [[103, 780]],
                488: [[75, 780]],
                489: [[107, 780]],
                490: [[79, 808], , { 772: 492 }],
                491: [[111, 808], , { 772: 493 }],
                492: [[490, 772]],
                493: [[491, 772]],
                494: [[439, 780]],
                495: [[658, 780]],
                496: [[106, 780]],
                497: [[68, 90], 256],
                498: [[68, 122], 256],
                499: [[100, 122], 256],
                500: [[71, 769]],
                501: [[103, 769]],
                504: [[78, 768]],
                505: [[110, 768]],
                506: [[197, 769]],
                507: [[229, 769]],
                508: [[198, 769]],
                509: [[230, 769]],
                510: [[216, 769]],
                511: [[248, 769]],
                66045: [, 220]
              },
              512: {
                512: [[65, 783]],
                513: [[97, 783]],
                514: [[65, 785]],
                515: [[97, 785]],
                516: [[69, 783]],
                517: [[101, 783]],
                518: [[69, 785]],
                519: [[101, 785]],
                520: [[73, 783]],
                521: [[105, 783]],
                522: [[73, 785]],
                523: [[105, 785]],
                524: [[79, 783]],
                525: [[111, 783]],
                526: [[79, 785]],
                527: [[111, 785]],
                528: [[82, 783]],
                529: [[114, 783]],
                530: [[82, 785]],
                531: [[114, 785]],
                532: [[85, 783]],
                533: [[117, 783]],
                534: [[85, 785]],
                535: [[117, 785]],
                536: [[83, 806]],
                537: [[115, 806]],
                538: [[84, 806]],
                539: [[116, 806]],
                542: [[72, 780]],
                543: [[104, 780]],
                550: [[65, 775], , { 772: 480 }],
                551: [[97, 775], , { 772: 481 }],
                552: [[69, 807], , { 774: 7708 }],
                553: [[101, 807], , { 774: 7709 }],
                554: [[214, 772]],
                555: [[246, 772]],
                556: [[213, 772]],
                557: [[245, 772]],
                558: [[79, 775], , { 772: 560 }],
                559: [[111, 775], , { 772: 561 }],
                560: [[558, 772]],
                561: [[559, 772]],
                562: [[89, 772]],
                563: [[121, 772]],
                658: [, , { 780: 495 }],
                688: [[104], 256],
                689: [[614], 256],
                690: [[106], 256],
                691: [[114], 256],
                692: [[633], 256],
                693: [[635], 256],
                694: [[641], 256],
                695: [[119], 256],
                696: [[121], 256],
                728: [[32, 774], 256],
                729: [[32, 775], 256],
                730: [[32, 778], 256],
                731: [[32, 808], 256],
                732: [[32, 771], 256],
                733: [[32, 779], 256],
                736: [[611], 256],
                737: [[108], 256],
                738: [[115], 256],
                739: [[120], 256],
                740: [[661], 256],
                66272: [, 220]
              },
              768: {
                768: [, 230],
                769: [, 230],
                770: [, 230],
                771: [, 230],
                772: [, 230],
                773: [, 230],
                774: [, 230],
                775: [, 230],
                776: [, 230, { 769: 836 }],
                777: [, 230],
                778: [, 230],
                779: [, 230],
                780: [, 230],
                781: [, 230],
                782: [, 230],
                783: [, 230],
                784: [, 230],
                785: [, 230],
                786: [, 230],
                787: [, 230],
                788: [, 230],
                789: [, 232],
                790: [, 220],
                791: [, 220],
                792: [, 220],
                793: [, 220],
                794: [, 232],
                795: [, 216],
                796: [, 220],
                797: [, 220],
                798: [, 220],
                799: [, 220],
                800: [, 220],
                801: [, 202],
                802: [, 202],
                803: [, 220],
                804: [, 220],
                805: [, 220],
                806: [, 220],
                807: [, 202],
                808: [, 202],
                809: [, 220],
                810: [, 220],
                811: [, 220],
                812: [, 220],
                813: [, 220],
                814: [, 220],
                815: [, 220],
                816: [, 220],
                817: [, 220],
                818: [, 220],
                819: [, 220],
                820: [, 1],
                821: [, 1],
                822: [, 1],
                823: [, 1],
                824: [, 1],
                825: [, 220],
                826: [, 220],
                827: [, 220],
                828: [, 220],
                829: [, 230],
                830: [, 230],
                831: [, 230],
                832: [[768], 230],
                833: [[769], 230],
                834: [, 230],
                835: [[787], 230],
                836: [[776, 769], 230],
                837: [, 240],
                838: [, 230],
                839: [, 220],
                840: [, 220],
                841: [, 220],
                842: [, 230],
                843: [, 230],
                844: [, 230],
                845: [, 220],
                846: [, 220],
                848: [, 230],
                849: [, 230],
                850: [, 230],
                851: [, 220],
                852: [, 220],
                853: [, 220],
                854: [, 220],
                855: [, 230],
                856: [, 232],
                857: [, 220],
                858: [, 220],
                859: [, 230],
                860: [, 233],
                861: [, 234],
                862: [, 234],
                863: [, 233],
                864: [, 234],
                865: [, 234],
                866: [, 233],
                867: [, 230],
                868: [, 230],
                869: [, 230],
                870: [, 230],
                871: [, 230],
                872: [, 230],
                873: [, 230],
                874: [, 230],
                875: [, 230],
                876: [, 230],
                877: [, 230],
                878: [, 230],
                879: [, 230],
                884: [[697]],
                890: [[32, 837], 256],
                894: [[59]],
                900: [[32, 769], 256],
                901: [[168, 769]],
                902: [[913, 769]],
                903: [[183]],
                904: [[917, 769]],
                905: [[919, 769]],
                906: [[921, 769]],
                908: [[927, 769]],
                910: [[933, 769]],
                911: [[937, 769]],
                912: [[970, 769]],
                913: [
                  ,
                  ,
                  {
                    768: 8122,
                    769: 902,
                    772: 8121,
                    774: 8120,
                    787: 7944,
                    788: 7945,
                    837: 8124
                  }
                ],
                917: [, , { 768: 8136, 769: 904, 787: 7960, 788: 7961 }],
                919: [
                  ,
                  ,
                  { 768: 8138, 769: 905, 787: 7976, 788: 7977, 837: 8140 }
                ],
                921: [
                  ,
                  ,
                  {
                    768: 8154,
                    769: 906,
                    772: 8153,
                    774: 8152,
                    776: 938,
                    787: 7992,
                    788: 7993
                  }
                ],
                927: [, , { 768: 8184, 769: 908, 787: 8008, 788: 8009 }],
                929: [, , { 788: 8172 }],
                933: [
                  ,
                  ,
                  {
                    768: 8170,
                    769: 910,
                    772: 8169,
                    774: 8168,
                    776: 939,
                    788: 8025
                  }
                ],
                937: [
                  ,
                  ,
                  { 768: 8186, 769: 911, 787: 8040, 788: 8041, 837: 8188 }
                ],
                938: [[921, 776]],
                939: [[933, 776]],
                940: [[945, 769], , { 837: 8116 }],
                941: [[949, 769]],
                942: [[951, 769], , { 837: 8132 }],
                943: [[953, 769]],
                944: [[971, 769]],
                945: [
                  ,
                  ,
                  {
                    768: 8048,
                    769: 940,
                    772: 8113,
                    774: 8112,
                    787: 7936,
                    788: 7937,
                    834: 8118,
                    837: 8115
                  }
                ],
                949: [, , { 768: 8050, 769: 941, 787: 7952, 788: 7953 }],
                951: [
                  ,
                  ,
                  {
                    768: 8052,
                    769: 942,
                    787: 7968,
                    788: 7969,
                    834: 8134,
                    837: 8131
                  }
                ],
                953: [
                  ,
                  ,
                  {
                    768: 8054,
                    769: 943,
                    772: 8145,
                    774: 8144,
                    776: 970,
                    787: 7984,
                    788: 7985,
                    834: 8150
                  }
                ],
                959: [, , { 768: 8056, 769: 972, 787: 8e3, 788: 8001 }],
                961: [, , { 787: 8164, 788: 8165 }],
                965: [
                  ,
                  ,
                  {
                    768: 8058,
                    769: 973,
                    772: 8161,
                    774: 8160,
                    776: 971,
                    787: 8016,
                    788: 8017,
                    834: 8166
                  }
                ],
                969: [
                  ,
                  ,
                  {
                    768: 8060,
                    769: 974,
                    787: 8032,
                    788: 8033,
                    834: 8182,
                    837: 8179
                  }
                ],
                970: [[953, 776], , { 768: 8146, 769: 912, 834: 8151 }],
                971: [[965, 776], , { 768: 8162, 769: 944, 834: 8167 }],
                972: [[959, 769]],
                973: [[965, 769]],
                974: [[969, 769], , { 837: 8180 }],
                976: [[946], 256],
                977: [[952], 256],
                978: [[933], 256, { 769: 979, 776: 980 }],
                979: [[978, 769]],
                980: [[978, 776]],
                981: [[966], 256],
                982: [[960], 256],
                1008: [[954], 256],
                1009: [[961], 256],
                1010: [[962], 256],
                1012: [[920], 256],
                1013: [[949], 256],
                1017: [[931], 256],
                66422: [, 230],
                66423: [, 230],
                66424: [, 230],
                66425: [, 230],
                66426: [, 230]
              },
              1024: {
                1024: [[1045, 768]],
                1025: [[1045, 776]],
                1027: [[1043, 769]],
                1030: [, , { 776: 1031 }],
                1031: [[1030, 776]],
                1036: [[1050, 769]],
                1037: [[1048, 768]],
                1038: [[1059, 774]],
                1040: [, , { 774: 1232, 776: 1234 }],
                1043: [, , { 769: 1027 }],
                1045: [, , { 768: 1024, 774: 1238, 776: 1025 }],
                1046: [, , { 774: 1217, 776: 1244 }],
                1047: [, , { 776: 1246 }],
                1048: [, , { 768: 1037, 772: 1250, 774: 1049, 776: 1252 }],
                1049: [[1048, 774]],
                1050: [, , { 769: 1036 }],
                1054: [, , { 776: 1254 }],
                1059: [, , { 772: 1262, 774: 1038, 776: 1264, 779: 1266 }],
                1063: [, , { 776: 1268 }],
                1067: [, , { 776: 1272 }],
                1069: [, , { 776: 1260 }],
                1072: [, , { 774: 1233, 776: 1235 }],
                1075: [, , { 769: 1107 }],
                1077: [, , { 768: 1104, 774: 1239, 776: 1105 }],
                1078: [, , { 774: 1218, 776: 1245 }],
                1079: [, , { 776: 1247 }],
                1080: [, , { 768: 1117, 772: 1251, 774: 1081, 776: 1253 }],
                1081: [[1080, 774]],
                1082: [, , { 769: 1116 }],
                1086: [, , { 776: 1255 }],
                1091: [, , { 772: 1263, 774: 1118, 776: 1265, 779: 1267 }],
                1095: [, , { 776: 1269 }],
                1099: [, , { 776: 1273 }],
                1101: [, , { 776: 1261 }],
                1104: [[1077, 768]],
                1105: [[1077, 776]],
                1107: [[1075, 769]],
                1110: [, , { 776: 1111 }],
                1111: [[1110, 776]],
                1116: [[1082, 769]],
                1117: [[1080, 768]],
                1118: [[1091, 774]],
                1140: [, , { 783: 1142 }],
                1141: [, , { 783: 1143 }],
                1142: [[1140, 783]],
                1143: [[1141, 783]],
                1155: [, 230],
                1156: [, 230],
                1157: [, 230],
                1158: [, 230],
                1159: [, 230],
                1217: [[1046, 774]],
                1218: [[1078, 774]],
                1232: [[1040, 774]],
                1233: [[1072, 774]],
                1234: [[1040, 776]],
                1235: [[1072, 776]],
                1238: [[1045, 774]],
                1239: [[1077, 774]],
                1240: [, , { 776: 1242 }],
                1241: [, , { 776: 1243 }],
                1242: [[1240, 776]],
                1243: [[1241, 776]],
                1244: [[1046, 776]],
                1245: [[1078, 776]],
                1246: [[1047, 776]],
                1247: [[1079, 776]],
                1250: [[1048, 772]],
                1251: [[1080, 772]],
                1252: [[1048, 776]],
                1253: [[1080, 776]],
                1254: [[1054, 776]],
                1255: [[1086, 776]],
                1256: [, , { 776: 1258 }],
                1257: [, , { 776: 1259 }],
                1258: [[1256, 776]],
                1259: [[1257, 776]],
                1260: [[1069, 776]],
                1261: [[1101, 776]],
                1262: [[1059, 772]],
                1263: [[1091, 772]],
                1264: [[1059, 776]],
                1265: [[1091, 776]],
                1266: [[1059, 779]],
                1267: [[1091, 779]],
                1268: [[1063, 776]],
                1269: [[1095, 776]],
                1272: [[1067, 776]],
                1273: [[1099, 776]]
              },
              1280: {
                1415: [[1381, 1410], 256],
                1425: [, 220],
                1426: [, 230],
                1427: [, 230],
                1428: [, 230],
                1429: [, 230],
                1430: [, 220],
                1431: [, 230],
                1432: [, 230],
                1433: [, 230],
                1434: [, 222],
                1435: [, 220],
                1436: [, 230],
                1437: [, 230],
                1438: [, 230],
                1439: [, 230],
                1440: [, 230],
                1441: [, 230],
                1442: [, 220],
                1443: [, 220],
                1444: [, 220],
                1445: [, 220],
                1446: [, 220],
                1447: [, 220],
                1448: [, 230],
                1449: [, 230],
                1450: [, 220],
                1451: [, 230],
                1452: [, 230],
                1453: [, 222],
                1454: [, 228],
                1455: [, 230],
                1456: [, 10],
                1457: [, 11],
                1458: [, 12],
                1459: [, 13],
                1460: [, 14],
                1461: [, 15],
                1462: [, 16],
                1463: [, 17],
                1464: [, 18],
                1465: [, 19],
                1466: [, 19],
                1467: [, 20],
                1468: [, 21],
                1469: [, 22],
                1471: [, 23],
                1473: [, 24],
                1474: [, 25],
                1476: [, 230],
                1477: [, 220],
                1479: [, 18]
              },
              1536: {
                1552: [, 230],
                1553: [, 230],
                1554: [, 230],
                1555: [, 230],
                1556: [, 230],
                1557: [, 230],
                1558: [, 230],
                1559: [, 230],
                1560: [, 30],
                1561: [, 31],
                1562: [, 32],
                1570: [[1575, 1619]],
                1571: [[1575, 1620]],
                1572: [[1608, 1620]],
                1573: [[1575, 1621]],
                1574: [[1610, 1620]],
                1575: [, , { 1619: 1570, 1620: 1571, 1621: 1573 }],
                1608: [, , { 1620: 1572 }],
                1610: [, , { 1620: 1574 }],
                1611: [, 27],
                1612: [, 28],
                1613: [, 29],
                1614: [, 30],
                1615: [, 31],
                1616: [, 32],
                1617: [, 33],
                1618: [, 34],
                1619: [, 230],
                1620: [, 230],
                1621: [, 220],
                1622: [, 220],
                1623: [, 230],
                1624: [, 230],
                1625: [, 230],
                1626: [, 230],
                1627: [, 230],
                1628: [, 220],
                1629: [, 230],
                1630: [, 230],
                1631: [, 220],
                1648: [, 35],
                1653: [[1575, 1652], 256],
                1654: [[1608, 1652], 256],
                1655: [[1735, 1652], 256],
                1656: [[1610, 1652], 256],
                1728: [[1749, 1620]],
                1729: [, , { 1620: 1730 }],
                1730: [[1729, 1620]],
                1746: [, , { 1620: 1747 }],
                1747: [[1746, 1620]],
                1749: [, , { 1620: 1728 }],
                1750: [, 230],
                1751: [, 230],
                1752: [, 230],
                1753: [, 230],
                1754: [, 230],
                1755: [, 230],
                1756: [, 230],
                1759: [, 230],
                1760: [, 230],
                1761: [, 230],
                1762: [, 230],
                1763: [, 220],
                1764: [, 230],
                1767: [, 230],
                1768: [, 230],
                1770: [, 220],
                1771: [, 230],
                1772: [, 230],
                1773: [, 220]
              },
              1792: {
                1809: [, 36],
                1840: [, 230],
                1841: [, 220],
                1842: [, 230],
                1843: [, 230],
                1844: [, 220],
                1845: [, 230],
                1846: [, 230],
                1847: [, 220],
                1848: [, 220],
                1849: [, 220],
                1850: [, 230],
                1851: [, 220],
                1852: [, 220],
                1853: [, 230],
                1854: [, 220],
                1855: [, 230],
                1856: [, 230],
                1857: [, 230],
                1858: [, 220],
                1859: [, 230],
                1860: [, 220],
                1861: [, 230],
                1862: [, 220],
                1863: [, 230],
                1864: [, 220],
                1865: [, 230],
                1866: [, 230],
                2027: [, 230],
                2028: [, 230],
                2029: [, 230],
                2030: [, 230],
                2031: [, 230],
                2032: [, 230],
                2033: [, 230],
                2034: [, 220],
                2035: [, 230]
              },
              2048: {
                2070: [, 230],
                2071: [, 230],
                2072: [, 230],
                2073: [, 230],
                2075: [, 230],
                2076: [, 230],
                2077: [, 230],
                2078: [, 230],
                2079: [, 230],
                2080: [, 230],
                2081: [, 230],
                2082: [, 230],
                2083: [, 230],
                2085: [, 230],
                2086: [, 230],
                2087: [, 230],
                2089: [, 230],
                2090: [, 230],
                2091: [, 230],
                2092: [, 230],
                2093: [, 230],
                2137: [, 220],
                2138: [, 220],
                2139: [, 220],
                2276: [, 230],
                2277: [, 230],
                2278: [, 220],
                2279: [, 230],
                2280: [, 230],
                2281: [, 220],
                2282: [, 230],
                2283: [, 230],
                2284: [, 230],
                2285: [, 220],
                2286: [, 220],
                2287: [, 220],
                2288: [, 27],
                2289: [, 28],
                2290: [, 29],
                2291: [, 230],
                2292: [, 230],
                2293: [, 230],
                2294: [, 220],
                2295: [, 230],
                2296: [, 230],
                2297: [, 220],
                2298: [, 220],
                2299: [, 230],
                2300: [, 230],
                2301: [, 230],
                2302: [, 230],
                2303: [, 230]
              },
              2304: {
                2344: [, , { 2364: 2345 }],
                2345: [[2344, 2364]],
                2352: [, , { 2364: 2353 }],
                2353: [[2352, 2364]],
                2355: [, , { 2364: 2356 }],
                2356: [[2355, 2364]],
                2364: [, 7],
                2381: [, 9],
                2385: [, 230],
                2386: [, 220],
                2387: [, 230],
                2388: [, 230],
                2392: [[2325, 2364], 512],
                2393: [[2326, 2364], 512],
                2394: [[2327, 2364], 512],
                2395: [[2332, 2364], 512],
                2396: [[2337, 2364], 512],
                2397: [[2338, 2364], 512],
                2398: [[2347, 2364], 512],
                2399: [[2351, 2364], 512],
                2492: [, 7],
                2503: [, , { 2494: 2507, 2519: 2508 }],
                2507: [[2503, 2494]],
                2508: [[2503, 2519]],
                2509: [, 9],
                2524: [[2465, 2492], 512],
                2525: [[2466, 2492], 512],
                2527: [[2479, 2492], 512]
              },
              2560: {
                2611: [[2610, 2620], 512],
                2614: [[2616, 2620], 512],
                2620: [, 7],
                2637: [, 9],
                2649: [[2582, 2620], 512],
                2650: [[2583, 2620], 512],
                2651: [[2588, 2620], 512],
                2654: [[2603, 2620], 512],
                2748: [, 7],
                2765: [, 9],
                68109: [, 220],
                68111: [, 230],
                68152: [, 230],
                68153: [, 1],
                68154: [, 220],
                68159: [, 9],
                68325: [, 230],
                68326: [, 220]
              },
              2816: {
                2876: [, 7],
                2887: [, , { 2878: 2891, 2902: 2888, 2903: 2892 }],
                2888: [[2887, 2902]],
                2891: [[2887, 2878]],
                2892: [[2887, 2903]],
                2893: [, 9],
                2908: [[2849, 2876], 512],
                2909: [[2850, 2876], 512],
                2962: [, , { 3031: 2964 }],
                2964: [[2962, 3031]],
                3014: [, , { 3006: 3018, 3031: 3020 }],
                3015: [, , { 3006: 3019 }],
                3018: [[3014, 3006]],
                3019: [[3015, 3006]],
                3020: [[3014, 3031]],
                3021: [, 9]
              },
              3072: {
                3142: [, , { 3158: 3144 }],
                3144: [[3142, 3158]],
                3149: [, 9],
                3157: [, 84],
                3158: [, 91],
                3260: [, 7],
                3263: [, , { 3285: 3264 }],
                3264: [[3263, 3285]],
                3270: [, , { 3266: 3274, 3285: 3271, 3286: 3272 }],
                3271: [[3270, 3285]],
                3272: [[3270, 3286]],
                3274: [[3270, 3266], , { 3285: 3275 }],
                3275: [[3274, 3285]],
                3277: [, 9]
              },
              3328: {
                3398: [, , { 3390: 3402, 3415: 3404 }],
                3399: [, , { 3390: 3403 }],
                3402: [[3398, 3390]],
                3403: [[3399, 3390]],
                3404: [[3398, 3415]],
                3405: [, 9],
                3530: [, 9],
                3545: [, , { 3530: 3546, 3535: 3548, 3551: 3550 }],
                3546: [[3545, 3530]],
                3548: [[3545, 3535], , { 3530: 3549 }],
                3549: [[3548, 3530]],
                3550: [[3545, 3551]]
              },
              3584: {
                3635: [[3661, 3634], 256],
                3640: [, 103],
                3641: [, 103],
                3642: [, 9],
                3656: [, 107],
                3657: [, 107],
                3658: [, 107],
                3659: [, 107],
                3763: [[3789, 3762], 256],
                3768: [, 118],
                3769: [, 118],
                3784: [, 122],
                3785: [, 122],
                3786: [, 122],
                3787: [, 122],
                3804: [[3755, 3737], 256],
                3805: [[3755, 3745], 256]
              },
              3840: {
                3852: [[3851], 256],
                3864: [, 220],
                3865: [, 220],
                3893: [, 220],
                3895: [, 220],
                3897: [, 216],
                3907: [[3906, 4023], 512],
                3917: [[3916, 4023], 512],
                3922: [[3921, 4023], 512],
                3927: [[3926, 4023], 512],
                3932: [[3931, 4023], 512],
                3945: [[3904, 4021], 512],
                3953: [, 129],
                3954: [, 130],
                3955: [[3953, 3954], 512],
                3956: [, 132],
                3957: [[3953, 3956], 512],
                3958: [[4018, 3968], 512],
                3959: [[4018, 3969], 256],
                3960: [[4019, 3968], 512],
                3961: [[4019, 3969], 256],
                3962: [, 130],
                3963: [, 130],
                3964: [, 130],
                3965: [, 130],
                3968: [, 130],
                3969: [[3953, 3968], 512],
                3970: [, 230],
                3971: [, 230],
                3972: [, 9],
                3974: [, 230],
                3975: [, 230],
                3987: [[3986, 4023], 512],
                3997: [[3996, 4023], 512],
                4002: [[4001, 4023], 512],
                4007: [[4006, 4023], 512],
                4012: [[4011, 4023], 512],
                4025: [[3984, 4021], 512],
                4038: [, 220]
              },
              4096: {
                4133: [, , { 4142: 4134 }],
                4134: [[4133, 4142]],
                4151: [, 7],
                4153: [, 9],
                4154: [, 9],
                4237: [, 220],
                4348: [[4316], 256],
                69702: [, 9],
                69759: [, 9],
                69785: [, , { 69818: 69786 }],
                69786: [[69785, 69818]],
                69787: [, , { 69818: 69788 }],
                69788: [[69787, 69818]],
                69797: [, , { 69818: 69803 }],
                69803: [[69797, 69818]],
                69817: [, 9],
                69818: [, 7]
              },
              4352: {
                69888: [, 230],
                69889: [, 230],
                69890: [, 230],
                69934: [[69937, 69927]],
                69935: [[69938, 69927]],
                69937: [, , { 69927: 69934 }],
                69938: [, , { 69927: 69935 }],
                69939: [, 9],
                69940: [, 9],
                70003: [, 7],
                70080: [, 9]
              },
              4608: { 70197: [, 9], 70198: [, 7], 70377: [, 7], 70378: [, 9] },
              4864: {
                4957: [, 230],
                4958: [, 230],
                4959: [, 230],
                70460: [, 7],
                70471: [, , { 70462: 70475, 70487: 70476 }],
                70475: [[70471, 70462]],
                70476: [[70471, 70487]],
                70477: [, 9],
                70502: [, 230],
                70503: [, 230],
                70504: [, 230],
                70505: [, 230],
                70506: [, 230],
                70507: [, 230],
                70508: [, 230],
                70512: [, 230],
                70513: [, 230],
                70514: [, 230],
                70515: [, 230],
                70516: [, 230]
              },
              5120: {
                70841: [, , { 70832: 70844, 70842: 70843, 70845: 70846 }],
                70843: [[70841, 70842]],
                70844: [[70841, 70832]],
                70846: [[70841, 70845]],
                70850: [, 9],
                70851: [, 7]
              },
              5376: {
                71096: [, , { 71087: 71098 }],
                71097: [, , { 71087: 71099 }],
                71098: [[71096, 71087]],
                71099: [[71097, 71087]],
                71103: [, 9],
                71104: [, 7]
              },
              5632: { 71231: [, 9], 71350: [, 9], 71351: [, 7] },
              5888: { 5908: [, 9], 5940: [, 9], 6098: [, 9], 6109: [, 230] },
              6144: { 6313: [, 228] },
              6400: { 6457: [, 222], 6458: [, 230], 6459: [, 220] },
              6656: {
                6679: [, 230],
                6680: [, 220],
                6752: [, 9],
                6773: [, 230],
                6774: [, 230],
                6775: [, 230],
                6776: [, 230],
                6777: [, 230],
                6778: [, 230],
                6779: [, 230],
                6780: [, 230],
                6783: [, 220],
                6832: [, 230],
                6833: [, 230],
                6834: [, 230],
                6835: [, 230],
                6836: [, 230],
                6837: [, 220],
                6838: [, 220],
                6839: [, 220],
                6840: [, 220],
                6841: [, 220],
                6842: [, 220],
                6843: [, 230],
                6844: [, 230],
                6845: [, 220]
              },
              6912: {
                6917: [, , { 6965: 6918 }],
                6918: [[6917, 6965]],
                6919: [, , { 6965: 6920 }],
                6920: [[6919, 6965]],
                6921: [, , { 6965: 6922 }],
                6922: [[6921, 6965]],
                6923: [, , { 6965: 6924 }],
                6924: [[6923, 6965]],
                6925: [, , { 6965: 6926 }],
                6926: [[6925, 6965]],
                6929: [, , { 6965: 6930 }],
                6930: [[6929, 6965]],
                6964: [, 7],
                6970: [, , { 6965: 6971 }],
                6971: [[6970, 6965]],
                6972: [, , { 6965: 6973 }],
                6973: [[6972, 6965]],
                6974: [, , { 6965: 6976 }],
                6975: [, , { 6965: 6977 }],
                6976: [[6974, 6965]],
                6977: [[6975, 6965]],
                6978: [, , { 6965: 6979 }],
                6979: [[6978, 6965]],
                6980: [, 9],
                7019: [, 230],
                7020: [, 220],
                7021: [, 230],
                7022: [, 230],
                7023: [, 230],
                7024: [, 230],
                7025: [, 230],
                7026: [, 230],
                7027: [, 230],
                7082: [, 9],
                7083: [, 9],
                7142: [, 7],
                7154: [, 9],
                7155: [, 9]
              },
              7168: {
                7223: [, 7],
                7376: [, 230],
                7377: [, 230],
                7378: [, 230],
                7380: [, 1],
                7381: [, 220],
                7382: [, 220],
                7383: [, 220],
                7384: [, 220],
                7385: [, 220],
                7386: [, 230],
                7387: [, 230],
                7388: [, 220],
                7389: [, 220],
                7390: [, 220],
                7391: [, 220],
                7392: [, 230],
                7394: [, 1],
                7395: [, 1],
                7396: [, 1],
                7397: [, 1],
                7398: [, 1],
                7399: [, 1],
                7400: [, 1],
                7405: [, 220],
                7412: [, 230],
                7416: [, 230],
                7417: [, 230]
              },
              7424: {
                7468: [[65], 256],
                7469: [[198], 256],
                7470: [[66], 256],
                7472: [[68], 256],
                7473: [[69], 256],
                7474: [[398], 256],
                7475: [[71], 256],
                7476: [[72], 256],
                7477: [[73], 256],
                7478: [[74], 256],
                7479: [[75], 256],
                7480: [[76], 256],
                7481: [[77], 256],
                7482: [[78], 256],
                7484: [[79], 256],
                7485: [[546], 256],
                7486: [[80], 256],
                7487: [[82], 256],
                7488: [[84], 256],
                7489: [[85], 256],
                7490: [[87], 256],
                7491: [[97], 256],
                7492: [[592], 256],
                7493: [[593], 256],
                7494: [[7426], 256],
                7495: [[98], 256],
                7496: [[100], 256],
                7497: [[101], 256],
                7498: [[601], 256],
                7499: [[603], 256],
                7500: [[604], 256],
                7501: [[103], 256],
                7503: [[107], 256],
                7504: [[109], 256],
                7505: [[331], 256],
                7506: [[111], 256],
                7507: [[596], 256],
                7508: [[7446], 256],
                7509: [[7447], 256],
                7510: [[112], 256],
                7511: [[116], 256],
                7512: [[117], 256],
                7513: [[7453], 256],
                7514: [[623], 256],
                7515: [[118], 256],
                7516: [[7461], 256],
                7517: [[946], 256],
                7518: [[947], 256],
                7519: [[948], 256],
                7520: [[966], 256],
                7521: [[967], 256],
                7522: [[105], 256],
                7523: [[114], 256],
                7524: [[117], 256],
                7525: [[118], 256],
                7526: [[946], 256],
                7527: [[947], 256],
                7528: [[961], 256],
                7529: [[966], 256],
                7530: [[967], 256],
                7544: [[1085], 256],
                7579: [[594], 256],
                7580: [[99], 256],
                7581: [[597], 256],
                7582: [[240], 256],
                7583: [[604], 256],
                7584: [[102], 256],
                7585: [[607], 256],
                7586: [[609], 256],
                7587: [[613], 256],
                7588: [[616], 256],
                7589: [[617], 256],
                7590: [[618], 256],
                7591: [[7547], 256],
                7592: [[669], 256],
                7593: [[621], 256],
                7594: [[7557], 256],
                7595: [[671], 256],
                7596: [[625], 256],
                7597: [[624], 256],
                7598: [[626], 256],
                7599: [[627], 256],
                7600: [[628], 256],
                7601: [[629], 256],
                7602: [[632], 256],
                7603: [[642], 256],
                7604: [[643], 256],
                7605: [[427], 256],
                7606: [[649], 256],
                7607: [[650], 256],
                7608: [[7452], 256],
                7609: [[651], 256],
                7610: [[652], 256],
                7611: [[122], 256],
                7612: [[656], 256],
                7613: [[657], 256],
                7614: [[658], 256],
                7615: [[952], 256],
                7616: [, 230],
                7617: [, 230],
                7618: [, 220],
                7619: [, 230],
                7620: [, 230],
                7621: [, 230],
                7622: [, 230],
                7623: [, 230],
                7624: [, 230],
                7625: [, 230],
                7626: [, 220],
                7627: [, 230],
                7628: [, 230],
                7629: [, 234],
                7630: [, 214],
                7631: [, 220],
                7632: [, 202],
                7633: [, 230],
                7634: [, 230],
                7635: [, 230],
                7636: [, 230],
                7637: [, 230],
                7638: [, 230],
                7639: [, 230],
                7640: [, 230],
                7641: [, 230],
                7642: [, 230],
                7643: [, 230],
                7644: [, 230],
                7645: [, 230],
                7646: [, 230],
                7647: [, 230],
                7648: [, 230],
                7649: [, 230],
                7650: [, 230],
                7651: [, 230],
                7652: [, 230],
                7653: [, 230],
                7654: [, 230],
                7655: [, 230],
                7656: [, 230],
                7657: [, 230],
                7658: [, 230],
                7659: [, 230],
                7660: [, 230],
                7661: [, 230],
                7662: [, 230],
                7663: [, 230],
                7664: [, 230],
                7665: [, 230],
                7666: [, 230],
                7667: [, 230],
                7668: [, 230],
                7669: [, 230],
                7676: [, 233],
                7677: [, 220],
                7678: [, 230],
                7679: [, 220]
              },
              7680: {
                7680: [[65, 805]],
                7681: [[97, 805]],
                7682: [[66, 775]],
                7683: [[98, 775]],
                7684: [[66, 803]],
                7685: [[98, 803]],
                7686: [[66, 817]],
                7687: [[98, 817]],
                7688: [[199, 769]],
                7689: [[231, 769]],
                7690: [[68, 775]],
                7691: [[100, 775]],
                7692: [[68, 803]],
                7693: [[100, 803]],
                7694: [[68, 817]],
                7695: [[100, 817]],
                7696: [[68, 807]],
                7697: [[100, 807]],
                7698: [[68, 813]],
                7699: [[100, 813]],
                7700: [[274, 768]],
                7701: [[275, 768]],
                7702: [[274, 769]],
                7703: [[275, 769]],
                7704: [[69, 813]],
                7705: [[101, 813]],
                7706: [[69, 816]],
                7707: [[101, 816]],
                7708: [[552, 774]],
                7709: [[553, 774]],
                7710: [[70, 775]],
                7711: [[102, 775]],
                7712: [[71, 772]],
                7713: [[103, 772]],
                7714: [[72, 775]],
                7715: [[104, 775]],
                7716: [[72, 803]],
                7717: [[104, 803]],
                7718: [[72, 776]],
                7719: [[104, 776]],
                7720: [[72, 807]],
                7721: [[104, 807]],
                7722: [[72, 814]],
                7723: [[104, 814]],
                7724: [[73, 816]],
                7725: [[105, 816]],
                7726: [[207, 769]],
                7727: [[239, 769]],
                7728: [[75, 769]],
                7729: [[107, 769]],
                7730: [[75, 803]],
                7731: [[107, 803]],
                7732: [[75, 817]],
                7733: [[107, 817]],
                7734: [[76, 803], , { 772: 7736 }],
                7735: [[108, 803], , { 772: 7737 }],
                7736: [[7734, 772]],
                7737: [[7735, 772]],
                7738: [[76, 817]],
                7739: [[108, 817]],
                7740: [[76, 813]],
                7741: [[108, 813]],
                7742: [[77, 769]],
                7743: [[109, 769]],
                7744: [[77, 775]],
                7745: [[109, 775]],
                7746: [[77, 803]],
                7747: [[109, 803]],
                7748: [[78, 775]],
                7749: [[110, 775]],
                7750: [[78, 803]],
                7751: [[110, 803]],
                7752: [[78, 817]],
                7753: [[110, 817]],
                7754: [[78, 813]],
                7755: [[110, 813]],
                7756: [[213, 769]],
                7757: [[245, 769]],
                7758: [[213, 776]],
                7759: [[245, 776]],
                7760: [[332, 768]],
                7761: [[333, 768]],
                7762: [[332, 769]],
                7763: [[333, 769]],
                7764: [[80, 769]],
                7765: [[112, 769]],
                7766: [[80, 775]],
                7767: [[112, 775]],
                7768: [[82, 775]],
                7769: [[114, 775]],
                7770: [[82, 803], , { 772: 7772 }],
                7771: [[114, 803], , { 772: 7773 }],
                7772: [[7770, 772]],
                7773: [[7771, 772]],
                7774: [[82, 817]],
                7775: [[114, 817]],
                7776: [[83, 775]],
                7777: [[115, 775]],
                7778: [[83, 803], , { 775: 7784 }],
                7779: [[115, 803], , { 775: 7785 }],
                7780: [[346, 775]],
                7781: [[347, 775]],
                7782: [[352, 775]],
                7783: [[353, 775]],
                7784: [[7778, 775]],
                7785: [[7779, 775]],
                7786: [[84, 775]],
                7787: [[116, 775]],
                7788: [[84, 803]],
                7789: [[116, 803]],
                7790: [[84, 817]],
                7791: [[116, 817]],
                7792: [[84, 813]],
                7793: [[116, 813]],
                7794: [[85, 804]],
                7795: [[117, 804]],
                7796: [[85, 816]],
                7797: [[117, 816]],
                7798: [[85, 813]],
                7799: [[117, 813]],
                7800: [[360, 769]],
                7801: [[361, 769]],
                7802: [[362, 776]],
                7803: [[363, 776]],
                7804: [[86, 771]],
                7805: [[118, 771]],
                7806: [[86, 803]],
                7807: [[118, 803]],
                7808: [[87, 768]],
                7809: [[119, 768]],
                7810: [[87, 769]],
                7811: [[119, 769]],
                7812: [[87, 776]],
                7813: [[119, 776]],
                7814: [[87, 775]],
                7815: [[119, 775]],
                7816: [[87, 803]],
                7817: [[119, 803]],
                7818: [[88, 775]],
                7819: [[120, 775]],
                7820: [[88, 776]],
                7821: [[120, 776]],
                7822: [[89, 775]],
                7823: [[121, 775]],
                7824: [[90, 770]],
                7825: [[122, 770]],
                7826: [[90, 803]],
                7827: [[122, 803]],
                7828: [[90, 817]],
                7829: [[122, 817]],
                7830: [[104, 817]],
                7831: [[116, 776]],
                7832: [[119, 778]],
                7833: [[121, 778]],
                7834: [[97, 702], 256],
                7835: [[383, 775]],
                7840: [[65, 803], , { 770: 7852, 774: 7862 }],
                7841: [[97, 803], , { 770: 7853, 774: 7863 }],
                7842: [[65, 777]],
                7843: [[97, 777]],
                7844: [[194, 769]],
                7845: [[226, 769]],
                7846: [[194, 768]],
                7847: [[226, 768]],
                7848: [[194, 777]],
                7849: [[226, 777]],
                7850: [[194, 771]],
                7851: [[226, 771]],
                7852: [[7840, 770]],
                7853: [[7841, 770]],
                7854: [[258, 769]],
                7855: [[259, 769]],
                7856: [[258, 768]],
                7857: [[259, 768]],
                7858: [[258, 777]],
                7859: [[259, 777]],
                7860: [[258, 771]],
                7861: [[259, 771]],
                7862: [[7840, 774]],
                7863: [[7841, 774]],
                7864: [[69, 803], , { 770: 7878 }],
                7865: [[101, 803], , { 770: 7879 }],
                7866: [[69, 777]],
                7867: [[101, 777]],
                7868: [[69, 771]],
                7869: [[101, 771]],
                7870: [[202, 769]],
                7871: [[234, 769]],
                7872: [[202, 768]],
                7873: [[234, 768]],
                7874: [[202, 777]],
                7875: [[234, 777]],
                7876: [[202, 771]],
                7877: [[234, 771]],
                7878: [[7864, 770]],
                7879: [[7865, 770]],
                7880: [[73, 777]],
                7881: [[105, 777]],
                7882: [[73, 803]],
                7883: [[105, 803]],
                7884: [[79, 803], , { 770: 7896 }],
                7885: [[111, 803], , { 770: 7897 }],
                7886: [[79, 777]],
                7887: [[111, 777]],
                7888: [[212, 769]],
                7889: [[244, 769]],
                7890: [[212, 768]],
                7891: [[244, 768]],
                7892: [[212, 777]],
                7893: [[244, 777]],
                7894: [[212, 771]],
                7895: [[244, 771]],
                7896: [[7884, 770]],
                7897: [[7885, 770]],
                7898: [[416, 769]],
                7899: [[417, 769]],
                7900: [[416, 768]],
                7901: [[417, 768]],
                7902: [[416, 777]],
                7903: [[417, 777]],
                7904: [[416, 771]],
                7905: [[417, 771]],
                7906: [[416, 803]],
                7907: [[417, 803]],
                7908: [[85, 803]],
                7909: [[117, 803]],
                7910: [[85, 777]],
                7911: [[117, 777]],
                7912: [[431, 769]],
                7913: [[432, 769]],
                7914: [[431, 768]],
                7915: [[432, 768]],
                7916: [[431, 777]],
                7917: [[432, 777]],
                7918: [[431, 771]],
                7919: [[432, 771]],
                7920: [[431, 803]],
                7921: [[432, 803]],
                7922: [[89, 768]],
                7923: [[121, 768]],
                7924: [[89, 803]],
                7925: [[121, 803]],
                7926: [[89, 777]],
                7927: [[121, 777]],
                7928: [[89, 771]],
                7929: [[121, 771]]
              },
              7936: {
                7936: [
                  [945, 787],
                  ,
                  { 768: 7938, 769: 7940, 834: 7942, 837: 8064 }
                ],
                7937: [
                  [945, 788],
                  ,
                  { 768: 7939, 769: 7941, 834: 7943, 837: 8065 }
                ],
                7938: [[7936, 768], , { 837: 8066 }],
                7939: [[7937, 768], , { 837: 8067 }],
                7940: [[7936, 769], , { 837: 8068 }],
                7941: [[7937, 769], , { 837: 8069 }],
                7942: [[7936, 834], , { 837: 8070 }],
                7943: [[7937, 834], , { 837: 8071 }],
                7944: [
                  [913, 787],
                  ,
                  { 768: 7946, 769: 7948, 834: 7950, 837: 8072 }
                ],
                7945: [
                  [913, 788],
                  ,
                  { 768: 7947, 769: 7949, 834: 7951, 837: 8073 }
                ],
                7946: [[7944, 768], , { 837: 8074 }],
                7947: [[7945, 768], , { 837: 8075 }],
                7948: [[7944, 769], , { 837: 8076 }],
                7949: [[7945, 769], , { 837: 8077 }],
                7950: [[7944, 834], , { 837: 8078 }],
                7951: [[7945, 834], , { 837: 8079 }],
                7952: [[949, 787], , { 768: 7954, 769: 7956 }],
                7953: [[949, 788], , { 768: 7955, 769: 7957 }],
                7954: [[7952, 768]],
                7955: [[7953, 768]],
                7956: [[7952, 769]],
                7957: [[7953, 769]],
                7960: [[917, 787], , { 768: 7962, 769: 7964 }],
                7961: [[917, 788], , { 768: 7963, 769: 7965 }],
                7962: [[7960, 768]],
                7963: [[7961, 768]],
                7964: [[7960, 769]],
                7965: [[7961, 769]],
                7968: [
                  [951, 787],
                  ,
                  { 768: 7970, 769: 7972, 834: 7974, 837: 8080 }
                ],
                7969: [
                  [951, 788],
                  ,
                  { 768: 7971, 769: 7973, 834: 7975, 837: 8081 }
                ],
                7970: [[7968, 768], , { 837: 8082 }],
                7971: [[7969, 768], , { 837: 8083 }],
                7972: [[7968, 769], , { 837: 8084 }],
                7973: [[7969, 769], , { 837: 8085 }],
                7974: [[7968, 834], , { 837: 8086 }],
                7975: [[7969, 834], , { 837: 8087 }],
                7976: [
                  [919, 787],
                  ,
                  { 768: 7978, 769: 7980, 834: 7982, 837: 8088 }
                ],
                7977: [
                  [919, 788],
                  ,
                  { 768: 7979, 769: 7981, 834: 7983, 837: 8089 }
                ],
                7978: [[7976, 768], , { 837: 8090 }],
                7979: [[7977, 768], , { 837: 8091 }],
                7980: [[7976, 769], , { 837: 8092 }],
                7981: [[7977, 769], , { 837: 8093 }],
                7982: [[7976, 834], , { 837: 8094 }],
                7983: [[7977, 834], , { 837: 8095 }],
                7984: [[953, 787], , { 768: 7986, 769: 7988, 834: 7990 }],
                7985: [[953, 788], , { 768: 7987, 769: 7989, 834: 7991 }],
                7986: [[7984, 768]],
                7987: [[7985, 768]],
                7988: [[7984, 769]],
                7989: [[7985, 769]],
                7990: [[7984, 834]],
                7991: [[7985, 834]],
                7992: [[921, 787], , { 768: 7994, 769: 7996, 834: 7998 }],
                7993: [[921, 788], , { 768: 7995, 769: 7997, 834: 7999 }],
                7994: [[7992, 768]],
                7995: [[7993, 768]],
                7996: [[7992, 769]],
                7997: [[7993, 769]],
                7998: [[7992, 834]],
                7999: [[7993, 834]],
                8000: [[959, 787], , { 768: 8002, 769: 8004 }],
                8001: [[959, 788], , { 768: 8003, 769: 8005 }],
                8002: [[8e3, 768]],
                8003: [[8001, 768]],
                8004: [[8e3, 769]],
                8005: [[8001, 769]],
                8008: [[927, 787], , { 768: 8010, 769: 8012 }],
                8009: [[927, 788], , { 768: 8011, 769: 8013 }],
                8010: [[8008, 768]],
                8011: [[8009, 768]],
                8012: [[8008, 769]],
                8013: [[8009, 769]],
                8016: [[965, 787], , { 768: 8018, 769: 8020, 834: 8022 }],
                8017: [[965, 788], , { 768: 8019, 769: 8021, 834: 8023 }],
                8018: [[8016, 768]],
                8019: [[8017, 768]],
                8020: [[8016, 769]],
                8021: [[8017, 769]],
                8022: [[8016, 834]],
                8023: [[8017, 834]],
                8025: [[933, 788], , { 768: 8027, 769: 8029, 834: 8031 }],
                8027: [[8025, 768]],
                8029: [[8025, 769]],
                8031: [[8025, 834]],
                8032: [
                  [969, 787],
                  ,
                  { 768: 8034, 769: 8036, 834: 8038, 837: 8096 }
                ],
                8033: [
                  [969, 788],
                  ,
                  { 768: 8035, 769: 8037, 834: 8039, 837: 8097 }
                ],
                8034: [[8032, 768], , { 837: 8098 }],
                8035: [[8033, 768], , { 837: 8099 }],
                8036: [[8032, 769], , { 837: 8100 }],
                8037: [[8033, 769], , { 837: 8101 }],
                8038: [[8032, 834], , { 837: 8102 }],
                8039: [[8033, 834], , { 837: 8103 }],
                8040: [
                  [937, 787],
                  ,
                  { 768: 8042, 769: 8044, 834: 8046, 837: 8104 }
                ],
                8041: [
                  [937, 788],
                  ,
                  { 768: 8043, 769: 8045, 834: 8047, 837: 8105 }
                ],
                8042: [[8040, 768], , { 837: 8106 }],
                8043: [[8041, 768], , { 837: 8107 }],
                8044: [[8040, 769], , { 837: 8108 }],
                8045: [[8041, 769], , { 837: 8109 }],
                8046: [[8040, 834], , { 837: 8110 }],
                8047: [[8041, 834], , { 837: 8111 }],
                8048: [[945, 768], , { 837: 8114 }],
                8049: [[940]],
                8050: [[949, 768]],
                8051: [[941]],
                8052: [[951, 768], , { 837: 8130 }],
                8053: [[942]],
                8054: [[953, 768]],
                8055: [[943]],
                8056: [[959, 768]],
                8057: [[972]],
                8058: [[965, 768]],
                8059: [[973]],
                8060: [[969, 768], , { 837: 8178 }],
                8061: [[974]],
                8064: [[7936, 837]],
                8065: [[7937, 837]],
                8066: [[7938, 837]],
                8067: [[7939, 837]],
                8068: [[7940, 837]],
                8069: [[7941, 837]],
                8070: [[7942, 837]],
                8071: [[7943, 837]],
                8072: [[7944, 837]],
                8073: [[7945, 837]],
                8074: [[7946, 837]],
                8075: [[7947, 837]],
                8076: [[7948, 837]],
                8077: [[7949, 837]],
                8078: [[7950, 837]],
                8079: [[7951, 837]],
                8080: [[7968, 837]],
                8081: [[7969, 837]],
                8082: [[7970, 837]],
                8083: [[7971, 837]],
                8084: [[7972, 837]],
                8085: [[7973, 837]],
                8086: [[7974, 837]],
                8087: [[7975, 837]],
                8088: [[7976, 837]],
                8089: [[7977, 837]],
                8090: [[7978, 837]],
                8091: [[7979, 837]],
                8092: [[7980, 837]],
                8093: [[7981, 837]],
                8094: [[7982, 837]],
                8095: [[7983, 837]],
                8096: [[8032, 837]],
                8097: [[8033, 837]],
                8098: [[8034, 837]],
                8099: [[8035, 837]],
                8100: [[8036, 837]],
                8101: [[8037, 837]],
                8102: [[8038, 837]],
                8103: [[8039, 837]],
                8104: [[8040, 837]],
                8105: [[8041, 837]],
                8106: [[8042, 837]],
                8107: [[8043, 837]],
                8108: [[8044, 837]],
                8109: [[8045, 837]],
                8110: [[8046, 837]],
                8111: [[8047, 837]],
                8112: [[945, 774]],
                8113: [[945, 772]],
                8114: [[8048, 837]],
                8115: [[945, 837]],
                8116: [[940, 837]],
                8118: [[945, 834], , { 837: 8119 }],
                8119: [[8118, 837]],
                8120: [[913, 774]],
                8121: [[913, 772]],
                8122: [[913, 768]],
                8123: [[902]],
                8124: [[913, 837]],
                8125: [[32, 787], 256],
                8126: [[953]],
                8127: [[32, 787], 256, { 768: 8141, 769: 8142, 834: 8143 }],
                8128: [[32, 834], 256],
                8129: [[168, 834]],
                8130: [[8052, 837]],
                8131: [[951, 837]],
                8132: [[942, 837]],
                8134: [[951, 834], , { 837: 8135 }],
                8135: [[8134, 837]],
                8136: [[917, 768]],
                8137: [[904]],
                8138: [[919, 768]],
                8139: [[905]],
                8140: [[919, 837]],
                8141: [[8127, 768]],
                8142: [[8127, 769]],
                8143: [[8127, 834]],
                8144: [[953, 774]],
                8145: [[953, 772]],
                8146: [[970, 768]],
                8147: [[912]],
                8150: [[953, 834]],
                8151: [[970, 834]],
                8152: [[921, 774]],
                8153: [[921, 772]],
                8154: [[921, 768]],
                8155: [[906]],
                8157: [[8190, 768]],
                8158: [[8190, 769]],
                8159: [[8190, 834]],
                8160: [[965, 774]],
                8161: [[965, 772]],
                8162: [[971, 768]],
                8163: [[944]],
                8164: [[961, 787]],
                8165: [[961, 788]],
                8166: [[965, 834]],
                8167: [[971, 834]],
                8168: [[933, 774]],
                8169: [[933, 772]],
                8170: [[933, 768]],
                8171: [[910]],
                8172: [[929, 788]],
                8173: [[168, 768]],
                8174: [[901]],
                8175: [[96]],
                8178: [[8060, 837]],
                8179: [[969, 837]],
                8180: [[974, 837]],
                8182: [[969, 834], , { 837: 8183 }],
                8183: [[8182, 837]],
                8184: [[927, 768]],
                8185: [[908]],
                8186: [[937, 768]],
                8187: [[911]],
                8188: [[937, 837]],
                8189: [[180]],
                8190: [[32, 788], 256, { 768: 8157, 769: 8158, 834: 8159 }]
              },
              8192: {
                8192: [[8194]],
                8193: [[8195]],
                8194: [[32], 256],
                8195: [[32], 256],
                8196: [[32], 256],
                8197: [[32], 256],
                8198: [[32], 256],
                8199: [[32], 256],
                8200: [[32], 256],
                8201: [[32], 256],
                8202: [[32], 256],
                8209: [[8208], 256],
                8215: [[32, 819], 256],
                8228: [[46], 256],
                8229: [[46, 46], 256],
                8230: [[46, 46, 46], 256],
                8239: [[32], 256],
                8243: [[8242, 8242], 256],
                8244: [[8242, 8242, 8242], 256],
                8246: [[8245, 8245], 256],
                8247: [[8245, 8245, 8245], 256],
                8252: [[33, 33], 256],
                8254: [[32, 773], 256],
                8263: [[63, 63], 256],
                8264: [[63, 33], 256],
                8265: [[33, 63], 256],
                8279: [[8242, 8242, 8242, 8242], 256],
                8287: [[32], 256],
                8304: [[48], 256],
                8305: [[105], 256],
                8308: [[52], 256],
                8309: [[53], 256],
                8310: [[54], 256],
                8311: [[55], 256],
                8312: [[56], 256],
                8313: [[57], 256],
                8314: [[43], 256],
                8315: [[8722], 256],
                8316: [[61], 256],
                8317: [[40], 256],
                8318: [[41], 256],
                8319: [[110], 256],
                8320: [[48], 256],
                8321: [[49], 256],
                8322: [[50], 256],
                8323: [[51], 256],
                8324: [[52], 256],
                8325: [[53], 256],
                8326: [[54], 256],
                8327: [[55], 256],
                8328: [[56], 256],
                8329: [[57], 256],
                8330: [[43], 256],
                8331: [[8722], 256],
                8332: [[61], 256],
                8333: [[40], 256],
                8334: [[41], 256],
                8336: [[97], 256],
                8337: [[101], 256],
                8338: [[111], 256],
                8339: [[120], 256],
                8340: [[601], 256],
                8341: [[104], 256],
                8342: [[107], 256],
                8343: [[108], 256],
                8344: [[109], 256],
                8345: [[110], 256],
                8346: [[112], 256],
                8347: [[115], 256],
                8348: [[116], 256],
                8360: [[82, 115], 256],
                8400: [, 230],
                8401: [, 230],
                8402: [, 1],
                8403: [, 1],
                8404: [, 230],
                8405: [, 230],
                8406: [, 230],
                8407: [, 230],
                8408: [, 1],
                8409: [, 1],
                8410: [, 1],
                8411: [, 230],
                8412: [, 230],
                8417: [, 230],
                8421: [, 1],
                8422: [, 1],
                8423: [, 230],
                8424: [, 220],
                8425: [, 230],
                8426: [, 1],
                8427: [, 1],
                8428: [, 220],
                8429: [, 220],
                8430: [, 220],
                8431: [, 220],
                8432: [, 230]
              },
              8448: {
                8448: [[97, 47, 99], 256],
                8449: [[97, 47, 115], 256],
                8450: [[67], 256],
                8451: [[176, 67], 256],
                8453: [[99, 47, 111], 256],
                8454: [[99, 47, 117], 256],
                8455: [[400], 256],
                8457: [[176, 70], 256],
                8458: [[103], 256],
                8459: [[72], 256],
                8460: [[72], 256],
                8461: [[72], 256],
                8462: [[104], 256],
                8463: [[295], 256],
                8464: [[73], 256],
                8465: [[73], 256],
                8466: [[76], 256],
                8467: [[108], 256],
                8469: [[78], 256],
                8470: [[78, 111], 256],
                8473: [[80], 256],
                8474: [[81], 256],
                8475: [[82], 256],
                8476: [[82], 256],
                8477: [[82], 256],
                8480: [[83, 77], 256],
                8481: [[84, 69, 76], 256],
                8482: [[84, 77], 256],
                8484: [[90], 256],
                8486: [[937]],
                8488: [[90], 256],
                8490: [[75]],
                8491: [[197]],
                8492: [[66], 256],
                8493: [[67], 256],
                8495: [[101], 256],
                8496: [[69], 256],
                8497: [[70], 256],
                8499: [[77], 256],
                8500: [[111], 256],
                8501: [[1488], 256],
                8502: [[1489], 256],
                8503: [[1490], 256],
                8504: [[1491], 256],
                8505: [[105], 256],
                8507: [[70, 65, 88], 256],
                8508: [[960], 256],
                8509: [[947], 256],
                8510: [[915], 256],
                8511: [[928], 256],
                8512: [[8721], 256],
                8517: [[68], 256],
                8518: [[100], 256],
                8519: [[101], 256],
                8520: [[105], 256],
                8521: [[106], 256],
                8528: [[49, 8260, 55], 256],
                8529: [[49, 8260, 57], 256],
                8530: [[49, 8260, 49, 48], 256],
                8531: [[49, 8260, 51], 256],
                8532: [[50, 8260, 51], 256],
                8533: [[49, 8260, 53], 256],
                8534: [[50, 8260, 53], 256],
                8535: [[51, 8260, 53], 256],
                8536: [[52, 8260, 53], 256],
                8537: [[49, 8260, 54], 256],
                8538: [[53, 8260, 54], 256],
                8539: [[49, 8260, 56], 256],
                8540: [[51, 8260, 56], 256],
                8541: [[53, 8260, 56], 256],
                8542: [[55, 8260, 56], 256],
                8543: [[49, 8260], 256],
                8544: [[73], 256],
                8545: [[73, 73], 256],
                8546: [[73, 73, 73], 256],
                8547: [[73, 86], 256],
                8548: [[86], 256],
                8549: [[86, 73], 256],
                8550: [[86, 73, 73], 256],
                8551: [[86, 73, 73, 73], 256],
                8552: [[73, 88], 256],
                8553: [[88], 256],
                8554: [[88, 73], 256],
                8555: [[88, 73, 73], 256],
                8556: [[76], 256],
                8557: [[67], 256],
                8558: [[68], 256],
                8559: [[77], 256],
                8560: [[105], 256],
                8561: [[105, 105], 256],
                8562: [[105, 105, 105], 256],
                8563: [[105, 118], 256],
                8564: [[118], 256],
                8565: [[118, 105], 256],
                8566: [[118, 105, 105], 256],
                8567: [[118, 105, 105, 105], 256],
                8568: [[105, 120], 256],
                8569: [[120], 256],
                8570: [[120, 105], 256],
                8571: [[120, 105, 105], 256],
                8572: [[108], 256],
                8573: [[99], 256],
                8574: [[100], 256],
                8575: [[109], 256],
                8585: [[48, 8260, 51], 256],
                8592: [, , { 824: 8602 }],
                8594: [, , { 824: 8603 }],
                8596: [, , { 824: 8622 }],
                8602: [[8592, 824]],
                8603: [[8594, 824]],
                8622: [[8596, 824]],
                8653: [[8656, 824]],
                8654: [[8660, 824]],
                8655: [[8658, 824]],
                8656: [, , { 824: 8653 }],
                8658: [, , { 824: 8655 }],
                8660: [, , { 824: 8654 }]
              },
              8704: {
                8707: [, , { 824: 8708 }],
                8708: [[8707, 824]],
                8712: [, , { 824: 8713 }],
                8713: [[8712, 824]],
                8715: [, , { 824: 8716 }],
                8716: [[8715, 824]],
                8739: [, , { 824: 8740 }],
                8740: [[8739, 824]],
                8741: [, , { 824: 8742 }],
                8742: [[8741, 824]],
                8748: [[8747, 8747], 256],
                8749: [[8747, 8747, 8747], 256],
                8751: [[8750, 8750], 256],
                8752: [[8750, 8750, 8750], 256],
                8764: [, , { 824: 8769 }],
                8769: [[8764, 824]],
                8771: [, , { 824: 8772 }],
                8772: [[8771, 824]],
                8773: [, , { 824: 8775 }],
                8775: [[8773, 824]],
                8776: [, , { 824: 8777 }],
                8777: [[8776, 824]],
                8781: [, , { 824: 8813 }],
                8800: [[61, 824]],
                8801: [, , { 824: 8802 }],
                8802: [[8801, 824]],
                8804: [, , { 824: 8816 }],
                8805: [, , { 824: 8817 }],
                8813: [[8781, 824]],
                8814: [[60, 824]],
                8815: [[62, 824]],
                8816: [[8804, 824]],
                8817: [[8805, 824]],
                8818: [, , { 824: 8820 }],
                8819: [, , { 824: 8821 }],
                8820: [[8818, 824]],
                8821: [[8819, 824]],
                8822: [, , { 824: 8824 }],
                8823: [, , { 824: 8825 }],
                8824: [[8822, 824]],
                8825: [[8823, 824]],
                8826: [, , { 824: 8832 }],
                8827: [, , { 824: 8833 }],
                8828: [, , { 824: 8928 }],
                8829: [, , { 824: 8929 }],
                8832: [[8826, 824]],
                8833: [[8827, 824]],
                8834: [, , { 824: 8836 }],
                8835: [, , { 824: 8837 }],
                8836: [[8834, 824]],
                8837: [[8835, 824]],
                8838: [, , { 824: 8840 }],
                8839: [, , { 824: 8841 }],
                8840: [[8838, 824]],
                8841: [[8839, 824]],
                8849: [, , { 824: 8930 }],
                8850: [, , { 824: 8931 }],
                8866: [, , { 824: 8876 }],
                8872: [, , { 824: 8877 }],
                8873: [, , { 824: 8878 }],
                8875: [, , { 824: 8879 }],
                8876: [[8866, 824]],
                8877: [[8872, 824]],
                8878: [[8873, 824]],
                8879: [[8875, 824]],
                8882: [, , { 824: 8938 }],
                8883: [, , { 824: 8939 }],
                8884: [, , { 824: 8940 }],
                8885: [, , { 824: 8941 }],
                8928: [[8828, 824]],
                8929: [[8829, 824]],
                8930: [[8849, 824]],
                8931: [[8850, 824]],
                8938: [[8882, 824]],
                8939: [[8883, 824]],
                8940: [[8884, 824]],
                8941: [[8885, 824]]
              },
              8960: { 9001: [[12296]], 9002: [[12297]] },
              9216: {
                9312: [[49], 256],
                9313: [[50], 256],
                9314: [[51], 256],
                9315: [[52], 256],
                9316: [[53], 256],
                9317: [[54], 256],
                9318: [[55], 256],
                9319: [[56], 256],
                9320: [[57], 256],
                9321: [[49, 48], 256],
                9322: [[49, 49], 256],
                9323: [[49, 50], 256],
                9324: [[49, 51], 256],
                9325: [[49, 52], 256],
                9326: [[49, 53], 256],
                9327: [[49, 54], 256],
                9328: [[49, 55], 256],
                9329: [[49, 56], 256],
                9330: [[49, 57], 256],
                9331: [[50, 48], 256],
                9332: [[40, 49, 41], 256],
                9333: [[40, 50, 41], 256],
                9334: [[40, 51, 41], 256],
                9335: [[40, 52, 41], 256],
                9336: [[40, 53, 41], 256],
                9337: [[40, 54, 41], 256],
                9338: [[40, 55, 41], 256],
                9339: [[40, 56, 41], 256],
                9340: [[40, 57, 41], 256],
                9341: [[40, 49, 48, 41], 256],
                9342: [[40, 49, 49, 41], 256],
                9343: [[40, 49, 50, 41], 256],
                9344: [[40, 49, 51, 41], 256],
                9345: [[40, 49, 52, 41], 256],
                9346: [[40, 49, 53, 41], 256],
                9347: [[40, 49, 54, 41], 256],
                9348: [[40, 49, 55, 41], 256],
                9349: [[40, 49, 56, 41], 256],
                9350: [[40, 49, 57, 41], 256],
                9351: [[40, 50, 48, 41], 256],
                9352: [[49, 46], 256],
                9353: [[50, 46], 256],
                9354: [[51, 46], 256],
                9355: [[52, 46], 256],
                9356: [[53, 46], 256],
                9357: [[54, 46], 256],
                9358: [[55, 46], 256],
                9359: [[56, 46], 256],
                9360: [[57, 46], 256],
                9361: [[49, 48, 46], 256],
                9362: [[49, 49, 46], 256],
                9363: [[49, 50, 46], 256],
                9364: [[49, 51, 46], 256],
                9365: [[49, 52, 46], 256],
                9366: [[49, 53, 46], 256],
                9367: [[49, 54, 46], 256],
                9368: [[49, 55, 46], 256],
                9369: [[49, 56, 46], 256],
                9370: [[49, 57, 46], 256],
                9371: [[50, 48, 46], 256],
                9372: [[40, 97, 41], 256],
                9373: [[40, 98, 41], 256],
                9374: [[40, 99, 41], 256],
                9375: [[40, 100, 41], 256],
                9376: [[40, 101, 41], 256],
                9377: [[40, 102, 41], 256],
                9378: [[40, 103, 41], 256],
                9379: [[40, 104, 41], 256],
                9380: [[40, 105, 41], 256],
                9381: [[40, 106, 41], 256],
                9382: [[40, 107, 41], 256],
                9383: [[40, 108, 41], 256],
                9384: [[40, 109, 41], 256],
                9385: [[40, 110, 41], 256],
                9386: [[40, 111, 41], 256],
                9387: [[40, 112, 41], 256],
                9388: [[40, 113, 41], 256],
                9389: [[40, 114, 41], 256],
                9390: [[40, 115, 41], 256],
                9391: [[40, 116, 41], 256],
                9392: [[40, 117, 41], 256],
                9393: [[40, 118, 41], 256],
                9394: [[40, 119, 41], 256],
                9395: [[40, 120, 41], 256],
                9396: [[40, 121, 41], 256],
                9397: [[40, 122, 41], 256],
                9398: [[65], 256],
                9399: [[66], 256],
                9400: [[67], 256],
                9401: [[68], 256],
                9402: [[69], 256],
                9403: [[70], 256],
                9404: [[71], 256],
                9405: [[72], 256],
                9406: [[73], 256],
                9407: [[74], 256],
                9408: [[75], 256],
                9409: [[76], 256],
                9410: [[77], 256],
                9411: [[78], 256],
                9412: [[79], 256],
                9413: [[80], 256],
                9414: [[81], 256],
                9415: [[82], 256],
                9416: [[83], 256],
                9417: [[84], 256],
                9418: [[85], 256],
                9419: [[86], 256],
                9420: [[87], 256],
                9421: [[88], 256],
                9422: [[89], 256],
                9423: [[90], 256],
                9424: [[97], 256],
                9425: [[98], 256],
                9426: [[99], 256],
                9427: [[100], 256],
                9428: [[101], 256],
                9429: [[102], 256],
                9430: [[103], 256],
                9431: [[104], 256],
                9432: [[105], 256],
                9433: [[106], 256],
                9434: [[107], 256],
                9435: [[108], 256],
                9436: [[109], 256],
                9437: [[110], 256],
                9438: [[111], 256],
                9439: [[112], 256],
                9440: [[113], 256],
                9441: [[114], 256],
                9442: [[115], 256],
                9443: [[116], 256],
                9444: [[117], 256],
                9445: [[118], 256],
                9446: [[119], 256],
                9447: [[120], 256],
                9448: [[121], 256],
                9449: [[122], 256],
                9450: [[48], 256]
              },
              10752: {
                10764: [[8747, 8747, 8747, 8747], 256],
                10868: [[58, 58, 61], 256],
                10869: [[61, 61], 256],
                10870: [[61, 61, 61], 256],
                10972: [[10973, 824], 512]
              },
              11264: {
                11388: [[106], 256],
                11389: [[86], 256],
                11503: [, 230],
                11504: [, 230],
                11505: [, 230]
              },
              11520: {
                11631: [[11617], 256],
                11647: [, 9],
                11744: [, 230],
                11745: [, 230],
                11746: [, 230],
                11747: [, 230],
                11748: [, 230],
                11749: [, 230],
                11750: [, 230],
                11751: [, 230],
                11752: [, 230],
                11753: [, 230],
                11754: [, 230],
                11755: [, 230],
                11756: [, 230],
                11757: [, 230],
                11758: [, 230],
                11759: [, 230],
                11760: [, 230],
                11761: [, 230],
                11762: [, 230],
                11763: [, 230],
                11764: [, 230],
                11765: [, 230],
                11766: [, 230],
                11767: [, 230],
                11768: [, 230],
                11769: [, 230],
                11770: [, 230],
                11771: [, 230],
                11772: [, 230],
                11773: [, 230],
                11774: [, 230],
                11775: [, 230]
              },
              11776: { 11935: [[27597], 256], 12019: [[40863], 256] },
              12032: {
                12032: [[19968], 256],
                12033: [[20008], 256],
                12034: [[20022], 256],
                12035: [[20031], 256],
                12036: [[20057], 256],
                12037: [[20101], 256],
                12038: [[20108], 256],
                12039: [[20128], 256],
                12040: [[20154], 256],
                12041: [[20799], 256],
                12042: [[20837], 256],
                12043: [[20843], 256],
                12044: [[20866], 256],
                12045: [[20886], 256],
                12046: [[20907], 256],
                12047: [[20960], 256],
                12048: [[20981], 256],
                12049: [[20992], 256],
                12050: [[21147], 256],
                12051: [[21241], 256],
                12052: [[21269], 256],
                12053: [[21274], 256],
                12054: [[21304], 256],
                12055: [[21313], 256],
                12056: [[21340], 256],
                12057: [[21353], 256],
                12058: [[21378], 256],
                12059: [[21430], 256],
                12060: [[21448], 256],
                12061: [[21475], 256],
                12062: [[22231], 256],
                12063: [[22303], 256],
                12064: [[22763], 256],
                12065: [[22786], 256],
                12066: [[22794], 256],
                12067: [[22805], 256],
                12068: [[22823], 256],
                12069: [[22899], 256],
                12070: [[23376], 256],
                12071: [[23424], 256],
                12072: [[23544], 256],
                12073: [[23567], 256],
                12074: [[23586], 256],
                12075: [[23608], 256],
                12076: [[23662], 256],
                12077: [[23665], 256],
                12078: [[24027], 256],
                12079: [[24037], 256],
                12080: [[24049], 256],
                12081: [[24062], 256],
                12082: [[24178], 256],
                12083: [[24186], 256],
                12084: [[24191], 256],
                12085: [[24308], 256],
                12086: [[24318], 256],
                12087: [[24331], 256],
                12088: [[24339], 256],
                12089: [[24400], 256],
                12090: [[24417], 256],
                12091: [[24435], 256],
                12092: [[24515], 256],
                12093: [[25096], 256],
                12094: [[25142], 256],
                12095: [[25163], 256],
                12096: [[25903], 256],
                12097: [[25908], 256],
                12098: [[25991], 256],
                12099: [[26007], 256],
                12100: [[26020], 256],
                12101: [[26041], 256],
                12102: [[26080], 256],
                12103: [[26085], 256],
                12104: [[26352], 256],
                12105: [[26376], 256],
                12106: [[26408], 256],
                12107: [[27424], 256],
                12108: [[27490], 256],
                12109: [[27513], 256],
                12110: [[27571], 256],
                12111: [[27595], 256],
                12112: [[27604], 256],
                12113: [[27611], 256],
                12114: [[27663], 256],
                12115: [[27668], 256],
                12116: [[27700], 256],
                12117: [[28779], 256],
                12118: [[29226], 256],
                12119: [[29238], 256],
                12120: [[29243], 256],
                12121: [[29247], 256],
                12122: [[29255], 256],
                12123: [[29273], 256],
                12124: [[29275], 256],
                12125: [[29356], 256],
                12126: [[29572], 256],
                12127: [[29577], 256],
                12128: [[29916], 256],
                12129: [[29926], 256],
                12130: [[29976], 256],
                12131: [[29983], 256],
                12132: [[29992], 256],
                12133: [[3e4], 256],
                12134: [[30091], 256],
                12135: [[30098], 256],
                12136: [[30326], 256],
                12137: [[30333], 256],
                12138: [[30382], 256],
                12139: [[30399], 256],
                12140: [[30446], 256],
                12141: [[30683], 256],
                12142: [[30690], 256],
                12143: [[30707], 256],
                12144: [[31034], 256],
                12145: [[31160], 256],
                12146: [[31166], 256],
                12147: [[31348], 256],
                12148: [[31435], 256],
                12149: [[31481], 256],
                12150: [[31859], 256],
                12151: [[31992], 256],
                12152: [[32566], 256],
                12153: [[32593], 256],
                12154: [[32650], 256],
                12155: [[32701], 256],
                12156: [[32769], 256],
                12157: [[32780], 256],
                12158: [[32786], 256],
                12159: [[32819], 256],
                12160: [[32895], 256],
                12161: [[32905], 256],
                12162: [[33251], 256],
                12163: [[33258], 256],
                12164: [[33267], 256],
                12165: [[33276], 256],
                12166: [[33292], 256],
                12167: [[33307], 256],
                12168: [[33311], 256],
                12169: [[33390], 256],
                12170: [[33394], 256],
                12171: [[33400], 256],
                12172: [[34381], 256],
                12173: [[34411], 256],
                12174: [[34880], 256],
                12175: [[34892], 256],
                12176: [[34915], 256],
                12177: [[35198], 256],
                12178: [[35211], 256],
                12179: [[35282], 256],
                12180: [[35328], 256],
                12181: [[35895], 256],
                12182: [[35910], 256],
                12183: [[35925], 256],
                12184: [[35960], 256],
                12185: [[35997], 256],
                12186: [[36196], 256],
                12187: [[36208], 256],
                12188: [[36275], 256],
                12189: [[36523], 256],
                12190: [[36554], 256],
                12191: [[36763], 256],
                12192: [[36784], 256],
                12193: [[36789], 256],
                12194: [[37009], 256],
                12195: [[37193], 256],
                12196: [[37318], 256],
                12197: [[37324], 256],
                12198: [[37329], 256],
                12199: [[38263], 256],
                12200: [[38272], 256],
                12201: [[38428], 256],
                12202: [[38582], 256],
                12203: [[38585], 256],
                12204: [[38632], 256],
                12205: [[38737], 256],
                12206: [[38750], 256],
                12207: [[38754], 256],
                12208: [[38761], 256],
                12209: [[38859], 256],
                12210: [[38893], 256],
                12211: [[38899], 256],
                12212: [[38913], 256],
                12213: [[39080], 256],
                12214: [[39131], 256],
                12215: [[39135], 256],
                12216: [[39318], 256],
                12217: [[39321], 256],
                12218: [[39340], 256],
                12219: [[39592], 256],
                12220: [[39640], 256],
                12221: [[39647], 256],
                12222: [[39717], 256],
                12223: [[39727], 256],
                12224: [[39730], 256],
                12225: [[39740], 256],
                12226: [[39770], 256],
                12227: [[40165], 256],
                12228: [[40565], 256],
                12229: [[40575], 256],
                12230: [[40613], 256],
                12231: [[40635], 256],
                12232: [[40643], 256],
                12233: [[40653], 256],
                12234: [[40657], 256],
                12235: [[40697], 256],
                12236: [[40701], 256],
                12237: [[40718], 256],
                12238: [[40723], 256],
                12239: [[40736], 256],
                12240: [[40763], 256],
                12241: [[40778], 256],
                12242: [[40786], 256],
                12243: [[40845], 256],
                12244: [[40860], 256],
                12245: [[40864], 256]
              },
              12288: {
                12288: [[32], 256],
                12330: [, 218],
                12331: [, 228],
                12332: [, 232],
                12333: [, 222],
                12334: [, 224],
                12335: [, 224],
                12342: [[12306], 256],
                12344: [[21313], 256],
                12345: [[21316], 256],
                12346: [[21317], 256],
                12358: [, , { 12441: 12436 }],
                12363: [, , { 12441: 12364 }],
                12364: [[12363, 12441]],
                12365: [, , { 12441: 12366 }],
                12366: [[12365, 12441]],
                12367: [, , { 12441: 12368 }],
                12368: [[12367, 12441]],
                12369: [, , { 12441: 12370 }],
                12370: [[12369, 12441]],
                12371: [, , { 12441: 12372 }],
                12372: [[12371, 12441]],
                12373: [, , { 12441: 12374 }],
                12374: [[12373, 12441]],
                12375: [, , { 12441: 12376 }],
                12376: [[12375, 12441]],
                12377: [, , { 12441: 12378 }],
                12378: [[12377, 12441]],
                12379: [, , { 12441: 12380 }],
                12380: [[12379, 12441]],
                12381: [, , { 12441: 12382 }],
                12382: [[12381, 12441]],
                12383: [, , { 12441: 12384 }],
                12384: [[12383, 12441]],
                12385: [, , { 12441: 12386 }],
                12386: [[12385, 12441]],
                12388: [, , { 12441: 12389 }],
                12389: [[12388, 12441]],
                12390: [, , { 12441: 12391 }],
                12391: [[12390, 12441]],
                12392: [, , { 12441: 12393 }],
                12393: [[12392, 12441]],
                12399: [, , { 12441: 12400, 12442: 12401 }],
                12400: [[12399, 12441]],
                12401: [[12399, 12442]],
                12402: [, , { 12441: 12403, 12442: 12404 }],
                12403: [[12402, 12441]],
                12404: [[12402, 12442]],
                12405: [, , { 12441: 12406, 12442: 12407 }],
                12406: [[12405, 12441]],
                12407: [[12405, 12442]],
                12408: [, , { 12441: 12409, 12442: 12410 }],
                12409: [[12408, 12441]],
                12410: [[12408, 12442]],
                12411: [, , { 12441: 12412, 12442: 12413 }],
                12412: [[12411, 12441]],
                12413: [[12411, 12442]],
                12436: [[12358, 12441]],
                12441: [, 8],
                12442: [, 8],
                12443: [[32, 12441], 256],
                12444: [[32, 12442], 256],
                12445: [, , { 12441: 12446 }],
                12446: [[12445, 12441]],
                12447: [[12424, 12426], 256],
                12454: [, , { 12441: 12532 }],
                12459: [, , { 12441: 12460 }],
                12460: [[12459, 12441]],
                12461: [, , { 12441: 12462 }],
                12462: [[12461, 12441]],
                12463: [, , { 12441: 12464 }],
                12464: [[12463, 12441]],
                12465: [, , { 12441: 12466 }],
                12466: [[12465, 12441]],
                12467: [, , { 12441: 12468 }],
                12468: [[12467, 12441]],
                12469: [, , { 12441: 12470 }],
                12470: [[12469, 12441]],
                12471: [, , { 12441: 12472 }],
                12472: [[12471, 12441]],
                12473: [, , { 12441: 12474 }],
                12474: [[12473, 12441]],
                12475: [, , { 12441: 12476 }],
                12476: [[12475, 12441]],
                12477: [, , { 12441: 12478 }],
                12478: [[12477, 12441]],
                12479: [, , { 12441: 12480 }],
                12480: [[12479, 12441]],
                12481: [, , { 12441: 12482 }],
                12482: [[12481, 12441]],
                12484: [, , { 12441: 12485 }],
                12485: [[12484, 12441]],
                12486: [, , { 12441: 12487 }],
                12487: [[12486, 12441]],
                12488: [, , { 12441: 12489 }],
                12489: [[12488, 12441]],
                12495: [, , { 12441: 12496, 12442: 12497 }],
                12496: [[12495, 12441]],
                12497: [[12495, 12442]],
                12498: [, , { 12441: 12499, 12442: 12500 }],
                12499: [[12498, 12441]],
                12500: [[12498, 12442]],
                12501: [, , { 12441: 12502, 12442: 12503 }],
                12502: [[12501, 12441]],
                12503: [[12501, 12442]],
                12504: [, , { 12441: 12505, 12442: 12506 }],
                12505: [[12504, 12441]],
                12506: [[12504, 12442]],
                12507: [, , { 12441: 12508, 12442: 12509 }],
                12508: [[12507, 12441]],
                12509: [[12507, 12442]],
                12527: [, , { 12441: 12535 }],
                12528: [, , { 12441: 12536 }],
                12529: [, , { 12441: 12537 }],
                12530: [, , { 12441: 12538 }],
                12532: [[12454, 12441]],
                12535: [[12527, 12441]],
                12536: [[12528, 12441]],
                12537: [[12529, 12441]],
                12538: [[12530, 12441]],
                12541: [, , { 12441: 12542 }],
                12542: [[12541, 12441]],
                12543: [[12467, 12488], 256]
              },
              12544: {
                12593: [[4352], 256],
                12594: [[4353], 256],
                12595: [[4522], 256],
                12596: [[4354], 256],
                12597: [[4524], 256],
                12598: [[4525], 256],
                12599: [[4355], 256],
                12600: [[4356], 256],
                12601: [[4357], 256],
                12602: [[4528], 256],
                12603: [[4529], 256],
                12604: [[4530], 256],
                12605: [[4531], 256],
                12606: [[4532], 256],
                12607: [[4533], 256],
                12608: [[4378], 256],
                12609: [[4358], 256],
                12610: [[4359], 256],
                12611: [[4360], 256],
                12612: [[4385], 256],
                12613: [[4361], 256],
                12614: [[4362], 256],
                12615: [[4363], 256],
                12616: [[4364], 256],
                12617: [[4365], 256],
                12618: [[4366], 256],
                12619: [[4367], 256],
                12620: [[4368], 256],
                12621: [[4369], 256],
                12622: [[4370], 256],
                12623: [[4449], 256],
                12624: [[4450], 256],
                12625: [[4451], 256],
                12626: [[4452], 256],
                12627: [[4453], 256],
                12628: [[4454], 256],
                12629: [[4455], 256],
                12630: [[4456], 256],
                12631: [[4457], 256],
                12632: [[4458], 256],
                12633: [[4459], 256],
                12634: [[4460], 256],
                12635: [[4461], 256],
                12636: [[4462], 256],
                12637: [[4463], 256],
                12638: [[4464], 256],
                12639: [[4465], 256],
                12640: [[4466], 256],
                12641: [[4467], 256],
                12642: [[4468], 256],
                12643: [[4469], 256],
                12644: [[4448], 256],
                12645: [[4372], 256],
                12646: [[4373], 256],
                12647: [[4551], 256],
                12648: [[4552], 256],
                12649: [[4556], 256],
                12650: [[4558], 256],
                12651: [[4563], 256],
                12652: [[4567], 256],
                12653: [[4569], 256],
                12654: [[4380], 256],
                12655: [[4573], 256],
                12656: [[4575], 256],
                12657: [[4381], 256],
                12658: [[4382], 256],
                12659: [[4384], 256],
                12660: [[4386], 256],
                12661: [[4387], 256],
                12662: [[4391], 256],
                12663: [[4393], 256],
                12664: [[4395], 256],
                12665: [[4396], 256],
                12666: [[4397], 256],
                12667: [[4398], 256],
                12668: [[4399], 256],
                12669: [[4402], 256],
                12670: [[4406], 256],
                12671: [[4416], 256],
                12672: [[4423], 256],
                12673: [[4428], 256],
                12674: [[4593], 256],
                12675: [[4594], 256],
                12676: [[4439], 256],
                12677: [[4440], 256],
                12678: [[4441], 256],
                12679: [[4484], 256],
                12680: [[4485], 256],
                12681: [[4488], 256],
                12682: [[4497], 256],
                12683: [[4498], 256],
                12684: [[4500], 256],
                12685: [[4510], 256],
                12686: [[4513], 256],
                12690: [[19968], 256],
                12691: [[20108], 256],
                12692: [[19977], 256],
                12693: [[22235], 256],
                12694: [[19978], 256],
                12695: [[20013], 256],
                12696: [[19979], 256],
                12697: [[30002], 256],
                12698: [[20057], 256],
                12699: [[19993], 256],
                12700: [[19969], 256],
                12701: [[22825], 256],
                12702: [[22320], 256],
                12703: [[20154], 256]
              },
              12800: {
                12800: [[40, 4352, 41], 256],
                12801: [[40, 4354, 41], 256],
                12802: [[40, 4355, 41], 256],
                12803: [[40, 4357, 41], 256],
                12804: [[40, 4358, 41], 256],
                12805: [[40, 4359, 41], 256],
                12806: [[40, 4361, 41], 256],
                12807: [[40, 4363, 41], 256],
                12808: [[40, 4364, 41], 256],
                12809: [[40, 4366, 41], 256],
                12810: [[40, 4367, 41], 256],
                12811: [[40, 4368, 41], 256],
                12812: [[40, 4369, 41], 256],
                12813: [[40, 4370, 41], 256],
                12814: [[40, 4352, 4449, 41], 256],
                12815: [[40, 4354, 4449, 41], 256],
                12816: [[40, 4355, 4449, 41], 256],
                12817: [[40, 4357, 4449, 41], 256],
                12818: [[40, 4358, 4449, 41], 256],
                12819: [[40, 4359, 4449, 41], 256],
                12820: [[40, 4361, 4449, 41], 256],
                12821: [[40, 4363, 4449, 41], 256],
                12822: [[40, 4364, 4449, 41], 256],
                12823: [[40, 4366, 4449, 41], 256],
                12824: [[40, 4367, 4449, 41], 256],
                12825: [[40, 4368, 4449, 41], 256],
                12826: [[40, 4369, 4449, 41], 256],
                12827: [[40, 4370, 4449, 41], 256],
                12828: [[40, 4364, 4462, 41], 256],
                12829: [[40, 4363, 4457, 4364, 4453, 4523, 41], 256],
                12830: [[40, 4363, 4457, 4370, 4462, 41], 256],
                12832: [[40, 19968, 41], 256],
                12833: [[40, 20108, 41], 256],
                12834: [[40, 19977, 41], 256],
                12835: [[40, 22235, 41], 256],
                12836: [[40, 20116, 41], 256],
                12837: [[40, 20845, 41], 256],
                12838: [[40, 19971, 41], 256],
                12839: [[40, 20843, 41], 256],
                12840: [[40, 20061, 41], 256],
                12841: [[40, 21313, 41], 256],
                12842: [[40, 26376, 41], 256],
                12843: [[40, 28779, 41], 256],
                12844: [[40, 27700, 41], 256],
                12845: [[40, 26408, 41], 256],
                12846: [[40, 37329, 41], 256],
                12847: [[40, 22303, 41], 256],
                12848: [[40, 26085, 41], 256],
                12849: [[40, 26666, 41], 256],
                12850: [[40, 26377, 41], 256],
                12851: [[40, 31038, 41], 256],
                12852: [[40, 21517, 41], 256],
                12853: [[40, 29305, 41], 256],
                12854: [[40, 36001, 41], 256],
                12855: [[40, 31069, 41], 256],
                12856: [[40, 21172, 41], 256],
                12857: [[40, 20195, 41], 256],
                12858: [[40, 21628, 41], 256],
                12859: [[40, 23398, 41], 256],
                12860: [[40, 30435, 41], 256],
                12861: [[40, 20225, 41], 256],
                12862: [[40, 36039, 41], 256],
                12863: [[40, 21332, 41], 256],
                12864: [[40, 31085, 41], 256],
                12865: [[40, 20241, 41], 256],
                12866: [[40, 33258, 41], 256],
                12867: [[40, 33267, 41], 256],
                12868: [[21839], 256],
                12869: [[24188], 256],
                12870: [[25991], 256],
                12871: [[31631], 256],
                12880: [[80, 84, 69], 256],
                12881: [[50, 49], 256],
                12882: [[50, 50], 256],
                12883: [[50, 51], 256],
                12884: [[50, 52], 256],
                12885: [[50, 53], 256],
                12886: [[50, 54], 256],
                12887: [[50, 55], 256],
                12888: [[50, 56], 256],
                12889: [[50, 57], 256],
                12890: [[51, 48], 256],
                12891: [[51, 49], 256],
                12892: [[51, 50], 256],
                12893: [[51, 51], 256],
                12894: [[51, 52], 256],
                12895: [[51, 53], 256],
                12896: [[4352], 256],
                12897: [[4354], 256],
                12898: [[4355], 256],
                12899: [[4357], 256],
                12900: [[4358], 256],
                12901: [[4359], 256],
                12902: [[4361], 256],
                12903: [[4363], 256],
                12904: [[4364], 256],
                12905: [[4366], 256],
                12906: [[4367], 256],
                12907: [[4368], 256],
                12908: [[4369], 256],
                12909: [[4370], 256],
                12910: [[4352, 4449], 256],
                12911: [[4354, 4449], 256],
                12912: [[4355, 4449], 256],
                12913: [[4357, 4449], 256],
                12914: [[4358, 4449], 256],
                12915: [[4359, 4449], 256],
                12916: [[4361, 4449], 256],
                12917: [[4363, 4449], 256],
                12918: [[4364, 4449], 256],
                12919: [[4366, 4449], 256],
                12920: [[4367, 4449], 256],
                12921: [[4368, 4449], 256],
                12922: [[4369, 4449], 256],
                12923: [[4370, 4449], 256],
                12924: [[4366, 4449, 4535, 4352, 4457], 256],
                12925: [[4364, 4462, 4363, 4468], 256],
                12926: [[4363, 4462], 256],
                12928: [[19968], 256],
                12929: [[20108], 256],
                12930: [[19977], 256],
                12931: [[22235], 256],
                12932: [[20116], 256],
                12933: [[20845], 256],
                12934: [[19971], 256],
                12935: [[20843], 256],
                12936: [[20061], 256],
                12937: [[21313], 256],
                12938: [[26376], 256],
                12939: [[28779], 256],
                12940: [[27700], 256],
                12941: [[26408], 256],
                12942: [[37329], 256],
                12943: [[22303], 256],
                12944: [[26085], 256],
                12945: [[26666], 256],
                12946: [[26377], 256],
                12947: [[31038], 256],
                12948: [[21517], 256],
                12949: [[29305], 256],
                12950: [[36001], 256],
                12951: [[31069], 256],
                12952: [[21172], 256],
                12953: [[31192], 256],
                12954: [[30007], 256],
                12955: [[22899], 256],
                12956: [[36969], 256],
                12957: [[20778], 256],
                12958: [[21360], 256],
                12959: [[27880], 256],
                12960: [[38917], 256],
                12961: [[20241], 256],
                12962: [[20889], 256],
                12963: [[27491], 256],
                12964: [[19978], 256],
                12965: [[20013], 256],
                12966: [[19979], 256],
                12967: [[24038], 256],
                12968: [[21491], 256],
                12969: [[21307], 256],
                12970: [[23447], 256],
                12971: [[23398], 256],
                12972: [[30435], 256],
                12973: [[20225], 256],
                12974: [[36039], 256],
                12975: [[21332], 256],
                12976: [[22812], 256],
                12977: [[51, 54], 256],
                12978: [[51, 55], 256],
                12979: [[51, 56], 256],
                12980: [[51, 57], 256],
                12981: [[52, 48], 256],
                12982: [[52, 49], 256],
                12983: [[52, 50], 256],
                12984: [[52, 51], 256],
                12985: [[52, 52], 256],
                12986: [[52, 53], 256],
                12987: [[52, 54], 256],
                12988: [[52, 55], 256],
                12989: [[52, 56], 256],
                12990: [[52, 57], 256],
                12991: [[53, 48], 256],
                12992: [[49, 26376], 256],
                12993: [[50, 26376], 256],
                12994: [[51, 26376], 256],
                12995: [[52, 26376], 256],
                12996: [[53, 26376], 256],
                12997: [[54, 26376], 256],
                12998: [[55, 26376], 256],
                12999: [[56, 26376], 256],
                13000: [[57, 26376], 256],
                13001: [[49, 48, 26376], 256],
                13002: [[49, 49, 26376], 256],
                13003: [[49, 50, 26376], 256],
                13004: [[72, 103], 256],
                13005: [[101, 114, 103], 256],
                13006: [[101, 86], 256],
                13007: [[76, 84, 68], 256],
                13008: [[12450], 256],
                13009: [[12452], 256],
                13010: [[12454], 256],
                13011: [[12456], 256],
                13012: [[12458], 256],
                13013: [[12459], 256],
                13014: [[12461], 256],
                13015: [[12463], 256],
                13016: [[12465], 256],
                13017: [[12467], 256],
                13018: [[12469], 256],
                13019: [[12471], 256],
                13020: [[12473], 256],
                13021: [[12475], 256],
                13022: [[12477], 256],
                13023: [[12479], 256],
                13024: [[12481], 256],
                13025: [[12484], 256],
                13026: [[12486], 256],
                13027: [[12488], 256],
                13028: [[12490], 256],
                13029: [[12491], 256],
                13030: [[12492], 256],
                13031: [[12493], 256],
                13032: [[12494], 256],
                13033: [[12495], 256],
                13034: [[12498], 256],
                13035: [[12501], 256],
                13036: [[12504], 256],
                13037: [[12507], 256],
                13038: [[12510], 256],
                13039: [[12511], 256],
                13040: [[12512], 256],
                13041: [[12513], 256],
                13042: [[12514], 256],
                13043: [[12516], 256],
                13044: [[12518], 256],
                13045: [[12520], 256],
                13046: [[12521], 256],
                13047: [[12522], 256],
                13048: [[12523], 256],
                13049: [[12524], 256],
                13050: [[12525], 256],
                13051: [[12527], 256],
                13052: [[12528], 256],
                13053: [[12529], 256],
                13054: [[12530], 256]
              },
              13056: {
                13056: [[12450, 12497, 12540, 12488], 256],
                13057: [[12450, 12523, 12501, 12449], 256],
                13058: [[12450, 12531, 12506, 12450], 256],
                13059: [[12450, 12540, 12523], 256],
                13060: [[12452, 12491, 12531, 12464], 256],
                13061: [[12452, 12531, 12481], 256],
                13062: [[12454, 12457, 12531], 256],
                13063: [[12456, 12473, 12463, 12540, 12489], 256],
                13064: [[12456, 12540, 12459, 12540], 256],
                13065: [[12458, 12531, 12473], 256],
                13066: [[12458, 12540, 12512], 256],
                13067: [[12459, 12452, 12522], 256],
                13068: [[12459, 12521, 12483, 12488], 256],
                13069: [[12459, 12525, 12522, 12540], 256],
                13070: [[12460, 12525, 12531], 256],
                13071: [[12460, 12531, 12510], 256],
                13072: [[12462, 12460], 256],
                13073: [[12462, 12491, 12540], 256],
                13074: [[12461, 12517, 12522, 12540], 256],
                13075: [[12462, 12523, 12480, 12540], 256],
                13076: [[12461, 12525], 256],
                13077: [[12461, 12525, 12464, 12521, 12512], 256],
                13078: [[12461, 12525, 12513, 12540, 12488, 12523], 256],
                13079: [[12461, 12525, 12527, 12483, 12488], 256],
                13080: [[12464, 12521, 12512], 256],
                13081: [[12464, 12521, 12512, 12488, 12531], 256],
                13082: [[12463, 12523, 12476, 12452, 12525], 256],
                13083: [[12463, 12525, 12540, 12493], 256],
                13084: [[12465, 12540, 12473], 256],
                13085: [[12467, 12523, 12490], 256],
                13086: [[12467, 12540, 12509], 256],
                13087: [[12469, 12452, 12463, 12523], 256],
                13088: [[12469, 12531, 12481, 12540, 12512], 256],
                13089: [[12471, 12522, 12531, 12464], 256],
                13090: [[12475, 12531, 12481], 256],
                13091: [[12475, 12531, 12488], 256],
                13092: [[12480, 12540, 12473], 256],
                13093: [[12487, 12471], 256],
                13094: [[12489, 12523], 256],
                13095: [[12488, 12531], 256],
                13096: [[12490, 12494], 256],
                13097: [[12494, 12483, 12488], 256],
                13098: [[12495, 12452, 12484], 256],
                13099: [[12497, 12540, 12475, 12531, 12488], 256],
                13100: [[12497, 12540, 12484], 256],
                13101: [[12496, 12540, 12524, 12523], 256],
                13102: [[12500, 12450, 12473, 12488, 12523], 256],
                13103: [[12500, 12463, 12523], 256],
                13104: [[12500, 12467], 256],
                13105: [[12499, 12523], 256],
                13106: [[12501, 12449, 12521, 12483, 12489], 256],
                13107: [[12501, 12451, 12540, 12488], 256],
                13108: [[12502, 12483, 12471, 12455, 12523], 256],
                13109: [[12501, 12521, 12531], 256],
                13110: [[12504, 12463, 12479, 12540, 12523], 256],
                13111: [[12506, 12477], 256],
                13112: [[12506, 12491, 12498], 256],
                13113: [[12504, 12523, 12484], 256],
                13114: [[12506, 12531, 12473], 256],
                13115: [[12506, 12540, 12472], 256],
                13116: [[12505, 12540, 12479], 256],
                13117: [[12509, 12452, 12531, 12488], 256],
                13118: [[12508, 12523, 12488], 256],
                13119: [[12507, 12531], 256],
                13120: [[12509, 12531, 12489], 256],
                13121: [[12507, 12540, 12523], 256],
                13122: [[12507, 12540, 12531], 256],
                13123: [[12510, 12452, 12463, 12525], 256],
                13124: [[12510, 12452, 12523], 256],
                13125: [[12510, 12483, 12495], 256],
                13126: [[12510, 12523, 12463], 256],
                13127: [[12510, 12531, 12471, 12519, 12531], 256],
                13128: [[12511, 12463, 12525, 12531], 256],
                13129: [[12511, 12522], 256],
                13130: [[12511, 12522, 12496, 12540, 12523], 256],
                13131: [[12513, 12460], 256],
                13132: [[12513, 12460, 12488, 12531], 256],
                13133: [[12513, 12540, 12488, 12523], 256],
                13134: [[12516, 12540, 12489], 256],
                13135: [[12516, 12540, 12523], 256],
                13136: [[12518, 12450, 12531], 256],
                13137: [[12522, 12483, 12488, 12523], 256],
                13138: [[12522, 12521], 256],
                13139: [[12523, 12500, 12540], 256],
                13140: [[12523, 12540, 12502, 12523], 256],
                13141: [[12524, 12512], 256],
                13142: [[12524, 12531, 12488, 12466, 12531], 256],
                13143: [[12527, 12483, 12488], 256],
                13144: [[48, 28857], 256],
                13145: [[49, 28857], 256],
                13146: [[50, 28857], 256],
                13147: [[51, 28857], 256],
                13148: [[52, 28857], 256],
                13149: [[53, 28857], 256],
                13150: [[54, 28857], 256],
                13151: [[55, 28857], 256],
                13152: [[56, 28857], 256],
                13153: [[57, 28857], 256],
                13154: [[49, 48, 28857], 256],
                13155: [[49, 49, 28857], 256],
                13156: [[49, 50, 28857], 256],
                13157: [[49, 51, 28857], 256],
                13158: [[49, 52, 28857], 256],
                13159: [[49, 53, 28857], 256],
                13160: [[49, 54, 28857], 256],
                13161: [[49, 55, 28857], 256],
                13162: [[49, 56, 28857], 256],
                13163: [[49, 57, 28857], 256],
                13164: [[50, 48, 28857], 256],
                13165: [[50, 49, 28857], 256],
                13166: [[50, 50, 28857], 256],
                13167: [[50, 51, 28857], 256],
                13168: [[50, 52, 28857], 256],
                13169: [[104, 80, 97], 256],
                13170: [[100, 97], 256],
                13171: [[65, 85], 256],
                13172: [[98, 97, 114], 256],
                13173: [[111, 86], 256],
                13174: [[112, 99], 256],
                13175: [[100, 109], 256],
                13176: [[100, 109, 178], 256],
                13177: [[100, 109, 179], 256],
                13178: [[73, 85], 256],
                13179: [[24179, 25104], 256],
                13180: [[26157, 21644], 256],
                13181: [[22823, 27491], 256],
                13182: [[26126, 27835], 256],
                13183: [[26666, 24335, 20250, 31038], 256],
                13184: [[112, 65], 256],
                13185: [[110, 65], 256],
                13186: [[956, 65], 256],
                13187: [[109, 65], 256],
                13188: [[107, 65], 256],
                13189: [[75, 66], 256],
                13190: [[77, 66], 256],
                13191: [[71, 66], 256],
                13192: [[99, 97, 108], 256],
                13193: [[107, 99, 97, 108], 256],
                13194: [[112, 70], 256],
                13195: [[110, 70], 256],
                13196: [[956, 70], 256],
                13197: [[956, 103], 256],
                13198: [[109, 103], 256],
                13199: [[107, 103], 256],
                13200: [[72, 122], 256],
                13201: [[107, 72, 122], 256],
                13202: [[77, 72, 122], 256],
                13203: [[71, 72, 122], 256],
                13204: [[84, 72, 122], 256],
                13205: [[956, 8467], 256],
                13206: [[109, 8467], 256],
                13207: [[100, 8467], 256],
                13208: [[107, 8467], 256],
                13209: [[102, 109], 256],
                13210: [[110, 109], 256],
                13211: [[956, 109], 256],
                13212: [[109, 109], 256],
                13213: [[99, 109], 256],
                13214: [[107, 109], 256],
                13215: [[109, 109, 178], 256],
                13216: [[99, 109, 178], 256],
                13217: [[109, 178], 256],
                13218: [[107, 109, 178], 256],
                13219: [[109, 109, 179], 256],
                13220: [[99, 109, 179], 256],
                13221: [[109, 179], 256],
                13222: [[107, 109, 179], 256],
                13223: [[109, 8725, 115], 256],
                13224: [[109, 8725, 115, 178], 256],
                13225: [[80, 97], 256],
                13226: [[107, 80, 97], 256],
                13227: [[77, 80, 97], 256],
                13228: [[71, 80, 97], 256],
                13229: [[114, 97, 100], 256],
                13230: [[114, 97, 100, 8725, 115], 256],
                13231: [[114, 97, 100, 8725, 115, 178], 256],
                13232: [[112, 115], 256],
                13233: [[110, 115], 256],
                13234: [[956, 115], 256],
                13235: [[109, 115], 256],
                13236: [[112, 86], 256],
                13237: [[110, 86], 256],
                13238: [[956, 86], 256],
                13239: [[109, 86], 256],
                13240: [[107, 86], 256],
                13241: [[77, 86], 256],
                13242: [[112, 87], 256],
                13243: [[110, 87], 256],
                13244: [[956, 87], 256],
                13245: [[109, 87], 256],
                13246: [[107, 87], 256],
                13247: [[77, 87], 256],
                13248: [[107, 937], 256],
                13249: [[77, 937], 256],
                13250: [[97, 46, 109, 46], 256],
                13251: [[66, 113], 256],
                13252: [[99, 99], 256],
                13253: [[99, 100], 256],
                13254: [[67, 8725, 107, 103], 256],
                13255: [[67, 111, 46], 256],
                13256: [[100, 66], 256],
                13257: [[71, 121], 256],
                13258: [[104, 97], 256],
                13259: [[72, 80], 256],
                13260: [[105, 110], 256],
                13261: [[75, 75], 256],
                13262: [[75, 77], 256],
                13263: [[107, 116], 256],
                13264: [[108, 109], 256],
                13265: [[108, 110], 256],
                13266: [[108, 111, 103], 256],
                13267: [[108, 120], 256],
                13268: [[109, 98], 256],
                13269: [[109, 105, 108], 256],
                13270: [[109, 111, 108], 256],
                13271: [[80, 72], 256],
                13272: [[112, 46, 109, 46], 256],
                13273: [[80, 80, 77], 256],
                13274: [[80, 82], 256],
                13275: [[115, 114], 256],
                13276: [[83, 118], 256],
                13277: [[87, 98], 256],
                13278: [[86, 8725, 109], 256],
                13279: [[65, 8725, 109], 256],
                13280: [[49, 26085], 256],
                13281: [[50, 26085], 256],
                13282: [[51, 26085], 256],
                13283: [[52, 26085], 256],
                13284: [[53, 26085], 256],
                13285: [[54, 26085], 256],
                13286: [[55, 26085], 256],
                13287: [[56, 26085], 256],
                13288: [[57, 26085], 256],
                13289: [[49, 48, 26085], 256],
                13290: [[49, 49, 26085], 256],
                13291: [[49, 50, 26085], 256],
                13292: [[49, 51, 26085], 256],
                13293: [[49, 52, 26085], 256],
                13294: [[49, 53, 26085], 256],
                13295: [[49, 54, 26085], 256],
                13296: [[49, 55, 26085], 256],
                13297: [[49, 56, 26085], 256],
                13298: [[49, 57, 26085], 256],
                13299: [[50, 48, 26085], 256],
                13300: [[50, 49, 26085], 256],
                13301: [[50, 50, 26085], 256],
                13302: [[50, 51, 26085], 256],
                13303: [[50, 52, 26085], 256],
                13304: [[50, 53, 26085], 256],
                13305: [[50, 54, 26085], 256],
                13306: [[50, 55, 26085], 256],
                13307: [[50, 56, 26085], 256],
                13308: [[50, 57, 26085], 256],
                13309: [[51, 48, 26085], 256],
                13310: [[51, 49, 26085], 256],
                13311: [[103, 97, 108], 256]
              },
              27136: {
                92912: [, 1],
                92913: [, 1],
                92914: [, 1],
                92915: [, 1],
                92916: [, 1]
              },
              27392: {
                92976: [, 230],
                92977: [, 230],
                92978: [, 230],
                92979: [, 230],
                92980: [, 230],
                92981: [, 230],
                92982: [, 230]
              },
              42496: {
                42607: [, 230],
                42612: [, 230],
                42613: [, 230],
                42614: [, 230],
                42615: [, 230],
                42616: [, 230],
                42617: [, 230],
                42618: [, 230],
                42619: [, 230],
                42620: [, 230],
                42621: [, 230],
                42652: [[1098], 256],
                42653: [[1100], 256],
                42655: [, 230],
                42736: [, 230],
                42737: [, 230]
              },
              42752: {
                42864: [[42863], 256],
                43000: [[294], 256],
                43001: [[339], 256]
              },
              43008: {
                43014: [, 9],
                43204: [, 9],
                43232: [, 230],
                43233: [, 230],
                43234: [, 230],
                43235: [, 230],
                43236: [, 230],
                43237: [, 230],
                43238: [, 230],
                43239: [, 230],
                43240: [, 230],
                43241: [, 230],
                43242: [, 230],
                43243: [, 230],
                43244: [, 230],
                43245: [, 230],
                43246: [, 230],
                43247: [, 230],
                43248: [, 230],
                43249: [, 230]
              },
              43264: {
                43307: [, 220],
                43308: [, 220],
                43309: [, 220],
                43347: [, 9],
                43443: [, 7],
                43456: [, 9]
              },
              43520: {
                43696: [, 230],
                43698: [, 230],
                43699: [, 230],
                43700: [, 220],
                43703: [, 230],
                43704: [, 230],
                43710: [, 230],
                43711: [, 230],
                43713: [, 230],
                43766: [, 9]
              },
              43776: {
                43868: [[42791], 256],
                43869: [[43831], 256],
                43870: [[619], 256],
                43871: [[43858], 256],
                44013: [, 9]
              },
              48128: { 113822: [, 1] },
              53504: {
                119134: [[119127, 119141], 512],
                119135: [[119128, 119141], 512],
                119136: [[119135, 119150], 512],
                119137: [[119135, 119151], 512],
                119138: [[119135, 119152], 512],
                119139: [[119135, 119153], 512],
                119140: [[119135, 119154], 512],
                119141: [, 216],
                119142: [, 216],
                119143: [, 1],
                119144: [, 1],
                119145: [, 1],
                119149: [, 226],
                119150: [, 216],
                119151: [, 216],
                119152: [, 216],
                119153: [, 216],
                119154: [, 216],
                119163: [, 220],
                119164: [, 220],
                119165: [, 220],
                119166: [, 220],
                119167: [, 220],
                119168: [, 220],
                119169: [, 220],
                119170: [, 220],
                119173: [, 230],
                119174: [, 230],
                119175: [, 230],
                119176: [, 230],
                119177: [, 230],
                119178: [, 220],
                119179: [, 220],
                119210: [, 230],
                119211: [, 230],
                119212: [, 230],
                119213: [, 230],
                119227: [[119225, 119141], 512],
                119228: [[119226, 119141], 512],
                119229: [[119227, 119150], 512],
                119230: [[119228, 119150], 512],
                119231: [[119227, 119151], 512],
                119232: [[119228, 119151], 512]
              },
              53760: { 119362: [, 230], 119363: [, 230], 119364: [, 230] },
              54272: {
                119808: [[65], 256],
                119809: [[66], 256],
                119810: [[67], 256],
                119811: [[68], 256],
                119812: [[69], 256],
                119813: [[70], 256],
                119814: [[71], 256],
                119815: [[72], 256],
                119816: [[73], 256],
                119817: [[74], 256],
                119818: [[75], 256],
                119819: [[76], 256],
                119820: [[77], 256],
                119821: [[78], 256],
                119822: [[79], 256],
                119823: [[80], 256],
                119824: [[81], 256],
                119825: [[82], 256],
                119826: [[83], 256],
                119827: [[84], 256],
                119828: [[85], 256],
                119829: [[86], 256],
                119830: [[87], 256],
                119831: [[88], 256],
                119832: [[89], 256],
                119833: [[90], 256],
                119834: [[97], 256],
                119835: [[98], 256],
                119836: [[99], 256],
                119837: [[100], 256],
                119838: [[101], 256],
                119839: [[102], 256],
                119840: [[103], 256],
                119841: [[104], 256],
                119842: [[105], 256],
                119843: [[106], 256],
                119844: [[107], 256],
                119845: [[108], 256],
                119846: [[109], 256],
                119847: [[110], 256],
                119848: [[111], 256],
                119849: [[112], 256],
                119850: [[113], 256],
                119851: [[114], 256],
                119852: [[115], 256],
                119853: [[116], 256],
                119854: [[117], 256],
                119855: [[118], 256],
                119856: [[119], 256],
                119857: [[120], 256],
                119858: [[121], 256],
                119859: [[122], 256],
                119860: [[65], 256],
                119861: [[66], 256],
                119862: [[67], 256],
                119863: [[68], 256],
                119864: [[69], 256],
                119865: [[70], 256],
                119866: [[71], 256],
                119867: [[72], 256],
                119868: [[73], 256],
                119869: [[74], 256],
                119870: [[75], 256],
                119871: [[76], 256],
                119872: [[77], 256],
                119873: [[78], 256],
                119874: [[79], 256],
                119875: [[80], 256],
                119876: [[81], 256],
                119877: [[82], 256],
                119878: [[83], 256],
                119879: [[84], 256],
                119880: [[85], 256],
                119881: [[86], 256],
                119882: [[87], 256],
                119883: [[88], 256],
                119884: [[89], 256],
                119885: [[90], 256],
                119886: [[97], 256],
                119887: [[98], 256],
                119888: [[99], 256],
                119889: [[100], 256],
                119890: [[101], 256],
                119891: [[102], 256],
                119892: [[103], 256],
                119894: [[105], 256],
                119895: [[106], 256],
                119896: [[107], 256],
                119897: [[108], 256],
                119898: [[109], 256],
                119899: [[110], 256],
                119900: [[111], 256],
                119901: [[112], 256],
                119902: [[113], 256],
                119903: [[114], 256],
                119904: [[115], 256],
                119905: [[116], 256],
                119906: [[117], 256],
                119907: [[118], 256],
                119908: [[119], 256],
                119909: [[120], 256],
                119910: [[121], 256],
                119911: [[122], 256],
                119912: [[65], 256],
                119913: [[66], 256],
                119914: [[67], 256],
                119915: [[68], 256],
                119916: [[69], 256],
                119917: [[70], 256],
                119918: [[71], 256],
                119919: [[72], 256],
                119920: [[73], 256],
                119921: [[74], 256],
                119922: [[75], 256],
                119923: [[76], 256],
                119924: [[77], 256],
                119925: [[78], 256],
                119926: [[79], 256],
                119927: [[80], 256],
                119928: [[81], 256],
                119929: [[82], 256],
                119930: [[83], 256],
                119931: [[84], 256],
                119932: [[85], 256],
                119933: [[86], 256],
                119934: [[87], 256],
                119935: [[88], 256],
                119936: [[89], 256],
                119937: [[90], 256],
                119938: [[97], 256],
                119939: [[98], 256],
                119940: [[99], 256],
                119941: [[100], 256],
                119942: [[101], 256],
                119943: [[102], 256],
                119944: [[103], 256],
                119945: [[104], 256],
                119946: [[105], 256],
                119947: [[106], 256],
                119948: [[107], 256],
                119949: [[108], 256],
                119950: [[109], 256],
                119951: [[110], 256],
                119952: [[111], 256],
                119953: [[112], 256],
                119954: [[113], 256],
                119955: [[114], 256],
                119956: [[115], 256],
                119957: [[116], 256],
                119958: [[117], 256],
                119959: [[118], 256],
                119960: [[119], 256],
                119961: [[120], 256],
                119962: [[121], 256],
                119963: [[122], 256],
                119964: [[65], 256],
                119966: [[67], 256],
                119967: [[68], 256],
                119970: [[71], 256],
                119973: [[74], 256],
                119974: [[75], 256],
                119977: [[78], 256],
                119978: [[79], 256],
                119979: [[80], 256],
                119980: [[81], 256],
                119982: [[83], 256],
                119983: [[84], 256],
                119984: [[85], 256],
                119985: [[86], 256],
                119986: [[87], 256],
                119987: [[88], 256],
                119988: [[89], 256],
                119989: [[90], 256],
                119990: [[97], 256],
                119991: [[98], 256],
                119992: [[99], 256],
                119993: [[100], 256],
                119995: [[102], 256],
                119997: [[104], 256],
                119998: [[105], 256],
                119999: [[106], 256],
                120000: [[107], 256],
                120001: [[108], 256],
                120002: [[109], 256],
                120003: [[110], 256],
                120005: [[112], 256],
                120006: [[113], 256],
                120007: [[114], 256],
                120008: [[115], 256],
                120009: [[116], 256],
                120010: [[117], 256],
                120011: [[118], 256],
                120012: [[119], 256],
                120013: [[120], 256],
                120014: [[121], 256],
                120015: [[122], 256],
                120016: [[65], 256],
                120017: [[66], 256],
                120018: [[67], 256],
                120019: [[68], 256],
                120020: [[69], 256],
                120021: [[70], 256],
                120022: [[71], 256],
                120023: [[72], 256],
                120024: [[73], 256],
                120025: [[74], 256],
                120026: [[75], 256],
                120027: [[76], 256],
                120028: [[77], 256],
                120029: [[78], 256],
                120030: [[79], 256],
                120031: [[80], 256],
                120032: [[81], 256],
                120033: [[82], 256],
                120034: [[83], 256],
                120035: [[84], 256],
                120036: [[85], 256],
                120037: [[86], 256],
                120038: [[87], 256],
                120039: [[88], 256],
                120040: [[89], 256],
                120041: [[90], 256],
                120042: [[97], 256],
                120043: [[98], 256],
                120044: [[99], 256],
                120045: [[100], 256],
                120046: [[101], 256],
                120047: [[102], 256],
                120048: [[103], 256],
                120049: [[104], 256],
                120050: [[105], 256],
                120051: [[106], 256],
                120052: [[107], 256],
                120053: [[108], 256],
                120054: [[109], 256],
                120055: [[110], 256],
                120056: [[111], 256],
                120057: [[112], 256],
                120058: [[113], 256],
                120059: [[114], 256],
                120060: [[115], 256],
                120061: [[116], 256],
                120062: [[117], 256],
                120063: [[118], 256]
              },
              54528: {
                120064: [[119], 256],
                120065: [[120], 256],
                120066: [[121], 256],
                120067: [[122], 256],
                120068: [[65], 256],
                120069: [[66], 256],
                120071: [[68], 256],
                120072: [[69], 256],
                120073: [[70], 256],
                120074: [[71], 256],
                120077: [[74], 256],
                120078: [[75], 256],
                120079: [[76], 256],
                120080: [[77], 256],
                120081: [[78], 256],
                120082: [[79], 256],
                120083: [[80], 256],
                120084: [[81], 256],
                120086: [[83], 256],
                120087: [[84], 256],
                120088: [[85], 256],
                120089: [[86], 256],
                120090: [[87], 256],
                120091: [[88], 256],
                120092: [[89], 256],
                120094: [[97], 256],
                120095: [[98], 256],
                120096: [[99], 256],
                120097: [[100], 256],
                120098: [[101], 256],
                120099: [[102], 256],
                120100: [[103], 256],
                120101: [[104], 256],
                120102: [[105], 256],
                120103: [[106], 256],
                120104: [[107], 256],
                120105: [[108], 256],
                120106: [[109], 256],
                120107: [[110], 256],
                120108: [[111], 256],
                120109: [[112], 256],
                120110: [[113], 256],
                120111: [[114], 256],
                120112: [[115], 256],
                120113: [[116], 256],
                120114: [[117], 256],
                120115: [[118], 256],
                120116: [[119], 256],
                120117: [[120], 256],
                120118: [[121], 256],
                120119: [[122], 256],
                120120: [[65], 256],
                120121: [[66], 256],
                120123: [[68], 256],
                120124: [[69], 256],
                120125: [[70], 256],
                120126: [[71], 256],
                120128: [[73], 256],
                120129: [[74], 256],
                120130: [[75], 256],
                120131: [[76], 256],
                120132: [[77], 256],
                120134: [[79], 256],
                120138: [[83], 256],
                120139: [[84], 256],
                120140: [[85], 256],
                120141: [[86], 256],
                120142: [[87], 256],
                120143: [[88], 256],
                120144: [[89], 256],
                120146: [[97], 256],
                120147: [[98], 256],
                120148: [[99], 256],
                120149: [[100], 256],
                120150: [[101], 256],
                120151: [[102], 256],
                120152: [[103], 256],
                120153: [[104], 256],
                120154: [[105], 256],
                120155: [[106], 256],
                120156: [[107], 256],
                120157: [[108], 256],
                120158: [[109], 256],
                120159: [[110], 256],
                120160: [[111], 256],
                120161: [[112], 256],
                120162: [[113], 256],
                120163: [[114], 256],
                120164: [[115], 256],
                120165: [[116], 256],
                120166: [[117], 256],
                120167: [[118], 256],
                120168: [[119], 256],
                120169: [[120], 256],
                120170: [[121], 256],
                120171: [[122], 256],
                120172: [[65], 256],
                120173: [[66], 256],
                120174: [[67], 256],
                120175: [[68], 256],
                120176: [[69], 256],
                120177: [[70], 256],
                120178: [[71], 256],
                120179: [[72], 256],
                120180: [[73], 256],
                120181: [[74], 256],
                120182: [[75], 256],
                120183: [[76], 256],
                120184: [[77], 256],
                120185: [[78], 256],
                120186: [[79], 256],
                120187: [[80], 256],
                120188: [[81], 256],
                120189: [[82], 256],
                120190: [[83], 256],
                120191: [[84], 256],
                120192: [[85], 256],
                120193: [[86], 256],
                120194: [[87], 256],
                120195: [[88], 256],
                120196: [[89], 256],
                120197: [[90], 256],
                120198: [[97], 256],
                120199: [[98], 256],
                120200: [[99], 256],
                120201: [[100], 256],
                120202: [[101], 256],
                120203: [[102], 256],
                120204: [[103], 256],
                120205: [[104], 256],
                120206: [[105], 256],
                120207: [[106], 256],
                120208: [[107], 256],
                120209: [[108], 256],
                120210: [[109], 256],
                120211: [[110], 256],
                120212: [[111], 256],
                120213: [[112], 256],
                120214: [[113], 256],
                120215: [[114], 256],
                120216: [[115], 256],
                120217: [[116], 256],
                120218: [[117], 256],
                120219: [[118], 256],
                120220: [[119], 256],
                120221: [[120], 256],
                120222: [[121], 256],
                120223: [[122], 256],
                120224: [[65], 256],
                120225: [[66], 256],
                120226: [[67], 256],
                120227: [[68], 256],
                120228: [[69], 256],
                120229: [[70], 256],
                120230: [[71], 256],
                120231: [[72], 256],
                120232: [[73], 256],
                120233: [[74], 256],
                120234: [[75], 256],
                120235: [[76], 256],
                120236: [[77], 256],
                120237: [[78], 256],
                120238: [[79], 256],
                120239: [[80], 256],
                120240: [[81], 256],
                120241: [[82], 256],
                120242: [[83], 256],
                120243: [[84], 256],
                120244: [[85], 256],
                120245: [[86], 256],
                120246: [[87], 256],
                120247: [[88], 256],
                120248: [[89], 256],
                120249: [[90], 256],
                120250: [[97], 256],
                120251: [[98], 256],
                120252: [[99], 256],
                120253: [[100], 256],
                120254: [[101], 256],
                120255: [[102], 256],
                120256: [[103], 256],
                120257: [[104], 256],
                120258: [[105], 256],
                120259: [[106], 256],
                120260: [[107], 256],
                120261: [[108], 256],
                120262: [[109], 256],
                120263: [[110], 256],
                120264: [[111], 256],
                120265: [[112], 256],
                120266: [[113], 256],
                120267: [[114], 256],
                120268: [[115], 256],
                120269: [[116], 256],
                120270: [[117], 256],
                120271: [[118], 256],
                120272: [[119], 256],
                120273: [[120], 256],
                120274: [[121], 256],
                120275: [[122], 256],
                120276: [[65], 256],
                120277: [[66], 256],
                120278: [[67], 256],
                120279: [[68], 256],
                120280: [[69], 256],
                120281: [[70], 256],
                120282: [[71], 256],
                120283: [[72], 256],
                120284: [[73], 256],
                120285: [[74], 256],
                120286: [[75], 256],
                120287: [[76], 256],
                120288: [[77], 256],
                120289: [[78], 256],
                120290: [[79], 256],
                120291: [[80], 256],
                120292: [[81], 256],
                120293: [[82], 256],
                120294: [[83], 256],
                120295: [[84], 256],
                120296: [[85], 256],
                120297: [[86], 256],
                120298: [[87], 256],
                120299: [[88], 256],
                120300: [[89], 256],
                120301: [[90], 256],
                120302: [[97], 256],
                120303: [[98], 256],
                120304: [[99], 256],
                120305: [[100], 256],
                120306: [[101], 256],
                120307: [[102], 256],
                120308: [[103], 256],
                120309: [[104], 256],
                120310: [[105], 256],
                120311: [[106], 256],
                120312: [[107], 256],
                120313: [[108], 256],
                120314: [[109], 256],
                120315: [[110], 256],
                120316: [[111], 256],
                120317: [[112], 256],
                120318: [[113], 256],
                120319: [[114], 256]
              },
              54784: {
                120320: [[115], 256],
                120321: [[116], 256],
                120322: [[117], 256],
                120323: [[118], 256],
                120324: [[119], 256],
                120325: [[120], 256],
                120326: [[121], 256],
                120327: [[122], 256],
                120328: [[65], 256],
                120329: [[66], 256],
                120330: [[67], 256],
                120331: [[68], 256],
                120332: [[69], 256],
                120333: [[70], 256],
                120334: [[71], 256],
                120335: [[72], 256],
                120336: [[73], 256],
                120337: [[74], 256],
                120338: [[75], 256],
                120339: [[76], 256],
                120340: [[77], 256],
                120341: [[78], 256],
                120342: [[79], 256],
                120343: [[80], 256],
                120344: [[81], 256],
                120345: [[82], 256],
                120346: [[83], 256],
                120347: [[84], 256],
                120348: [[85], 256],
                120349: [[86], 256],
                120350: [[87], 256],
                120351: [[88], 256],
                120352: [[89], 256],
                120353: [[90], 256],
                120354: [[97], 256],
                120355: [[98], 256],
                120356: [[99], 256],
                120357: [[100], 256],
                120358: [[101], 256],
                120359: [[102], 256],
                120360: [[103], 256],
                120361: [[104], 256],
                120362: [[105], 256],
                120363: [[106], 256],
                120364: [[107], 256],
                120365: [[108], 256],
                120366: [[109], 256],
                120367: [[110], 256],
                120368: [[111], 256],
                120369: [[112], 256],
                120370: [[113], 256],
                120371: [[114], 256],
                120372: [[115], 256],
                120373: [[116], 256],
                120374: [[117], 256],
                120375: [[118], 256],
                120376: [[119], 256],
                120377: [[120], 256],
                120378: [[121], 256],
                120379: [[122], 256],
                120380: [[65], 256],
                120381: [[66], 256],
                120382: [[67], 256],
                120383: [[68], 256],
                120384: [[69], 256],
                120385: [[70], 256],
                120386: [[71], 256],
                120387: [[72], 256],
                120388: [[73], 256],
                120389: [[74], 256],
                120390: [[75], 256],
                120391: [[76], 256],
                120392: [[77], 256],
                120393: [[78], 256],
                120394: [[79], 256],
                120395: [[80], 256],
                120396: [[81], 256],
                120397: [[82], 256],
                120398: [[83], 256],
                120399: [[84], 256],
                120400: [[85], 256],
                120401: [[86], 256],
                120402: [[87], 256],
                120403: [[88], 256],
                120404: [[89], 256],
                120405: [[90], 256],
                120406: [[97], 256],
                120407: [[98], 256],
                120408: [[99], 256],
                120409: [[100], 256],
                120410: [[101], 256],
                120411: [[102], 256],
                120412: [[103], 256],
                120413: [[104], 256],
                120414: [[105], 256],
                120415: [[106], 256],
                120416: [[107], 256],
                120417: [[108], 256],
                120418: [[109], 256],
                120419: [[110], 256],
                120420: [[111], 256],
                120421: [[112], 256],
                120422: [[113], 256],
                120423: [[114], 256],
                120424: [[115], 256],
                120425: [[116], 256],
                120426: [[117], 256],
                120427: [[118], 256],
                120428: [[119], 256],
                120429: [[120], 256],
                120430: [[121], 256],
                120431: [[122], 256],
                120432: [[65], 256],
                120433: [[66], 256],
                120434: [[67], 256],
                120435: [[68], 256],
                120436: [[69], 256],
                120437: [[70], 256],
                120438: [[71], 256],
                120439: [[72], 256],
                120440: [[73], 256],
                120441: [[74], 256],
                120442: [[75], 256],
                120443: [[76], 256],
                120444: [[77], 256],
                120445: [[78], 256],
                120446: [[79], 256],
                120447: [[80], 256],
                120448: [[81], 256],
                120449: [[82], 256],
                120450: [[83], 256],
                120451: [[84], 256],
                120452: [[85], 256],
                120453: [[86], 256],
                120454: [[87], 256],
                120455: [[88], 256],
                120456: [[89], 256],
                120457: [[90], 256],
                120458: [[97], 256],
                120459: [[98], 256],
                120460: [[99], 256],
                120461: [[100], 256],
                120462: [[101], 256],
                120463: [[102], 256],
                120464: [[103], 256],
                120465: [[104], 256],
                120466: [[105], 256],
                120467: [[106], 256],
                120468: [[107], 256],
                120469: [[108], 256],
                120470: [[109], 256],
                120471: [[110], 256],
                120472: [[111], 256],
                120473: [[112], 256],
                120474: [[113], 256],
                120475: [[114], 256],
                120476: [[115], 256],
                120477: [[116], 256],
                120478: [[117], 256],
                120479: [[118], 256],
                120480: [[119], 256],
                120481: [[120], 256],
                120482: [[121], 256],
                120483: [[122], 256],
                120484: [[305], 256],
                120485: [[567], 256],
                120488: [[913], 256],
                120489: [[914], 256],
                120490: [[915], 256],
                120491: [[916], 256],
                120492: [[917], 256],
                120493: [[918], 256],
                120494: [[919], 256],
                120495: [[920], 256],
                120496: [[921], 256],
                120497: [[922], 256],
                120498: [[923], 256],
                120499: [[924], 256],
                120500: [[925], 256],
                120501: [[926], 256],
                120502: [[927], 256],
                120503: [[928], 256],
                120504: [[929], 256],
                120505: [[1012], 256],
                120506: [[931], 256],
                120507: [[932], 256],
                120508: [[933], 256],
                120509: [[934], 256],
                120510: [[935], 256],
                120511: [[936], 256],
                120512: [[937], 256],
                120513: [[8711], 256],
                120514: [[945], 256],
                120515: [[946], 256],
                120516: [[947], 256],
                120517: [[948], 256],
                120518: [[949], 256],
                120519: [[950], 256],
                120520: [[951], 256],
                120521: [[952], 256],
                120522: [[953], 256],
                120523: [[954], 256],
                120524: [[955], 256],
                120525: [[956], 256],
                120526: [[957], 256],
                120527: [[958], 256],
                120528: [[959], 256],
                120529: [[960], 256],
                120530: [[961], 256],
                120531: [[962], 256],
                120532: [[963], 256],
                120533: [[964], 256],
                120534: [[965], 256],
                120535: [[966], 256],
                120536: [[967], 256],
                120537: [[968], 256],
                120538: [[969], 256],
                120539: [[8706], 256],
                120540: [[1013], 256],
                120541: [[977], 256],
                120542: [[1008], 256],
                120543: [[981], 256],
                120544: [[1009], 256],
                120545: [[982], 256],
                120546: [[913], 256],
                120547: [[914], 256],
                120548: [[915], 256],
                120549: [[916], 256],
                120550: [[917], 256],
                120551: [[918], 256],
                120552: [[919], 256],
                120553: [[920], 256],
                120554: [[921], 256],
                120555: [[922], 256],
                120556: [[923], 256],
                120557: [[924], 256],
                120558: [[925], 256],
                120559: [[926], 256],
                120560: [[927], 256],
                120561: [[928], 256],
                120562: [[929], 256],
                120563: [[1012], 256],
                120564: [[931], 256],
                120565: [[932], 256],
                120566: [[933], 256],
                120567: [[934], 256],
                120568: [[935], 256],
                120569: [[936], 256],
                120570: [[937], 256],
                120571: [[8711], 256],
                120572: [[945], 256],
                120573: [[946], 256],
                120574: [[947], 256],
                120575: [[948], 256]
              },
              55040: {
                120576: [[949], 256],
                120577: [[950], 256],
                120578: [[951], 256],
                120579: [[952], 256],
                120580: [[953], 256],
                120581: [[954], 256],
                120582: [[955], 256],
                120583: [[956], 256],
                120584: [[957], 256],
                120585: [[958], 256],
                120586: [[959], 256],
                120587: [[960], 256],
                120588: [[961], 256],
                120589: [[962], 256],
                120590: [[963], 256],
                120591: [[964], 256],
                120592: [[965], 256],
                120593: [[966], 256],
                120594: [[967], 256],
                120595: [[968], 256],
                120596: [[969], 256],
                120597: [[8706], 256],
                120598: [[1013], 256],
                120599: [[977], 256],
                120600: [[1008], 256],
                120601: [[981], 256],
                120602: [[1009], 256],
                120603: [[982], 256],
                120604: [[913], 256],
                120605: [[914], 256],
                120606: [[915], 256],
                120607: [[916], 256],
                120608: [[917], 256],
                120609: [[918], 256],
                120610: [[919], 256],
                120611: [[920], 256],
                120612: [[921], 256],
                120613: [[922], 256],
                120614: [[923], 256],
                120615: [[924], 256],
                120616: [[925], 256],
                120617: [[926], 256],
                120618: [[927], 256],
                120619: [[928], 256],
                120620: [[929], 256],
                120621: [[1012], 256],
                120622: [[931], 256],
                120623: [[932], 256],
                120624: [[933], 256],
                120625: [[934], 256],
                120626: [[935], 256],
                120627: [[936], 256],
                120628: [[937], 256],
                120629: [[8711], 256],
                120630: [[945], 256],
                120631: [[946], 256],
                120632: [[947], 256],
                120633: [[948], 256],
                120634: [[949], 256],
                120635: [[950], 256],
                120636: [[951], 256],
                120637: [[952], 256],
                120638: [[953], 256],
                120639: [[954], 256],
                120640: [[955], 256],
                120641: [[956], 256],
                120642: [[957], 256],
                120643: [[958], 256],
                120644: [[959], 256],
                120645: [[960], 256],
                120646: [[961], 256],
                120647: [[962], 256],
                120648: [[963], 256],
                120649: [[964], 256],
                120650: [[965], 256],
                120651: [[966], 256],
                120652: [[967], 256],
                120653: [[968], 256],
                120654: [[969], 256],
                120655: [[8706], 256],
                120656: [[1013], 256],
                120657: [[977], 256],
                120658: [[1008], 256],
                120659: [[981], 256],
                120660: [[1009], 256],
                120661: [[982], 256],
                120662: [[913], 256],
                120663: [[914], 256],
                120664: [[915], 256],
                120665: [[916], 256],
                120666: [[917], 256],
                120667: [[918], 256],
                120668: [[919], 256],
                120669: [[920], 256],
                120670: [[921], 256],
                120671: [[922], 256],
                120672: [[923], 256],
                120673: [[924], 256],
                120674: [[925], 256],
                120675: [[926], 256],
                120676: [[927], 256],
                120677: [[928], 256],
                120678: [[929], 256],
                120679: [[1012], 256],
                120680: [[931], 256],
                120681: [[932], 256],
                120682: [[933], 256],
                120683: [[934], 256],
                120684: [[935], 256],
                120685: [[936], 256],
                120686: [[937], 256],
                120687: [[8711], 256],
                120688: [[945], 256],
                120689: [[946], 256],
                120690: [[947], 256],
                120691: [[948], 256],
                120692: [[949], 256],
                120693: [[950], 256],
                120694: [[951], 256],
                120695: [[952], 256],
                120696: [[953], 256],
                120697: [[954], 256],
                120698: [[955], 256],
                120699: [[956], 256],
                120700: [[957], 256],
                120701: [[958], 256],
                120702: [[959], 256],
                120703: [[960], 256],
                120704: [[961], 256],
                120705: [[962], 256],
                120706: [[963], 256],
                120707: [[964], 256],
                120708: [[965], 256],
                120709: [[966], 256],
                120710: [[967], 256],
                120711: [[968], 256],
                120712: [[969], 256],
                120713: [[8706], 256],
                120714: [[1013], 256],
                120715: [[977], 256],
                120716: [[1008], 256],
                120717: [[981], 256],
                120718: [[1009], 256],
                120719: [[982], 256],
                120720: [[913], 256],
                120721: [[914], 256],
                120722: [[915], 256],
                120723: [[916], 256],
                120724: [[917], 256],
                120725: [[918], 256],
                120726: [[919], 256],
                120727: [[920], 256],
                120728: [[921], 256],
                120729: [[922], 256],
                120730: [[923], 256],
                120731: [[924], 256],
                120732: [[925], 256],
                120733: [[926], 256],
                120734: [[927], 256],
                120735: [[928], 256],
                120736: [[929], 256],
                120737: [[1012], 256],
                120738: [[931], 256],
                120739: [[932], 256],
                120740: [[933], 256],
                120741: [[934], 256],
                120742: [[935], 256],
                120743: [[936], 256],
                120744: [[937], 256],
                120745: [[8711], 256],
                120746: [[945], 256],
                120747: [[946], 256],
                120748: [[947], 256],
                120749: [[948], 256],
                120750: [[949], 256],
                120751: [[950], 256],
                120752: [[951], 256],
                120753: [[952], 256],
                120754: [[953], 256],
                120755: [[954], 256],
                120756: [[955], 256],
                120757: [[956], 256],
                120758: [[957], 256],
                120759: [[958], 256],
                120760: [[959], 256],
                120761: [[960], 256],
                120762: [[961], 256],
                120763: [[962], 256],
                120764: [[963], 256],
                120765: [[964], 256],
                120766: [[965], 256],
                120767: [[966], 256],
                120768: [[967], 256],
                120769: [[968], 256],
                120770: [[969], 256],
                120771: [[8706], 256],
                120772: [[1013], 256],
                120773: [[977], 256],
                120774: [[1008], 256],
                120775: [[981], 256],
                120776: [[1009], 256],
                120777: [[982], 256],
                120778: [[988], 256],
                120779: [[989], 256],
                120782: [[48], 256],
                120783: [[49], 256],
                120784: [[50], 256],
                120785: [[51], 256],
                120786: [[52], 256],
                120787: [[53], 256],
                120788: [[54], 256],
                120789: [[55], 256],
                120790: [[56], 256],
                120791: [[57], 256],
                120792: [[48], 256],
                120793: [[49], 256],
                120794: [[50], 256],
                120795: [[51], 256],
                120796: [[52], 256],
                120797: [[53], 256],
                120798: [[54], 256],
                120799: [[55], 256],
                120800: [[56], 256],
                120801: [[57], 256],
                120802: [[48], 256],
                120803: [[49], 256],
                120804: [[50], 256],
                120805: [[51], 256],
                120806: [[52], 256],
                120807: [[53], 256],
                120808: [[54], 256],
                120809: [[55], 256],
                120810: [[56], 256],
                120811: [[57], 256],
                120812: [[48], 256],
                120813: [[49], 256],
                120814: [[50], 256],
                120815: [[51], 256],
                120816: [[52], 256],
                120817: [[53], 256],
                120818: [[54], 256],
                120819: [[55], 256],
                120820: [[56], 256],
                120821: [[57], 256],
                120822: [[48], 256],
                120823: [[49], 256],
                120824: [[50], 256],
                120825: [[51], 256],
                120826: [[52], 256],
                120827: [[53], 256],
                120828: [[54], 256],
                120829: [[55], 256],
                120830: [[56], 256],
                120831: [[57], 256]
              },
              59392: {
                125136: [, 220],
                125137: [, 220],
                125138: [, 220],
                125139: [, 220],
                125140: [, 220],
                125141: [, 220],
                125142: [, 220]
              },
              60928: {
                126464: [[1575], 256],
                126465: [[1576], 256],
                126466: [[1580], 256],
                126467: [[1583], 256],
                126469: [[1608], 256],
                126470: [[1586], 256],
                126471: [[1581], 256],
                126472: [[1591], 256],
                126473: [[1610], 256],
                126474: [[1603], 256],
                126475: [[1604], 256],
                126476: [[1605], 256],
                126477: [[1606], 256],
                126478: [[1587], 256],
                126479: [[1593], 256],
                126480: [[1601], 256],
                126481: [[1589], 256],
                126482: [[1602], 256],
                126483: [[1585], 256],
                126484: [[1588], 256],
                126485: [[1578], 256],
                126486: [[1579], 256],
                126487: [[1582], 256],
                126488: [[1584], 256],
                126489: [[1590], 256],
                126490: [[1592], 256],
                126491: [[1594], 256],
                126492: [[1646], 256],
                126493: [[1722], 256],
                126494: [[1697], 256],
                126495: [[1647], 256],
                126497: [[1576], 256],
                126498: [[1580], 256],
                126500: [[1607], 256],
                126503: [[1581], 256],
                126505: [[1610], 256],
                126506: [[1603], 256],
                126507: [[1604], 256],
                126508: [[1605], 256],
                126509: [[1606], 256],
                126510: [[1587], 256],
                126511: [[1593], 256],
                126512: [[1601], 256],
                126513: [[1589], 256],
                126514: [[1602], 256],
                126516: [[1588], 256],
                126517: [[1578], 256],
                126518: [[1579], 256],
                126519: [[1582], 256],
                126521: [[1590], 256],
                126523: [[1594], 256],
                126530: [[1580], 256],
                126535: [[1581], 256],
                126537: [[1610], 256],
                126539: [[1604], 256],
                126541: [[1606], 256],
                126542: [[1587], 256],
                126543: [[1593], 256],
                126545: [[1589], 256],
                126546: [[1602], 256],
                126548: [[1588], 256],
                126551: [[1582], 256],
                126553: [[1590], 256],
                126555: [[1594], 256],
                126557: [[1722], 256],
                126559: [[1647], 256],
                126561: [[1576], 256],
                126562: [[1580], 256],
                126564: [[1607], 256],
                126567: [[1581], 256],
                126568: [[1591], 256],
                126569: [[1610], 256],
                126570: [[1603], 256],
                126572: [[1605], 256],
                126573: [[1606], 256],
                126574: [[1587], 256],
                126575: [[1593], 256],
                126576: [[1601], 256],
                126577: [[1589], 256],
                126578: [[1602], 256],
                126580: [[1588], 256],
                126581: [[1578], 256],
                126582: [[1579], 256],
                126583: [[1582], 256],
                126585: [[1590], 256],
                126586: [[1592], 256],
                126587: [[1594], 256],
                126588: [[1646], 256],
                126590: [[1697], 256],
                126592: [[1575], 256],
                126593: [[1576], 256],
                126594: [[1580], 256],
                126595: [[1583], 256],
                126596: [[1607], 256],
                126597: [[1608], 256],
                126598: [[1586], 256],
                126599: [[1581], 256],
                126600: [[1591], 256],
                126601: [[1610], 256],
                126603: [[1604], 256],
                126604: [[1605], 256],
                126605: [[1606], 256],
                126606: [[1587], 256],
                126607: [[1593], 256],
                126608: [[1601], 256],
                126609: [[1589], 256],
                126610: [[1602], 256],
                126611: [[1585], 256],
                126612: [[1588], 256],
                126613: [[1578], 256],
                126614: [[1579], 256],
                126615: [[1582], 256],
                126616: [[1584], 256],
                126617: [[1590], 256],
                126618: [[1592], 256],
                126619: [[1594], 256],
                126625: [[1576], 256],
                126626: [[1580], 256],
                126627: [[1583], 256],
                126629: [[1608], 256],
                126630: [[1586], 256],
                126631: [[1581], 256],
                126632: [[1591], 256],
                126633: [[1610], 256],
                126635: [[1604], 256],
                126636: [[1605], 256],
                126637: [[1606], 256],
                126638: [[1587], 256],
                126639: [[1593], 256],
                126640: [[1601], 256],
                126641: [[1589], 256],
                126642: [[1602], 256],
                126643: [[1585], 256],
                126644: [[1588], 256],
                126645: [[1578], 256],
                126646: [[1579], 256],
                126647: [[1582], 256],
                126648: [[1584], 256],
                126649: [[1590], 256],
                126650: [[1592], 256],
                126651: [[1594], 256]
              },
              61696: {
                127232: [[48, 46], 256],
                127233: [[48, 44], 256],
                127234: [[49, 44], 256],
                127235: [[50, 44], 256],
                127236: [[51, 44], 256],
                127237: [[52, 44], 256],
                127238: [[53, 44], 256],
                127239: [[54, 44], 256],
                127240: [[55, 44], 256],
                127241: [[56, 44], 256],
                127242: [[57, 44], 256],
                127248: [[40, 65, 41], 256],
                127249: [[40, 66, 41], 256],
                127250: [[40, 67, 41], 256],
                127251: [[40, 68, 41], 256],
                127252: [[40, 69, 41], 256],
                127253: [[40, 70, 41], 256],
                127254: [[40, 71, 41], 256],
                127255: [[40, 72, 41], 256],
                127256: [[40, 73, 41], 256],
                127257: [[40, 74, 41], 256],
                127258: [[40, 75, 41], 256],
                127259: [[40, 76, 41], 256],
                127260: [[40, 77, 41], 256],
                127261: [[40, 78, 41], 256],
                127262: [[40, 79, 41], 256],
                127263: [[40, 80, 41], 256],
                127264: [[40, 81, 41], 256],
                127265: [[40, 82, 41], 256],
                127266: [[40, 83, 41], 256],
                127267: [[40, 84, 41], 256],
                127268: [[40, 85, 41], 256],
                127269: [[40, 86, 41], 256],
                127270: [[40, 87, 41], 256],
                127271: [[40, 88, 41], 256],
                127272: [[40, 89, 41], 256],
                127273: [[40, 90, 41], 256],
                127274: [[12308, 83, 12309], 256],
                127275: [[67], 256],
                127276: [[82], 256],
                127277: [[67, 68], 256],
                127278: [[87, 90], 256],
                127280: [[65], 256],
                127281: [[66], 256],
                127282: [[67], 256],
                127283: [[68], 256],
                127284: [[69], 256],
                127285: [[70], 256],
                127286: [[71], 256],
                127287: [[72], 256],
                127288: [[73], 256],
                127289: [[74], 256],
                127290: [[75], 256],
                127291: [[76], 256],
                127292: [[77], 256],
                127293: [[78], 256],
                127294: [[79], 256],
                127295: [[80], 256],
                127296: [[81], 256],
                127297: [[82], 256],
                127298: [[83], 256],
                127299: [[84], 256],
                127300: [[85], 256],
                127301: [[86], 256],
                127302: [[87], 256],
                127303: [[88], 256],
                127304: [[89], 256],
                127305: [[90], 256],
                127306: [[72, 86], 256],
                127307: [[77, 86], 256],
                127308: [[83, 68], 256],
                127309: [[83, 83], 256],
                127310: [[80, 80, 86], 256],
                127311: [[87, 67], 256],
                127338: [[77, 67], 256],
                127339: [[77, 68], 256],
                127376: [[68, 74], 256]
              },
              61952: {
                127488: [[12411, 12363], 256],
                127489: [[12467, 12467], 256],
                127490: [[12469], 256],
                127504: [[25163], 256],
                127505: [[23383], 256],
                127506: [[21452], 256],
                127507: [[12487], 256],
                127508: [[20108], 256],
                127509: [[22810], 256],
                127510: [[35299], 256],
                127511: [[22825], 256],
                127512: [[20132], 256],
                127513: [[26144], 256],
                127514: [[28961], 256],
                127515: [[26009], 256],
                127516: [[21069], 256],
                127517: [[24460], 256],
                127518: [[20877], 256],
                127519: [[26032], 256],
                127520: [[21021], 256],
                127521: [[32066], 256],
                127522: [[29983], 256],
                127523: [[36009], 256],
                127524: [[22768], 256],
                127525: [[21561], 256],
                127526: [[28436], 256],
                127527: [[25237], 256],
                127528: [[25429], 256],
                127529: [[19968], 256],
                127530: [[19977], 256],
                127531: [[36938], 256],
                127532: [[24038], 256],
                127533: [[20013], 256],
                127534: [[21491], 256],
                127535: [[25351], 256],
                127536: [[36208], 256],
                127537: [[25171], 256],
                127538: [[31105], 256],
                127539: [[31354], 256],
                127540: [[21512], 256],
                127541: [[28288], 256],
                127542: [[26377], 256],
                127543: [[26376], 256],
                127544: [[30003], 256],
                127545: [[21106], 256],
                127546: [[21942], 256],
                127552: [[12308, 26412, 12309], 256],
                127553: [[12308, 19977, 12309], 256],
                127554: [[12308, 20108, 12309], 256],
                127555: [[12308, 23433, 12309], 256],
                127556: [[12308, 28857, 12309], 256],
                127557: [[12308, 25171, 12309], 256],
                127558: [[12308, 30423, 12309], 256],
                127559: [[12308, 21213, 12309], 256],
                127560: [[12308, 25943, 12309], 256],
                127568: [[24471], 256],
                127569: [[21487], 256]
              },
              63488: {
                194560: [[20029]],
                194561: [[20024]],
                194562: [[20033]],
                194563: [[131362]],
                194564: [[20320]],
                194565: [[20398]],
                194566: [[20411]],
                194567: [[20482]],
                194568: [[20602]],
                194569: [[20633]],
                194570: [[20711]],
                194571: [[20687]],
                194572: [[13470]],
                194573: [[132666]],
                194574: [[20813]],
                194575: [[20820]],
                194576: [[20836]],
                194577: [[20855]],
                194578: [[132380]],
                194579: [[13497]],
                194580: [[20839]],
                194581: [[20877]],
                194582: [[132427]],
                194583: [[20887]],
                194584: [[20900]],
                194585: [[20172]],
                194586: [[20908]],
                194587: [[20917]],
                194588: [[168415]],
                194589: [[20981]],
                194590: [[20995]],
                194591: [[13535]],
                194592: [[21051]],
                194593: [[21062]],
                194594: [[21106]],
                194595: [[21111]],
                194596: [[13589]],
                194597: [[21191]],
                194598: [[21193]],
                194599: [[21220]],
                194600: [[21242]],
                194601: [[21253]],
                194602: [[21254]],
                194603: [[21271]],
                194604: [[21321]],
                194605: [[21329]],
                194606: [[21338]],
                194607: [[21363]],
                194608: [[21373]],
                194609: [[21375]],
                194610: [[21375]],
                194611: [[21375]],
                194612: [[133676]],
                194613: [[28784]],
                194614: [[21450]],
                194615: [[21471]],
                194616: [[133987]],
                194617: [[21483]],
                194618: [[21489]],
                194619: [[21510]],
                194620: [[21662]],
                194621: [[21560]],
                194622: [[21576]],
                194623: [[21608]],
                194624: [[21666]],
                194625: [[21750]],
                194626: [[21776]],
                194627: [[21843]],
                194628: [[21859]],
                194629: [[21892]],
                194630: [[21892]],
                194631: [[21913]],
                194632: [[21931]],
                194633: [[21939]],
                194634: [[21954]],
                194635: [[22294]],
                194636: [[22022]],
                194637: [[22295]],
                194638: [[22097]],
                194639: [[22132]],
                194640: [[20999]],
                194641: [[22766]],
                194642: [[22478]],
                194643: [[22516]],
                194644: [[22541]],
                194645: [[22411]],
                194646: [[22578]],
                194647: [[22577]],
                194648: [[22700]],
                194649: [[136420]],
                194650: [[22770]],
                194651: [[22775]],
                194652: [[22790]],
                194653: [[22810]],
                194654: [[22818]],
                194655: [[22882]],
                194656: [[136872]],
                194657: [[136938]],
                194658: [[23020]],
                194659: [[23067]],
                194660: [[23079]],
                194661: [[23e3]],
                194662: [[23142]],
                194663: [[14062]],
                194664: [[14076]],
                194665: [[23304]],
                194666: [[23358]],
                194667: [[23358]],
                194668: [[137672]],
                194669: [[23491]],
                194670: [[23512]],
                194671: [[23527]],
                194672: [[23539]],
                194673: [[138008]],
                194674: [[23551]],
                194675: [[23558]],
                194676: [[24403]],
                194677: [[23586]],
                194678: [[14209]],
                194679: [[23648]],
                194680: [[23662]],
                194681: [[23744]],
                194682: [[23693]],
                194683: [[138724]],
                194684: [[23875]],
                194685: [[138726]],
                194686: [[23918]],
                194687: [[23915]],
                194688: [[23932]],
                194689: [[24033]],
                194690: [[24034]],
                194691: [[14383]],
                194692: [[24061]],
                194693: [[24104]],
                194694: [[24125]],
                194695: [[24169]],
                194696: [[14434]],
                194697: [[139651]],
                194698: [[14460]],
                194699: [[24240]],
                194700: [[24243]],
                194701: [[24246]],
                194702: [[24266]],
                194703: [[172946]],
                194704: [[24318]],
                194705: [[140081]],
                194706: [[140081]],
                194707: [[33281]],
                194708: [[24354]],
                194709: [[24354]],
                194710: [[14535]],
                194711: [[144056]],
                194712: [[156122]],
                194713: [[24418]],
                194714: [[24427]],
                194715: [[14563]],
                194716: [[24474]],
                194717: [[24525]],
                194718: [[24535]],
                194719: [[24569]],
                194720: [[24705]],
                194721: [[14650]],
                194722: [[14620]],
                194723: [[24724]],
                194724: [[141012]],
                194725: [[24775]],
                194726: [[24904]],
                194727: [[24908]],
                194728: [[24910]],
                194729: [[24908]],
                194730: [[24954]],
                194731: [[24974]],
                194732: [[25010]],
                194733: [[24996]],
                194734: [[25007]],
                194735: [[25054]],
                194736: [[25074]],
                194737: [[25078]],
                194738: [[25104]],
                194739: [[25115]],
                194740: [[25181]],
                194741: [[25265]],
                194742: [[25300]],
                194743: [[25424]],
                194744: [[142092]],
                194745: [[25405]],
                194746: [[25340]],
                194747: [[25448]],
                194748: [[25475]],
                194749: [[25572]],
                194750: [[142321]],
                194751: [[25634]],
                194752: [[25541]],
                194753: [[25513]],
                194754: [[14894]],
                194755: [[25705]],
                194756: [[25726]],
                194757: [[25757]],
                194758: [[25719]],
                194759: [[14956]],
                194760: [[25935]],
                194761: [[25964]],
                194762: [[143370]],
                194763: [[26083]],
                194764: [[26360]],
                194765: [[26185]],
                194766: [[15129]],
                194767: [[26257]],
                194768: [[15112]],
                194769: [[15076]],
                194770: [[20882]],
                194771: [[20885]],
                194772: [[26368]],
                194773: [[26268]],
                194774: [[32941]],
                194775: [[17369]],
                194776: [[26391]],
                194777: [[26395]],
                194778: [[26401]],
                194779: [[26462]],
                194780: [[26451]],
                194781: [[144323]],
                194782: [[15177]],
                194783: [[26618]],
                194784: [[26501]],
                194785: [[26706]],
                194786: [[26757]],
                194787: [[144493]],
                194788: [[26766]],
                194789: [[26655]],
                194790: [[26900]],
                194791: [[15261]],
                194792: [[26946]],
                194793: [[27043]],
                194794: [[27114]],
                194795: [[27304]],
                194796: [[145059]],
                194797: [[27355]],
                194798: [[15384]],
                194799: [[27425]],
                194800: [[145575]],
                194801: [[27476]],
                194802: [[15438]],
                194803: [[27506]],
                194804: [[27551]],
                194805: [[27578]],
                194806: [[27579]],
                194807: [[146061]],
                194808: [[138507]],
                194809: [[146170]],
                194810: [[27726]],
                194811: [[146620]],
                194812: [[27839]],
                194813: [[27853]],
                194814: [[27751]],
                194815: [[27926]]
              },
              63744: {
                63744: [[35912]],
                63745: [[26356]],
                63746: [[36554]],
                63747: [[36040]],
                63748: [[28369]],
                63749: [[20018]],
                63750: [[21477]],
                63751: [[40860]],
                63752: [[40860]],
                63753: [[22865]],
                63754: [[37329]],
                63755: [[21895]],
                63756: [[22856]],
                63757: [[25078]],
                63758: [[30313]],
                63759: [[32645]],
                63760: [[34367]],
                63761: [[34746]],
                63762: [[35064]],
                63763: [[37007]],
                63764: [[27138]],
                63765: [[27931]],
                63766: [[28889]],
                63767: [[29662]],
                63768: [[33853]],
                63769: [[37226]],
                63770: [[39409]],
                63771: [[20098]],
                63772: [[21365]],
                63773: [[27396]],
                63774: [[29211]],
                63775: [[34349]],
                63776: [[40478]],
                63777: [[23888]],
                63778: [[28651]],
                63779: [[34253]],
                63780: [[35172]],
                63781: [[25289]],
                63782: [[33240]],
                63783: [[34847]],
                63784: [[24266]],
                63785: [[26391]],
                63786: [[28010]],
                63787: [[29436]],
                63788: [[37070]],
                63789: [[20358]],
                63790: [[20919]],
                63791: [[21214]],
                63792: [[25796]],
                63793: [[27347]],
                63794: [[29200]],
                63795: [[30439]],
                63796: [[32769]],
                63797: [[34310]],
                63798: [[34396]],
                63799: [[36335]],
                63800: [[38706]],
                63801: [[39791]],
                63802: [[40442]],
                63803: [[30860]],
                63804: [[31103]],
                63805: [[32160]],
                63806: [[33737]],
                63807: [[37636]],
                63808: [[40575]],
                63809: [[35542]],
                63810: [[22751]],
                63811: [[24324]],
                63812: [[31840]],
                63813: [[32894]],
                63814: [[29282]],
                63815: [[30922]],
                63816: [[36034]],
                63817: [[38647]],
                63818: [[22744]],
                63819: [[23650]],
                63820: [[27155]],
                63821: [[28122]],
                63822: [[28431]],
                63823: [[32047]],
                63824: [[32311]],
                63825: [[38475]],
                63826: [[21202]],
                63827: [[32907]],
                63828: [[20956]],
                63829: [[20940]],
                63830: [[31260]],
                63831: [[32190]],
                63832: [[33777]],
                63833: [[38517]],
                63834: [[35712]],
                63835: [[25295]],
                63836: [[27138]],
                63837: [[35582]],
                63838: [[20025]],
                63839: [[23527]],
                63840: [[24594]],
                63841: [[29575]],
                63842: [[30064]],
                63843: [[21271]],
                63844: [[30971]],
                63845: [[20415]],
                63846: [[24489]],
                63847: [[19981]],
                63848: [[27852]],
                63849: [[25976]],
                63850: [[32034]],
                63851: [[21443]],
                63852: [[22622]],
                63853: [[30465]],
                63854: [[33865]],
                63855: [[35498]],
                63856: [[27578]],
                63857: [[36784]],
                63858: [[27784]],
                63859: [[25342]],
                63860: [[33509]],
                63861: [[25504]],
                63862: [[30053]],
                63863: [[20142]],
                63864: [[20841]],
                63865: [[20937]],
                63866: [[26753]],
                63867: [[31975]],
                63868: [[33391]],
                63869: [[35538]],
                63870: [[37327]],
                63871: [[21237]],
                63872: [[21570]],
                63873: [[22899]],
                63874: [[24300]],
                63875: [[26053]],
                63876: [[28670]],
                63877: [[31018]],
                63878: [[38317]],
                63879: [[39530]],
                63880: [[40599]],
                63881: [[40654]],
                63882: [[21147]],
                63883: [[26310]],
                63884: [[27511]],
                63885: [[36706]],
                63886: [[24180]],
                63887: [[24976]],
                63888: [[25088]],
                63889: [[25754]],
                63890: [[28451]],
                63891: [[29001]],
                63892: [[29833]],
                63893: [[31178]],
                63894: [[32244]],
                63895: [[32879]],
                63896: [[36646]],
                63897: [[34030]],
                63898: [[36899]],
                63899: [[37706]],
                63900: [[21015]],
                63901: [[21155]],
                63902: [[21693]],
                63903: [[28872]],
                63904: [[35010]],
                63905: [[35498]],
                63906: [[24265]],
                63907: [[24565]],
                63908: [[25467]],
                63909: [[27566]],
                63910: [[31806]],
                63911: [[29557]],
                63912: [[20196]],
                63913: [[22265]],
                63914: [[23527]],
                63915: [[23994]],
                63916: [[24604]],
                63917: [[29618]],
                63918: [[29801]],
                63919: [[32666]],
                63920: [[32838]],
                63921: [[37428]],
                63922: [[38646]],
                63923: [[38728]],
                63924: [[38936]],
                63925: [[20363]],
                63926: [[31150]],
                63927: [[37300]],
                63928: [[38584]],
                63929: [[24801]],
                63930: [[20102]],
                63931: [[20698]],
                63932: [[23534]],
                63933: [[23615]],
                63934: [[26009]],
                63935: [[27138]],
                63936: [[29134]],
                63937: [[30274]],
                63938: [[34044]],
                63939: [[36988]],
                63940: [[40845]],
                63941: [[26248]],
                63942: [[38446]],
                63943: [[21129]],
                63944: [[26491]],
                63945: [[26611]],
                63946: [[27969]],
                63947: [[28316]],
                63948: [[29705]],
                63949: [[30041]],
                63950: [[30827]],
                63951: [[32016]],
                63952: [[39006]],
                63953: [[20845]],
                63954: [[25134]],
                63955: [[38520]],
                63956: [[20523]],
                63957: [[23833]],
                63958: [[28138]],
                63959: [[36650]],
                63960: [[24459]],
                63961: [[24900]],
                63962: [[26647]],
                63963: [[29575]],
                63964: [[38534]],
                63965: [[21033]],
                63966: [[21519]],
                63967: [[23653]],
                63968: [[26131]],
                63969: [[26446]],
                63970: [[26792]],
                63971: [[27877]],
                63972: [[29702]],
                63973: [[30178]],
                63974: [[32633]],
                63975: [[35023]],
                63976: [[35041]],
                63977: [[37324]],
                63978: [[38626]],
                63979: [[21311]],
                63980: [[28346]],
                63981: [[21533]],
                63982: [[29136]],
                63983: [[29848]],
                63984: [[34298]],
                63985: [[38563]],
                63986: [[40023]],
                63987: [[40607]],
                63988: [[26519]],
                63989: [[28107]],
                63990: [[33256]],
                63991: [[31435]],
                63992: [[31520]],
                63993: [[31890]],
                63994: [[29376]],
                63995: [[28825]],
                63996: [[35672]],
                63997: [[20160]],
                63998: [[33590]],
                63999: [[21050]],
                194816: [[27966]],
                194817: [[28023]],
                194818: [[27969]],
                194819: [[28009]],
                194820: [[28024]],
                194821: [[28037]],
                194822: [[146718]],
                194823: [[27956]],
                194824: [[28207]],
                194825: [[28270]],
                194826: [[15667]],
                194827: [[28363]],
                194828: [[28359]],
                194829: [[147153]],
                194830: [[28153]],
                194831: [[28526]],
                194832: [[147294]],
                194833: [[147342]],
                194834: [[28614]],
                194835: [[28729]],
                194836: [[28702]],
                194837: [[28699]],
                194838: [[15766]],
                194839: [[28746]],
                194840: [[28797]],
                194841: [[28791]],
                194842: [[28845]],
                194843: [[132389]],
                194844: [[28997]],
                194845: [[148067]],
                194846: [[29084]],
                194847: [[148395]],
                194848: [[29224]],
                194849: [[29237]],
                194850: [[29264]],
                194851: [[149e3]],
                194852: [[29312]],
                194853: [[29333]],
                194854: [[149301]],
                194855: [[149524]],
                194856: [[29562]],
                194857: [[29579]],
                194858: [[16044]],
                194859: [[29605]],
                194860: [[16056]],
                194861: [[16056]],
                194862: [[29767]],
                194863: [[29788]],
                194864: [[29809]],
                194865: [[29829]],
                194866: [[29898]],
                194867: [[16155]],
                194868: [[29988]],
                194869: [[150582]],
                194870: [[30014]],
                194871: [[150674]],
                194872: [[30064]],
                194873: [[139679]],
                194874: [[30224]],
                194875: [[151457]],
                194876: [[151480]],
                194877: [[151620]],
                194878: [[16380]],
                194879: [[16392]],
                194880: [[30452]],
                194881: [[151795]],
                194882: [[151794]],
                194883: [[151833]],
                194884: [[151859]],
                194885: [[30494]],
                194886: [[30495]],
                194887: [[30495]],
                194888: [[30538]],
                194889: [[16441]],
                194890: [[30603]],
                194891: [[16454]],
                194892: [[16534]],
                194893: [[152605]],
                194894: [[30798]],
                194895: [[30860]],
                194896: [[30924]],
                194897: [[16611]],
                194898: [[153126]],
                194899: [[31062]],
                194900: [[153242]],
                194901: [[153285]],
                194902: [[31119]],
                194903: [[31211]],
                194904: [[16687]],
                194905: [[31296]],
                194906: [[31306]],
                194907: [[31311]],
                194908: [[153980]],
                194909: [[154279]],
                194910: [[154279]],
                194911: [[31470]],
                194912: [[16898]],
                194913: [[154539]],
                194914: [[31686]],
                194915: [[31689]],
                194916: [[16935]],
                194917: [[154752]],
                194918: [[31954]],
                194919: [[17056]],
                194920: [[31976]],
                194921: [[31971]],
                194922: [[32e3]],
                194923: [[155526]],
                194924: [[32099]],
                194925: [[17153]],
                194926: [[32199]],
                194927: [[32258]],
                194928: [[32325]],
                194929: [[17204]],
                194930: [[156200]],
                194931: [[156231]],
                194932: [[17241]],
                194933: [[156377]],
                194934: [[32634]],
                194935: [[156478]],
                194936: [[32661]],
                194937: [[32762]],
                194938: [[32773]],
                194939: [[156890]],
                194940: [[156963]],
                194941: [[32864]],
                194942: [[157096]],
                194943: [[32880]],
                194944: [[144223]],
                194945: [[17365]],
                194946: [[32946]],
                194947: [[33027]],
                194948: [[17419]],
                194949: [[33086]],
                194950: [[23221]],
                194951: [[157607]],
                194952: [[157621]],
                194953: [[144275]],
                194954: [[144284]],
                194955: [[33281]],
                194956: [[33284]],
                194957: [[36766]],
                194958: [[17515]],
                194959: [[33425]],
                194960: [[33419]],
                194961: [[33437]],
                194962: [[21171]],
                194963: [[33457]],
                194964: [[33459]],
                194965: [[33469]],
                194966: [[33510]],
                194967: [[158524]],
                194968: [[33509]],
                194969: [[33565]],
                194970: [[33635]],
                194971: [[33709]],
                194972: [[33571]],
                194973: [[33725]],
                194974: [[33767]],
                194975: [[33879]],
                194976: [[33619]],
                194977: [[33738]],
                194978: [[33740]],
                194979: [[33756]],
                194980: [[158774]],
                194981: [[159083]],
                194982: [[158933]],
                194983: [[17707]],
                194984: [[34033]],
                194985: [[34035]],
                194986: [[34070]],
                194987: [[160714]],
                194988: [[34148]],
                194989: [[159532]],
                194990: [[17757]],
                194991: [[17761]],
                194992: [[159665]],
                194993: [[159954]],
                194994: [[17771]],
                194995: [[34384]],
                194996: [[34396]],
                194997: [[34407]],
                194998: [[34409]],
                194999: [[34473]],
                195000: [[34440]],
                195001: [[34574]],
                195002: [[34530]],
                195003: [[34681]],
                195004: [[34600]],
                195005: [[34667]],
                195006: [[34694]],
                195007: [[17879]],
                195008: [[34785]],
                195009: [[34817]],
                195010: [[17913]],
                195011: [[34912]],
                195012: [[34915]],
                195013: [[161383]],
                195014: [[35031]],
                195015: [[35038]],
                195016: [[17973]],
                195017: [[35066]],
                195018: [[13499]],
                195019: [[161966]],
                195020: [[162150]],
                195021: [[18110]],
                195022: [[18119]],
                195023: [[35488]],
                195024: [[35565]],
                195025: [[35722]],
                195026: [[35925]],
                195027: [[162984]],
                195028: [[36011]],
                195029: [[36033]],
                195030: [[36123]],
                195031: [[36215]],
                195032: [[163631]],
                195033: [[133124]],
                195034: [[36299]],
                195035: [[36284]],
                195036: [[36336]],
                195037: [[133342]],
                195038: [[36564]],
                195039: [[36664]],
                195040: [[165330]],
                195041: [[165357]],
                195042: [[37012]],
                195043: [[37105]],
                195044: [[37137]],
                195045: [[165678]],
                195046: [[37147]],
                195047: [[37432]],
                195048: [[37591]],
                195049: [[37592]],
                195050: [[37500]],
                195051: [[37881]],
                195052: [[37909]],
                195053: [[166906]],
                195054: [[38283]],
                195055: [[18837]],
                195056: [[38327]],
                195057: [[167287]],
                195058: [[18918]],
                195059: [[38595]],
                195060: [[23986]],
                195061: [[38691]],
                195062: [[168261]],
                195063: [[168474]],
                195064: [[19054]],
                195065: [[19062]],
                195066: [[38880]],
                195067: [[168970]],
                195068: [[19122]],
                195069: [[169110]],
                195070: [[38923]],
                195071: [[38923]]
              },
              64000: {
                64000: [[20999]],
                64001: [[24230]],
                64002: [[25299]],
                64003: [[31958]],
                64004: [[23429]],
                64005: [[27934]],
                64006: [[26292]],
                64007: [[36667]],
                64008: [[34892]],
                64009: [[38477]],
                64010: [[35211]],
                64011: [[24275]],
                64012: [[20800]],
                64013: [[21952]],
                64016: [[22618]],
                64018: [[26228]],
                64021: [[20958]],
                64022: [[29482]],
                64023: [[30410]],
                64024: [[31036]],
                64025: [[31070]],
                64026: [[31077]],
                64027: [[31119]],
                64028: [[38742]],
                64029: [[31934]],
                64030: [[32701]],
                64032: [[34322]],
                64034: [[35576]],
                64037: [[36920]],
                64038: [[37117]],
                64042: [[39151]],
                64043: [[39164]],
                64044: [[39208]],
                64045: [[40372]],
                64046: [[37086]],
                64047: [[38583]],
                64048: [[20398]],
                64049: [[20711]],
                64050: [[20813]],
                64051: [[21193]],
                64052: [[21220]],
                64053: [[21329]],
                64054: [[21917]],
                64055: [[22022]],
                64056: [[22120]],
                64057: [[22592]],
                64058: [[22696]],
                64059: [[23652]],
                64060: [[23662]],
                64061: [[24724]],
                64062: [[24936]],
                64063: [[24974]],
                64064: [[25074]],
                64065: [[25935]],
                64066: [[26082]],
                64067: [[26257]],
                64068: [[26757]],
                64069: [[28023]],
                64070: [[28186]],
                64071: [[28450]],
                64072: [[29038]],
                64073: [[29227]],
                64074: [[29730]],
                64075: [[30865]],
                64076: [[31038]],
                64077: [[31049]],
                64078: [[31048]],
                64079: [[31056]],
                64080: [[31062]],
                64081: [[31069]],
                64082: [[31117]],
                64083: [[31118]],
                64084: [[31296]],
                64085: [[31361]],
                64086: [[31680]],
                64087: [[32244]],
                64088: [[32265]],
                64089: [[32321]],
                64090: [[32626]],
                64091: [[32773]],
                64092: [[33261]],
                64093: [[33401]],
                64094: [[33401]],
                64095: [[33879]],
                64096: [[35088]],
                64097: [[35222]],
                64098: [[35585]],
                64099: [[35641]],
                64100: [[36051]],
                64101: [[36104]],
                64102: [[36790]],
                64103: [[36920]],
                64104: [[38627]],
                64105: [[38911]],
                64106: [[38971]],
                64107: [[24693]],
                64108: [[148206]],
                64109: [[33304]],
                64112: [[20006]],
                64113: [[20917]],
                64114: [[20840]],
                64115: [[20352]],
                64116: [[20805]],
                64117: [[20864]],
                64118: [[21191]],
                64119: [[21242]],
                64120: [[21917]],
                64121: [[21845]],
                64122: [[21913]],
                64123: [[21986]],
                64124: [[22618]],
                64125: [[22707]],
                64126: [[22852]],
                64127: [[22868]],
                64128: [[23138]],
                64129: [[23336]],
                64130: [[24274]],
                64131: [[24281]],
                64132: [[24425]],
                64133: [[24493]],
                64134: [[24792]],
                64135: [[24910]],
                64136: [[24840]],
                64137: [[24974]],
                64138: [[24928]],
                64139: [[25074]],
                64140: [[25140]],
                64141: [[25540]],
                64142: [[25628]],
                64143: [[25682]],
                64144: [[25942]],
                64145: [[26228]],
                64146: [[26391]],
                64147: [[26395]],
                64148: [[26454]],
                64149: [[27513]],
                64150: [[27578]],
                64151: [[27969]],
                64152: [[28379]],
                64153: [[28363]],
                64154: [[28450]],
                64155: [[28702]],
                64156: [[29038]],
                64157: [[30631]],
                64158: [[29237]],
                64159: [[29359]],
                64160: [[29482]],
                64161: [[29809]],
                64162: [[29958]],
                64163: [[30011]],
                64164: [[30237]],
                64165: [[30239]],
                64166: [[30410]],
                64167: [[30427]],
                64168: [[30452]],
                64169: [[30538]],
                64170: [[30528]],
                64171: [[30924]],
                64172: [[31409]],
                64173: [[31680]],
                64174: [[31867]],
                64175: [[32091]],
                64176: [[32244]],
                64177: [[32574]],
                64178: [[32773]],
                64179: [[33618]],
                64180: [[33775]],
                64181: [[34681]],
                64182: [[35137]],
                64183: [[35206]],
                64184: [[35222]],
                64185: [[35519]],
                64186: [[35576]],
                64187: [[35531]],
                64188: [[35585]],
                64189: [[35582]],
                64190: [[35565]],
                64191: [[35641]],
                64192: [[35722]],
                64193: [[36104]],
                64194: [[36664]],
                64195: [[36978]],
                64196: [[37273]],
                64197: [[37494]],
                64198: [[38524]],
                64199: [[38627]],
                64200: [[38742]],
                64201: [[38875]],
                64202: [[38911]],
                64203: [[38923]],
                64204: [[38971]],
                64205: [[39698]],
                64206: [[40860]],
                64207: [[141386]],
                64208: [[141380]],
                64209: [[144341]],
                64210: [[15261]],
                64211: [[16408]],
                64212: [[16441]],
                64213: [[152137]],
                64214: [[154832]],
                64215: [[163539]],
                64216: [[40771]],
                64217: [[40846]],
                195072: [[38953]],
                195073: [[169398]],
                195074: [[39138]],
                195075: [[19251]],
                195076: [[39209]],
                195077: [[39335]],
                195078: [[39362]],
                195079: [[39422]],
                195080: [[19406]],
                195081: [[170800]],
                195082: [[39698]],
                195083: [[4e4]],
                195084: [[40189]],
                195085: [[19662]],
                195086: [[19693]],
                195087: [[40295]],
                195088: [[172238]],
                195089: [[19704]],
                195090: [[172293]],
                195091: [[172558]],
                195092: [[172689]],
                195093: [[40635]],
                195094: [[19798]],
                195095: [[40697]],
                195096: [[40702]],
                195097: [[40709]],
                195098: [[40719]],
                195099: [[40726]],
                195100: [[40763]],
                195101: [[173568]]
              },
              64256: {
                64256: [[102, 102], 256],
                64257: [[102, 105], 256],
                64258: [[102, 108], 256],
                64259: [[102, 102, 105], 256],
                64260: [[102, 102, 108], 256],
                64261: [[383, 116], 256],
                64262: [[115, 116], 256],
                64275: [[1396, 1398], 256],
                64276: [[1396, 1381], 256],
                64277: [[1396, 1387], 256],
                64278: [[1406, 1398], 256],
                64279: [[1396, 1389], 256],
                64285: [[1497, 1460], 512],
                64286: [, 26],
                64287: [[1522, 1463], 512],
                64288: [[1506], 256],
                64289: [[1488], 256],
                64290: [[1491], 256],
                64291: [[1492], 256],
                64292: [[1499], 256],
                64293: [[1500], 256],
                64294: [[1501], 256],
                64295: [[1512], 256],
                64296: [[1514], 256],
                64297: [[43], 256],
                64298: [[1513, 1473], 512],
                64299: [[1513, 1474], 512],
                64300: [[64329, 1473], 512],
                64301: [[64329, 1474], 512],
                64302: [[1488, 1463], 512],
                64303: [[1488, 1464], 512],
                64304: [[1488, 1468], 512],
                64305: [[1489, 1468], 512],
                64306: [[1490, 1468], 512],
                64307: [[1491, 1468], 512],
                64308: [[1492, 1468], 512],
                64309: [[1493, 1468], 512],
                64310: [[1494, 1468], 512],
                64312: [[1496, 1468], 512],
                64313: [[1497, 1468], 512],
                64314: [[1498, 1468], 512],
                64315: [[1499, 1468], 512],
                64316: [[1500, 1468], 512],
                64318: [[1502, 1468], 512],
                64320: [[1504, 1468], 512],
                64321: [[1505, 1468], 512],
                64323: [[1507, 1468], 512],
                64324: [[1508, 1468], 512],
                64326: [[1510, 1468], 512],
                64327: [[1511, 1468], 512],
                64328: [[1512, 1468], 512],
                64329: [[1513, 1468], 512],
                64330: [[1514, 1468], 512],
                64331: [[1493, 1465], 512],
                64332: [[1489, 1471], 512],
                64333: [[1499, 1471], 512],
                64334: [[1508, 1471], 512],
                64335: [[1488, 1500], 256],
                64336: [[1649], 256],
                64337: [[1649], 256],
                64338: [[1659], 256],
                64339: [[1659], 256],
                64340: [[1659], 256],
                64341: [[1659], 256],
                64342: [[1662], 256],
                64343: [[1662], 256],
                64344: [[1662], 256],
                64345: [[1662], 256],
                64346: [[1664], 256],
                64347: [[1664], 256],
                64348: [[1664], 256],
                64349: [[1664], 256],
                64350: [[1658], 256],
                64351: [[1658], 256],
                64352: [[1658], 256],
                64353: [[1658], 256],
                64354: [[1663], 256],
                64355: [[1663], 256],
                64356: [[1663], 256],
                64357: [[1663], 256],
                64358: [[1657], 256],
                64359: [[1657], 256],
                64360: [[1657], 256],
                64361: [[1657], 256],
                64362: [[1700], 256],
                64363: [[1700], 256],
                64364: [[1700], 256],
                64365: [[1700], 256],
                64366: [[1702], 256],
                64367: [[1702], 256],
                64368: [[1702], 256],
                64369: [[1702], 256],
                64370: [[1668], 256],
                64371: [[1668], 256],
                64372: [[1668], 256],
                64373: [[1668], 256],
                64374: [[1667], 256],
                64375: [[1667], 256],
                64376: [[1667], 256],
                64377: [[1667], 256],
                64378: [[1670], 256],
                64379: [[1670], 256],
                64380: [[1670], 256],
                64381: [[1670], 256],
                64382: [[1671], 256],
                64383: [[1671], 256],
                64384: [[1671], 256],
                64385: [[1671], 256],
                64386: [[1677], 256],
                64387: [[1677], 256],
                64388: [[1676], 256],
                64389: [[1676], 256],
                64390: [[1678], 256],
                64391: [[1678], 256],
                64392: [[1672], 256],
                64393: [[1672], 256],
                64394: [[1688], 256],
                64395: [[1688], 256],
                64396: [[1681], 256],
                64397: [[1681], 256],
                64398: [[1705], 256],
                64399: [[1705], 256],
                64400: [[1705], 256],
                64401: [[1705], 256],
                64402: [[1711], 256],
                64403: [[1711], 256],
                64404: [[1711], 256],
                64405: [[1711], 256],
                64406: [[1715], 256],
                64407: [[1715], 256],
                64408: [[1715], 256],
                64409: [[1715], 256],
                64410: [[1713], 256],
                64411: [[1713], 256],
                64412: [[1713], 256],
                64413: [[1713], 256],
                64414: [[1722], 256],
                64415: [[1722], 256],
                64416: [[1723], 256],
                64417: [[1723], 256],
                64418: [[1723], 256],
                64419: [[1723], 256],
                64420: [[1728], 256],
                64421: [[1728], 256],
                64422: [[1729], 256],
                64423: [[1729], 256],
                64424: [[1729], 256],
                64425: [[1729], 256],
                64426: [[1726], 256],
                64427: [[1726], 256],
                64428: [[1726], 256],
                64429: [[1726], 256],
                64430: [[1746], 256],
                64431: [[1746], 256],
                64432: [[1747], 256],
                64433: [[1747], 256],
                64467: [[1709], 256],
                64468: [[1709], 256],
                64469: [[1709], 256],
                64470: [[1709], 256],
                64471: [[1735], 256],
                64472: [[1735], 256],
                64473: [[1734], 256],
                64474: [[1734], 256],
                64475: [[1736], 256],
                64476: [[1736], 256],
                64477: [[1655], 256],
                64478: [[1739], 256],
                64479: [[1739], 256],
                64480: [[1733], 256],
                64481: [[1733], 256],
                64482: [[1737], 256],
                64483: [[1737], 256],
                64484: [[1744], 256],
                64485: [[1744], 256],
                64486: [[1744], 256],
                64487: [[1744], 256],
                64488: [[1609], 256],
                64489: [[1609], 256],
                64490: [[1574, 1575], 256],
                64491: [[1574, 1575], 256],
                64492: [[1574, 1749], 256],
                64493: [[1574, 1749], 256],
                64494: [[1574, 1608], 256],
                64495: [[1574, 1608], 256],
                64496: [[1574, 1735], 256],
                64497: [[1574, 1735], 256],
                64498: [[1574, 1734], 256],
                64499: [[1574, 1734], 256],
                64500: [[1574, 1736], 256],
                64501: [[1574, 1736], 256],
                64502: [[1574, 1744], 256],
                64503: [[1574, 1744], 256],
                64504: [[1574, 1744], 256],
                64505: [[1574, 1609], 256],
                64506: [[1574, 1609], 256],
                64507: [[1574, 1609], 256],
                64508: [[1740], 256],
                64509: [[1740], 256],
                64510: [[1740], 256],
                64511: [[1740], 256]
              },
              64512: {
                64512: [[1574, 1580], 256],
                64513: [[1574, 1581], 256],
                64514: [[1574, 1605], 256],
                64515: [[1574, 1609], 256],
                64516: [[1574, 1610], 256],
                64517: [[1576, 1580], 256],
                64518: [[1576, 1581], 256],
                64519: [[1576, 1582], 256],
                64520: [[1576, 1605], 256],
                64521: [[1576, 1609], 256],
                64522: [[1576, 1610], 256],
                64523: [[1578, 1580], 256],
                64524: [[1578, 1581], 256],
                64525: [[1578, 1582], 256],
                64526: [[1578, 1605], 256],
                64527: [[1578, 1609], 256],
                64528: [[1578, 1610], 256],
                64529: [[1579, 1580], 256],
                64530: [[1579, 1605], 256],
                64531: [[1579, 1609], 256],
                64532: [[1579, 1610], 256],
                64533: [[1580, 1581], 256],
                64534: [[1580, 1605], 256],
                64535: [[1581, 1580], 256],
                64536: [[1581, 1605], 256],
                64537: [[1582, 1580], 256],
                64538: [[1582, 1581], 256],
                64539: [[1582, 1605], 256],
                64540: [[1587, 1580], 256],
                64541: [[1587, 1581], 256],
                64542: [[1587, 1582], 256],
                64543: [[1587, 1605], 256],
                64544: [[1589, 1581], 256],
                64545: [[1589, 1605], 256],
                64546: [[1590, 1580], 256],
                64547: [[1590, 1581], 256],
                64548: [[1590, 1582], 256],
                64549: [[1590, 1605], 256],
                64550: [[1591, 1581], 256],
                64551: [[1591, 1605], 256],
                64552: [[1592, 1605], 256],
                64553: [[1593, 1580], 256],
                64554: [[1593, 1605], 256],
                64555: [[1594, 1580], 256],
                64556: [[1594, 1605], 256],
                64557: [[1601, 1580], 256],
                64558: [[1601, 1581], 256],
                64559: [[1601, 1582], 256],
                64560: [[1601, 1605], 256],
                64561: [[1601, 1609], 256],
                64562: [[1601, 1610], 256],
                64563: [[1602, 1581], 256],
                64564: [[1602, 1605], 256],
                64565: [[1602, 1609], 256],
                64566: [[1602, 1610], 256],
                64567: [[1603, 1575], 256],
                64568: [[1603, 1580], 256],
                64569: [[1603, 1581], 256],
                64570: [[1603, 1582], 256],
                64571: [[1603, 1604], 256],
                64572: [[1603, 1605], 256],
                64573: [[1603, 1609], 256],
                64574: [[1603, 1610], 256],
                64575: [[1604, 1580], 256],
                64576: [[1604, 1581], 256],
                64577: [[1604, 1582], 256],
                64578: [[1604, 1605], 256],
                64579: [[1604, 1609], 256],
                64580: [[1604, 1610], 256],
                64581: [[1605, 1580], 256],
                64582: [[1605, 1581], 256],
                64583: [[1605, 1582], 256],
                64584: [[1605, 1605], 256],
                64585: [[1605, 1609], 256],
                64586: [[1605, 1610], 256],
                64587: [[1606, 1580], 256],
                64588: [[1606, 1581], 256],
                64589: [[1606, 1582], 256],
                64590: [[1606, 1605], 256],
                64591: [[1606, 1609], 256],
                64592: [[1606, 1610], 256],
                64593: [[1607, 1580], 256],
                64594: [[1607, 1605], 256],
                64595: [[1607, 1609], 256],
                64596: [[1607, 1610], 256],
                64597: [[1610, 1580], 256],
                64598: [[1610, 1581], 256],
                64599: [[1610, 1582], 256],
                64600: [[1610, 1605], 256],
                64601: [[1610, 1609], 256],
                64602: [[1610, 1610], 256],
                64603: [[1584, 1648], 256],
                64604: [[1585, 1648], 256],
                64605: [[1609, 1648], 256],
                64606: [[32, 1612, 1617], 256],
                64607: [[32, 1613, 1617], 256],
                64608: [[32, 1614, 1617], 256],
                64609: [[32, 1615, 1617], 256],
                64610: [[32, 1616, 1617], 256],
                64611: [[32, 1617, 1648], 256],
                64612: [[1574, 1585], 256],
                64613: [[1574, 1586], 256],
                64614: [[1574, 1605], 256],
                64615: [[1574, 1606], 256],
                64616: [[1574, 1609], 256],
                64617: [[1574, 1610], 256],
                64618: [[1576, 1585], 256],
                64619: [[1576, 1586], 256],
                64620: [[1576, 1605], 256],
                64621: [[1576, 1606], 256],
                64622: [[1576, 1609], 256],
                64623: [[1576, 1610], 256],
                64624: [[1578, 1585], 256],
                64625: [[1578, 1586], 256],
                64626: [[1578, 1605], 256],
                64627: [[1578, 1606], 256],
                64628: [[1578, 1609], 256],
                64629: [[1578, 1610], 256],
                64630: [[1579, 1585], 256],
                64631: [[1579, 1586], 256],
                64632: [[1579, 1605], 256],
                64633: [[1579, 1606], 256],
                64634: [[1579, 1609], 256],
                64635: [[1579, 1610], 256],
                64636: [[1601, 1609], 256],
                64637: [[1601, 1610], 256],
                64638: [[1602, 1609], 256],
                64639: [[1602, 1610], 256],
                64640: [[1603, 1575], 256],
                64641: [[1603, 1604], 256],
                64642: [[1603, 1605], 256],
                64643: [[1603, 1609], 256],
                64644: [[1603, 1610], 256],
                64645: [[1604, 1605], 256],
                64646: [[1604, 1609], 256],
                64647: [[1604, 1610], 256],
                64648: [[1605, 1575], 256],
                64649: [[1605, 1605], 256],
                64650: [[1606, 1585], 256],
                64651: [[1606, 1586], 256],
                64652: [[1606, 1605], 256],
                64653: [[1606, 1606], 256],
                64654: [[1606, 1609], 256],
                64655: [[1606, 1610], 256],
                64656: [[1609, 1648], 256],
                64657: [[1610, 1585], 256],
                64658: [[1610, 1586], 256],
                64659: [[1610, 1605], 256],
                64660: [[1610, 1606], 256],
                64661: [[1610, 1609], 256],
                64662: [[1610, 1610], 256],
                64663: [[1574, 1580], 256],
                64664: [[1574, 1581], 256],
                64665: [[1574, 1582], 256],
                64666: [[1574, 1605], 256],
                64667: [[1574, 1607], 256],
                64668: [[1576, 1580], 256],
                64669: [[1576, 1581], 256],
                64670: [[1576, 1582], 256],
                64671: [[1576, 1605], 256],
                64672: [[1576, 1607], 256],
                64673: [[1578, 1580], 256],
                64674: [[1578, 1581], 256],
                64675: [[1578, 1582], 256],
                64676: [[1578, 1605], 256],
                64677: [[1578, 1607], 256],
                64678: [[1579, 1605], 256],
                64679: [[1580, 1581], 256],
                64680: [[1580, 1605], 256],
                64681: [[1581, 1580], 256],
                64682: [[1581, 1605], 256],
                64683: [[1582, 1580], 256],
                64684: [[1582, 1605], 256],
                64685: [[1587, 1580], 256],
                64686: [[1587, 1581], 256],
                64687: [[1587, 1582], 256],
                64688: [[1587, 1605], 256],
                64689: [[1589, 1581], 256],
                64690: [[1589, 1582], 256],
                64691: [[1589, 1605], 256],
                64692: [[1590, 1580], 256],
                64693: [[1590, 1581], 256],
                64694: [[1590, 1582], 256],
                64695: [[1590, 1605], 256],
                64696: [[1591, 1581], 256],
                64697: [[1592, 1605], 256],
                64698: [[1593, 1580], 256],
                64699: [[1593, 1605], 256],
                64700: [[1594, 1580], 256],
                64701: [[1594, 1605], 256],
                64702: [[1601, 1580], 256],
                64703: [[1601, 1581], 256],
                64704: [[1601, 1582], 256],
                64705: [[1601, 1605], 256],
                64706: [[1602, 1581], 256],
                64707: [[1602, 1605], 256],
                64708: [[1603, 1580], 256],
                64709: [[1603, 1581], 256],
                64710: [[1603, 1582], 256],
                64711: [[1603, 1604], 256],
                64712: [[1603, 1605], 256],
                64713: [[1604, 1580], 256],
                64714: [[1604, 1581], 256],
                64715: [[1604, 1582], 256],
                64716: [[1604, 1605], 256],
                64717: [[1604, 1607], 256],
                64718: [[1605, 1580], 256],
                64719: [[1605, 1581], 256],
                64720: [[1605, 1582], 256],
                64721: [[1605, 1605], 256],
                64722: [[1606, 1580], 256],
                64723: [[1606, 1581], 256],
                64724: [[1606, 1582], 256],
                64725: [[1606, 1605], 256],
                64726: [[1606, 1607], 256],
                64727: [[1607, 1580], 256],
                64728: [[1607, 1605], 256],
                64729: [[1607, 1648], 256],
                64730: [[1610, 1580], 256],
                64731: [[1610, 1581], 256],
                64732: [[1610, 1582], 256],
                64733: [[1610, 1605], 256],
                64734: [[1610, 1607], 256],
                64735: [[1574, 1605], 256],
                64736: [[1574, 1607], 256],
                64737: [[1576, 1605], 256],
                64738: [[1576, 1607], 256],
                64739: [[1578, 1605], 256],
                64740: [[1578, 1607], 256],
                64741: [[1579, 1605], 256],
                64742: [[1579, 1607], 256],
                64743: [[1587, 1605], 256],
                64744: [[1587, 1607], 256],
                64745: [[1588, 1605], 256],
                64746: [[1588, 1607], 256],
                64747: [[1603, 1604], 256],
                64748: [[1603, 1605], 256],
                64749: [[1604, 1605], 256],
                64750: [[1606, 1605], 256],
                64751: [[1606, 1607], 256],
                64752: [[1610, 1605], 256],
                64753: [[1610, 1607], 256],
                64754: [[1600, 1614, 1617], 256],
                64755: [[1600, 1615, 1617], 256],
                64756: [[1600, 1616, 1617], 256],
                64757: [[1591, 1609], 256],
                64758: [[1591, 1610], 256],
                64759: [[1593, 1609], 256],
                64760: [[1593, 1610], 256],
                64761: [[1594, 1609], 256],
                64762: [[1594, 1610], 256],
                64763: [[1587, 1609], 256],
                64764: [[1587, 1610], 256],
                64765: [[1588, 1609], 256],
                64766: [[1588, 1610], 256],
                64767: [[1581, 1609], 256]
              },
              64768: {
                64768: [[1581, 1610], 256],
                64769: [[1580, 1609], 256],
                64770: [[1580, 1610], 256],
                64771: [[1582, 1609], 256],
                64772: [[1582, 1610], 256],
                64773: [[1589, 1609], 256],
                64774: [[1589, 1610], 256],
                64775: [[1590, 1609], 256],
                64776: [[1590, 1610], 256],
                64777: [[1588, 1580], 256],
                64778: [[1588, 1581], 256],
                64779: [[1588, 1582], 256],
                64780: [[1588, 1605], 256],
                64781: [[1588, 1585], 256],
                64782: [[1587, 1585], 256],
                64783: [[1589, 1585], 256],
                64784: [[1590, 1585], 256],
                64785: [[1591, 1609], 256],
                64786: [[1591, 1610], 256],
                64787: [[1593, 1609], 256],
                64788: [[1593, 1610], 256],
                64789: [[1594, 1609], 256],
                64790: [[1594, 1610], 256],
                64791: [[1587, 1609], 256],
                64792: [[1587, 1610], 256],
                64793: [[1588, 1609], 256],
                64794: [[1588, 1610], 256],
                64795: [[1581, 1609], 256],
                64796: [[1581, 1610], 256],
                64797: [[1580, 1609], 256],
                64798: [[1580, 1610], 256],
                64799: [[1582, 1609], 256],
                64800: [[1582, 1610], 256],
                64801: [[1589, 1609], 256],
                64802: [[1589, 1610], 256],
                64803: [[1590, 1609], 256],
                64804: [[1590, 1610], 256],
                64805: [[1588, 1580], 256],
                64806: [[1588, 1581], 256],
                64807: [[1588, 1582], 256],
                64808: [[1588, 1605], 256],
                64809: [[1588, 1585], 256],
                64810: [[1587, 1585], 256],
                64811: [[1589, 1585], 256],
                64812: [[1590, 1585], 256],
                64813: [[1588, 1580], 256],
                64814: [[1588, 1581], 256],
                64815: [[1588, 1582], 256],
                64816: [[1588, 1605], 256],
                64817: [[1587, 1607], 256],
                64818: [[1588, 1607], 256],
                64819: [[1591, 1605], 256],
                64820: [[1587, 1580], 256],
                64821: [[1587, 1581], 256],
                64822: [[1587, 1582], 256],
                64823: [[1588, 1580], 256],
                64824: [[1588, 1581], 256],
                64825: [[1588, 1582], 256],
                64826: [[1591, 1605], 256],
                64827: [[1592, 1605], 256],
                64828: [[1575, 1611], 256],
                64829: [[1575, 1611], 256],
                64848: [[1578, 1580, 1605], 256],
                64849: [[1578, 1581, 1580], 256],
                64850: [[1578, 1581, 1580], 256],
                64851: [[1578, 1581, 1605], 256],
                64852: [[1578, 1582, 1605], 256],
                64853: [[1578, 1605, 1580], 256],
                64854: [[1578, 1605, 1581], 256],
                64855: [[1578, 1605, 1582], 256],
                64856: [[1580, 1605, 1581], 256],
                64857: [[1580, 1605, 1581], 256],
                64858: [[1581, 1605, 1610], 256],
                64859: [[1581, 1605, 1609], 256],
                64860: [[1587, 1581, 1580], 256],
                64861: [[1587, 1580, 1581], 256],
                64862: [[1587, 1580, 1609], 256],
                64863: [[1587, 1605, 1581], 256],
                64864: [[1587, 1605, 1581], 256],
                64865: [[1587, 1605, 1580], 256],
                64866: [[1587, 1605, 1605], 256],
                64867: [[1587, 1605, 1605], 256],
                64868: [[1589, 1581, 1581], 256],
                64869: [[1589, 1581, 1581], 256],
                64870: [[1589, 1605, 1605], 256],
                64871: [[1588, 1581, 1605], 256],
                64872: [[1588, 1581, 1605], 256],
                64873: [[1588, 1580, 1610], 256],
                64874: [[1588, 1605, 1582], 256],
                64875: [[1588, 1605, 1582], 256],
                64876: [[1588, 1605, 1605], 256],
                64877: [[1588, 1605, 1605], 256],
                64878: [[1590, 1581, 1609], 256],
                64879: [[1590, 1582, 1605], 256],
                64880: [[1590, 1582, 1605], 256],
                64881: [[1591, 1605, 1581], 256],
                64882: [[1591, 1605, 1581], 256],
                64883: [[1591, 1605, 1605], 256],
                64884: [[1591, 1605, 1610], 256],
                64885: [[1593, 1580, 1605], 256],
                64886: [[1593, 1605, 1605], 256],
                64887: [[1593, 1605, 1605], 256],
                64888: [[1593, 1605, 1609], 256],
                64889: [[1594, 1605, 1605], 256],
                64890: [[1594, 1605, 1610], 256],
                64891: [[1594, 1605, 1609], 256],
                64892: [[1601, 1582, 1605], 256],
                64893: [[1601, 1582, 1605], 256],
                64894: [[1602, 1605, 1581], 256],
                64895: [[1602, 1605, 1605], 256],
                64896: [[1604, 1581, 1605], 256],
                64897: [[1604, 1581, 1610], 256],
                64898: [[1604, 1581, 1609], 256],
                64899: [[1604, 1580, 1580], 256],
                64900: [[1604, 1580, 1580], 256],
                64901: [[1604, 1582, 1605], 256],
                64902: [[1604, 1582, 1605], 256],
                64903: [[1604, 1605, 1581], 256],
                64904: [[1604, 1605, 1581], 256],
                64905: [[1605, 1581, 1580], 256],
                64906: [[1605, 1581, 1605], 256],
                64907: [[1605, 1581, 1610], 256],
                64908: [[1605, 1580, 1581], 256],
                64909: [[1605, 1580, 1605], 256],
                64910: [[1605, 1582, 1580], 256],
                64911: [[1605, 1582, 1605], 256],
                64914: [[1605, 1580, 1582], 256],
                64915: [[1607, 1605, 1580], 256],
                64916: [[1607, 1605, 1605], 256],
                64917: [[1606, 1581, 1605], 256],
                64918: [[1606, 1581, 1609], 256],
                64919: [[1606, 1580, 1605], 256],
                64920: [[1606, 1580, 1605], 256],
                64921: [[1606, 1580, 1609], 256],
                64922: [[1606, 1605, 1610], 256],
                64923: [[1606, 1605, 1609], 256],
                64924: [[1610, 1605, 1605], 256],
                64925: [[1610, 1605, 1605], 256],
                64926: [[1576, 1582, 1610], 256],
                64927: [[1578, 1580, 1610], 256],
                64928: [[1578, 1580, 1609], 256],
                64929: [[1578, 1582, 1610], 256],
                64930: [[1578, 1582, 1609], 256],
                64931: [[1578, 1605, 1610], 256],
                64932: [[1578, 1605, 1609], 256],
                64933: [[1580, 1605, 1610], 256],
                64934: [[1580, 1581, 1609], 256],
                64935: [[1580, 1605, 1609], 256],
                64936: [[1587, 1582, 1609], 256],
                64937: [[1589, 1581, 1610], 256],
                64938: [[1588, 1581, 1610], 256],
                64939: [[1590, 1581, 1610], 256],
                64940: [[1604, 1580, 1610], 256],
                64941: [[1604, 1605, 1610], 256],
                64942: [[1610, 1581, 1610], 256],
                64943: [[1610, 1580, 1610], 256],
                64944: [[1610, 1605, 1610], 256],
                64945: [[1605, 1605, 1610], 256],
                64946: [[1602, 1605, 1610], 256],
                64947: [[1606, 1581, 1610], 256],
                64948: [[1602, 1605, 1581], 256],
                64949: [[1604, 1581, 1605], 256],
                64950: [[1593, 1605, 1610], 256],
                64951: [[1603, 1605, 1610], 256],
                64952: [[1606, 1580, 1581], 256],
                64953: [[1605, 1582, 1610], 256],
                64954: [[1604, 1580, 1605], 256],
                64955: [[1603, 1605, 1605], 256],
                64956: [[1604, 1580, 1605], 256],
                64957: [[1606, 1580, 1581], 256],
                64958: [[1580, 1581, 1610], 256],
                64959: [[1581, 1580, 1610], 256],
                64960: [[1605, 1580, 1610], 256],
                64961: [[1601, 1605, 1610], 256],
                64962: [[1576, 1581, 1610], 256],
                64963: [[1603, 1605, 1605], 256],
                64964: [[1593, 1580, 1605], 256],
                64965: [[1589, 1605, 1605], 256],
                64966: [[1587, 1582, 1610], 256],
                64967: [[1606, 1580, 1610], 256],
                65008: [[1589, 1604, 1746], 256],
                65009: [[1602, 1604, 1746], 256],
                65010: [[1575, 1604, 1604, 1607], 256],
                65011: [[1575, 1603, 1576, 1585], 256],
                65012: [[1605, 1581, 1605, 1583], 256],
                65013: [[1589, 1604, 1593, 1605], 256],
                65014: [[1585, 1587, 1608, 1604], 256],
                65015: [[1593, 1604, 1610, 1607], 256],
                65016: [[1608, 1587, 1604, 1605], 256],
                65017: [[1589, 1604, 1609], 256],
                65018: [
                  [
                    1589,
                    1604,
                    1609,
                    32,
                    1575,
                    1604,
                    1604,
                    1607,
                    32,
                    1593,
                    1604,
                    1610,
                    1607,
                    32,
                    1608,
                    1587,
                    1604,
                    1605
                  ],
                  256
                ],
                65019: [[1580, 1604, 32, 1580, 1604, 1575, 1604, 1607], 256],
                65020: [[1585, 1740, 1575, 1604], 256]
              },
              65024: {
                65040: [[44], 256],
                65041: [[12289], 256],
                65042: [[12290], 256],
                65043: [[58], 256],
                65044: [[59], 256],
                65045: [[33], 256],
                65046: [[63], 256],
                65047: [[12310], 256],
                65048: [[12311], 256],
                65049: [[8230], 256],
                65056: [, 230],
                65057: [, 230],
                65058: [, 230],
                65059: [, 230],
                65060: [, 230],
                65061: [, 230],
                65062: [, 230],
                65063: [, 220],
                65064: [, 220],
                65065: [, 220],
                65066: [, 220],
                65067: [, 220],
                65068: [, 220],
                65069: [, 220],
                65072: [[8229], 256],
                65073: [[8212], 256],
                65074: [[8211], 256],
                65075: [[95], 256],
                65076: [[95], 256],
                65077: [[40], 256],
                65078: [[41], 256],
                65079: [[123], 256],
                65080: [[125], 256],
                65081: [[12308], 256],
                65082: [[12309], 256],
                65083: [[12304], 256],
                65084: [[12305], 256],
                65085: [[12298], 256],
                65086: [[12299], 256],
                65087: [[12296], 256],
                65088: [[12297], 256],
                65089: [[12300], 256],
                65090: [[12301], 256],
                65091: [[12302], 256],
                65092: [[12303], 256],
                65095: [[91], 256],
                65096: [[93], 256],
                65097: [[8254], 256],
                65098: [[8254], 256],
                65099: [[8254], 256],
                65100: [[8254], 256],
                65101: [[95], 256],
                65102: [[95], 256],
                65103: [[95], 256],
                65104: [[44], 256],
                65105: [[12289], 256],
                65106: [[46], 256],
                65108: [[59], 256],
                65109: [[58], 256],
                65110: [[63], 256],
                65111: [[33], 256],
                65112: [[8212], 256],
                65113: [[40], 256],
                65114: [[41], 256],
                65115: [[123], 256],
                65116: [[125], 256],
                65117: [[12308], 256],
                65118: [[12309], 256],
                65119: [[35], 256],
                65120: [[38], 256],
                65121: [[42], 256],
                65122: [[43], 256],
                65123: [[45], 256],
                65124: [[60], 256],
                65125: [[62], 256],
                65126: [[61], 256],
                65128: [[92], 256],
                65129: [[36], 256],
                65130: [[37], 256],
                65131: [[64], 256],
                65136: [[32, 1611], 256],
                65137: [[1600, 1611], 256],
                65138: [[32, 1612], 256],
                65140: [[32, 1613], 256],
                65142: [[32, 1614], 256],
                65143: [[1600, 1614], 256],
                65144: [[32, 1615], 256],
                65145: [[1600, 1615], 256],
                65146: [[32, 1616], 256],
                65147: [[1600, 1616], 256],
                65148: [[32, 1617], 256],
                65149: [[1600, 1617], 256],
                65150: [[32, 1618], 256],
                65151: [[1600, 1618], 256],
                65152: [[1569], 256],
                65153: [[1570], 256],
                65154: [[1570], 256],
                65155: [[1571], 256],
                65156: [[1571], 256],
                65157: [[1572], 256],
                65158: [[1572], 256],
                65159: [[1573], 256],
                65160: [[1573], 256],
                65161: [[1574], 256],
                65162: [[1574], 256],
                65163: [[1574], 256],
                65164: [[1574], 256],
                65165: [[1575], 256],
                65166: [[1575], 256],
                65167: [[1576], 256],
                65168: [[1576], 256],
                65169: [[1576], 256],
                65170: [[1576], 256],
                65171: [[1577], 256],
                65172: [[1577], 256],
                65173: [[1578], 256],
                65174: [[1578], 256],
                65175: [[1578], 256],
                65176: [[1578], 256],
                65177: [[1579], 256],
                65178: [[1579], 256],
                65179: [[1579], 256],
                65180: [[1579], 256],
                65181: [[1580], 256],
                65182: [[1580], 256],
                65183: [[1580], 256],
                65184: [[1580], 256],
                65185: [[1581], 256],
                65186: [[1581], 256],
                65187: [[1581], 256],
                65188: [[1581], 256],
                65189: [[1582], 256],
                65190: [[1582], 256],
                65191: [[1582], 256],
                65192: [[1582], 256],
                65193: [[1583], 256],
                65194: [[1583], 256],
                65195: [[1584], 256],
                65196: [[1584], 256],
                65197: [[1585], 256],
                65198: [[1585], 256],
                65199: [[1586], 256],
                65200: [[1586], 256],
                65201: [[1587], 256],
                65202: [[1587], 256],
                65203: [[1587], 256],
                65204: [[1587], 256],
                65205: [[1588], 256],
                65206: [[1588], 256],
                65207: [[1588], 256],
                65208: [[1588], 256],
                65209: [[1589], 256],
                65210: [[1589], 256],
                65211: [[1589], 256],
                65212: [[1589], 256],
                65213: [[1590], 256],
                65214: [[1590], 256],
                65215: [[1590], 256],
                65216: [[1590], 256],
                65217: [[1591], 256],
                65218: [[1591], 256],
                65219: [[1591], 256],
                65220: [[1591], 256],
                65221: [[1592], 256],
                65222: [[1592], 256],
                65223: [[1592], 256],
                65224: [[1592], 256],
                65225: [[1593], 256],
                65226: [[1593], 256],
                65227: [[1593], 256],
                65228: [[1593], 256],
                65229: [[1594], 256],
                65230: [[1594], 256],
                65231: [[1594], 256],
                65232: [[1594], 256],
                65233: [[1601], 256],
                65234: [[1601], 256],
                65235: [[1601], 256],
                65236: [[1601], 256],
                65237: [[1602], 256],
                65238: [[1602], 256],
                65239: [[1602], 256],
                65240: [[1602], 256],
                65241: [[1603], 256],
                65242: [[1603], 256],
                65243: [[1603], 256],
                65244: [[1603], 256],
                65245: [[1604], 256],
                65246: [[1604], 256],
                65247: [[1604], 256],
                65248: [[1604], 256],
                65249: [[1605], 256],
                65250: [[1605], 256],
                65251: [[1605], 256],
                65252: [[1605], 256],
                65253: [[1606], 256],
                65254: [[1606], 256],
                65255: [[1606], 256],
                65256: [[1606], 256],
                65257: [[1607], 256],
                65258: [[1607], 256],
                65259: [[1607], 256],
                65260: [[1607], 256],
                65261: [[1608], 256],
                65262: [[1608], 256],
                65263: [[1609], 256],
                65264: [[1609], 256],
                65265: [[1610], 256],
                65266: [[1610], 256],
                65267: [[1610], 256],
                65268: [[1610], 256],
                65269: [[1604, 1570], 256],
                65270: [[1604, 1570], 256],
                65271: [[1604, 1571], 256],
                65272: [[1604, 1571], 256],
                65273: [[1604, 1573], 256],
                65274: [[1604, 1573], 256],
                65275: [[1604, 1575], 256],
                65276: [[1604, 1575], 256]
              },
              65280: {
                65281: [[33], 256],
                65282: [[34], 256],
                65283: [[35], 256],
                65284: [[36], 256],
                65285: [[37], 256],
                65286: [[38], 256],
                65287: [[39], 256],
                65288: [[40], 256],
                65289: [[41], 256],
                65290: [[42], 256],
                65291: [[43], 256],
                65292: [[44], 256],
                65293: [[45], 256],
                65294: [[46], 256],
                65295: [[47], 256],
                65296: [[48], 256],
                65297: [[49], 256],
                65298: [[50], 256],
                65299: [[51], 256],
                65300: [[52], 256],
                65301: [[53], 256],
                65302: [[54], 256],
                65303: [[55], 256],
                65304: [[56], 256],
                65305: [[57], 256],
                65306: [[58], 256],
                65307: [[59], 256],
                65308: [[60], 256],
                65309: [[61], 256],
                65310: [[62], 256],
                65311: [[63], 256],
                65312: [[64], 256],
                65313: [[65], 256],
                65314: [[66], 256],
                65315: [[67], 256],
                65316: [[68], 256],
                65317: [[69], 256],
                65318: [[70], 256],
                65319: [[71], 256],
                65320: [[72], 256],
                65321: [[73], 256],
                65322: [[74], 256],
                65323: [[75], 256],
                65324: [[76], 256],
                65325: [[77], 256],
                65326: [[78], 256],
                65327: [[79], 256],
                65328: [[80], 256],
                65329: [[81], 256],
                65330: [[82], 256],
                65331: [[83], 256],
                65332: [[84], 256],
                65333: [[85], 256],
                65334: [[86], 256],
                65335: [[87], 256],
                65336: [[88], 256],
                65337: [[89], 256],
                65338: [[90], 256],
                65339: [[91], 256],
                65340: [[92], 256],
                65341: [[93], 256],
                65342: [[94], 256],
                65343: [[95], 256],
                65344: [[96], 256],
                65345: [[97], 256],
                65346: [[98], 256],
                65347: [[99], 256],
                65348: [[100], 256],
                65349: [[101], 256],
                65350: [[102], 256],
                65351: [[103], 256],
                65352: [[104], 256],
                65353: [[105], 256],
                65354: [[106], 256],
                65355: [[107], 256],
                65356: [[108], 256],
                65357: [[109], 256],
                65358: [[110], 256],
                65359: [[111], 256],
                65360: [[112], 256],
                65361: [[113], 256],
                65362: [[114], 256],
                65363: [[115], 256],
                65364: [[116], 256],
                65365: [[117], 256],
                65366: [[118], 256],
                65367: [[119], 256],
                65368: [[120], 256],
                65369: [[121], 256],
                65370: [[122], 256],
                65371: [[123], 256],
                65372: [[124], 256],
                65373: [[125], 256],
                65374: [[126], 256],
                65375: [[10629], 256],
                65376: [[10630], 256],
                65377: [[12290], 256],
                65378: [[12300], 256],
                65379: [[12301], 256],
                65380: [[12289], 256],
                65381: [[12539], 256],
                65382: [[12530], 256],
                65383: [[12449], 256],
                65384: [[12451], 256],
                65385: [[12453], 256],
                65386: [[12455], 256],
                65387: [[12457], 256],
                65388: [[12515], 256],
                65389: [[12517], 256],
                65390: [[12519], 256],
                65391: [[12483], 256],
                65392: [[12540], 256],
                65393: [[12450], 256],
                65394: [[12452], 256],
                65395: [[12454], 256],
                65396: [[12456], 256],
                65397: [[12458], 256],
                65398: [[12459], 256],
                65399: [[12461], 256],
                65400: [[12463], 256],
                65401: [[12465], 256],
                65402: [[12467], 256],
                65403: [[12469], 256],
                65404: [[12471], 256],
                65405: [[12473], 256],
                65406: [[12475], 256],
                65407: [[12477], 256],
                65408: [[12479], 256],
                65409: [[12481], 256],
                65410: [[12484], 256],
                65411: [[12486], 256],
                65412: [[12488], 256],
                65413: [[12490], 256],
                65414: [[12491], 256],
                65415: [[12492], 256],
                65416: [[12493], 256],
                65417: [[12494], 256],
                65418: [[12495], 256],
                65419: [[12498], 256],
                65420: [[12501], 256],
                65421: [[12504], 256],
                65422: [[12507], 256],
                65423: [[12510], 256],
                65424: [[12511], 256],
                65425: [[12512], 256],
                65426: [[12513], 256],
                65427: [[12514], 256],
                65428: [[12516], 256],
                65429: [[12518], 256],
                65430: [[12520], 256],
                65431: [[12521], 256],
                65432: [[12522], 256],
                65433: [[12523], 256],
                65434: [[12524], 256],
                65435: [[12525], 256],
                65436: [[12527], 256],
                65437: [[12531], 256],
                65438: [[12441], 256],
                65439: [[12442], 256],
                65440: [[12644], 256],
                65441: [[12593], 256],
                65442: [[12594], 256],
                65443: [[12595], 256],
                65444: [[12596], 256],
                65445: [[12597], 256],
                65446: [[12598], 256],
                65447: [[12599], 256],
                65448: [[12600], 256],
                65449: [[12601], 256],
                65450: [[12602], 256],
                65451: [[12603], 256],
                65452: [[12604], 256],
                65453: [[12605], 256],
                65454: [[12606], 256],
                65455: [[12607], 256],
                65456: [[12608], 256],
                65457: [[12609], 256],
                65458: [[12610], 256],
                65459: [[12611], 256],
                65460: [[12612], 256],
                65461: [[12613], 256],
                65462: [[12614], 256],
                65463: [[12615], 256],
                65464: [[12616], 256],
                65465: [[12617], 256],
                65466: [[12618], 256],
                65467: [[12619], 256],
                65468: [[12620], 256],
                65469: [[12621], 256],
                65470: [[12622], 256],
                65474: [[12623], 256],
                65475: [[12624], 256],
                65476: [[12625], 256],
                65477: [[12626], 256],
                65478: [[12627], 256],
                65479: [[12628], 256],
                65482: [[12629], 256],
                65483: [[12630], 256],
                65484: [[12631], 256],
                65485: [[12632], 256],
                65486: [[12633], 256],
                65487: [[12634], 256],
                65490: [[12635], 256],
                65491: [[12636], 256],
                65492: [[12637], 256],
                65493: [[12638], 256],
                65494: [[12639], 256],
                65495: [[12640], 256],
                65498: [[12641], 256],
                65499: [[12642], 256],
                65500: [[12643], 256],
                65504: [[162], 256],
                65505: [[163], 256],
                65506: [[172], 256],
                65507: [[175], 256],
                65508: [[166], 256],
                65509: [[165], 256],
                65510: [[8361], 256],
                65512: [[9474], 256],
                65513: [[8592], 256],
                65514: [[8593], 256],
                65515: [[8594], 256],
                65516: [[8595], 256],
                65517: [[9632], 256],
                65518: [[9675], 256]
              }
            };
            var unorm = { nfc: nfc, nfd: nfd, nfkc: nfkc, nfkd: nfkd };
            if (typeof module === 'object') {
              module.exports = unorm;
            } else if (typeof define === 'function' && define.amd) {
              define('unorm', function() {
                return unorm;
              });
            } else {
              root.unorm = unorm;
            }
            unorm.shimApplied = false;
            if (!String.prototype.normalize) {
              String.prototype.normalize = function(form) {
                var str = '' + this;
                form = form === undefined ? 'NFC' : form;
                if (form === 'NFC') {
                  return unorm.nfc(str);
                } else if (form === 'NFD') {
                  return unorm.nfd(str);
                } else if (form === 'NFKC') {
                  return unorm.nfkc(str);
                } else if (form === 'NFKD') {
                  return unorm.nfkd(str);
                } else {
                  throw new RangeError('Invalid normalization form: ' + form);
                }
              };
              unorm.shimApplied = true;
            }
          })(this);
        },
        {}
      ],
      502: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          var _toDate = require('./lib/toDate');
          var _toDate2 = _interopRequireDefault(_toDate);
          var _toFloat = require('./lib/toFloat');
          var _toFloat2 = _interopRequireDefault(_toFloat);
          var _toInt = require('./lib/toInt');
          var _toInt2 = _interopRequireDefault(_toInt);
          var _toBoolean = require('./lib/toBoolean');
          var _toBoolean2 = _interopRequireDefault(_toBoolean);
          var _equals = require('./lib/equals');
          var _equals2 = _interopRequireDefault(_equals);
          var _contains = require('./lib/contains');
          var _contains2 = _interopRequireDefault(_contains);
          var _matches = require('./lib/matches');
          var _matches2 = _interopRequireDefault(_matches);
          var _isEmail = require('./lib/isEmail');
          var _isEmail2 = _interopRequireDefault(_isEmail);
          var _isURL = require('./lib/isURL');
          var _isURL2 = _interopRequireDefault(_isURL);
          var _isMACAddress = require('./lib/isMACAddress');
          var _isMACAddress2 = _interopRequireDefault(_isMACAddress);
          var _isIP = require('./lib/isIP');
          var _isIP2 = _interopRequireDefault(_isIP);
          var _isFQDN = require('./lib/isFQDN');
          var _isFQDN2 = _interopRequireDefault(_isFQDN);
          var _isBoolean = require('./lib/isBoolean');
          var _isBoolean2 = _interopRequireDefault(_isBoolean);
          var _isAlpha = require('./lib/isAlpha');
          var _isAlpha2 = _interopRequireDefault(_isAlpha);
          var _isAlphanumeric = require('./lib/isAlphanumeric');
          var _isAlphanumeric2 = _interopRequireDefault(_isAlphanumeric);
          var _isNumeric = require('./lib/isNumeric');
          var _isNumeric2 = _interopRequireDefault(_isNumeric);
          var _isLowercase = require('./lib/isLowercase');
          var _isLowercase2 = _interopRequireDefault(_isLowercase);
          var _isUppercase = require('./lib/isUppercase');
          var _isUppercase2 = _interopRequireDefault(_isUppercase);
          var _isAscii = require('./lib/isAscii');
          var _isAscii2 = _interopRequireDefault(_isAscii);
          var _isFullWidth = require('./lib/isFullWidth');
          var _isFullWidth2 = _interopRequireDefault(_isFullWidth);
          var _isHalfWidth = require('./lib/isHalfWidth');
          var _isHalfWidth2 = _interopRequireDefault(_isHalfWidth);
          var _isVariableWidth = require('./lib/isVariableWidth');
          var _isVariableWidth2 = _interopRequireDefault(_isVariableWidth);
          var _isMultibyte = require('./lib/isMultibyte');
          var _isMultibyte2 = _interopRequireDefault(_isMultibyte);
          var _isSurrogatePair = require('./lib/isSurrogatePair');
          var _isSurrogatePair2 = _interopRequireDefault(_isSurrogatePair);
          var _isInt = require('./lib/isInt');
          var _isInt2 = _interopRequireDefault(_isInt);
          var _isFloat = require('./lib/isFloat');
          var _isFloat2 = _interopRequireDefault(_isFloat);
          var _isDecimal = require('./lib/isDecimal');
          var _isDecimal2 = _interopRequireDefault(_isDecimal);
          var _isHexadecimal = require('./lib/isHexadecimal');
          var _isHexadecimal2 = _interopRequireDefault(_isHexadecimal);
          var _isDivisibleBy = require('./lib/isDivisibleBy');
          var _isDivisibleBy2 = _interopRequireDefault(_isDivisibleBy);
          var _isHexColor = require('./lib/isHexColor');
          var _isHexColor2 = _interopRequireDefault(_isHexColor);
          var _isISRC = require('./lib/isISRC');
          var _isISRC2 = _interopRequireDefault(_isISRC);
          var _isMD = require('./lib/isMD5');
          var _isMD2 = _interopRequireDefault(_isMD);
          var _isJSON = require('./lib/isJSON');
          var _isJSON2 = _interopRequireDefault(_isJSON);
          var _isEmpty = require('./lib/isEmpty');
          var _isEmpty2 = _interopRequireDefault(_isEmpty);
          var _isLength = require('./lib/isLength');
          var _isLength2 = _interopRequireDefault(_isLength);
          var _isByteLength = require('./lib/isByteLength');
          var _isByteLength2 = _interopRequireDefault(_isByteLength);
          var _isUUID = require('./lib/isUUID');
          var _isUUID2 = _interopRequireDefault(_isUUID);
          var _isMongoId = require('./lib/isMongoId');
          var _isMongoId2 = _interopRequireDefault(_isMongoId);
          var _isAfter = require('./lib/isAfter');
          var _isAfter2 = _interopRequireDefault(_isAfter);
          var _isBefore = require('./lib/isBefore');
          var _isBefore2 = _interopRequireDefault(_isBefore);
          var _isIn = require('./lib/isIn');
          var _isIn2 = _interopRequireDefault(_isIn);
          var _isCreditCard = require('./lib/isCreditCard');
          var _isCreditCard2 = _interopRequireDefault(_isCreditCard);
          var _isISIN = require('./lib/isISIN');
          var _isISIN2 = _interopRequireDefault(_isISIN);
          var _isISBN = require('./lib/isISBN');
          var _isISBN2 = _interopRequireDefault(_isISBN);
          var _isISSN = require('./lib/isISSN');
          var _isISSN2 = _interopRequireDefault(_isISSN);
          var _isMobilePhone = require('./lib/isMobilePhone');
          var _isMobilePhone2 = _interopRequireDefault(_isMobilePhone);
          var _isCurrency = require('./lib/isCurrency');
          var _isCurrency2 = _interopRequireDefault(_isCurrency);
          var _isISO = require('./lib/isISO8601');
          var _isISO2 = _interopRequireDefault(_isISO);
          var _isBase = require('./lib/isBase64');
          var _isBase2 = _interopRequireDefault(_isBase);
          var _isDataURI = require('./lib/isDataURI');
          var _isDataURI2 = _interopRequireDefault(_isDataURI);
          var _ltrim = require('./lib/ltrim');
          var _ltrim2 = _interopRequireDefault(_ltrim);
          var _rtrim = require('./lib/rtrim');
          var _rtrim2 = _interopRequireDefault(_rtrim);
          var _trim = require('./lib/trim');
          var _trim2 = _interopRequireDefault(_trim);
          var _escape = require('./lib/escape');
          var _escape2 = _interopRequireDefault(_escape);
          var _unescape = require('./lib/unescape');
          var _unescape2 = _interopRequireDefault(_unescape);
          var _stripLow = require('./lib/stripLow');
          var _stripLow2 = _interopRequireDefault(_stripLow);
          var _whitelist = require('./lib/whitelist');
          var _whitelist2 = _interopRequireDefault(_whitelist);
          var _blacklist = require('./lib/blacklist');
          var _blacklist2 = _interopRequireDefault(_blacklist);
          var _isWhitelisted = require('./lib/isWhitelisted');
          var _isWhitelisted2 = _interopRequireDefault(_isWhitelisted);
          var _normalizeEmail = require('./lib/normalizeEmail');
          var _normalizeEmail2 = _interopRequireDefault(_normalizeEmail);
          var _toString = require('./lib/util/toString');
          var _toString2 = _interopRequireDefault(_toString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          var version = '7.2.0';
          var validator = {
            version: version,
            toDate: _toDate2.default,
            toFloat: _toFloat2.default,
            toInt: _toInt2.default,
            toBoolean: _toBoolean2.default,
            equals: _equals2.default,
            contains: _contains2.default,
            matches: _matches2.default,
            isEmail: _isEmail2.default,
            isURL: _isURL2.default,
            isMACAddress: _isMACAddress2.default,
            isIP: _isIP2.default,
            isFQDN: _isFQDN2.default,
            isBoolean: _isBoolean2.default,
            isAlpha: _isAlpha2.default,
            isAlphanumeric: _isAlphanumeric2.default,
            isNumeric: _isNumeric2.default,
            isLowercase: _isLowercase2.default,
            isUppercase: _isUppercase2.default,
            isAscii: _isAscii2.default,
            isFullWidth: _isFullWidth2.default,
            isHalfWidth: _isHalfWidth2.default,
            isVariableWidth: _isVariableWidth2.default,
            isMultibyte: _isMultibyte2.default,
            isSurrogatePair: _isSurrogatePair2.default,
            isInt: _isInt2.default,
            isFloat: _isFloat2.default,
            isDecimal: _isDecimal2.default,
            isHexadecimal: _isHexadecimal2.default,
            isDivisibleBy: _isDivisibleBy2.default,
            isHexColor: _isHexColor2.default,
            isISRC: _isISRC2.default,
            isMD5: _isMD2.default,
            isJSON: _isJSON2.default,
            isEmpty: _isEmpty2.default,
            isLength: _isLength2.default,
            isByteLength: _isByteLength2.default,
            isUUID: _isUUID2.default,
            isMongoId: _isMongoId2.default,
            isAfter: _isAfter2.default,
            isBefore: _isBefore2.default,
            isIn: _isIn2.default,
            isCreditCard: _isCreditCard2.default,
            isISIN: _isISIN2.default,
            isISBN: _isISBN2.default,
            isISSN: _isISSN2.default,
            isMobilePhone: _isMobilePhone2.default,
            isCurrency: _isCurrency2.default,
            isISO8601: _isISO2.default,
            isBase64: _isBase2.default,
            isDataURI: _isDataURI2.default,
            ltrim: _ltrim2.default,
            rtrim: _rtrim2.default,
            trim: _trim2.default,
            escape: _escape2.default,
            unescape: _unescape2.default,
            stripLow: _stripLow2.default,
            whitelist: _whitelist2.default,
            blacklist: _blacklist2.default,
            isWhitelisted: _isWhitelisted2.default,
            normalizeEmail: _normalizeEmail2.default,
            toString: _toString2.default
          };
          exports.default = validator;
          module.exports = exports['default'];
        },
        {
          './lib/blacklist': 504,
          './lib/contains': 505,
          './lib/equals': 506,
          './lib/escape': 507,
          './lib/isAfter': 508,
          './lib/isAlpha': 509,
          './lib/isAlphanumeric': 510,
          './lib/isAscii': 511,
          './lib/isBase64': 512,
          './lib/isBefore': 513,
          './lib/isBoolean': 514,
          './lib/isByteLength': 515,
          './lib/isCreditCard': 516,
          './lib/isCurrency': 517,
          './lib/isDataURI': 518,
          './lib/isDecimal': 519,
          './lib/isDivisibleBy': 520,
          './lib/isEmail': 521,
          './lib/isEmpty': 522,
          './lib/isFQDN': 523,
          './lib/isFloat': 524,
          './lib/isFullWidth': 525,
          './lib/isHalfWidth': 526,
          './lib/isHexColor': 527,
          './lib/isHexadecimal': 528,
          './lib/isIP': 529,
          './lib/isISBN': 530,
          './lib/isISIN': 531,
          './lib/isISO8601': 532,
          './lib/isISRC': 533,
          './lib/isISSN': 534,
          './lib/isIn': 535,
          './lib/isInt': 536,
          './lib/isJSON': 537,
          './lib/isLength': 538,
          './lib/isLowercase': 539,
          './lib/isMACAddress': 540,
          './lib/isMD5': 541,
          './lib/isMobilePhone': 542,
          './lib/isMongoId': 543,
          './lib/isMultibyte': 544,
          './lib/isNumeric': 545,
          './lib/isSurrogatePair': 546,
          './lib/isURL': 547,
          './lib/isUUID': 548,
          './lib/isUppercase': 549,
          './lib/isVariableWidth': 550,
          './lib/isWhitelisted': 551,
          './lib/ltrim': 552,
          './lib/matches': 553,
          './lib/normalizeEmail': 554,
          './lib/rtrim': 555,
          './lib/stripLow': 556,
          './lib/toBoolean': 557,
          './lib/toDate': 558,
          './lib/toFloat': 559,
          './lib/toInt': 560,
          './lib/trim': 561,
          './lib/unescape': 562,
          './lib/util/toString': 565,
          './lib/whitelist': 566
        }
      ],
      503: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          var alpha = (exports.alpha = {
            'en-US': /^[A-Z]+$/i,
            'cs-CZ': /^[A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]+$/i,
            'da-DK': /^[A-ZÆØÅ]+$/i,
            'de-DE': /^[A-ZÄÖÜß]+$/i,
            'es-ES': /^[A-ZÁÉÍÑÓÚÜ]+$/i,
            'fr-FR': /^[A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/i,
            'nl-NL': /^[A-ZÉËÏÓÖÜ]+$/i,
            'hu-HU': /^[A-ZÁÉÍÓÖŐÚÜŰ]+$/i,
            'pl-PL': /^[A-ZĄĆĘŚŁŃÓŻŹ]+$/i,
            'pt-PT': /^[A-ZÃÁÀÂÇÉÊÍÕÓÔÚÜ]+$/i,
            'ru-RU': /^[А-ЯЁ]+$/i,
            'sr-RS@latin': /^[A-ZČĆŽŠĐ]+$/i,
            'sr-RS': /^[А-ЯЂЈЉЊЋЏ]+$/i,
            'tr-TR': /^[A-ZÇĞİıÖŞÜ]+$/i,
            'uk-UA': /^[А-ЩЬЮЯЄIЇҐ]+$/i,
            ar: /^[ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]+$/
          });
          var alphanumeric = (exports.alphanumeric = {
            'en-US': /^[0-9A-Z]+$/i,
            'cs-CZ': /^[0-9A-ZÁČĎÉĚÍŇÓŘŠŤÚŮÝŽ]+$/i,
            'da-DK': /^[0-9A-ZÆØÅ]$/i,
            'de-DE': /^[0-9A-ZÄÖÜß]+$/i,
            'es-ES': /^[0-9A-ZÁÉÍÑÓÚÜ]+$/i,
            'fr-FR': /^[0-9A-ZÀÂÆÇÉÈÊËÏÎÔŒÙÛÜŸ]+$/i,
            'hu-HU': /^[0-9A-ZÁÉÍÓÖŐÚÜŰ]+$/i,
            'nl-NL': /^[0-9A-ZÉËÏÓÖÜ]+$/i,
            'pl-PL': /^[0-9A-ZĄĆĘŚŁŃÓŻŹ]+$/i,
            'pt-PT': /^[0-9A-ZÃÁÀÂÇÉÊÍÕÓÔÚÜ]+$/i,
            'ru-RU': /^[0-9А-ЯЁ]+$/i,
            'sr-RS@latin': /^[0-9A-ZČĆŽŠĐ]+$/i,
            'sr-RS': /^[0-9А-ЯЂЈЉЊЋЏ]+$/i,
            'tr-TR': /^[0-9A-ZÇĞİıÖŞÜ]+$/i,
            'uk-UA': /^[0-9А-ЩЬЮЯЄIЇҐ]+$/i,
            ar: /^[٠١٢٣٤٥٦٧٨٩0-9ءآأؤإئابةتثجحخدذرزسشصضطظعغفقكلمنهوىيًٌٍَُِّْٰ]+$/
          });
          var englishLocales = (exports.englishLocales = [
            'AU',
            'GB',
            'HK',
            'IN',
            'NZ',
            'ZA',
            'ZM'
          ]);
          for (var locale, i = 0; i < englishLocales.length; i++) {
            locale = 'en-' + englishLocales[i];
            alpha[locale] = alpha['en-US'];
            alphanumeric[locale] = alphanumeric['en-US'];
          }
          alpha['pt-BR'] = alpha['pt-PT'];
          alphanumeric['pt-BR'] = alphanumeric['pt-PT'];
          var arabicLocales = (exports.arabicLocales = [
            'AE',
            'BH',
            'DZ',
            'EG',
            'IQ',
            'JO',
            'KW',
            'LB',
            'LY',
            'MA',
            'QM',
            'QA',
            'SA',
            'SD',
            'SY',
            'TN',
            'YE'
          ]);
          for (var _locale, _i = 0; _i < arabicLocales.length; _i++) {
            _locale = 'ar-' + arabicLocales[_i];
            alpha[_locale] = alpha.ar;
            alphanumeric[_locale] = alphanumeric.ar;
          }
        },
        {}
      ],
      504: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = blacklist;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function blacklist(str, chars) {
            (0, _assertString2.default)(str);
            return str.replace(new RegExp('[' + chars + ']+', 'g'), '');
          }
          module.exports = exports['default'];
        },
        { './util/assertString': 563 }
      ],
      505: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = contains;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          var _toString = require('./util/toString');
          var _toString2 = _interopRequireDefault(_toString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function contains(str, elem) {
            (0, _assertString2.default)(str);
            return str.indexOf((0, _toString2.default)(elem)) >= 0;
          }
          module.exports = exports['default'];
        },
        { './util/assertString': 563, './util/toString': 565 }
      ],
      506: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = equals;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function equals(str, comparison) {
            (0, _assertString2.default)(str);
            return str === comparison;
          }
          module.exports = exports['default'];
        },
        { './util/assertString': 563 }
      ],
      507: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = escape;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function escape(str) {
            (0, _assertString2.default)(str);
            return str
              .replace(/&/g, '&amp;')
              .replace(/"/g, '&quot;')
              .replace(/'/g, '&#x27;')
              .replace(/</g, '&lt;')
              .replace(/>/g, '&gt;')
              .replace(/\//g, '&#x2F;')
              .replace(/\\/g, '&#x5C;')
              .replace(/`/g, '&#96;');
          }
          module.exports = exports['default'];
        },
        { './util/assertString': 563 }
      ],
      508: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = isAfter;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          var _toDate = require('./toDate');
          var _toDate2 = _interopRequireDefault(_toDate);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function isAfter(str) {
            var date =
              arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : String(new Date());
            (0, _assertString2.default)(str);
            var comparison = (0, _toDate2.default)(date);
            var original = (0, _toDate2.default)(str);
            return !!(original && comparison && original > comparison);
          }
          module.exports = exports['default'];
        },
        { './toDate': 558, './util/assertString': 563 }
      ],
      509: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = isAlpha;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          var _alpha = require('./alpha');
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function isAlpha(str) {
            var locale =
              arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : 'en-US';
            (0, _assertString2.default)(str);
            if (locale in _alpha.alpha) {
              return _alpha.alpha[locale].test(str);
            }
            throw new Error("Invalid locale '" + locale + "'");
          }
          module.exports = exports['default'];
        },
        { './alpha': 503, './util/assertString': 563 }
      ],
      510: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = isAlphanumeric;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          var _alpha = require('./alpha');
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function isAlphanumeric(str) {
            var locale =
              arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : 'en-US';
            (0, _assertString2.default)(str);
            if (locale in _alpha.alphanumeric) {
              return _alpha.alphanumeric[locale].test(str);
            }
            throw new Error("Invalid locale '" + locale + "'");
          }
          module.exports = exports['default'];
        },
        { './alpha': 503, './util/assertString': 563 }
      ],
      511: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = isAscii;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          var ascii = /^[\x00-\x7F]+$/;
          function isAscii(str) {
            (0, _assertString2.default)(str);
            return ascii.test(str);
          }
          module.exports = exports['default'];
        },
        { './util/assertString': 563 }
      ],
      512: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = isBase64;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          var notBase64 = /[^A-Z0-9+\/=]/i;
          function isBase64(str) {
            (0, _assertString2.default)(str);
            var len = str.length;
            if (!len || len % 4 !== 0 || notBase64.test(str)) {
              return false;
            }
            var firstPaddingChar = str.indexOf('=');
            return (
              firstPaddingChar === -1 ||
              firstPaddingChar === len - 1 ||
              (firstPaddingChar === len - 2 && str[len - 1] === '=')
            );
          }
          module.exports = exports['default'];
        },
        { './util/assertString': 563 }
      ],
      513: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = isBefore;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          var _toDate = require('./toDate');
          var _toDate2 = _interopRequireDefault(_toDate);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function isBefore(str) {
            var date =
              arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : String(new Date());
            (0, _assertString2.default)(str);
            var comparison = (0, _toDate2.default)(date);
            var original = (0, _toDate2.default)(str);
            return !!(original && comparison && original < comparison);
          }
          module.exports = exports['default'];
        },
        { './toDate': 558, './util/assertString': 563 }
      ],
      514: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = isBoolean;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function isBoolean(str) {
            (0, _assertString2.default)(str);
            return ['true', 'false', '1', '0'].indexOf(str) >= 0;
          }
          module.exports = exports['default'];
        },
        { './util/assertString': 563 }
      ],
      515: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          var _typeof =
            typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
              ? function(obj) {
                  return typeof obj;
                }
              : function(obj) {
                  return obj &&
                    typeof Symbol === 'function' &&
                    obj.constructor === Symbol &&
                    obj !== Symbol.prototype
                    ? 'symbol'
                    : typeof obj;
                };
          exports.default = isByteLength;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function isByteLength(str, options) {
            (0, _assertString2.default)(str);
            var min = void 0;
            var max = void 0;
            if (
              (typeof options === 'undefined'
                ? 'undefined'
                : _typeof(options)) === 'object'
            ) {
              min = options.min || 0;
              max = options.max;
            } else {
              min = arguments[1];
              max = arguments[2];
            }
            var len = encodeURI(str).split(/%..|./).length - 1;
            return len >= min && (typeof max === 'undefined' || len <= max);
          }
          module.exports = exports['default'];
        },
        { './util/assertString': 563 }
      ],
      516: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = isCreditCard;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          var creditCard = /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11}|62[0-9]{14})$/;
          function isCreditCard(str) {
            (0, _assertString2.default)(str);
            var sanitized = str.replace(/[- ]+/g, '');
            if (!creditCard.test(sanitized)) {
              return false;
            }
            var sum = 0;
            var digit = void 0;
            var tmpNum = void 0;
            var shouldDouble = void 0;
            for (var i = sanitized.length - 1; i >= 0; i--) {
              digit = sanitized.substring(i, i + 1);
              tmpNum = parseInt(digit, 10);
              if (shouldDouble) {
                tmpNum *= 2;
                if (tmpNum >= 10) {
                  sum += (tmpNum % 10) + 1;
                } else {
                  sum += tmpNum;
                }
              } else {
                sum += tmpNum;
              }
              shouldDouble = !shouldDouble;
            }
            return !!(sum % 10 === 0 ? sanitized : false);
          }
          module.exports = exports['default'];
        },
        { './util/assertString': 563 }
      ],
      517: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = isCurrency;
          var _merge = require('./util/merge');
          var _merge2 = _interopRequireDefault(_merge);
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function currencyRegex(options) {
            var symbol =
                '(\\' +
                options.symbol.replace(/\./g, '\\.') +
                ')' +
                (options.require_symbol ? '' : '?'),
              negative = '-?',
              whole_dollar_amount_without_sep = '[1-9]\\d*',
              whole_dollar_amount_with_sep =
                '[1-9]\\d{0,2}(\\' + options.thousands_separator + '\\d{3})*',
              valid_whole_dollar_amounts = [
                '0',
                whole_dollar_amount_without_sep,
                whole_dollar_amount_with_sep
              ],
              whole_dollar_amount =
                '(' + valid_whole_dollar_amounts.join('|') + ')?',
              decimal_amount = '(\\' + options.decimal_separator + '\\d{2})?';
            var pattern = whole_dollar_amount + decimal_amount;
            if (options.allow_negatives && !options.parens_for_negatives) {
              if (options.negative_sign_after_digits) {
                pattern += negative;
              } else if (options.negative_sign_before_digits) {
                pattern = negative + pattern;
              }
            }
            if (options.allow_negative_sign_placeholder) {
              pattern = '( (?!\\-))?' + pattern;
            } else if (options.allow_space_after_symbol) {
              pattern = ' ?' + pattern;
            } else if (options.allow_space_after_digits) {
              pattern += '( (?!$))?';
            }
            if (options.symbol_after_digits) {
              pattern += symbol;
            } else {
              pattern = symbol + pattern;
            }
            if (options.allow_negatives) {
              if (options.parens_for_negatives) {
                pattern = '(\\(' + pattern + '\\)|' + pattern + ')';
              } else if (
                !(
                  options.negative_sign_before_digits ||
                  options.negative_sign_after_digits
                )
              ) {
                pattern = negative + pattern;
              }
            }
            return new RegExp('^(?!-? )(?=.*\\d)' + pattern + '$');
          }
          var default_currency_options = {
            symbol: '$',
            require_symbol: false,
            allow_space_after_symbol: false,
            symbol_after_digits: false,
            allow_negatives: true,
            parens_for_negatives: false,
            negative_sign_before_digits: false,
            negative_sign_after_digits: false,
            allow_negative_sign_placeholder: false,
            thousands_separator: ',',
            decimal_separator: '.',
            allow_space_after_digits: false
          };
          function isCurrency(str, options) {
            (0, _assertString2.default)(str);
            options = (0, _merge2.default)(options, default_currency_options);
            return currencyRegex(options).test(str);
          }
          module.exports = exports['default'];
        },
        { './util/assertString': 563, './util/merge': 564 }
      ],
      518: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = isDataURI;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          var dataURI = /^\s*data:([a-z]+\/[a-z0-9\-\+]+(;[a-z\-]+=[a-z0-9\-]+)?)?(;base64)?,[a-z0-9!\$&',\(\)\*\+,;=\-\._~:@\/\?%\s]*\s*$/i;
          function isDataURI(str) {
            (0, _assertString2.default)(str);
            return dataURI.test(str);
          }
          module.exports = exports['default'];
        },
        { './util/assertString': 563 }
      ],
      519: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = isDecimal;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          var decimal = /^[-+]?([0-9]+|\.[0-9]+|[0-9]+\.[0-9]+)$/;
          function isDecimal(str) {
            (0, _assertString2.default)(str);
            return str !== '' && decimal.test(str);
          }
          module.exports = exports['default'];
        },
        { './util/assertString': 563 }
      ],
      520: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = isDivisibleBy;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          var _toFloat = require('./toFloat');
          var _toFloat2 = _interopRequireDefault(_toFloat);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function isDivisibleBy(str, num) {
            (0, _assertString2.default)(str);
            return (0, _toFloat2.default)(str) % parseInt(num, 10) === 0;
          }
          module.exports = exports['default'];
        },
        { './toFloat': 559, './util/assertString': 563 }
      ],
      521: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = isEmail;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          var _merge = require('./util/merge');
          var _merge2 = _interopRequireDefault(_merge);
          var _isByteLength = require('./isByteLength');
          var _isByteLength2 = _interopRequireDefault(_isByteLength);
          var _isFQDN = require('./isFQDN');
          var _isFQDN2 = _interopRequireDefault(_isFQDN);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          var default_email_options = {
            allow_display_name: false,
            require_display_name: false,
            allow_utf8_local_part: true,
            require_tld: true
          };
          var displayName = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\.\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\.\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF\s]*<(.+)>$/i;
          var emailUserPart = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~]+$/i;
          var quotedEmailUser = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f]))*$/i;
          var emailUserUtf8Part = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/i;
          var quotedEmailUserUtf8 = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*$/i;
          function isEmail(str, options) {
            (0, _assertString2.default)(str);
            options = (0, _merge2.default)(options, default_email_options);
            if (options.require_display_name || options.allow_display_name) {
              var display_email = str.match(displayName);
              if (display_email) {
                str = display_email[1];
              } else if (options.require_display_name) {
                return false;
              }
            }
            var parts = str.split('@');
            var domain = parts.pop();
            var user = parts.join('@');
            var lower_domain = domain.toLowerCase();
            if (
              lower_domain === 'gmail.com' ||
              lower_domain === 'googlemail.com'
            ) {
              user = user.replace(/\./g, '').toLowerCase();
            }
            if (
              !(0, _isByteLength2.default)(user, { max: 64 }) ||
              !(0, _isByteLength2.default)(domain, { max: 254 })
            ) {
              return false;
            }
            if (
              !(0, _isFQDN2.default)(domain, {
                require_tld: options.require_tld
              })
            ) {
              return false;
            }
            if (user[0] === '"') {
              user = user.slice(1, user.length - 1);
              return options.allow_utf8_local_part
                ? quotedEmailUserUtf8.test(user)
                : quotedEmailUser.test(user);
            }
            var pattern = options.allow_utf8_local_part
              ? emailUserUtf8Part
              : emailUserPart;
            var user_parts = user.split('.');
            for (var i = 0; i < user_parts.length; i++) {
              if (!pattern.test(user_parts[i])) {
                return false;
              }
            }
            return true;
          }
          module.exports = exports['default'];
        },
        {
          './isByteLength': 515,
          './isFQDN': 523,
          './util/assertString': 563,
          './util/merge': 564
        }
      ],
      522: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = isEmpty;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function isEmpty(str) {
            (0, _assertString2.default)(str);
            return str.length === 0;
          }
          module.exports = exports['default'];
        },
        { './util/assertString': 563 }
      ],
      523: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = isFDQN;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          var _merge = require('./util/merge');
          var _merge2 = _interopRequireDefault(_merge);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          var default_fqdn_options = {
            require_tld: true,
            allow_underscores: false,
            allow_trailing_dot: false
          };
          function isFDQN(str, options) {
            (0, _assertString2.default)(str);
            options = (0, _merge2.default)(options, default_fqdn_options);
            if (options.allow_trailing_dot && str[str.length - 1] === '.') {
              str = str.substring(0, str.length - 1);
            }
            var parts = str.split('.');
            if (options.require_tld) {
              var tld = parts.pop();
              if (
                !parts.length ||
                !/^([a-z\u00a1-\uffff]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)
              ) {
                return false;
              }
              if (
                /[\s\u2002-\u200B\u202F\u205F\u3000\uFEFF\uDB40\uDC20]/.test(
                  tld
                )
              ) {
                return false;
              }
            }
            for (var part, i = 0; i < parts.length; i++) {
              part = parts[i];
              if (options.allow_underscores) {
                part = part.replace(/_/g, '');
              }
              if (!/^[a-z\u00a1-\uffff0-9-]+$/i.test(part)) {
                return false;
              }
              if (/[\uff01-\uff5e]/.test(part)) {
                return false;
              }
              if (part[0] === '-' || part[part.length - 1] === '-') {
                return false;
              }
            }
            return true;
          }
          module.exports = exports['default'];
        },
        { './util/assertString': 563, './util/merge': 564 }
      ],
      524: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = isFloat;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          var float = /^(?:[-+])?(?:[0-9]+)?(?:\.[0-9]*)?(?:[eE][\+\-]?(?:[0-9]+))?$/;
          function isFloat(str, options) {
            (0, _assertString2.default)(str);
            options = options || {};
            if (str === '' || str === '.') {
              return false;
            }
            return (
              float.test(str) &&
              (!options.hasOwnProperty('min') || str >= options.min) &&
              (!options.hasOwnProperty('max') || str <= options.max) &&
              (!options.hasOwnProperty('lt') || str < options.lt) &&
              (!options.hasOwnProperty('gt') || str > options.gt)
            );
          }
          module.exports = exports['default'];
        },
        { './util/assertString': 563 }
      ],
      525: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.fullWidth = undefined;
          exports.default = isFullWidth;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          var fullWidth = (exports.fullWidth = /[^\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/);
          function isFullWidth(str) {
            (0, _assertString2.default)(str);
            return fullWidth.test(str);
          }
        },
        { './util/assertString': 563 }
      ],
      526: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.halfWidth = undefined;
          exports.default = isHalfWidth;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          var halfWidth = (exports.halfWidth = /[\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/);
          function isHalfWidth(str) {
            (0, _assertString2.default)(str);
            return halfWidth.test(str);
          }
        },
        { './util/assertString': 563 }
      ],
      527: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = isHexColor;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          var hexcolor = /^#?([0-9A-F]{3}|[0-9A-F]{6})$/i;
          function isHexColor(str) {
            (0, _assertString2.default)(str);
            return hexcolor.test(str);
          }
          module.exports = exports['default'];
        },
        { './util/assertString': 563 }
      ],
      528: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = isHexadecimal;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          var hexadecimal = /^[0-9A-F]+$/i;
          function isHexadecimal(str) {
            (0, _assertString2.default)(str);
            return hexadecimal.test(str);
          }
          module.exports = exports['default'];
        },
        { './util/assertString': 563 }
      ],
      529: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = isIP;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          var ipv4Maybe = /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/;
          var ipv6Block = /^[0-9A-F]{1,4}$/i;
          function isIP(str) {
            var version =
              arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : '';
            (0, _assertString2.default)(str);
            version = String(version);
            if (!version) {
              return isIP(str, 4) || isIP(str, 6);
            } else if (version === '4') {
              if (!ipv4Maybe.test(str)) {
                return false;
              }
              var parts = str.split('.').sort(function(a, b) {
                return a - b;
              });
              return parts[3] <= 255;
            } else if (version === '6') {
              var blocks = str.split(':');
              var foundOmissionBlock = false;
              var foundIPv4TransitionBlock = isIP(blocks[blocks.length - 1], 4);
              var expectedNumberOfBlocks = foundIPv4TransitionBlock ? 7 : 8;
              if (blocks.length > expectedNumberOfBlocks) {
                return false;
              }
              if (str === '::') {
                return true;
              } else if (str.substr(0, 2) === '::') {
                blocks.shift();
                blocks.shift();
                foundOmissionBlock = true;
              } else if (str.substr(str.length - 2) === '::') {
                blocks.pop();
                blocks.pop();
                foundOmissionBlock = true;
              }
              for (var i = 0; i < blocks.length; ++i) {
                if (blocks[i] === '' && i > 0 && i < blocks.length - 1) {
                  if (foundOmissionBlock) {
                    return false;
                  }
                  foundOmissionBlock = true;
                } else if (
                  foundIPv4TransitionBlock &&
                  i === blocks.length - 1
                ) {
                } else if (!ipv6Block.test(blocks[i])) {
                  return false;
                }
              }
              if (foundOmissionBlock) {
                return blocks.length >= 1;
              }
              return blocks.length === expectedNumberOfBlocks;
            }
            return false;
          }
          module.exports = exports['default'];
        },
        { './util/assertString': 563 }
      ],
      530: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = isISBN;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          var isbn10Maybe = /^(?:[0-9]{9}X|[0-9]{10})$/;
          var isbn13Maybe = /^(?:[0-9]{13})$/;
          var factor = [1, 3];
          function isISBN(str) {
            var version =
              arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : '';
            (0, _assertString2.default)(str);
            version = String(version);
            if (!version) {
              return isISBN(str, 10) || isISBN(str, 13);
            }
            var sanitized = str.replace(/[\s-]+/g, '');
            var checksum = 0;
            var i = void 0;
            if (version === '10') {
              if (!isbn10Maybe.test(sanitized)) {
                return false;
              }
              for (i = 0; i < 9; i++) {
                checksum += (i + 1) * sanitized.charAt(i);
              }
              if (sanitized.charAt(9) === 'X') {
                checksum += 10 * 10;
              } else {
                checksum += 10 * sanitized.charAt(9);
              }
              if (checksum % 11 === 0) {
                return !!sanitized;
              }
            } else if (version === '13') {
              if (!isbn13Maybe.test(sanitized)) {
                return false;
              }
              for (i = 0; i < 12; i++) {
                checksum += factor[i % 2] * sanitized.charAt(i);
              }
              if (sanitized.charAt(12) - ((10 - (checksum % 10)) % 10) === 0) {
                return !!sanitized;
              }
            }
            return false;
          }
          module.exports = exports['default'];
        },
        { './util/assertString': 563 }
      ],
      531: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = isISIN;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          var isin = /^[A-Z]{2}[0-9A-Z]{9}[0-9]$/;
          function isISIN(str) {
            (0, _assertString2.default)(str);
            if (!isin.test(str)) {
              return false;
            }
            var checksumStr = str.replace(/[A-Z]/g, function(character) {
              return parseInt(character, 36);
            });
            var sum = 0;
            var digit = void 0;
            var tmpNum = void 0;
            var shouldDouble = true;
            for (var i = checksumStr.length - 2; i >= 0; i--) {
              digit = checksumStr.substring(i, i + 1);
              tmpNum = parseInt(digit, 10);
              if (shouldDouble) {
                tmpNum *= 2;
                if (tmpNum >= 10) {
                  sum += tmpNum + 1;
                } else {
                  sum += tmpNum;
                }
              } else {
                sum += tmpNum;
              }
              shouldDouble = !shouldDouble;
            }
            return (
              parseInt(str.substr(str.length - 1), 10) === (1e4 - sum) % 10
            );
          }
          module.exports = exports['default'];
        },
        { './util/assertString': 563 }
      ],
      532: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.iso8601 = undefined;
          exports.default = function(str) {
            (0, _assertString2.default)(str);
            return iso8601.test(str);
          };
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          var iso8601 = (exports.iso8601 = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/);
        },
        { './util/assertString': 563 }
      ],
      533: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = isISRC;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          var isrc = /^[A-Z]{2}[0-9A-Z]{3}\d{2}\d{5}$/;
          function isISRC(str) {
            (0, _assertString2.default)(str);
            return isrc.test(str);
          }
          module.exports = exports['default'];
        },
        { './util/assertString': 563 }
      ],
      534: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = isISSN;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          var issn = '^\\d{4}-?\\d{3}[\\dX]$';
          function isISSN(str) {
            var options =
              arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : {};
            (0, _assertString2.default)(str);
            var testIssn = issn;
            testIssn = options.require_hyphen
              ? testIssn.replace('?', '')
              : testIssn;
            testIssn = options.case_sensitive
              ? new RegExp(testIssn)
              : new RegExp(testIssn, 'i');
            if (!testIssn.test(str)) {
              return false;
            }
            var issnDigits = str.replace('-', '');
            var position = 8;
            var checksum = 0;
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;
            try {
              for (
                var _iterator = issnDigits[Symbol.iterator](), _step;
                !(_iteratorNormalCompletion = (_step = _iterator.next()).done);
                _iteratorNormalCompletion = true
              ) {
                var digit = _step.value;
                var digitValue = digit.toUpperCase() === 'X' ? 10 : +digit;
                checksum += digitValue * position;
                --position;
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
            return checksum % 11 === 0;
          }
          module.exports = exports['default'];
        },
        { './util/assertString': 563 }
      ],
      535: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          var _typeof =
            typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
              ? function(obj) {
                  return typeof obj;
                }
              : function(obj) {
                  return obj &&
                    typeof Symbol === 'function' &&
                    obj.constructor === Symbol &&
                    obj !== Symbol.prototype
                    ? 'symbol'
                    : typeof obj;
                };
          exports.default = isIn;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          var _toString = require('./util/toString');
          var _toString2 = _interopRequireDefault(_toString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function isIn(str, options) {
            (0, _assertString2.default)(str);
            var i = void 0;
            if (Object.prototype.toString.call(options) === '[object Array]') {
              var array = [];
              for (i in options) {
                if ({}.hasOwnProperty.call(options, i)) {
                  array[i] = (0, _toString2.default)(options[i]);
                }
              }
              return array.indexOf(str) >= 0;
            } else if (
              (typeof options === 'undefined'
                ? 'undefined'
                : _typeof(options)) === 'object'
            ) {
              return options.hasOwnProperty(str);
            } else if (options && typeof options.indexOf === 'function') {
              return options.indexOf(str) >= 0;
            }
            return false;
          }
          module.exports = exports['default'];
        },
        { './util/assertString': 563, './util/toString': 565 }
      ],
      536: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = isInt;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          var int = /^(?:[-+]?(?:0|[1-9][0-9]*))$/;
          var intLeadingZeroes = /^[-+]?[0-9]+$/;
          function isInt(str, options) {
            (0, _assertString2.default)(str);
            options = options || {};
            var regex =
              options.hasOwnProperty('allow_leading_zeroes') &&
              !options.allow_leading_zeroes
                ? int
                : intLeadingZeroes;
            var minCheckPassed =
              !options.hasOwnProperty('min') || str >= options.min;
            var maxCheckPassed =
              !options.hasOwnProperty('max') || str <= options.max;
            var ltCheckPassed =
              !options.hasOwnProperty('lt') || str < options.lt;
            var gtCheckPassed =
              !options.hasOwnProperty('gt') || str > options.gt;
            return (
              regex.test(str) &&
              minCheckPassed &&
              maxCheckPassed &&
              ltCheckPassed &&
              gtCheckPassed
            );
          }
          module.exports = exports['default'];
        },
        { './util/assertString': 563 }
      ],
      537: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          var _typeof =
            typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
              ? function(obj) {
                  return typeof obj;
                }
              : function(obj) {
                  return obj &&
                    typeof Symbol === 'function' &&
                    obj.constructor === Symbol &&
                    obj !== Symbol.prototype
                    ? 'symbol'
                    : typeof obj;
                };
          exports.default = isJSON;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function isJSON(str) {
            (0, _assertString2.default)(str);
            try {
              var obj = JSON.parse(str);
              return (
                !!obj &&
                (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) ===
                  'object'
              );
            } catch (e) {}
            return false;
          }
          module.exports = exports['default'];
        },
        { './util/assertString': 563 }
      ],
      538: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          var _typeof =
            typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
              ? function(obj) {
                  return typeof obj;
                }
              : function(obj) {
                  return obj &&
                    typeof Symbol === 'function' &&
                    obj.constructor === Symbol &&
                    obj !== Symbol.prototype
                    ? 'symbol'
                    : typeof obj;
                };
          exports.default = isLength;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function isLength(str, options) {
            (0, _assertString2.default)(str);
            var min = void 0;
            var max = void 0;
            if (
              (typeof options === 'undefined'
                ? 'undefined'
                : _typeof(options)) === 'object'
            ) {
              min = options.min || 0;
              max = options.max;
            } else {
              min = arguments[1];
              max = arguments[2];
            }
            var surrogatePairs =
              str.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g) || [];
            var len = str.length - surrogatePairs.length;
            return len >= min && (typeof max === 'undefined' || len <= max);
          }
          module.exports = exports['default'];
        },
        { './util/assertString': 563 }
      ],
      539: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = isLowercase;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function isLowercase(str) {
            (0, _assertString2.default)(str);
            return str === str.toLowerCase();
          }
          module.exports = exports['default'];
        },
        { './util/assertString': 563 }
      ],
      540: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = isMACAddress;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          var macAddress = /^([0-9a-fA-F][0-9a-fA-F]:){5}([0-9a-fA-F][0-9a-fA-F])$/;
          function isMACAddress(str) {
            (0, _assertString2.default)(str);
            return macAddress.test(str);
          }
          module.exports = exports['default'];
        },
        { './util/assertString': 563 }
      ],
      541: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = isMD5;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          var md5 = /^[a-f0-9]{32}$/;
          function isMD5(str) {
            (0, _assertString2.default)(str);
            return md5.test(str);
          }
          module.exports = exports['default'];
        },
        { './util/assertString': 563 }
      ],
      542: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = isMobilePhone;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          var phones = {
            'ar-DZ': /^(\+?213|0)(5|6|7)\d{8}$/,
            'ar-SY': /^(!?(\+?963)|0)?9\d{8}$/,
            'ar-SA': /^(!?(\+?966)|0)?5\d{8}$/,
            'en-US': /^(\+?1)?[2-9]\d{2}[2-9](?!11)\d{6}$/,
            'cs-CZ': /^(\+?420)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,
            'de-DE': /^(\+?49[ \.\-])?([\(]{1}[0-9]{1,6}[\)])?([0-9 \.\-\/]{3,20})((x|ext|extension)[ ]?[0-9]{1,4})?$/,
            'da-DK': /^(\+?45)?(\d{8})$/,
            'el-GR': /^(\+?30)?(69\d{8})$/,
            'en-AU': /^(\+?61|0)4\d{8}$/,
            'en-GB': /^(\+?44|0)7\d{9}$/,
            'en-HK': /^(\+?852\-?)?[569]\d{3}\-?\d{4}$/,
            'en-IN': /^(\+?91|0)?[789]\d{9}$/,
            'en-KE': /^(\+?254|0)?[7]\d{8}$/,
            'en-NG': /^(\+?234|0)?[789]\d{9}$/,
            'en-NZ': /^(\+?64|0)2\d{7,9}$/,
            'en-UG': /^(\+?256|0)?[7]\d{8}$/,
            'en-RW': /^(\+?250|0)?[7]\d{8}$/,
            'en-TZ': /^(\+?255|0)?[67]\d{8}$/,
            'en-ZA': /^(\+?27|0)\d{9}$/,
            'en-ZM': /^(\+?26)?09[567]\d{7}$/,
            'es-ES': /^(\+?34)?(6\d{1}|7[1234])\d{7}$/,
            'fi-FI': /^(\+?358|0)\s?(4(0|1|2|4|5|6)?|50)\s?(\d\s?){4,8}\d$/,
            'fa-IR': /^(\+?98[\-\s]?|0)9[0-39]\d[\-\s]?\d{3}[\-\s]?\d{4}$/,
            'fr-FR': /^(\+?33|0)[67]\d{8}$/,
            'he-IL': /^(\+972|0)([23489]|5[0248]|77)[1-9]\d{6}/,
            'hu-HU': /^(\+?36)(20|30|70)\d{7}$/,
            'lt-LT': /^(\+370|8)\d{8}$/,
            'id-ID': /^(\+?62|0[1-9])[\s|\d]+$/,
            'it-IT': /^(\+?39)?\s?3\d{2} ?\d{6,7}$/,
            'ko-KR': /^((\+?82)[ \-]?)?0?1([0|1|6|7|8|9]{1})[ \-]?\d{3,4}[ \-]?\d{4}$/,
            'ja-JP': /^(\+?81|0)\d{1,4}[ \-]?\d{1,4}[ \-]?\d{4}$/,
            'ms-MY': /^(\+?6?01){1}(([145]{1}(\-|\s)?\d{7,8})|([236789]{1}(\s|\-)?\d{7}))$/,
            'nb-NO': /^(\+?47)?[49]\d{7}$/,
            'nl-BE': /^(\+?32|0)4?\d{8}$/,
            'nn-NO': /^(\+?47)?[49]\d{7}$/,
            'pl-PL': /^(\+?48)? ?[5-8]\d ?\d{3} ?\d{2} ?\d{2}$/,
            'pt-BR': /^(\+?55|0)\-?[1-9]{2}\-?[2-9]{1}\d{3,4}\-?\d{4}$/,
            'pt-PT': /^(\+?351)?9[1236]\d{7}$/,
            'ro-RO': /^(\+?4?0)\s?7\d{2}(\/|\s|\.|\-)?\d{3}(\s|\.|\-)?\d{3}$/,
            'en-PK': /^((\+92)|(0092))-{0,1}\d{3}-{0,1}\d{7}$|^\d{11}$|^\d{4}-\d{7}$/,
            'ru-RU': /^(\+?7|8)?9\d{9}$/,
            'sr-RS': /^(\+3816|06)[- \d]{5,9}$/,
            'tr-TR': /^(\+?90|0)?5\d{9}$/,
            'vi-VN': /^(\+?84|0)?((1(2([0-9])|6([2-9])|88|99))|(9((?!5)[0-9])))([0-9]{7})$/,
            'zh-CN': /^(\+?0?86\-?)?1[345789]\d{9}$/,
            'zh-TW': /^(\+?886\-?|0)?9\d{8}$/
          };
          phones['en-CA'] = phones['en-US'];
          phones['fr-BE'] = phones['nl-BE'];
          phones['zh-HK'] = phones['en-HK'];
          function isMobilePhone(str, locale) {
            (0, _assertString2.default)(str);
            if (locale in phones) {
              return phones[locale].test(str);
            } else if (locale === 'any') {
              return !!Object.values(phones).find(function(phone) {
                return phone.test(str);
              });
            }
            return false;
          }
          module.exports = exports['default'];
        },
        { './util/assertString': 563 }
      ],
      543: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = isMongoId;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          var _isHexadecimal = require('./isHexadecimal');
          var _isHexadecimal2 = _interopRequireDefault(_isHexadecimal);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function isMongoId(str) {
            (0, _assertString2.default)(str);
            return (0, _isHexadecimal2.default)(str) && str.length === 24;
          }
          module.exports = exports['default'];
        },
        { './isHexadecimal': 528, './util/assertString': 563 }
      ],
      544: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = isMultibyte;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          var multibyte = /[^\x00-\x7F]/;
          function isMultibyte(str) {
            (0, _assertString2.default)(str);
            return multibyte.test(str);
          }
          module.exports = exports['default'];
        },
        { './util/assertString': 563 }
      ],
      545: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = isNumeric;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          var numeric = /^[-+]?[0-9]+$/;
          function isNumeric(str) {
            (0, _assertString2.default)(str);
            return numeric.test(str);
          }
          module.exports = exports['default'];
        },
        { './util/assertString': 563 }
      ],
      546: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = isSurrogatePair;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          var surrogatePair = /[\uD800-\uDBFF][\uDC00-\uDFFF]/;
          function isSurrogatePair(str) {
            (0, _assertString2.default)(str);
            return surrogatePair.test(str);
          }
          module.exports = exports['default'];
        },
        { './util/assertString': 563 }
      ],
      547: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = isURL;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          var _isFQDN = require('./isFQDN');
          var _isFQDN2 = _interopRequireDefault(_isFQDN);
          var _isIP = require('./isIP');
          var _isIP2 = _interopRequireDefault(_isIP);
          var _merge = require('./util/merge');
          var _merge2 = _interopRequireDefault(_merge);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          var default_url_options = {
            protocols: ['http', 'https', 'ftp'],
            require_tld: true,
            require_protocol: false,
            require_host: true,
            require_valid_protocol: true,
            allow_underscores: false,
            allow_trailing_dot: false,
            allow_protocol_relative_urls: false
          };
          var wrapped_ipv6 = /^\[([^\]]+)\](?::([0-9]+))?$/;
          function isRegExp(obj) {
            return Object.prototype.toString.call(obj) === '[object RegExp]';
          }
          function checkHost(host, matches) {
            for (var i = 0; i < matches.length; i++) {
              var match = matches[i];
              if (host === match || (isRegExp(match) && match.test(host))) {
                return true;
              }
            }
            return false;
          }
          function isURL(url, options) {
            (0, _assertString2.default)(url);
            if (!url || url.length >= 2083 || /[\s<>]/.test(url)) {
              return false;
            }
            if (url.indexOf('mailto:') === 0) {
              return false;
            }
            options = (0, _merge2.default)(options, default_url_options);
            var protocol = void 0,
              auth = void 0,
              host = void 0,
              hostname = void 0,
              port = void 0,
              port_str = void 0,
              split = void 0,
              ipv6 = void 0;
            split = url.split('#');
            url = split.shift();
            split = url.split('?');
            url = split.shift();
            split = url.split('://');
            if (split.length > 1) {
              protocol = split.shift();
              if (
                options.require_valid_protocol &&
                options.protocols.indexOf(protocol) === -1
              ) {
                return false;
              }
            } else if (options.require_protocol) {
              return false;
            } else if (
              options.allow_protocol_relative_urls &&
              url.substr(0, 2) === '//'
            ) {
              split[0] = url.substr(2);
            }
            url = split.join('://');
            split = url.split('/');
            url = split.shift();
            if (url === '' && !options.require_host) {
              return true;
            }
            split = url.split('@');
            if (split.length > 1) {
              auth = split.shift();
              if (auth.indexOf(':') >= 0 && auth.split(':').length > 2) {
                return false;
              }
            }
            hostname = split.join('@');
            port_str = null;
            ipv6 = null;
            var ipv6_match = hostname.match(wrapped_ipv6);
            if (ipv6_match) {
              host = '';
              ipv6 = ipv6_match[1];
              port_str = ipv6_match[2] || null;
            } else {
              split = hostname.split(':');
              host = split.shift();
              if (split.length) {
                port_str = split.join(':');
              }
            }
            if (port_str !== null) {
              port = parseInt(port_str, 10);
              if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {
                return false;
              }
            }
            if (
              !(0, _isIP2.default)(host) &&
              !(0, _isFQDN2.default)(host, options) &&
              (!ipv6 || !(0, _isIP2.default)(ipv6, 6)) &&
              host !== 'localhost'
            ) {
              return false;
            }
            host = host || ipv6;
            if (
              options.host_whitelist &&
              !checkHost(host, options.host_whitelist)
            ) {
              return false;
            }
            if (
              options.host_blacklist &&
              checkHost(host, options.host_blacklist)
            ) {
              return false;
            }
            return true;
          }
          module.exports = exports['default'];
        },
        {
          './isFQDN': 523,
          './isIP': 529,
          './util/assertString': 563,
          './util/merge': 564
        }
      ],
      548: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = isUUID;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          var uuid = {
            3: /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
            4: /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
            5: /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
            all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i
          };
          function isUUID(str) {
            var version =
              arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : 'all';
            (0, _assertString2.default)(str);
            var pattern = uuid[version];
            return pattern && pattern.test(str);
          }
          module.exports = exports['default'];
        },
        { './util/assertString': 563 }
      ],
      549: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = isUppercase;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function isUppercase(str) {
            (0, _assertString2.default)(str);
            return str === str.toUpperCase();
          }
          module.exports = exports['default'];
        },
        { './util/assertString': 563 }
      ],
      550: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = isVariableWidth;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          var _isFullWidth = require('./isFullWidth');
          var _isHalfWidth = require('./isHalfWidth');
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function isVariableWidth(str) {
            (0, _assertString2.default)(str);
            return (
              _isFullWidth.fullWidth.test(str) &&
              _isHalfWidth.halfWidth.test(str)
            );
          }
          module.exports = exports['default'];
        },
        {
          './isFullWidth': 525,
          './isHalfWidth': 526,
          './util/assertString': 563
        }
      ],
      551: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = isWhitelisted;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function isWhitelisted(str, chars) {
            (0, _assertString2.default)(str);
            for (var i = str.length - 1; i >= 0; i--) {
              if (chars.indexOf(str[i]) === -1) {
                return false;
              }
            }
            return true;
          }
          module.exports = exports['default'];
        },
        { './util/assertString': 563 }
      ],
      552: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = ltrim;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function ltrim(str, chars) {
            (0, _assertString2.default)(str);
            var pattern = chars
              ? new RegExp('^[' + chars + ']+', 'g')
              : /^\s+/g;
            return str.replace(pattern, '');
          }
          module.exports = exports['default'];
        },
        { './util/assertString': 563 }
      ],
      553: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = matches;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function matches(str, pattern, modifiers) {
            (0, _assertString2.default)(str);
            if (Object.prototype.toString.call(pattern) !== '[object RegExp]') {
              pattern = new RegExp(pattern, modifiers);
            }
            return pattern.test(str);
          }
          module.exports = exports['default'];
        },
        { './util/assertString': 563 }
      ],
      554: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = normalizeEmail;
          var _isEmail = require('./isEmail');
          var _isEmail2 = _interopRequireDefault(_isEmail);
          var _merge = require('./util/merge');
          var _merge2 = _interopRequireDefault(_merge);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          var default_normalize_email_options = {
            all_lowercase: true,
            gmail_lowercase: true,
            gmail_remove_dots: true,
            gmail_remove_subaddress: true,
            gmail_convert_googlemaildotcom: true,
            outlookdotcom_lowercase: true,
            outlookdotcom_remove_subaddress: true,
            yahoo_lowercase: true,
            yahoo_remove_subaddress: true,
            icloud_lowercase: true,
            icloud_remove_subaddress: true
          };
          var icloud_domains = ['icloud.com', 'me.com'];
          var outlookdotcom_domains = [
            'hotmail.at',
            'hotmail.be',
            'hotmail.ca',
            'hotmail.cl',
            'hotmail.co.il',
            'hotmail.co.nz',
            'hotmail.co.th',
            'hotmail.co.uk',
            'hotmail.com',
            'hotmail.com.ar',
            'hotmail.com.au',
            'hotmail.com.br',
            'hotmail.com.gr',
            'hotmail.com.mx',
            'hotmail.com.pe',
            'hotmail.com.tr',
            'hotmail.com.vn',
            'hotmail.cz',
            'hotmail.de',
            'hotmail.dk',
            'hotmail.es',
            'hotmail.fr',
            'hotmail.hu',
            'hotmail.id',
            'hotmail.ie',
            'hotmail.in',
            'hotmail.it',
            'hotmail.jp',
            'hotmail.kr',
            'hotmail.lv',
            'hotmail.my',
            'hotmail.ph',
            'hotmail.pt',
            'hotmail.sa',
            'hotmail.sg',
            'hotmail.sk',
            'live.be',
            'live.co.uk',
            'live.com',
            'live.com.ar',
            'live.com.mx',
            'live.de',
            'live.es',
            'live.eu',
            'live.fr',
            'live.it',
            'live.nl',
            'msn.com',
            'outlook.at',
            'outlook.be',
            'outlook.cl',
            'outlook.co.il',
            'outlook.co.nz',
            'outlook.co.th',
            'outlook.com',
            'outlook.com.ar',
            'outlook.com.au',
            'outlook.com.br',
            'outlook.com.gr',
            'outlook.com.pe',
            'outlook.com.tr',
            'outlook.com.vn',
            'outlook.cz',
            'outlook.de',
            'outlook.dk',
            'outlook.es',
            'outlook.fr',
            'outlook.hu',
            'outlook.id',
            'outlook.ie',
            'outlook.in',
            'outlook.it',
            'outlook.jp',
            'outlook.kr',
            'outlook.lv',
            'outlook.my',
            'outlook.ph',
            'outlook.pt',
            'outlook.sa',
            'outlook.sg',
            'outlook.sk',
            'passport.com'
          ];
          var yahoo_domains = [
            'rocketmail.com',
            'yahoo.ca',
            'yahoo.co.uk',
            'yahoo.com',
            'yahoo.de',
            'yahoo.fr',
            'yahoo.in',
            'yahoo.it',
            'ymail.com'
          ];
          function normalizeEmail(email, options) {
            options = (0, _merge2.default)(
              options,
              default_normalize_email_options
            );
            if (!(0, _isEmail2.default)(email)) {
              return false;
            }
            var raw_parts = email.split('@');
            var domain = raw_parts.pop();
            var user = raw_parts.join('@');
            var parts = [user, domain];
            parts[1] = parts[1].toLowerCase();
            if (parts[1] === 'gmail.com' || parts[1] === 'googlemail.com') {
              if (options.gmail_remove_subaddress) {
                parts[0] = parts[0].split('+')[0];
              }
              if (options.gmail_remove_dots) {
                parts[0] = parts[0].replace(/\./g, '');
              }
              if (!parts[0].length) {
                return false;
              }
              if (options.all_lowercase || options.gmail_lowercase) {
                parts[0] = parts[0].toLowerCase();
              }
              parts[1] = options.gmail_convert_googlemaildotcom
                ? 'gmail.com'
                : parts[1];
            } else if (~icloud_domains.indexOf(parts[1])) {
              if (options.icloud_remove_subaddress) {
                parts[0] = parts[0].split('+')[0];
              }
              if (!parts[0].length) {
                return false;
              }
              if (options.all_lowercase || options.icloud_lowercase) {
                parts[0] = parts[0].toLowerCase();
              }
            } else if (~outlookdotcom_domains.indexOf(parts[1])) {
              if (options.outlookdotcom_remove_subaddress) {
                parts[0] = parts[0].split('+')[0];
              }
              if (!parts[0].length) {
                return false;
              }
              if (options.all_lowercase || options.outlookdotcom_lowercase) {
                parts[0] = parts[0].toLowerCase();
              }
            } else if (~yahoo_domains.indexOf(parts[1])) {
              if (options.yahoo_remove_subaddress) {
                var components = parts[0].split('-');
                parts[0] =
                  components.length > 1
                    ? components.slice(0, -1).join('-')
                    : components[0];
              }
              if (!parts[0].length) {
                return false;
              }
              if (options.all_lowercase || options.yahoo_lowercase) {
                parts[0] = parts[0].toLowerCase();
              }
            } else if (options.all_lowercase) {
              parts[0] = parts[0].toLowerCase();
            }
            return parts.join('@');
          }
          module.exports = exports['default'];
        },
        { './isEmail': 521, './util/merge': 564 }
      ],
      555: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = rtrim;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function rtrim(str, chars) {
            (0, _assertString2.default)(str);
            var pattern = chars ? new RegExp('[' + chars + ']') : /\s/;
            var idx = str.length - 1;
            while (idx >= 0 && pattern.test(str[idx])) {
              idx--;
            }
            return idx < str.length ? str.substr(0, idx + 1) : str;
          }
          module.exports = exports['default'];
        },
        { './util/assertString': 563 }
      ],
      556: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = stripLow;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          var _blacklist = require('./blacklist');
          var _blacklist2 = _interopRequireDefault(_blacklist);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function stripLow(str, keep_new_lines) {
            (0, _assertString2.default)(str);
            var chars = keep_new_lines
              ? '\\x00-\\x09\\x0B\\x0C\\x0E-\\x1F\\x7F'
              : '\\x00-\\x1F\\x7F';
            return (0, _blacklist2.default)(str, chars);
          }
          module.exports = exports['default'];
        },
        { './blacklist': 504, './util/assertString': 563 }
      ],
      557: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = toBoolean;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function toBoolean(str, strict) {
            (0, _assertString2.default)(str);
            if (strict) {
              return str === '1' || str === 'true';
            }
            return str !== '0' && str !== 'false' && str !== '';
          }
          module.exports = exports['default'];
        },
        { './util/assertString': 563 }
      ],
      558: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = toDate;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function toDate(date) {
            (0, _assertString2.default)(date);
            date = Date.parse(date);
            return !isNaN(date) ? new Date(date) : null;
          }
          module.exports = exports['default'];
        },
        { './util/assertString': 563 }
      ],
      559: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = toFloat;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function toFloat(str) {
            (0, _assertString2.default)(str);
            return parseFloat(str);
          }
          module.exports = exports['default'];
        },
        { './util/assertString': 563 }
      ],
      560: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = toInt;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function toInt(str, radix) {
            (0, _assertString2.default)(str);
            return parseInt(str, radix || 10);
          }
          module.exports = exports['default'];
        },
        { './util/assertString': 563 }
      ],
      561: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = trim;
          var _rtrim = require('./rtrim');
          var _rtrim2 = _interopRequireDefault(_rtrim);
          var _ltrim = require('./ltrim');
          var _ltrim2 = _interopRequireDefault(_ltrim);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function trim(str, chars) {
            return (0, _rtrim2.default)(
              (0, _ltrim2.default)(str, chars),
              chars
            );
          }
          module.exports = exports['default'];
        },
        { './ltrim': 552, './rtrim': 555 }
      ],
      562: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = unescape;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function unescape(str) {
            (0, _assertString2.default)(str);
            return str
              .replace(/&amp;/g, '&')
              .replace(/&quot;/g, '"')
              .replace(/&#x27;/g, "'")
              .replace(/&lt;/g, '<')
              .replace(/&gt;/g, '>')
              .replace(/&#x2F;/g, '/')
              .replace(/&#96;/g, '`');
          }
          module.exports = exports['default'];
        },
        { './util/assertString': 563 }
      ],
      563: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = assertString;
          function assertString(input) {
            var isString = typeof input === 'string' || input instanceof String;
            if (!isString) {
              throw new TypeError(
                'This library (validator.js) validates strings only'
              );
            }
          }
          module.exports = exports['default'];
        },
        {}
      ],
      564: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = merge;
          function merge() {
            var obj =
              arguments.length > 0 && arguments[0] !== undefined
                ? arguments[0]
                : {};
            var defaults = arguments[1];
            for (var key in defaults) {
              if (typeof obj[key] === 'undefined') {
                obj[key] = defaults[key];
              }
            }
            return obj;
          }
          module.exports = exports['default'];
        },
        {}
      ],
      565: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          var _typeof =
            typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
              ? function(obj) {
                  return typeof obj;
                }
              : function(obj) {
                  return obj &&
                    typeof Symbol === 'function' &&
                    obj.constructor === Symbol &&
                    obj !== Symbol.prototype
                    ? 'symbol'
                    : typeof obj;
                };
          exports.default = toString;
          function toString(input) {
            if (
              (typeof input === 'undefined' ? 'undefined' : _typeof(input)) ===
                'object' &&
              input !== null
            ) {
              if (typeof input.toString === 'function') {
                input = input.toString();
              } else {
                input = '[object Object]';
              }
            } else if (
              input === null ||
              typeof input === 'undefined' ||
              (isNaN(input) && !input.length)
            ) {
              input = '';
            }
            return String(input);
          }
          module.exports = exports['default'];
        },
        {}
      ],
      566: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.default = whitelist;
          var _assertString = require('./util/assertString');
          var _assertString2 = _interopRequireDefault(_assertString);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function whitelist(str, chars) {
            (0, _assertString2.default)(str);
            return str.replace(new RegExp('[^' + chars + ']+', 'g'), '');
          }
          module.exports = exports['default'];
        },
        { './util/assertString': 563 }
      ],
      567: [
        function(require, module, exports) {
          'use strict';
          var Buffer = require('safe-buffer').Buffer;
          var MAX_SAFE_INTEGER = 9007199254740991;
          function checkUInt53(n) {
            if (n < 0 || n > MAX_SAFE_INTEGER || n % 1 !== 0)
              throw new RangeError('value out of range');
          }
          function encode(number, buffer, offset) {
            checkUInt53(number);
            if (!buffer) buffer = Buffer.allocUnsafe(encodingLength(number));
            if (!Buffer.isBuffer(buffer))
              throw new TypeError('buffer must be a Buffer instance');
            if (!offset) offset = 0;
            if (number < 253) {
              buffer.writeUInt8(number, offset);
              encode.bytes = 1;
            } else if (number <= 65535) {
              buffer.writeUInt8(253, offset);
              buffer.writeUInt16LE(number, offset + 1);
              encode.bytes = 3;
            } else if (number <= 4294967295) {
              buffer.writeUInt8(254, offset);
              buffer.writeUInt32LE(number, offset + 1);
              encode.bytes = 5;
            } else {
              buffer.writeUInt8(255, offset);
              buffer.writeUInt32LE(number >>> 0, offset + 1);
              buffer.writeUInt32LE((number / 4294967296) | 0, offset + 5);
              encode.bytes = 9;
            }
            return buffer;
          }
          function decode(buffer, offset) {
            if (!Buffer.isBuffer(buffer))
              throw new TypeError('buffer must be a Buffer instance');
            if (!offset) offset = 0;
            var first = buffer.readUInt8(offset);
            if (first < 253) {
              decode.bytes = 1;
              return first;
            } else if (first === 253) {
              decode.bytes = 3;
              return buffer.readUInt16LE(offset + 1);
            } else if (first === 254) {
              decode.bytes = 5;
              return buffer.readUInt32LE(offset + 1);
            } else {
              decode.bytes = 9;
              var lo = buffer.readUInt32LE(offset + 1);
              var hi = buffer.readUInt32LE(offset + 5);
              var number = hi * 4294967296 + lo;
              checkUInt53(number);
              return number;
            }
          }
          function encodingLength(number) {
            checkUInt53(number);
            return number < 253
              ? 1
              : number <= 65535
              ? 3
              : number <= 4294967295
              ? 5
              : 9;
          }
          module.exports = {
            encode: encode,
            decode: decode,
            encodingLength: encodingLength
          };
        },
        { 'safe-buffer': 460 }
      ],
      568: [
        function(require, module, exports) {
          (function(Buffer) {
            var bs58check = require('bs58check');
            function decodeRaw(buffer, version) {
              if (version !== undefined && buffer[0] !== version)
                throw new Error('Invalid network version');
              if (buffer.length === 33) {
                return {
                  version: buffer[0],
                  privateKey: buffer.slice(1, 33),
                  compressed: false
                };
              }
              if (buffer.length !== 34) throw new Error('Invalid WIF length');
              if (buffer[33] !== 1) throw new Error('Invalid compression flag');
              return {
                version: buffer[0],
                privateKey: buffer.slice(1, 33),
                compressed: true
              };
            }
            function encodeRaw(version, privateKey, compressed) {
              var result = new Buffer(compressed ? 34 : 33);
              result.writeUInt8(version, 0);
              privateKey.copy(result, 1);
              if (compressed) {
                result[33] = 1;
              }
              return result;
            }
            function decode(string, version) {
              return decodeRaw(bs58check.decode(string), version);
            }
            function encode(version, privateKey, compressed) {
              if (typeof version === 'number')
                return bs58check.encode(
                  encodeRaw(version, privateKey, compressed)
                );
              return bs58check.encode(
                encodeRaw(
                  version.version,
                  version.privateKey,
                  version.compressed
                )
              );
            }
            module.exports = {
              decode: decode,
              decodeRaw: decodeRaw,
              encode: encode,
              encodeRaw: encodeRaw
            };
          }.call(this, require('buffer').Buffer));
        },
        { bs58check: 269, buffer: 183 }
      ],
      569: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          var _makeZoneFile = require('./makeZoneFile');
          Object.defineProperty(exports, 'makeZoneFile', {
            enumerable: true,
            get: function get() {
              return _makeZoneFile.makeZoneFile;
            }
          });
          var _parseZoneFile = require('./parseZoneFile');
          Object.defineProperty(exports, 'parseZoneFile', {
            enumerable: true,
            get: function get() {
              return _parseZoneFile.parseZoneFile;
            }
          });
          var _zoneFile = require('./zoneFile');
          Object.defineProperty(exports, 'ZoneFile', {
            enumerable: true,
            get: function get() {
              return _zoneFile.ZoneFile;
            }
          });
        },
        { './makeZoneFile': 570, './parseZoneFile': 571, './zoneFile': 572 }
      ],
      570: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.makeZoneFile = makeZoneFile;
          var _zoneFileTemplate = require('./zoneFileTemplate');
          function makeZoneFile(jsonZoneFile) {
            var template =
              arguments.length > 1 && arguments[1] !== undefined
                ? arguments[1]
                : (0, _zoneFileTemplate.getZoneFileTemplate)();
            template = processOrigin(jsonZoneFile['$origin'], template);
            template = processTTL(jsonZoneFile['$ttl'], template);
            template = processSOA(jsonZoneFile['soa'], template);
            template = processNS(jsonZoneFile['ns'], template);
            template = processA(jsonZoneFile['a'], template);
            template = processAAAA(jsonZoneFile['aaaa'], template);
            template = processCNAME(jsonZoneFile['cname'], template);
            template = processMX(jsonZoneFile['mx'], template);
            template = processPTR(jsonZoneFile['ptr'], template);
            template = processTXT(jsonZoneFile['txt'], template);
            template = processSRV(jsonZoneFile['srv'], template);
            template = processSPF(jsonZoneFile['spf'], template);
            template = processURI(jsonZoneFile['uri'], template);
            template = processValues(jsonZoneFile, template);
            return template.replace(/\n{2,}/gim, '\n\n');
          }
          var processOrigin = function processOrigin(data, template) {
            var ret = '';
            if (typeof data !== 'undefined') {
              ret += '$ORIGIN ' + data;
            }
            return template.replace('{$origin}', ret);
          };
          var processTTL = function processTTL(data, template) {
            var ret = '';
            if (typeof data !== 'undefined') {
              ret += '$TTL ' + data;
            }
            return template.replace('{$ttl}', ret);
          };
          var processSOA = function processSOA(data, template) {
            var ret = template;
            if (typeof data !== 'undefined') {
              data.name = data.name || '@';
              data.ttl = data.ttl || '';
              for (var key in data) {
                var value = data[key];
                ret = ret.replace('{' + key + '}', value + '\t');
              }
            }
            return ret;
          };
          var processNS = function processNS(data, template) {
            var ret = '';
            for (var i in data) {
              ret += (data[i].name || '@') + '\t';
              if (data[i].ttl) ret += data[i].ttl + '\t';
              ret += 'IN\tNS\t' + data[i].host + '\n';
            }
            return template.replace('{ns}', ret);
          };
          var processA = function processA(data, template) {
            var ret = '';
            for (var i in data) {
              ret += (data[i].name || '@') + '\t';
              if (data[i].ttl) ret += data[i].ttl + '\t';
              ret += 'IN\tA\t' + data[i].ip + '\n';
            }
            return template.replace('{a}', ret);
          };
          var processAAAA = function processAAAA(data, template) {
            var ret = '';
            for (var i in data) {
              ret += (data[i].name || '@') + '\t';
              if (data[i].ttl) ret += data[i].ttl + '\t';
              ret += 'IN\tAAAA\t' + data[i].ip + '\n';
            }
            return template.replace('{aaaa}', ret);
          };
          var processCNAME = function processCNAME(data, template) {
            var ret = '';
            for (var i in data) {
              ret += (data[i].name || '@') + '\t';
              if (data[i].ttl) ret += data[i].ttl + '\t';
              ret += 'IN\tCNAME\t' + data[i].alias + '\n';
            }
            return template.replace('{cname}', ret);
          };
          var processMX = function processMX(data, template) {
            var ret = '';
            for (var i in data) {
              ret += (data[i].name || '@') + '\t';
              if (data[i].ttl) ret += data[i].ttl + '\t';
              ret +=
                'IN\tMX\t' + data[i].preference + '\t' + data[i].host + '\n';
            }
            return template.replace('{mx}', ret);
          };
          var processPTR = function processPTR(data, template) {
            var ret = '';
            for (var i in data) {
              ret += (data[i].name || '@') + '\t';
              if (data[i].ttl) ret += data[i].ttl + '\t';
              ret += 'IN\tPTR\t' + data[i].host + '\n';
            }
            return template.replace('{ptr}', ret);
          };
          var processTXT = function processTXT(data, template) {
            var ret = '';
            for (var i in data) {
              ret += (data[i].name || '@') + '\t';
              if (data[i].ttl) ret += data[i].ttl + '\t';
              ret += 'IN\tTXT\t"' + data[i].txt + '"\n';
            }
            return template.replace('{txt}', ret);
          };
          var processSRV = function processSRV(data, template) {
            var ret = '';
            for (var i in data) {
              ret += (data[i].name || '@') + '\t';
              if (data[i].ttl) ret += data[i].ttl + '\t';
              ret += 'IN\tSRV\t' + data[i].priority + '\t';
              ret += data[i].weight + '\t';
              ret += data[i].port + '\t';
              ret += data[i].target + '\n';
            }
            return template.replace('{srv}', ret);
          };
          var processSPF = function processSPF(data, template) {
            var ret = '';
            for (var i in data) {
              ret += (data[i].name || '@') + '\t';
              if (data[i].ttl) ret += data[i].ttl + '\t';
              ret += 'IN\tSPF\t' + data[i].data + '\n';
            }
            return template.replace('{spf}', ret);
          };
          var processURI = function processURI(data, template) {
            var ret = '';
            for (var i in data) {
              ret += (data[i].name || '@') + '\t';
              if (data[i].ttl) ret += data[i].ttl + '\t';
              ret += 'IN\tURI\t' + data[i].priority + '\t';
              ret += data[i].weight + '\t';
              ret += '"' + data[i].target + '"\n';
            }
            return template.replace('{uri}', ret);
          };
          var processValues = function processValues(jsonZoneFile, template) {
            template = template.replace(
              '{zone}',
              jsonZoneFile['$origin'] || jsonZoneFile['soa']['name'] || ''
            );
            template = template.replace('{datetime}', new Date().toISOString());
            return template.replace('{time}', Math.round(Date.now() / 1e3));
          };
        },
        { './zoneFileTemplate': 573 }
      ],
      571: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.parseZoneFile = parseZoneFile;
          function parseZoneFile(text) {
            text = removeComments(text);
            text = flatten(text);
            return parseRRs(text);
          }
          var removeComments = function removeComments(text) {
            var re = /(^|[^\\]);.*/g;
            return text.replace(re, function(m, g1) {
              return g1 ? g1 : '';
            });
          };
          var flatten = function flatten(text) {
            var captured = [];
            var re = /\([\s\S]*?\)/gim;
            var match = re.exec(text);
            while (match !== null) {
              match.replacement = match[0].replace(/\s+/gm, ' ');
              captured.push(match);
              match = re.exec(text);
            }
            var arrText = text.split('');
            for (var i in captured) {
              match = captured[i];
              arrText.splice(match.index, match[0].length, match.replacement);
            }
            return arrText.join('').replace(/\(|\)/gim, ' ');
          };
          var parseRRs = function parseRRs(text) {
            var ret = {};
            var rrs = text.split('\n');
            for (var i in rrs) {
              var rr = rrs[i];
              if (!rr || !rr.trim()) {
                continue;
              }
              var uRR = rr.toUpperCase();
              if (/\s+TXT\s+/.test(uRR)) {
                ret.txt = ret.txt || [];
                ret.txt.push(parseTXT(rr));
              } else if (uRR.indexOf('$ORIGIN') === 0) {
                ret.$origin = rr.split(/\s+/g)[1];
              } else if (uRR.indexOf('$TTL') === 0) {
                ret.$ttl = parseInt(rr.split(/\s+/g)[1], 10);
              } else if (/\s+SOA\s+/.test(uRR)) {
                ret.soa = parseSOA(rr);
              } else if (/\s+NS\s+/.test(uRR)) {
                ret.ns = ret.ns || [];
                ret.ns.push(parseNS(rr));
              } else if (/\s+A\s+/.test(uRR)) {
                ret.a = ret.a || [];
                ret.a.push(parseA(rr, ret.a));
              } else if (/\s+AAAA\s+/.test(uRR)) {
                ret.aaaa = ret.aaaa || [];
                ret.aaaa.push(parseAAAA(rr));
              } else if (/\s+CNAME\s+/.test(uRR)) {
                ret.cname = ret.cname || [];
                ret.cname.push(parseCNAME(rr));
              } else if (/\s+MX\s+/.test(uRR)) {
                ret.mx = ret.mx || [];
                ret.mx.push(parseMX(rr));
              } else if (/\s+PTR\s+/.test(uRR)) {
                ret.ptr = ret.ptr || [];
                ret.ptr.push(parsePTR(rr, ret.ptr, ret.$origin));
              } else if (/\s+SRV\s+/.test(uRR)) {
                ret.srv = ret.srv || [];
                ret.srv.push(parseSRV(rr));
              } else if (/\s+SPF\s+/.test(uRR)) {
                ret.spf = ret.spf || [];
                ret.spf.push(parseSPF(rr));
              } else if (/\s+URI\s+/.test(uRR)) {
                ret.uri = ret.uri || [];
                ret.uri.push(parseURI(rr));
              }
            }
            return ret;
          };
          var parseSOA = function parseSOA(rr) {
            var soa = {};
            var rrTokens = rr.trim().split(/\s+/g);
            var l = rrTokens.length;
            soa.name = rrTokens[0];
            soa.minimum = parseInt(rrTokens[l - 1], 10);
            soa.expire = parseInt(rrTokens[l - 2], 10);
            soa.retry = parseInt(rrTokens[l - 3], 10);
            soa.refresh = parseInt(rrTokens[l - 4], 10);
            soa.serial = parseInt(rrTokens[l - 5], 10);
            soa.rname = rrTokens[l - 6];
            soa.mname = rrTokens[l - 7];
            if (!isNaN(rrTokens[1])) soa.ttl = parseInt(rrTokens[1], 10);
            return soa;
          };
          var parseNS = function parseNS(rr) {
            var rrTokens = rr.trim().split(/\s+/g);
            var l = rrTokens.length;
            var result = { name: rrTokens[0], host: rrTokens[l - 1] };
            if (!isNaN(rrTokens[1])) result.ttl = parseInt(rrTokens[1], 10);
            return result;
          };
          var parseA = function parseA(rr, recordsSoFar) {
            var rrTokens = rr.trim().split(/\s+/g);
            var urrTokens = rr
              .trim()
              .toUpperCase()
              .split(/\s+/g);
            var l = rrTokens.length;
            var result = { name: rrTokens[0], ip: rrTokens[l - 1] };
            if (urrTokens.lastIndexOf('A') === 0) {
              if (recordsSoFar.length) {
                result.name = recordsSoFar[recordsSoFar.length - 1].name;
              } else {
                result.name = '@';
              }
            }
            if (!isNaN(rrTokens[1])) result.ttl = parseInt(rrTokens[1], 10);
            return result;
          };
          var parseAAAA = function parseAAAA(rr) {
            var rrTokens = rr.trim().split(/\s+/g);
            var l = rrTokens.length;
            var result = { name: rrTokens[0], ip: rrTokens[l - 1] };
            if (!isNaN(rrTokens[1])) result.ttl = parseInt(rrTokens[1], 10);
            return result;
          };
          var parseCNAME = function parseCNAME(rr) {
            var rrTokens = rr.trim().split(/\s+/g);
            var l = rrTokens.length;
            var result = { name: rrTokens[0], alias: rrTokens[l - 1] };
            if (!isNaN(rrTokens[1])) result.ttl = parseInt(rrTokens[1], 10);
            return result;
          };
          var parseMX = function parseMX(rr) {
            var rrTokens = rr.trim().split(/\s+/g);
            var l = rrTokens.length;
            var result = {
              name: rrTokens[0],
              preference: parseInt(rrTokens[l - 2], 10),
              host: rrTokens[l - 1]
            };
            if (!isNaN(rrTokens[1])) result.ttl = parseInt(rrTokens[1], 10);
            return result;
          };
          var parseTXT = function parseTXT(rr) {
            var rrTokens = rr.trim().match(/[^\s\"']+|\"[^\"]*\"|'[^']*'/g);
            var l = rrTokens.length;
            var tokenTxt = rrTokens[l - 1];
            if (tokenTxt.indexOf('"') > -1) {
              tokenTxt = tokenTxt.split('"')[1];
            }
            if (tokenTxt.indexOf('"') > -1) {
              tokenTxt = tokenTxt.split('"')[1];
            }
            var result = { name: rrTokens[0], txt: tokenTxt };
            if (!isNaN(rrTokens[1])) result.ttl = parseInt(rrTokens[1], 10);
            return result;
          };
          var parsePTR = function parsePTR(rr, recordsSoFar, currentOrigin) {
            var rrTokens = rr.trim().split(/\s+/g);
            var urrTokens = rr
              .trim()
              .toUpperCase()
              .split(/\s+/g);
            if (
              urrTokens.lastIndexOf('PTR') === 0 &&
              recordsSoFar[recordsSoFar.length - 1]
            ) {
              rrTokens.unshift(recordsSoFar[recordsSoFar.length - 1].name);
            }
            var l = rrTokens.length;
            var result = {
              name: rrTokens[0],
              fullname: rrTokens[0] + '.' + currentOrigin,
              host: rrTokens[l - 1]
            };
            if (!isNaN(rrTokens[1])) result.ttl = parseInt(rrTokens[1], 10);
            return result;
          };
          var parseSRV = function parseSRV(rr) {
            var rrTokens = rr.trim().split(/\s+/g);
            var l = rrTokens.length;
            var result = {
              name: rrTokens[0],
              target: rrTokens[l - 1],
              priority: parseInt(rrTokens[l - 4], 10),
              weight: parseInt(rrTokens[l - 3], 10),
              port: parseInt(rrTokens[l - 2], 10)
            };
            if (!isNaN(rrTokens[1])) result.ttl = parseInt(rrTokens[1], 10);
            return result;
          };
          var parseSPF = function parseSPF(rr) {
            var rrTokens = rr.trim().split(/\s+/g);
            var result = { name: rrTokens[0], data: '' };
            var l = rrTokens.length;
            while (l-- > 4) {
              result.data = rrTokens[l] + ' ' + result.data.trim();
            }
            if (!isNaN(rrTokens[1])) result.ttl = parseInt(rrTokens[1], 10);
            return result;
          };
          var parseURI = function parseURI(rr) {
            var rrTokens = rr.trim().split(/\s+/g);
            var l = rrTokens.length;
            var result = {
              name: rrTokens[0],
              target: rrTokens[l - 1].replace(/"/g, ''),
              priority: parseInt(rrTokens[l - 3], 10),
              weight: parseInt(rrTokens[l - 2], 10)
            };
            if (!isNaN(rrTokens[1])) result.ttl = parseInt(rrTokens[1], 10);
            return result;
          };
        },
        {}
      ],
      572: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.ZoneFile = undefined;
          var _typeof =
            typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
              ? function(obj) {
                  return typeof obj;
                }
              : function(obj) {
                  return obj &&
                    typeof Symbol === 'function' &&
                    obj.constructor === Symbol &&
                    obj !== Symbol.prototype
                    ? 'symbol'
                    : typeof obj;
                };
          var _createClass = (function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          })();
          var _makeZoneFile = require('./makeZoneFile');
          var _parseZoneFile = require('./parseZoneFile');
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          var ZoneFile = (exports.ZoneFile = (function() {
            function ZoneFile(zoneFile) {
              _classCallCheck(this, ZoneFile);
              if (
                (typeof zoneFile === 'undefined'
                  ? 'undefined'
                  : _typeof(zoneFile)) === 'object'
              ) {
                this.jsonZoneFile = JSON.parse(JSON.stringify(zoneFile));
              } else if (typeof zoneFile === 'string') {
                this.jsonZoneFile = (0, _parseZoneFile.parseZoneFile)(zoneFile);
              }
            }
            _createClass(ZoneFile, [
              {
                key: 'toJSON',
                value: function toJSON() {
                  return this.jsonZoneFile;
                }
              },
              {
                key: 'toString',
                value: function toString() {
                  return (0, _makeZoneFile.makeZoneFile)(this.toJSON());
                }
              }
            ]);
            return ZoneFile;
          })());
        },
        { './makeZoneFile': 570, './parseZoneFile': 571 }
      ],
      573: [
        function(require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.getZoneFileTemplate = getZoneFileTemplate;
          function getZoneFileTemplate() {
            return '{$origin}\n{$ttl}\n\n; SOA Record\n{name} {ttl}    IN  SOA {mname}{rname}(\n{serial} ;serial\n{refresh} ;refresh\n{retry} ;retry\n{expire} ;expire\n{minimum} ;minimum ttl\n)\n\n; NS Records\n{ns}\n\n; MX Records\n{mx}\n\n; A Records\n{a}\n\n; AAAA Records\n{aaaa}\n\n; CNAME Records\n{cname}\n\n; PTR Records\n{ptr}\n\n; TXT Records\n{txt}\n\n; SRV Records\n{srv}\n\n; SPF Records\n{spf}\n\n; URI Records\n{uri}\n';
          }
        },
        {}
      ]
    },
    {},
    [16]
  )(16);
});
